###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       06/May/2016  23:31:38
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\usb_lib\core\usbd_core.c
#    Command line =  
#        "D:\IAR Workspace\STM32F407\VCP_ESP\usb_lib\core\usbd_core.c" -D
#        USE_STDPERIPH_DRIVER -D STM32F4XX -D USE_FULL_ASSERT -lCN "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\List" -o "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\Obj" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\Include\" -I
#        "D:\IAR Workspace\STM32F407\VCP_ESP\..\Utilities\STM32F4-Discovery\"
#        -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\ST\STM32F4xx\Include\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_conf\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\cdc\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\otg\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\core\" -On --use_c++_inline -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    List file    =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\Debug\List\usbd_core.lst
#    Object file  =  D:\IAR Workspace\STM32F407\VCP_ESP\Debug\Obj\usbd_core.o
#
###############################################################################

D:\IAR Workspace\STM32F407\VCP_ESP\usb_lib\core\usbd_core.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbd_core.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    22-July-2011 
      7            * @brief   This file provides all the USBD core functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */ 
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "usbd_core.h"
     24          #include "usbd_req.h"
     25          #include "usbd_ioreq.h"
     26          #include "usb_dcd_int.h"
     27          #include "usb_bsp.h"
     28          
     29          /** @addtogroup STM32_USB_OTG_DEVICE_LIBRARY
     30          * @{
     31          */
     32          
     33          
     34          /** @defgroup USBD_CORE 
     35          * @brief usbd core module
     36          * @{
     37          */ 
     38          
     39          /** @defgroup USBD_CORE_Private_TypesDefinitions
     40          * @{
     41          */ 
     42          /**
     43          * @}
     44          */ 
     45          
     46          
     47          /** @defgroup USBD_CORE_Private_Defines
     48          * @{
     49          */ 
     50          
     51          /**
     52          * @}
     53          */ 
     54          
     55          
     56          /** @defgroup USBD_CORE_Private_Macros
     57          * @{
     58          */ 
     59          /**
     60          * @}
     61          */ 
     62          
     63          
     64          
     65          
     66          /** @defgroup USBD_CORE_Private_FunctionPrototypes
     67          * @{
     68          */ 
     69          static uint8_t USBD_SetupStage(USB_OTG_CORE_HANDLE *pdev);
     70          static uint8_t USBD_DataOutStage(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum);
     71          static uint8_t USBD_DataInStage(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum);
     72          static uint8_t USBD_SOF(USB_OTG_CORE_HANDLE  *pdev);
     73          static uint8_t USBD_Reset(USB_OTG_CORE_HANDLE  *pdev);
     74          static uint8_t USBD_Suspend(USB_OTG_CORE_HANDLE  *pdev);
     75          static uint8_t USBD_Resume(USB_OTG_CORE_HANDLE  *pdev);
     76          #ifdef VBUS_SENSING_ENABLED
     77          static uint8_t USBD_DevConnected(USB_OTG_CORE_HANDLE  *pdev);
     78          static uint8_t USBD_DevDisconnected(USB_OTG_CORE_HANDLE  *pdev);
     79          #endif
     80          static uint8_t USBD_IsoINIncomplete(USB_OTG_CORE_HANDLE  *pdev);
     81          static uint8_t USBD_IsoOUTIncomplete(USB_OTG_CORE_HANDLE  *pdev);
     82          /**
     83          * @}
     84          */ 
     85          
     86          /** @defgroup USBD_CORE_Private_Variables
     87          * @{
     88          */ 
     89          
     90          
     91          

   \                                 In section .data, align 4
     92          USBD_DCD_INT_cb_TypeDef USBD_DCD_INT_cb = 
   \                     USBD_DCD_INT_cb:
   \   00000000   0x........         DC32 USBD_DataOutStage, USBD_DataInStage, USBD_SetupStage, USBD_SOF
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000010   0x........         DC32 USBD_Reset, USBD_Suspend, USBD_Resume, USBD_IsoINIncomplete
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000020   0x........         DC32 USBD_IsoOUTIncomplete
   \   00000024   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     93          {
     94            USBD_DataOutStage,
     95            USBD_DataInStage,
     96            USBD_SetupStage,
     97            USBD_SOF,
     98            USBD_Reset,
     99            USBD_Suspend,
    100            USBD_Resume,
    101            USBD_IsoINIncomplete,
    102            USBD_IsoOUTIncomplete,
    103          #ifdef VBUS_SENSING_ENABLED
    104          USBD_DevConnected, 
    105          USBD_DevDisconnected,    
    106          #endif  
    107          };
    108          

   \                                 In section .data, align 4
    109          USBD_DCD_INT_cb_TypeDef  *USBD_DCD_INT_fops = &USBD_DCD_INT_cb;
   \                     USBD_DCD_INT_fops:
   \   00000000   0x........         DC32 USBD_DCD_INT_cb
    110          /**
    111          * @}
    112          */ 
    113          
    114          /** @defgroup USBD_CORE_Private_Functions
    115          * @{
    116          */ 
    117          
    118          /**
    119          * @brief  USBD_Init
    120          *         Initailizes the device stack and load the class driver
    121          * @param  pdev: device instance
    122          * @param  core_address: USB OTG core ID
    123          * @param  class_cb: Class callback structure address
    124          * @param  usr_cb: User callback structure address
    125          * @retval None
    126          */

   \                                 In section .text, align 2, keep-with-next
    127          void USBD_Init(USB_OTG_CORE_HANDLE *pdev,
    128                         USB_OTG_CORE_ID_TypeDef coreID,
    129                         USBD_DEVICE *pDevice,                  
    130                         USBD_Class_cb_TypeDef *class_cb, 
    131                         USBD_Usr_cb_TypeDef *usr_cb)
    132          {
   \                     USBD_Init: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0xF8DD 0x8018      LDR      R8,[SP, #+24]
    133            /* Hardware Init */
    134            USB_OTG_BSP_Init(pdev);  
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       USB_OTG_BSP_Init
    135            
    136            USBD_DeInit(pdev);
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       USBD_DeInit
    137            
    138            /*Register class and user callbacks */
    139            pdev->dev.class_cb = class_cb;
   \   0000001C   0xF8C4 0x75E0      STR      R7,[R4, #+1504]
    140            pdev->dev.usr_cb = usr_cb;  
   \   00000020   0xF8C4 0x85E4      STR      R8,[R4, #+1508]
    141            pdev->dev.usr_device = pDevice;    
   \   00000024   0xF8C4 0x65E8      STR      R6,[R4, #+1512]
    142            
    143            /* set USB OTG core params */
    144            DCD_Init(pdev , coreID);
   \   00000028   0x0029             MOVS     R1,R5
   \   0000002A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       DCD_Init
    145            
    146            /* Upon Init call usr callback */
    147            pdev->dev.usr_cb->Init();
   \   00000032   0xF8D4 0x05E4      LDR      R0,[R4, #+1508]
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x4780             BLX      R0
    148            
    149            /* Enable Interrupts */
    150            USB_OTG_BSP_EnableInterrupt(pdev);
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       USB_OTG_BSP_EnableInterrupt
    151          }
   \   00000040   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    152          
    153          /**
    154          * @brief  USBD_DeInit 
    155          *         Re-Initialize th deviuce library
    156          * @param  pdev: device instance
    157          * @retval status: status
    158          */

   \                                 In section .text, align 2, keep-with-next
    159          USBD_Status USBD_DeInit(USB_OTG_CORE_HANDLE *pdev)
    160          {
   \                     USBD_DeInit: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    161            /* Software Init */
    162            
    163            return USBD_OK;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR               ;; return
    164          }
    165          
    166          /**
    167          * @brief  USBD_SetupStage 
    168          *         Handle the setup stage
    169          * @param  pdev: device instance
    170          * @retval status
    171          */

   \                                 In section .text, align 2, keep-with-next
    172          static uint8_t USBD_SetupStage(USB_OTG_CORE_HANDLE *pdev)
    173          {
   \                     USBD_SetupStage: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    174            USB_SETUP_REQ req;
    175            
    176            USBD_ParseSetupRequest(pdev , &req);
   \   00000004   0x4669             MOV      R1,SP
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       USBD_ParseSetupRequest
    177            
    178            switch (req.bmRequest & 0x1F) 
   \   0000000C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000010   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD003             BEQ.N    ??USBD_SetupStage_0
   \   0000001A   0x2802             CMP      R0,#+2
   \   0000001C   0xD00B             BEQ.N    ??USBD_SetupStage_1
   \   0000001E   0xD305             BCC.N    ??USBD_SetupStage_2
   \   00000020   0xE00E             B.N      ??USBD_SetupStage_3
    179            {
    180            case USB_REQ_RECIPIENT_DEVICE:   
    181              USBD_StdDevReq (pdev, &req);
   \                     ??USBD_SetupStage_0: (+1)
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       USBD_StdDevReq
    182              break;
   \   0000002A   0xE010             B.N      ??USBD_SetupStage_4
    183              
    184            case USB_REQ_RECIPIENT_INTERFACE:     
    185              USBD_StdItfReq(pdev, &req);
   \                     ??USBD_SetupStage_2: (+1)
   \   0000002C   0x4669             MOV      R1,SP
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       USBD_StdItfReq
    186              break;
   \   00000034   0xE00B             B.N      ??USBD_SetupStage_4
    187              
    188            case USB_REQ_RECIPIENT_ENDPOINT:        
    189              USBD_StdEPReq(pdev, &req);   
   \                     ??USBD_SetupStage_1: (+1)
   \   00000036   0x4669             MOV      R1,SP
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       USBD_StdEPReq
    190              break;
   \   0000003E   0xE006             B.N      ??USBD_SetupStage_4
    191              
    192            default:           
    193              DCD_EP_Stall(pdev , req.bmRequest & 0x80);
   \                     ??USBD_SetupStage_3: (+1)
   \   00000040   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000044   0xF010 0x0180      ANDS     R1,R0,#0x80
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       DCD_EP_Stall
    194              break;
    195            }  
    196            return USBD_OK;
   \                     ??USBD_SetupStage_4: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    197          }
    198          
    199          /**
    200          * @brief  USBD_DataOutStage 
    201          *         Handle data out stage
    202          * @param  pdev: device instance
    203          * @param  epnum: endpoint index
    204          * @retval status
    205          */

   \                                 In section .text, align 2, keep-with-next
    206          static uint8_t USBD_DataOutStage(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
    207          {
   \                     USBD_DataOutStage: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    208            USB_OTG_EP *ep;
    209            
    210            if(epnum == 0) 
   \   00000006   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD134             BNE.N    ??USBD_DataOutStage_0
    211            {
    212              ep = &pdev->dev.out_ep[0];
   \   0000000C   0xF514 0x705C      ADDS     R0,R4,#+880
   \   00000010   0x0006             MOVS     R6,R0
    213              if ( pdev->dev.device_state == USB_OTG_EP0_DATA_OUT)
   \   00000012   0xF894 0x0111      LDRB     R0,[R4, #+273]
   \   00000016   0x2803             CMP      R0,#+3
   \   00000018   0xD13D             BNE.N    ??USBD_DataOutStage_1
    214              {
    215                if(ep->rem_data_len > ep->maxpacket)
   \   0000001A   0x68B0             LDR      R0,[R6, #+8]
   \   0000001C   0x69F1             LDR      R1,[R6, #+28]
   \   0000001E   0x4288             CMP      R0,R1
   \   00000020   0xD217             BCS.N    ??USBD_DataOutStage_2
    216                {
    217                  ep->rem_data_len -=  ep->maxpacket;
   \   00000022   0x69F0             LDR      R0,[R6, #+28]
   \   00000024   0x68B1             LDR      R1,[R6, #+8]
   \   00000026   0x1A40             SUBS     R0,R0,R1
   \   00000028   0x61F0             STR      R0,[R6, #+28]
    218                  
    219                  if(pdev->cfg.dma_enable == 1)
   \   0000002A   0x78E0             LDRB     R0,[R4, #+3]
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD103             BNE.N    ??USBD_DataOutStage_3
    220                  {
    221                    /* in slave mode this, is handled by the RxSTSQLvl ISR */
    222                    ep->xfer_buff += ep->maxpacket; 
   \   00000030   0x68F0             LDR      R0,[R6, #+12]
   \   00000032   0x68B1             LDR      R1,[R6, #+8]
   \   00000034   0x1808             ADDS     R0,R1,R0
   \   00000036   0x60F0             STR      R0,[R6, #+12]
    223                  }        
    224                  USBD_CtlContinueRx (pdev, 
    225                                      ep->xfer_buff,
    226                                      MIN(ep->rem_data_len ,ep->maxpacket));
   \                     ??USBD_DataOutStage_3: (+1)
   \   00000038   0x69F0             LDR      R0,[R6, #+28]
   \   0000003A   0x68B1             LDR      R1,[R6, #+8]
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xD201             BCS.N    ??USBD_DataOutStage_4
   \   00000040   0x69F2             LDR      R2,[R6, #+28]
   \   00000042   0xE000             B.N      ??USBD_DataOutStage_5
   \                     ??USBD_DataOutStage_4: (+1)
   \   00000044   0x68B2             LDR      R2,[R6, #+8]
   \                     ??USBD_DataOutStage_5: (+1)
   \   00000046   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000048   0x68F1             LDR      R1,[R6, #+12]
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0x.... 0x....      BL       USBD_CtlContinueRx
   \   00000050   0xE021             B.N      ??USBD_DataOutStage_1
    227                }
    228                else
    229                {
    230                  if((pdev->dev.class_cb->EP0_RxReady != NULL)&&
    231                     (pdev->dev.device_status == USB_OTG_CONFIGURED))
   \                     ??USBD_DataOutStage_2: (+1)
   \   00000052   0xF8D4 0x05E0      LDR      R0,[R4, #+1504]
   \   00000056   0x6900             LDR      R0,[R0, #+16]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD008             BEQ.N    ??USBD_DataOutStage_6
   \   0000005C   0xF894 0x0112      LDRB     R0,[R4, #+274]
   \   00000060   0x2803             CMP      R0,#+3
   \   00000062   0xD104             BNE.N    ??USBD_DataOutStage_6
    232                  {
    233                    pdev->dev.class_cb->EP0_RxReady(pdev); 
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0xF8D4 0x15E0      LDR      R1,[R4, #+1504]
   \   0000006A   0x6909             LDR      R1,[R1, #+16]
   \   0000006C   0x4788             BLX      R1
    234                  }
    235                  USBD_CtlSendStatus(pdev);
   \                     ??USBD_DataOutStage_6: (+1)
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0x.... 0x....      BL       USBD_CtlSendStatus
   \   00000074   0xE00F             B.N      ??USBD_DataOutStage_1
    236                }
    237              }
    238            }
    239            else if((pdev->dev.class_cb->DataOut != NULL)&&
    240                    (pdev->dev.device_status == USB_OTG_CONFIGURED))
   \                     ??USBD_DataOutStage_0: (+1)
   \   00000076   0xF8D4 0x05E0      LDR      R0,[R4, #+1504]
   \   0000007A   0x6980             LDR      R0,[R0, #+24]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD00A             BEQ.N    ??USBD_DataOutStage_1
   \   00000080   0xF894 0x0112      LDRB     R0,[R4, #+274]
   \   00000084   0x2803             CMP      R0,#+3
   \   00000086   0xD106             BNE.N    ??USBD_DataOutStage_1
    241            {
    242              pdev->dev.class_cb->DataOut(pdev, epnum); 
   \   00000088   0x0029             MOVS     R1,R5
   \   0000008A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008C   0x0020             MOVS     R0,R4
   \   0000008E   0xF8D4 0x25E0      LDR      R2,[R4, #+1504]
   \   00000092   0x6992             LDR      R2,[R2, #+24]
   \   00000094   0x4790             BLX      R2
    243            }  
    244            return USBD_OK;
   \                     ??USBD_DataOutStage_1: (+1)
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0xBD70             POP      {R4-R6,PC}       ;; return
    245          }
    246          
    247          /**
    248          * @brief  USBD_DataInStage 
    249          *         Handle data in stage
    250          * @param  pdev: device instance
    251          * @param  epnum: endpoint index
    252          * @retval status
    253          */

   \                                 In section .text, align 2, keep-with-next
    254          static uint8_t USBD_DataInStage(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
    255          {
   \                     USBD_DataInStage: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    256            USB_OTG_EP *ep;
    257            
    258            if(epnum == 0) 
   \   00000006   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD146             BNE.N    ??USBD_DataInStage_0
    259            {
    260              ep = &pdev->dev.in_ep[0];
   \   0000000C   0xF514 0x708C      ADDS     R0,R4,#+280
   \   00000010   0x0006             MOVS     R6,R0
    261              if ( pdev->dev.device_state == USB_OTG_EP0_DATA_IN)
   \   00000012   0xF894 0x0111      LDRB     R0,[R4, #+273]
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD14F             BNE.N    ??USBD_DataInStage_1
    262              {
    263                if(ep->rem_data_len > ep->maxpacket)
   \   0000001A   0x68B0             LDR      R0,[R6, #+8]
   \   0000001C   0x69F1             LDR      R1,[R6, #+28]
   \   0000001E   0x4288             CMP      R0,R1
   \   00000020   0xD211             BCS.N    ??USBD_DataInStage_2
    264                {
    265                  ep->rem_data_len -=  ep->maxpacket;
   \   00000022   0x69F0             LDR      R0,[R6, #+28]
   \   00000024   0x68B1             LDR      R1,[R6, #+8]
   \   00000026   0x1A40             SUBS     R0,R0,R1
   \   00000028   0x61F0             STR      R0,[R6, #+28]
    266                  if(pdev->cfg.dma_enable == 1)
   \   0000002A   0x78E0             LDRB     R0,[R4, #+3]
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD103             BNE.N    ??USBD_DataInStage_3
    267                  {
    268                    /* in slave mode this, is handled by the TxFifoEmpty ISR */
    269                    ep->xfer_buff += ep->maxpacket;
   \   00000030   0x68F0             LDR      R0,[R6, #+12]
   \   00000032   0x68B1             LDR      R1,[R6, #+8]
   \   00000034   0x1808             ADDS     R0,R1,R0
   \   00000036   0x60F0             STR      R0,[R6, #+12]
    270                  }
    271                  USBD_CtlContinueSendData (pdev, 
    272                                            ep->xfer_buff, 
    273                                            ep->rem_data_len);
   \                     ??USBD_DataInStage_3: (+1)
   \   00000038   0x69F2             LDR      R2,[R6, #+28]
   \   0000003A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000003C   0x68F1             LDR      R1,[R6, #+12]
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       USBD_CtlContinueSendData
   \   00000044   0xE039             B.N      ??USBD_DataInStage_1
    274                }
    275                else
    276                { /* last packet is MPS multiple, so send ZLP packet */
    277                  if((ep->total_data_len % ep->maxpacket == 0) &&
    278                     (ep->total_data_len >= ep->maxpacket) &&
    279                       (ep->total_data_len < ep->ctl_data_len ))
   \                     ??USBD_DataInStage_2: (+1)
   \   00000046   0x6A30             LDR      R0,[R6, #+32]
   \   00000048   0x68B1             LDR      R1,[R6, #+8]
   \   0000004A   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   0000004E   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD10F             BNE.N    ??USBD_DataInStage_4
   \   00000056   0x6A30             LDR      R0,[R6, #+32]
   \   00000058   0x68B1             LDR      R1,[R6, #+8]
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xD30B             BCC.N    ??USBD_DataInStage_4
   \   0000005E   0x6A30             LDR      R0,[R6, #+32]
   \   00000060   0x6A71             LDR      R1,[R6, #+36]
   \   00000062   0x4288             CMP      R0,R1
   \   00000064   0xD207             BCS.N    ??USBD_DataInStage_4
    280                  {
    281                    
    282                    USBD_CtlContinueSendData(pdev , NULL, 0);
   \   00000066   0x2200             MOVS     R2,#+0
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0x.... 0x....      BL       USBD_CtlContinueSendData
    283                    ep->ctl_data_len = 0;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x6270             STR      R0,[R6, #+36]
   \   00000074   0xE021             B.N      ??USBD_DataInStage_1
    284                  }
    285                  else
    286                  {
    287                    if((pdev->dev.class_cb->EP0_TxSent != NULL)&&
    288                       (pdev->dev.device_status == USB_OTG_CONFIGURED))
   \                     ??USBD_DataInStage_4: (+1)
   \   00000076   0xF8D4 0x05E0      LDR      R0,[R4, #+1504]
   \   0000007A   0x68C0             LDR      R0,[R0, #+12]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD008             BEQ.N    ??USBD_DataInStage_5
   \   00000080   0xF894 0x0112      LDRB     R0,[R4, #+274]
   \   00000084   0x2803             CMP      R0,#+3
   \   00000086   0xD104             BNE.N    ??USBD_DataInStage_5
    289                    {
    290                      pdev->dev.class_cb->EP0_TxSent(pdev); 
   \   00000088   0x0020             MOVS     R0,R4
   \   0000008A   0xF8D4 0x15E0      LDR      R1,[R4, #+1504]
   \   0000008E   0x68C9             LDR      R1,[R1, #+12]
   \   00000090   0x4788             BLX      R1
    291                    }          
    292                    USBD_CtlReceiveStatus(pdev);
   \                     ??USBD_DataInStage_5: (+1)
   \   00000092   0x0020             MOVS     R0,R4
   \   00000094   0x.... 0x....      BL       USBD_CtlReceiveStatus
   \   00000098   0xE00F             B.N      ??USBD_DataInStage_1
    293                  }
    294                }
    295              }
    296            }
    297            else if((pdev->dev.class_cb->DataIn != NULL)&& 
    298                    (pdev->dev.device_status == USB_OTG_CONFIGURED))
   \                     ??USBD_DataInStage_0: (+1)
   \   0000009A   0xF8D4 0x05E0      LDR      R0,[R4, #+1504]
   \   0000009E   0x6940             LDR      R0,[R0, #+20]
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD00A             BEQ.N    ??USBD_DataInStage_1
   \   000000A4   0xF894 0x0112      LDRB     R0,[R4, #+274]
   \   000000A8   0x2803             CMP      R0,#+3
   \   000000AA   0xD106             BNE.N    ??USBD_DataInStage_1
    299            {
    300              pdev->dev.class_cb->DataIn(pdev, epnum); 
   \   000000AC   0x0029             MOVS     R1,R5
   \   000000AE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000B0   0x0020             MOVS     R0,R4
   \   000000B2   0xF8D4 0x25E0      LDR      R2,[R4, #+1504]
   \   000000B6   0x6952             LDR      R2,[R2, #+20]
   \   000000B8   0x4790             BLX      R2
    301            }  
    302            return USBD_OK;
   \                     ??USBD_DataInStage_1: (+1)
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xBD70             POP      {R4-R6,PC}       ;; return
    303          }
    304          
    305          /**
    306          * @brief  USBD_Reset 
    307          *         Handle Reset event
    308          * @param  pdev: device instance
    309          * @retval status
    310          */
    311          

   \                                 In section .text, align 2, keep-with-next
    312          static uint8_t USBD_Reset(USB_OTG_CORE_HANDLE  *pdev)
    313          {
   \                     USBD_Reset: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    314            /* Open EP0 OUT */
    315            DCD_EP_Open(pdev,
    316                        0x00,
    317                        USB_OTG_MAX_EP0_SIZE,
    318                        EP_TYPE_CTRL);
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x2240             MOVS     R2,#+64
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       DCD_EP_Open
    319            
    320            /* Open EP0 IN */
    321            DCD_EP_Open(pdev,
    322                        0x80,
    323                        USB_OTG_MAX_EP0_SIZE,
    324                        EP_TYPE_CTRL);
   \   00000010   0x2300             MOVS     R3,#+0
   \   00000012   0x2240             MOVS     R2,#+64
   \   00000014   0x2180             MOVS     R1,#+128
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       DCD_EP_Open
    325            
    326            /* Upon Reset call usr call back */
    327            pdev->dev.device_status = USB_OTG_DEFAULT;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xF884 0x0112      STRB     R0,[R4, #+274]
    328            pdev->dev.usr_cb->DeviceReset(pdev->cfg.speed);
   \   00000022   0x78A0             LDRB     R0,[R4, #+2]
   \   00000024   0xF8D4 0x15E4      LDR      R1,[R4, #+1508]
   \   00000028   0x6849             LDR      R1,[R1, #+4]
   \   0000002A   0x4788             BLX      R1
    329            
    330            return USBD_OK;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    331          }
    332          
    333          /**
    334          * @brief  USBD_Resume 
    335          *         Handle Resume event
    336          * @param  pdev: device instance
    337          * @retval status
    338          */
    339          

   \                                 In section .text, align 2, keep-with-next
    340          static uint8_t USBD_Resume(USB_OTG_CORE_HANDLE  *pdev)
    341          {
   \                     USBD_Resume: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    342            /* Upon Resume call usr call back */
    343            pdev->dev.usr_cb->DeviceResumed(); 
   \   00000004   0xF8D4 0x05E4      LDR      R0,[R4, #+1508]
   \   00000008   0x6900             LDR      R0,[R0, #+16]
   \   0000000A   0x4780             BLX      R0
    344            pdev->dev.device_status = USB_OTG_CONFIGURED;  
   \   0000000C   0x2003             MOVS     R0,#+3
   \   0000000E   0xF884 0x0112      STRB     R0,[R4, #+274]
    345            return USBD_OK;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    346          }
    347          
    348          
    349          /**
    350          * @brief  USBD_Suspend 
    351          *         Handle Suspend event
    352          * @param  pdev: device instance
    353          * @retval status
    354          */
    355          

   \                                 In section .text, align 2, keep-with-next
    356          static uint8_t USBD_Suspend(USB_OTG_CORE_HANDLE  *pdev)
    357          {
   \                     USBD_Suspend: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    358            
    359            pdev->dev.device_status  = USB_OTG_SUSPENDED;
   \   00000004   0x2004             MOVS     R0,#+4
   \   00000006   0xF884 0x0112      STRB     R0,[R4, #+274]
    360            /* Upon Resume call usr call back */
    361            pdev->dev.usr_cb->DeviceSuspended(); 
   \   0000000A   0xF8D4 0x05E4      LDR      R0,[R4, #+1508]
   \   0000000E   0x68C0             LDR      R0,[R0, #+12]
   \   00000010   0x4780             BLX      R0
    362            return USBD_OK;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    363          }
    364          
    365          
    366          /**
    367          * @brief  USBD_SOF 
    368          *         Handle SOF event
    369          * @param  pdev: device instance
    370          * @retval status
    371          */
    372          

   \                                 In section .text, align 2, keep-with-next
    373          static uint8_t USBD_SOF(USB_OTG_CORE_HANDLE  *pdev)
    374          {
   \                     USBD_SOF: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    375            if(pdev->dev.class_cb->SOF)
   \   00000004   0xF8D4 0x05E0      LDR      R0,[R4, #+1504]
   \   00000008   0x69C0             LDR      R0,[R0, #+28]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD004             BEQ.N    ??USBD_SOF_0
    376            {
    377              pdev->dev.class_cb->SOF(pdev); 
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0xF8D4 0x15E0      LDR      R1,[R4, #+1504]
   \   00000014   0x69C9             LDR      R1,[R1, #+28]
   \   00000016   0x4788             BLX      R1
    378            }
    379            return USBD_OK;
   \                     ??USBD_SOF_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    380          }
    381          /**
    382          * @brief  USBD_SetCfg 
    383          *        Configure device and start the interface
    384          * @param  pdev: device instance
    385          * @param  cfgidx: configuration index
    386          * @retval status
    387          */
    388          

   \                                 In section .text, align 2, keep-with-next
    389          USBD_Status USBD_SetCfg(USB_OTG_CORE_HANDLE  *pdev, uint8_t cfgidx)
    390          {
   \                     USBD_SetCfg: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    391            pdev->dev.class_cb->Init(pdev, cfgidx); 
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xF8D4 0x25E0      LDR      R2,[R4, #+1504]
   \   00000010   0x6812             LDR      R2,[R2, #+0]
   \   00000012   0x4790             BLX      R2
    392            
    393            /* Upon set config call usr call back */
    394            pdev->dev.usr_cb->DeviceConfigured();
   \   00000014   0xF8D4 0x05E4      LDR      R0,[R4, #+1508]
   \   00000018   0x6880             LDR      R0,[R0, #+8]
   \   0000001A   0x4780             BLX      R0
    395            return USBD_OK; 
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    396          }
    397          
    398          /**
    399          * @brief  USBD_ClrCfg 
    400          *         Clear current configuration
    401          * @param  pdev: device instance
    402          * @param  cfgidx: configuration index
    403          * @retval status: USBD_Status
    404          */

   \                                 In section .text, align 2, keep-with-next
    405          USBD_Status USBD_ClrCfg(USB_OTG_CORE_HANDLE  *pdev, uint8_t cfgidx)
    406          {
   \                     USBD_ClrCfg: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    407            pdev->dev.class_cb->DeInit(pdev, cfgidx);   
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xF8D4 0x25E0      LDR      R2,[R4, #+1504]
   \   00000010   0x6852             LDR      R2,[R2, #+4]
   \   00000012   0x4790             BLX      R2
    408            return USBD_OK;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    409          }
    410          
    411          /**
    412          * @brief  USBD_IsoINIncomplete 
    413          *         Handle iso in incomplete event
    414          * @param  pdev: device instance
    415          * @retval status
    416          */

   \                                 In section .text, align 2, keep-with-next
    417          static uint8_t USBD_IsoINIncomplete(USB_OTG_CORE_HANDLE  *pdev)
    418          {
   \                     USBD_IsoINIncomplete: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    419            pdev->dev.class_cb->IsoINIncomplete(pdev);   
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xF8D4 0x15E0      LDR      R1,[R4, #+1504]
   \   0000000A   0x6A09             LDR      R1,[R1, #+32]
   \   0000000C   0x4788             BLX      R1
    420            return USBD_OK;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
    421          }
    422          
    423          /**
    424          * @brief  USBD_IsoOUTIncomplete 
    425          *         Handle iso out incomplete event
    426          * @param  pdev: device instance
    427          * @retval status
    428          */

   \                                 In section .text, align 2, keep-with-next
    429          static uint8_t USBD_IsoOUTIncomplete(USB_OTG_CORE_HANDLE  *pdev)
    430          {
   \                     USBD_IsoOUTIncomplete: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    431            pdev->dev.class_cb->IsoOUTIncomplete(pdev);   
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xF8D4 0x15E0      LDR      R1,[R4, #+1504]
   \   0000000A   0x6A49             LDR      R1,[R1, #+36]
   \   0000000C   0x4788             BLX      R1
    432            return USBD_OK;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
    433          }
    434          
    435          #ifdef VBUS_SENSING_ENABLED
    436          /**
    437          * @brief  USBD_DevConnected 
    438          *         Handle device connection event
    439          * @param  pdev: device instance
    440          * @retval status
    441          */
    442          static uint8_t USBD_DevConnected(USB_OTG_CORE_HANDLE  *pdev)
    443          {
    444            pdev->dev.usr_cb->DeviceConnected();
    445            return USBD_OK;
    446          }
    447          
    448          /**
    449          * @brief  USBD_DevDisconnected 
    450          *         Handle device disconnection event
    451          * @param  pdev: device instance
    452          * @retval status
    453          */
    454          static uint8_t USBD_DevDisconnected(USB_OTG_CORE_HANDLE  *pdev)
    455          {
    456            pdev->dev.usr_cb->DeviceDisconnected();
    457            pdev->dev.class_cb->DeInit(pdev, 0);
    458            return USBD_OK;
    459          }
    460          #endif
    461          /**
    462          * @}
    463          */ 
    464          
    465          
    466          /**
    467          * @}
    468          */ 
    469          
    470          
    471          /**
    472          * @}
    473          */ 
    474          
    475          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
    476          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   USBD_ClrCfg
        16   -- Indirect call
      16   USBD_DataInStage
        16   -- Indirect call
        16   -> USBD_CtlContinueSendData
        16   -> USBD_CtlReceiveStatus
      16   USBD_DataOutStage
        16   -- Indirect call
        16   -> USBD_CtlContinueRx
        16   -> USBD_CtlSendStatus
       0   USBD_DeInit
      24   USBD_Init
        24   -- Indirect call
        24   -> DCD_Init
        24   -> USBD_DeInit
        24   -> USB_OTG_BSP_EnableInterrupt
        24   -> USB_OTG_BSP_Init
       8   USBD_IsoINIncomplete
         8   -- Indirect call
       8   USBD_IsoOUTIncomplete
         8   -- Indirect call
       8   USBD_Reset
         8   -- Indirect call
         8   -> DCD_EP_Open
       8   USBD_Resume
         8   -- Indirect call
       8   USBD_SOF
         8   -- Indirect call
      16   USBD_SetCfg
        16   -- Indirect call
      16   USBD_SetupStage
        16   -> DCD_EP_Stall
        16   -> USBD_ParseSetupRequest
        16   -> USBD_StdDevReq
        16   -> USBD_StdEPReq
        16   -> USBD_StdItfReq
       8   USBD_Suspend
         8   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      24  USBD_ClrCfg
      44  USBD_DCD_INT_cb
       4  USBD_DCD_INT_fops
     190  USBD_DataInStage
     154  USBD_DataOutStage
       6  USBD_DeInit
      68  USBD_Init
      18  USBD_IsoINIncomplete
      18  USBD_IsoOUTIncomplete
      48  USBD_Reset
      22  USBD_Resume
      28  USBD_SOF
      32  USBD_SetCfg
      82  USBD_SetupStage
      22  USBD_Suspend

 
  48 bytes in section .data
 712 bytes in section .text
 
 712 bytes of CODE memory
  48 bytes of DATA memory

Errors: none
Warnings: 1
