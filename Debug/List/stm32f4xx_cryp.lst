###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       06/May/2016  23:31:31
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\IAR
#        Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_cryp.c
#    Command line =  
#        "D:\IAR
#        Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_cryp.c"
#        -D USE_STDPERIPH_DRIVER -D STM32F4XX -D USE_FULL_ASSERT -lCN "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\List" -o "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\Obj" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\Include\" -I
#        "D:\IAR Workspace\STM32F407\VCP_ESP\..\Utilities\STM32F4-Discovery\"
#        -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\ST\STM32F4xx\Include\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_conf\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\cdc\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\otg\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\core\" -On --use_c++_inline -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    List file    =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\Debug\List\stm32f4xx_cryp.lst
#    Object file  =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\Debug\Obj\stm32f4xx_cryp.o
#
###############################################################################

D:\IAR Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_cryp.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_cryp.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    30-September-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the  Cryptographic processor (CRYP) peripheral:           
      9            *           - Initialization and Configuration functions
     10            *           - Data treatment functions 
     11            *           - Context swapping functions     
     12            *           - DMA interface function       
     13            *           - Interrupts and flags management       
     14            *
     15            *  @verbatim
     16            *                               
     17            *          ===================================================================      
     18            *                                 How to use this driver
     19            *          =================================================================== 
     20            *          1. Enable the CRYP controller clock using 
     21            *              RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_CRYP, ENABLE); function.
     22            *
     23            *          2. Initialise the CRYP using CRYP_Init(), CRYP_KeyInit() and if 
     24            *             needed CRYP_IVInit(). 
     25            *
     26            *          3. Flush the IN and OUT FIFOs by using CRYP_FIFOFlush() function.
     27            *
     28            *          4. Enable the CRYP controller using the CRYP_Cmd() function. 
     29            *
     30            *          5. If using DMA for Data input and output transfer, 
     31            *             Activate the needed DMA Requests using CRYP_DMACmd() function 
     32            
     33            *          6. If DMA is not used for data transfer, use CRYP_DataIn() and 
     34            *             CRYP_DataOut() functions to enter data to IN FIFO and get result
     35            *             from OUT FIFO.
     36            *
     37            *          7. To control CRYP events you can use one of the following 
     38            *              two methods:
     39            *               - Check on CRYP flags using the CRYP_GetFlagStatus() function.  
     40            *               - Use CRYP interrupts through the function CRYP_ITConfig() at 
     41            *                 initialization phase and CRYP_GetITStatus() function into 
     42            *                 interrupt routines in processing phase.
     43            *       
     44            *          8. Save and restore Cryptographic processor context using  
     45            *             CRYP_SaveContext() and CRYP_RestoreContext() functions.     
     46            *
     47            *
     48            *          ===================================================================  
     49            *                Procedure to perform an encryption or a decryption
     50            *          ===================================================================  
     51            *
     52            *      Initialization
     53            *      ===============  
     54            *     1. Initialize the peripheral using CRYP_Init(), CRYP_KeyInit() and 
     55            *        CRYP_IVInit functions:
     56            *        - Configure the key size (128-, 192- or 256-bit, in the AES only) 
     57            *        - Enter the symmetric key 
     58            *        - Configure the data type
     59            *        - In case of decryption in AES-ECB or AES-CBC, you must prepare 
     60            *          the key: configure the key preparation mode. Then Enable the CRYP 
     61            *          peripheral using CRYP_Cmd() function: the BUSY flag is set. 
     62            *          Wait until BUSY flag is reset : the key is prepared for decryption
     63            *       - Configure the algorithm and chaining (the DES/TDES in ECB/CBC, the 
     64            *          AES in ECB/CBC/CTR) 
     65            *       - Configure the direction (encryption/decryption).
     66            *       - Write the initialization vectors (in CBC or CTR modes only)
     67            *
     68            *    2. Flush the IN and OUT FIFOs using the CRYP_FIFOFlush() function
     69            *
     70            *
     71            *    Basic Processing mode (polling mode) 
     72            *    ====================================  
     73            *    1. Enable the cryptographic processor using CRYP_Cmd() function.
     74            *
     75            *    2. Write the first blocks in the input FIFO (2 to 8 words) using 
     76            *       CRYP_DataIn() function.
     77            *
     78            *    3. Repeat the following sequence until the complete message has been 
     79            *       processed:
     80            *
     81            *       a) Wait for flag CRYP_FLAG_OFNE occurs (using CRYP_GetFlagStatus() 
     82            *          function), then read the OUT-FIFO using CRYP_DataOut() function
     83            *          (1 block or until the FIFO is empty)
     84            *
     85            *       b) Wait for flag CRYP_FLAG_IFNF occurs, (using CRYP_GetFlagStatus() 
     86            *          function then write the IN FIFO using CRYP_DataIn() function 
     87            *          (1 block or until the FIFO is full)
     88            *
     89            *    4. At the end of the processing, CRYP_FLAG_BUSY flag will be reset and 
     90            *        both FIFOs are empty (CRYP_FLAG_IFEM is set and CRYP_FLAG_OFNE is 
     91            *        reset). You can disable the peripheral using CRYP_Cmd() function.
     92            *
     93            *    Interrupts Processing mode 
     94            *    ===========================
     95            *    In this mode, Processing is done when the data are transferred by the 
     96            *    CPU during interrupts.
     97            *
     98            *    1. Enable the interrupts CRYP_IT_INI and CRYP_IT_OUTI using 
     99            *       CRYP_ITConfig() function.
    100            *
    101            *    2. Enable the cryptographic processor using CRYP_Cmd() function.
    102            *
    103            *    3. In the CRYP_IT_INI interrupt handler : load the input message into the 
    104            *       IN FIFO using CRYP_DataIn() function . You can load 2 or 4 words at a 
    105            *       time, or load data until the IN FIFO is full. When the last word of
    106            *       the message has been entered into the IN FIFO, disable the CRYP_IT_INI 
    107            *       interrupt (using CRYP_ITConfig() function).
    108            *
    109            *    4. In the CRYP_IT_OUTI interrupt handler : read the output message from 
    110            *       the OUT FIFO using CRYP_DataOut() function. You can read 1 block (2 or 
    111            *       4 words) at a time or read data until the FIFO is empty.
    112            *       When the last word has been read, INIM=0, BUSY=0 and both FIFOs are 
    113            *       empty (CRYP_FLAG_IFEM is set and CRYP_FLAG_OFNE is reset). 
    114            *       You can disable the CRYP_IT_OUTI interrupt (using CRYP_ITConfig() 
    115            *       function) and you can disable the peripheral using CRYP_Cmd() function.
    116            *
    117            *    DMA Processing mode 
    118            *    ====================
    119            *    In this mode, Processing is done when the DMA is used to transfer the 
    120            *    data from/to the memory.
    121            *
    122            *    1. Configure the DMA controller to transfer the input data from the 
    123            *       memory using DMA_Init() function. 
    124            *       The transfer length is the length of the message. 
    125            *       As message padding is not managed by the peripheral, the message 
    126            *       length must be an entire number of blocks. The data are transferred 
    127            *       in burst mode. The burst length is 4 words in the AES and 2 or 4 
    128            *       words in the DES/TDES. The DMA should be configured to set an 
    129            *       interrupt on transfer completion of the output data to indicate that 
    130            *       the processing is finished. 
    131            *       Refer to DMA peripheral driver for more details.  
    132            *
    133            *    2. Enable the cryptographic processor using CRYP_Cmd() function. 
    134            *       Enable the DMA requests CRYP_DMAReq_DataIN and CRYP_DMAReq_DataOUT 
    135            *       using CRYP_DMACmd() function.
    136            *
    137            *    3. All the transfers and processing are managed by the DMA and the 
    138            *       cryptographic processor. The DMA transfer complete interrupt indicates 
    139            *       that the processing is complete. Both FIFOs are normally empty and 
    140            *       CRYP_FLAG_BUSY flag is reset.
    141            *
    142            *  @endverbatim
    143            *
    144            ******************************************************************************
    145            * @attention
    146            *
    147            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
    148            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
    149            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
    150            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
    151            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
    152            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
    153            *
    154            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
    155            ******************************************************************************  
    156            */
    157          
    158          /* Includes ------------------------------------------------------------------*/
    159          #include "stm32f4xx_cryp.h"
    160          #include "stm32f4xx_rcc.h"
    161          
    162          /** @addtogroup STM32F4xx_StdPeriph_Driver
    163            * @{
    164            */
    165          
    166          /** @defgroup CRYP 
    167            * @brief CRYP driver modules
    168            * @{
    169            */ 
    170          
    171          /* Private typedef -----------------------------------------------------------*/
    172          /* Private define ------------------------------------------------------------*/
    173          #define FLAG_MASK     ((uint8_t)0x20)
    174          #define MAX_TIMEOUT   ((uint16_t)0xFFFF)
    175          
    176          /* Private macro -------------------------------------------------------------*/
    177          /* Private variables ---------------------------------------------------------*/
    178          /* Private function prototypes -----------------------------------------------*/
    179          /* Private functions ---------------------------------------------------------*/
    180          
    181          /** @defgroup CRYP_Private_Functions
    182            * @{
    183            */ 
    184          
    185          /** @defgroup CRYP_Group1 Initialization and Configuration functions
    186           *  @brief    Initialization and Configuration functions 
    187           *
    188          @verbatim    
    189           ===============================================================================
    190                                Initialization and Configuration functions
    191           ===============================================================================  
    192            This section provides functions allowing to 
    193             - Initialize the cryptographic Processor using CRYP_Init() function 
    194                -  Encrypt or Decrypt 
    195                -  mode : TDES-ECB, TDES-CBC, 
    196                          DES-ECB, DES-CBC, 
    197                          AES-ECB, AES-CBC, AES-CTR, AES-Key 
    198                - DataType :  32-bit data, 16-bit data, bit data or bit-string
    199                - Key Size (only in AES modes)
    200             - Configure the Encrypt or Decrypt Key using CRYP_KeyInit() function 
    201             - Configure the Initialization Vectors(IV) for CBC and CTR modes using 
    202               CRYP_IVInit() function.  
    203             - Flushes the IN and OUT FIFOs : using CRYP_FIFOFlush() function.                         
    204             - Enable or disable the CRYP Processor using CRYP_Cmd() function 
    205              
    206             
    207          @endverbatim
    208            * @{
    209            */
    210          /**
    211            * @brief  Deinitializes the CRYP peripheral registers to their default reset values
    212            * @param  None
    213            * @retval None
    214            */

   \                                 In section .text, align 2, keep-with-next
    215          void CRYP_DeInit(void)
    216          {
   \                     CRYP_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    217            /* Enable CRYP reset state */
    218            RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_CRYP, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2010             MOVS     R0,#+16
   \   00000006   0x.... 0x....      BL       RCC_AHB2PeriphResetCmd
    219          
    220            /* Release CRYP from reset state */
    221            RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_CRYP, DISABLE);
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x2010             MOVS     R0,#+16
   \   0000000E   0x.... 0x....      BL       RCC_AHB2PeriphResetCmd
    222          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
    223          
    224          /**
    225            * @brief  Initializes the CRYP peripheral according to the specified parameters
    226            *         in the CRYP_InitStruct.
    227            * @param  CRYP_InitStruct: pointer to a CRYP_InitTypeDef structure that contains
    228            *         the configuration information for the CRYP peripheral.
    229            * @retval None
    230            */

   \                                 In section .text, align 2, keep-with-next
    231          void CRYP_Init(CRYP_InitTypeDef* CRYP_InitStruct)
    232          {
   \                     CRYP_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    233            /* Check the parameters */
    234            assert_param(IS_CRYP_ALGOMODE(CRYP_InitStruct->CRYP_AlgoMode));
   \   00000004   0x8860             LDRH     R0,[R4, #+2]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD019             BEQ.N    ??CRYP_Init_0
   \   0000000A   0x8860             LDRH     R0,[R4, #+2]
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD016             BEQ.N    ??CRYP_Init_0
   \   00000010   0x8860             LDRH     R0,[R4, #+2]
   \   00000012   0x2810             CMP      R0,#+16
   \   00000014   0xD013             BEQ.N    ??CRYP_Init_0
   \   00000016   0x8860             LDRH     R0,[R4, #+2]
   \   00000018   0x2818             CMP      R0,#+24
   \   0000001A   0xD010             BEQ.N    ??CRYP_Init_0
   \   0000001C   0x8860             LDRH     R0,[R4, #+2]
   \   0000001E   0x2820             CMP      R0,#+32
   \   00000020   0xD00D             BEQ.N    ??CRYP_Init_0
   \   00000022   0x8860             LDRH     R0,[R4, #+2]
   \   00000024   0x2828             CMP      R0,#+40
   \   00000026   0xD00A             BEQ.N    ??CRYP_Init_0
   \   00000028   0x8860             LDRH     R0,[R4, #+2]
   \   0000002A   0x2830             CMP      R0,#+48
   \   0000002C   0xD007             BEQ.N    ??CRYP_Init_0
   \   0000002E   0x8860             LDRH     R0,[R4, #+2]
   \   00000030   0x2838             CMP      R0,#+56
   \   00000032   0xD004             BEQ.N    ??CRYP_Init_0
   \   00000034   0x21EA             MOVS     R1,#+234
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000003A   0x.... 0x....      BL       assert_failed
    235            assert_param(IS_CRYP_DATATYPE(CRYP_InitStruct->CRYP_DataType));
   \                     ??CRYP_Init_0: (+1)
   \   0000003E   0x88A0             LDRH     R0,[R4, #+4]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD00D             BEQ.N    ??CRYP_Init_1
   \   00000044   0x88A0             LDRH     R0,[R4, #+4]
   \   00000046   0x2840             CMP      R0,#+64
   \   00000048   0xD00A             BEQ.N    ??CRYP_Init_1
   \   0000004A   0x88A0             LDRH     R0,[R4, #+4]
   \   0000004C   0x2880             CMP      R0,#+128
   \   0000004E   0xD007             BEQ.N    ??CRYP_Init_1
   \   00000050   0x88A0             LDRH     R0,[R4, #+4]
   \   00000052   0x28C0             CMP      R0,#+192
   \   00000054   0xD004             BEQ.N    ??CRYP_Init_1
   \   00000056   0x21EB             MOVS     R1,#+235
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000005C   0x.... 0x....      BL       assert_failed
    236            assert_param(IS_CRYP_ALGODIR(CRYP_InitStruct->CRYP_AlgoDir));
   \                     ??CRYP_Init_1: (+1)
   \   00000060   0x8820             LDRH     R0,[R4, #+0]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD007             BEQ.N    ??CRYP_Init_2
   \   00000066   0x8820             LDRH     R0,[R4, #+0]
   \   00000068   0x2804             CMP      R0,#+4
   \   0000006A   0xD004             BEQ.N    ??CRYP_Init_2
   \   0000006C   0x21EC             MOVS     R1,#+236
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000072   0x.... 0x....      BL       assert_failed
    237          
    238            /* Select Algorithm mode*/  
    239            CRYP->CR &= ~CRYP_CR_ALGOMODE;
   \                     ??CRYP_Init_2: (+1)
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x50060000
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0xF030 0x0038      BICS     R0,R0,#0x38
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable12_1  ;; 0x50060000
   \   00000084   0x6008             STR      R0,[R1, #+0]
    240            CRYP->CR |= CRYP_InitStruct->CRYP_AlgoMode;
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x50060000
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x8861             LDRH     R1,[R4, #+2]
   \   0000008E   0x4308             ORRS     R0,R1,R0
   \   00000090   0x.... 0x....      LDR.W    R1,??DataTable12_1  ;; 0x50060000
   \   00000094   0x6008             STR      R0,[R1, #+0]
    241          
    242            /* Select dataType */ 
    243            CRYP->CR &= ~CRYP_CR_DATATYPE;
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x50060000
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0xF030 0x00C0      BICS     R0,R0,#0xC0
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable12_1  ;; 0x50060000
   \   000000A4   0x6008             STR      R0,[R1, #+0]
    244            CRYP->CR |= CRYP_InitStruct->CRYP_DataType;
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x50060000
   \   000000AA   0x6800             LDR      R0,[R0, #+0]
   \   000000AC   0x88A1             LDRH     R1,[R4, #+4]
   \   000000AE   0x4308             ORRS     R0,R1,R0
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable12_1  ;; 0x50060000
   \   000000B4   0x6008             STR      R0,[R1, #+0]
    245          
    246            /* select Key size (used only with AES algorithm) */
    247            if ((CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_ECB) ||
    248                (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_CBC) ||
    249                (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_CTR) ||
    250                (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_Key))
   \   000000B6   0x8860             LDRH     R0,[R4, #+2]
   \   000000B8   0x2820             CMP      R0,#+32
   \   000000BA   0xD008             BEQ.N    ??CRYP_Init_3
   \   000000BC   0x8860             LDRH     R0,[R4, #+2]
   \   000000BE   0x2828             CMP      R0,#+40
   \   000000C0   0xD005             BEQ.N    ??CRYP_Init_3
   \   000000C2   0x8860             LDRH     R0,[R4, #+2]
   \   000000C4   0x2830             CMP      R0,#+48
   \   000000C6   0xD002             BEQ.N    ??CRYP_Init_3
   \   000000C8   0x8860             LDRH     R0,[R4, #+2]
   \   000000CA   0x2838             CMP      R0,#+56
   \   000000CC   0xD11F             BNE.N    ??CRYP_Init_4
    251            {
    252              assert_param(IS_CRYP_KEYSIZE(CRYP_InitStruct->CRYP_KeySize));
   \                     ??CRYP_Init_3: (+1)
   \   000000CE   0x88E0             LDRH     R0,[R4, #+6]
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD00C             BEQ.N    ??CRYP_Init_5
   \   000000D4   0x88E0             LDRH     R0,[R4, #+6]
   \   000000D6   0xF5B0 0x7F80      CMP      R0,#+256
   \   000000DA   0xD008             BEQ.N    ??CRYP_Init_5
   \   000000DC   0x88E0             LDRH     R0,[R4, #+6]
   \   000000DE   0xF5B0 0x7F00      CMP      R0,#+512
   \   000000E2   0xD004             BEQ.N    ??CRYP_Init_5
   \   000000E4   0x21FC             MOVS     R1,#+252
   \   000000E6   0x.... 0x....      LDR.W    R0,??DataTable12
   \   000000EA   0x.... 0x....      BL       assert_failed
    253              CRYP->CR &= ~CRYP_CR_KEYSIZE;
   \                     ??CRYP_Init_5: (+1)
   \   000000EE   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x50060000
   \   000000F2   0x6800             LDR      R0,[R0, #+0]
   \   000000F4   0xF430 0x7040      BICS     R0,R0,#0x300
   \   000000F8   0x.... 0x....      LDR.W    R1,??DataTable12_1  ;; 0x50060000
   \   000000FC   0x6008             STR      R0,[R1, #+0]
    254              CRYP->CR |= CRYP_InitStruct->CRYP_KeySize; /* Key size and value must be 
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x50060000
   \   00000102   0x6800             LDR      R0,[R0, #+0]
   \   00000104   0x88E1             LDRH     R1,[R4, #+6]
   \   00000106   0x4308             ORRS     R0,R1,R0
   \   00000108   0x.... 0x....      LDR.W    R1,??DataTable12_1  ;; 0x50060000
   \   0000010C   0x6008             STR      R0,[R1, #+0]
    255                                                            configured once the key has 
    256                                                            been prepared */
    257            }
    258          
    259            /* Select data Direction */ 
    260            CRYP->CR &= ~CRYP_CR_ALGODIR;
   \                     ??CRYP_Init_4: (+1)
   \   0000010E   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x50060000
   \   00000112   0x6800             LDR      R0,[R0, #+0]
   \   00000114   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000118   0x.... 0x....      LDR.W    R1,??DataTable12_1  ;; 0x50060000
   \   0000011C   0x6008             STR      R0,[R1, #+0]
    261            CRYP->CR |= CRYP_InitStruct->CRYP_AlgoDir;
   \   0000011E   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x50060000
   \   00000122   0x6800             LDR      R0,[R0, #+0]
   \   00000124   0x8821             LDRH     R1,[R4, #+0]
   \   00000126   0x4308             ORRS     R0,R1,R0
   \   00000128   0x.... 0x....      LDR.W    R1,??DataTable12_1  ;; 0x50060000
   \   0000012C   0x6008             STR      R0,[R1, #+0]
    262          }
   \   0000012E   0xBD10             POP      {R4,PC}          ;; return
    263          
    264          /**
    265            * @brief  Fills each CRYP_InitStruct member with its default value.
    266            * @param  CRYP_InitStruct: pointer to a CRYP_InitTypeDef structure which will
    267            *         be initialized.
    268            * @retval None
    269            */

   \                                 In section .text, align 2, keep-with-next
    270          void CRYP_StructInit(CRYP_InitTypeDef* CRYP_InitStruct)
    271          {
    272            /* Initialize the CRYP_AlgoDir member */
    273            CRYP_InitStruct->CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
   \                     CRYP_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    274          
    275            /* initialize the CRYP_AlgoMode member */
    276            CRYP_InitStruct->CRYP_AlgoMode = CRYP_AlgoMode_TDES_ECB;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x8041             STRH     R1,[R0, #+2]
    277          
    278            /* initialize the CRYP_DataType member */
    279            CRYP_InitStruct->CRYP_DataType = CRYP_DataType_32b;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x8081             STRH     R1,[R0, #+4]
    280            
    281            /* Initialize the CRYP_KeySize member */
    282            CRYP_InitStruct->CRYP_KeySize = CRYP_KeySize_128b;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x80C1             STRH     R1,[R0, #+6]
    283          }
   \   00000010   0x4770             BX       LR               ;; return
    284          
    285          /**
    286            * @brief  Initializes the CRYP Keys according to the specified parameters in
    287            *         the CRYP_KeyInitStruct.
    288            * @param  CRYP_KeyInitStruct: pointer to a CRYP_KeyInitTypeDef structure that
    289            *         contains the configuration information for the CRYP Keys.
    290            * @retval None
    291            */

   \                                 In section .text, align 2, keep-with-next
    292          void CRYP_KeyInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
    293          {
    294            /* Key Initialisation */
    295            CRYP->K0LR = CRYP_KeyInitStruct->CRYP_Key0Left;
   \                     CRYP_KeyInit: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable12_2  ;; 0x50060020
   \   00000006   0x6011             STR      R1,[R2, #+0]
    296            CRYP->K0RR = CRYP_KeyInitStruct->CRYP_Key0Right;
   \   00000008   0x6841             LDR      R1,[R0, #+4]
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable12_3  ;; 0x50060024
   \   0000000E   0x6011             STR      R1,[R2, #+0]
    297            CRYP->K1LR = CRYP_KeyInitStruct->CRYP_Key1Left;
   \   00000010   0x6881             LDR      R1,[R0, #+8]
   \   00000012   0x.... 0x....      LDR.W    R2,??DataTable12_4  ;; 0x50060028
   \   00000016   0x6011             STR      R1,[R2, #+0]
    298            CRYP->K1RR = CRYP_KeyInitStruct->CRYP_Key1Right;
   \   00000018   0x68C1             LDR      R1,[R0, #+12]
   \   0000001A   0x.... 0x....      LDR.W    R2,??DataTable12_5  ;; 0x5006002c
   \   0000001E   0x6011             STR      R1,[R2, #+0]
    299            CRYP->K2LR = CRYP_KeyInitStruct->CRYP_Key2Left;
   \   00000020   0x6901             LDR      R1,[R0, #+16]
   \   00000022   0x.... 0x....      LDR.W    R2,??DataTable12_6  ;; 0x50060030
   \   00000026   0x6011             STR      R1,[R2, #+0]
    300            CRYP->K2RR = CRYP_KeyInitStruct->CRYP_Key2Right;
   \   00000028   0x6941             LDR      R1,[R0, #+20]
   \   0000002A   0x.... 0x....      LDR.W    R2,??DataTable12_7  ;; 0x50060034
   \   0000002E   0x6011             STR      R1,[R2, #+0]
    301            CRYP->K3LR = CRYP_KeyInitStruct->CRYP_Key3Left;
   \   00000030   0x6981             LDR      R1,[R0, #+24]
   \   00000032   0x.... 0x....      LDR.W    R2,??DataTable12_8  ;; 0x50060038
   \   00000036   0x6011             STR      R1,[R2, #+0]
    302            CRYP->K3RR = CRYP_KeyInitStruct->CRYP_Key3Right;
   \   00000038   0x69C1             LDR      R1,[R0, #+28]
   \   0000003A   0x.... 0x....      LDR.W    R2,??DataTable12_9  ;; 0x5006003c
   \   0000003E   0x6011             STR      R1,[R2, #+0]
    303          }
   \   00000040   0x4770             BX       LR               ;; return
    304          
    305          /**
    306            * @brief  Fills each CRYP_KeyInitStruct member with its default value.
    307            * @param  CRYP_KeyInitStruct: pointer to a CRYP_KeyInitTypeDef structure 
    308            *         which will be initialized.
    309            * @retval None
    310            */

   \                                 In section .text, align 2, keep-with-next
    311          void CRYP_KeyStructInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
    312          {
    313            CRYP_KeyInitStruct->CRYP_Key0Left  = 0;
   \                     CRYP_KeyStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    314            CRYP_KeyInitStruct->CRYP_Key0Right = 0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6041             STR      R1,[R0, #+4]
    315            CRYP_KeyInitStruct->CRYP_Key1Left  = 0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6081             STR      R1,[R0, #+8]
    316            CRYP_KeyInitStruct->CRYP_Key1Right = 0;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
    317            CRYP_KeyInitStruct->CRYP_Key2Left  = 0;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6101             STR      R1,[R0, #+16]
    318            CRYP_KeyInitStruct->CRYP_Key2Right = 0;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6141             STR      R1,[R0, #+20]
    319            CRYP_KeyInitStruct->CRYP_Key3Left  = 0;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x6181             STR      R1,[R0, #+24]
    320            CRYP_KeyInitStruct->CRYP_Key3Right = 0;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x61C1             STR      R1,[R0, #+28]
    321          }
   \   00000020   0x4770             BX       LR               ;; return
    322          /**
    323            * @brief  Initializes the CRYP Initialization Vectors(IV) according to the
    324            *         specified parameters in the CRYP_IVInitStruct.
    325            * @param  CRYP_IVInitStruct: pointer to a CRYP_IVInitTypeDef structure that contains
    326            *         the configuration information for the CRYP Initialization Vectors(IV).
    327            * @retval None
    328            */

   \                                 In section .text, align 2, keep-with-next
    329          void CRYP_IVInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct)
    330          {
    331            CRYP->IV0LR = CRYP_IVInitStruct->CRYP_IV0Left;
   \                     CRYP_IVInit: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x....             LDR.N    R2,??DataTable12_10  ;; 0x50060040
   \   00000004   0x6011             STR      R1,[R2, #+0]
    332            CRYP->IV0RR = CRYP_IVInitStruct->CRYP_IV0Right;
   \   00000006   0x6841             LDR      R1,[R0, #+4]
   \   00000008   0x....             LDR.N    R2,??DataTable12_11  ;; 0x50060044
   \   0000000A   0x6011             STR      R1,[R2, #+0]
    333            CRYP->IV1LR = CRYP_IVInitStruct->CRYP_IV1Left;
   \   0000000C   0x6881             LDR      R1,[R0, #+8]
   \   0000000E   0x....             LDR.N    R2,??DataTable12_12  ;; 0x50060048
   \   00000010   0x6011             STR      R1,[R2, #+0]
    334            CRYP->IV1RR = CRYP_IVInitStruct->CRYP_IV1Right;
   \   00000012   0x68C1             LDR      R1,[R0, #+12]
   \   00000014   0x....             LDR.N    R2,??DataTable12_13  ;; 0x5006004c
   \   00000016   0x6011             STR      R1,[R2, #+0]
    335          }
   \   00000018   0x4770             BX       LR               ;; return
    336          
    337          /**
    338            * @brief  Fills each CRYP_IVInitStruct member with its default value.
    339            * @param  CRYP_IVInitStruct: pointer to a CRYP_IVInitTypeDef Initialization 
    340            *         Vectors(IV) structure which will be initialized.
    341            * @retval None
    342            */

   \                                 In section .text, align 2, keep-with-next
    343          void CRYP_IVStructInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct)
    344          {
    345            CRYP_IVInitStruct->CRYP_IV0Left  = 0;
   \                     CRYP_IVStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    346            CRYP_IVInitStruct->CRYP_IV0Right = 0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6041             STR      R1,[R0, #+4]
    347            CRYP_IVInitStruct->CRYP_IV1Left  = 0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6081             STR      R1,[R0, #+8]
    348            CRYP_IVInitStruct->CRYP_IV1Right = 0;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
    349          }
   \   00000010   0x4770             BX       LR               ;; return
    350          
    351          /**
    352            * @brief  Flushes the IN and OUT FIFOs (that is read and write pointers of the 
    353            *         FIFOs are reset)
    354            * @note   The FIFOs must be flushed only when BUSY flag is reset.  
    355            * @param  None
    356            * @retval None
    357            */

   \                                 In section .text, align 2, keep-with-next
    358          void CRYP_FIFOFlush(void)
    359          {
    360            /* Reset the read and write pointers of the FIFOs */
    361            CRYP->CR |= CRYP_CR_FFLUSH;
   \                     CRYP_FIFOFlush: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_1  ;; 0x50060000
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   00000008   0x....             LDR.N    R1,??DataTable12_1  ;; 0x50060000
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    362          }
   \   0000000C   0x4770             BX       LR               ;; return
    363          
    364          /**
    365            * @brief  Enables or disables the CRYP peripheral.
    366            * @param  NewState: new state of the CRYP peripheral.
    367            *          This parameter can be: ENABLE or DISABLE.
    368            * @retval None
    369            */

   \                                 In section .text, align 2, keep-with-next
    370          void CRYP_Cmd(FunctionalState NewState)
    371          {
   \                     CRYP_Cmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    372            /* Check the parameters */
    373            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??CRYP_Cmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??CRYP_Cmd_0
   \   00000010   0xF240 0x1175      MOVW     R1,#+373
   \   00000014   0x....             LDR.N    R0,??DataTable12
   \   00000016   0x.... 0x....      BL       assert_failed
    374          
    375            if (NewState != DISABLE)
   \                     ??CRYP_Cmd_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD006             BEQ.N    ??CRYP_Cmd_1
    376            {
    377              /* Enable the Cryptographic processor */
    378              CRYP->CR |= CRYP_CR_CRYPEN;
   \   00000020   0x....             LDR.N    R0,??DataTable12_1  ;; 0x50060000
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000028   0x....             LDR.N    R1,??DataTable12_1  ;; 0x50060000
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   \   0000002C   0xE005             B.N      ??CRYP_Cmd_2
    379            }
    380            else
    381            {
    382              /* Disable the Cryptographic processor */
    383              CRYP->CR &= ~CRYP_CR_CRYPEN;
   \                     ??CRYP_Cmd_1: (+1)
   \   0000002E   0x....             LDR.N    R0,??DataTable12_1  ;; 0x50060000
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   00000036   0x....             LDR.N    R1,??DataTable12_1  ;; 0x50060000
   \   00000038   0x6008             STR      R0,[R1, #+0]
    384            }
    385          }
   \                     ??CRYP_Cmd_2: (+1)
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    386          /**
    387            * @}
    388            */
    389            
    390          /** @defgroup CRYP_Group2 CRYP Data processing functions
    391           *  @brief    CRYP Data processing functions
    392           *
    393          @verbatim    
    394           ===============================================================================
    395                                CRYP Data processing functions
    396           ===============================================================================  
    397            This section provides functions allowing the encryption and decryption 
    398            operations: 
    399            - Enter data to be treated in the IN FIFO : using CRYP_DataIn() function.
    400            - Get the data result from the OUT FIFO : using CRYP_DataOut() function.
    401          
    402          @endverbatim
    403            * @{
    404            */
    405          
    406          /**
    407            * @brief  Writes data in the Data Input register (DIN).
    408            * @note   After the DIN register has been read once or several times, 
    409            *         the FIFO must be flushed (using CRYP_FIFOFlush() function).  
    410            * @param  Data: data to write in Data Input register
    411            * @retval None
    412            */

   \                                 In section .text, align 2, keep-with-next
    413          void CRYP_DataIn(uint32_t Data)
    414          {
    415            CRYP->DR = Data;
   \                     CRYP_DataIn: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable12_14  ;; 0x50060008
   \   00000002   0x6008             STR      R0,[R1, #+0]
    416          }
   \   00000004   0x4770             BX       LR               ;; return
    417          
    418          /**
    419            * @brief  Returns the last data entered into the output FIFO.
    420            * @param  None
    421            * @retval Last data entered into the output FIFO.
    422            */

   \                                 In section .text, align 2, keep-with-next
    423          uint32_t CRYP_DataOut(void)
    424          {
    425            return CRYP->DOUT;
   \                     CRYP_DataOut: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_15  ;; 0x5006000c
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    426          }
    427          /**
    428            * @}
    429            */
    430            
    431          /** @defgroup CRYP_Group3 Context swapping functions
    432           *  @brief   Context swapping functions
    433           *
    434          @verbatim   
    435           ===============================================================================
    436                                       Context swapping functions
    437           ===============================================================================  
    438          
    439            This section provides functions allowing to save and store CRYP Context
    440          
    441            It is possible to interrupt an encryption/ decryption/ key generation process 
    442            to perform another processing with a higher priority, and to complete the 
    443            interrupted process later on, when the higher-priority task is complete. To do 
    444            so, the context of the interrupted task must be saved from the CRYP registers 
    445            to memory, and then be restored from memory to the CRYP registers.
    446             
    447            1. To save the current context, use CRYP_SaveContext() function
    448            2. To restore the saved context, use CRYP_RestoreContext() function 
    449          
    450          
    451          @endverbatim
    452            * @{
    453            */
    454            
    455          /**
    456            * @brief  Saves the CRYP peripheral Context. 
    457            * @note   This function stops DMA transfer before to save the context. After 
    458            *         restoring the context, you have to enable the DMA again (if the DMA
    459            *         was previously used).
    460            * @param  CRYP_ContextSave: pointer to a CRYP_Context structure that contains
    461            *         the repository for current context.
    462            * @param  CRYP_KeyInitStruct: pointer to a CRYP_KeyInitTypeDef structure that 
    463            *         contains the configuration information for the CRYP Keys.  
    464            * @retval None
    465            */

   \                                 In section .text, align 2, keep-with-next
    466          ErrorStatus CRYP_SaveContext(CRYP_Context* CRYP_ContextSave,
    467                                       CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
    468          {
   \                     CRYP_SaveContext: (+1)
   \   00000000   0xB478             PUSH     {R3-R6}
   \   00000002   0x0002             MOVS     R2,R0
    469            __IO uint32_t timeout = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9000             STR      R0,[SP, #+0]
    470            uint32_t ckeckmask = 0, bitstatus;    
   \   00000008   0x2400             MOVS     R4,#+0
    471            ErrorStatus status = ERROR;
   \   0000000A   0x2000             MOVS     R0,#+0
    472          
    473            /* Stop DMA transfers on the IN FIFO by clearing the DIEN bit in the CRYP_DMACR */
    474            CRYP->DMACR &= ~(uint32_t)CRYP_DMACR_DIEN;
   \   0000000C   0x....             LDR.N    R5,??DataTable12_16  ;; 0x50060010
   \   0000000E   0x682D             LDR      R5,[R5, #+0]
   \   00000010   0x086D             LSRS     R5,R5,#+1
   \   00000012   0x006D             LSLS     R5,R5,#+1
   \   00000014   0x....             LDR.N    R6,??DataTable12_16  ;; 0x50060010
   \   00000016   0x6035             STR      R5,[R6, #+0]
    475              
    476            /* Wait until both the IN and OUT FIFOs are empty  
    477              (IFEM=1 and OFNE=0 in the CRYP_SR register) and the 
    478               BUSY bit is cleared. */
    479          
    480            if ((CRYP->CR & (uint32_t)(CRYP_CR_ALGOMODE_TDES_ECB | CRYP_CR_ALGOMODE_TDES_CBC)) != (uint32_t)0 )/* TDES */
   \   00000018   0x....             LDR.N    R5,??DataTable12_1  ;; 0x50060000
   \   0000001A   0x682D             LDR      R5,[R5, #+0]
   \   0000001C   0x072D             LSLS     R5,R5,#+28
   \   0000001E   0xD502             BPL.N    ??CRYP_SaveContext_0
    481            { 
    482              ckeckmask =  CRYP_SR_IFEM | CRYP_SR_BUSY ;
   \   00000020   0x2511             MOVS     R5,#+17
   \   00000022   0x002C             MOVS     R4,R5
   \   00000024   0xE001             B.N      ??CRYP_SaveContext_1
    483            }
    484            else /* AES or DES */
    485            {
    486              ckeckmask =  CRYP_SR_IFEM | CRYP_SR_BUSY | CRYP_SR_OFNE;
   \                     ??CRYP_SaveContext_0: (+1)
   \   00000026   0x2515             MOVS     R5,#+21
   \   00000028   0x002C             MOVS     R4,R5
    487            }           
    488             
    489            do 
    490            {
    491              bitstatus = CRYP->SR & ckeckmask;
   \                     ??CRYP_SaveContext_1: (+1)
   \   0000002A   0x....             LDR.N    R5,??DataTable12_17  ;; 0x50060004
   \   0000002C   0x682D             LDR      R5,[R5, #+0]
   \   0000002E   0x4025             ANDS     R5,R4,R5
   \   00000030   0x002B             MOVS     R3,R5
    492              timeout++;
   \   00000032   0x9D00             LDR      R5,[SP, #+0]
   \   00000034   0x1C6D             ADDS     R5,R5,#+1
   \   00000036   0x9500             STR      R5,[SP, #+0]
    493            }
    494            while ((timeout != MAX_TIMEOUT) && (bitstatus != CRYP_SR_IFEM));
   \   00000038   0x9D00             LDR      R5,[SP, #+0]
   \   0000003A   0xF64F 0x76FF      MOVW     R6,#+65535
   \   0000003E   0x42B5             CMP      R5,R6
   \   00000040   0xD001             BEQ.N    ??CRYP_SaveContext_2
   \   00000042   0x2B01             CMP      R3,#+1
   \   00000044   0xD1F1             BNE.N    ??CRYP_SaveContext_1
    495               
    496            if ((CRYP->SR & ckeckmask) != CRYP_SR_IFEM)
   \                     ??CRYP_SaveContext_2: (+1)
   \   00000046   0x....             LDR.N    R5,??DataTable12_17  ;; 0x50060004
   \   00000048   0x682D             LDR      R5,[R5, #+0]
   \   0000004A   0x4025             ANDS     R5,R4,R5
   \   0000004C   0x2D01             CMP      R5,#+1
   \   0000004E   0xD002             BEQ.N    ??CRYP_SaveContext_3
    497            {
    498              status = ERROR;
   \   00000050   0x2500             MOVS     R5,#+0
   \   00000052   0x0028             MOVS     R0,R5
   \   00000054   0xE02E             B.N      ??CRYP_SaveContext_4
    499            }
    500            else
    501            {      
    502              /* Stop DMA transfers on the OUT FIFO by 
    503                 - writing the DOEN bit to 0 in the CRYP_DMACR register 
    504                 - and clear the CRYPEN bit. */
    505          
    506              CRYP->DMACR &= ~(uint32_t)CRYP_DMACR_DOEN;
   \                     ??CRYP_SaveContext_3: (+1)
   \   00000056   0x....             LDR.N    R5,??DataTable12_16  ;; 0x50060010
   \   00000058   0x682D             LDR      R5,[R5, #+0]
   \   0000005A   0xF035 0x0502      BICS     R5,R5,#0x2
   \   0000005E   0x....             LDR.N    R6,??DataTable12_16  ;; 0x50060010
   \   00000060   0x6035             STR      R5,[R6, #+0]
    507              CRYP->CR &= ~(uint32_t)CRYP_CR_CRYPEN;
   \   00000062   0x....             LDR.N    R5,??DataTable12_1  ;; 0x50060000
   \   00000064   0x682D             LDR      R5,[R5, #+0]
   \   00000066   0xF435 0x4500      BICS     R5,R5,#0x8000
   \   0000006A   0x....             LDR.N    R6,??DataTable12_1  ;; 0x50060000
   \   0000006C   0x6035             STR      R5,[R6, #+0]
    508          
    509              /* Save the current configuration (bits [9:2] in the CRYP_CR register) */
    510              CRYP_ContextSave->CR_bits9to2  = CRYP->CR & (CRYP_CR_KEYSIZE  | 
    511                                                           CRYP_CR_DATATYPE | 
    512                                                           CRYP_CR_ALGOMODE |
    513                                                           CRYP_CR_ALGODIR); 
   \   0000006E   0x....             LDR.N    R5,??DataTable12_1  ;; 0x50060000
   \   00000070   0x682D             LDR      R5,[R5, #+0]
   \   00000072   0xF415 0x757F      ANDS     R5,R5,#0x3FC
   \   00000076   0x6015             STR      R5,[R2, #+0]
    514          
    515              /* and, if not in ECB mode, the initialization vectors. */
    516              CRYP_ContextSave->CRYP_IV0LR = CRYP->IV0LR;
   \   00000078   0x....             LDR.N    R5,??DataTable12_10  ;; 0x50060040
   \   0000007A   0x682D             LDR      R5,[R5, #+0]
   \   0000007C   0x6055             STR      R5,[R2, #+4]
    517              CRYP_ContextSave->CRYP_IV0RR = CRYP->IV0RR;
   \   0000007E   0x....             LDR.N    R5,??DataTable12_11  ;; 0x50060044
   \   00000080   0x682D             LDR      R5,[R5, #+0]
   \   00000082   0x6095             STR      R5,[R2, #+8]
    518              CRYP_ContextSave->CRYP_IV1LR = CRYP->IV1LR;
   \   00000084   0x....             LDR.N    R5,??DataTable12_12  ;; 0x50060048
   \   00000086   0x682D             LDR      R5,[R5, #+0]
   \   00000088   0x60D5             STR      R5,[R2, #+12]
    519              CRYP_ContextSave->CRYP_IV1RR = CRYP->IV1RR;
   \   0000008A   0x....             LDR.N    R5,??DataTable12_13  ;; 0x5006004c
   \   0000008C   0x682D             LDR      R5,[R5, #+0]
   \   0000008E   0x6115             STR      R5,[R2, #+16]
    520          
    521              /* save The key value */
    522              CRYP_ContextSave->CRYP_K0LR = CRYP_KeyInitStruct->CRYP_Key0Left; 
   \   00000090   0x680D             LDR      R5,[R1, #+0]
   \   00000092   0x6155             STR      R5,[R2, #+20]
    523              CRYP_ContextSave->CRYP_K0RR = CRYP_KeyInitStruct->CRYP_Key0Right; 
   \   00000094   0x684D             LDR      R5,[R1, #+4]
   \   00000096   0x6195             STR      R5,[R2, #+24]
    524              CRYP_ContextSave->CRYP_K1LR = CRYP_KeyInitStruct->CRYP_Key1Left; 
   \   00000098   0x688D             LDR      R5,[R1, #+8]
   \   0000009A   0x61D5             STR      R5,[R2, #+28]
    525              CRYP_ContextSave->CRYP_K1RR = CRYP_KeyInitStruct->CRYP_Key1Right; 
   \   0000009C   0x68CD             LDR      R5,[R1, #+12]
   \   0000009E   0x6215             STR      R5,[R2, #+32]
    526              CRYP_ContextSave->CRYP_K2LR = CRYP_KeyInitStruct->CRYP_Key2Left; 
   \   000000A0   0x690D             LDR      R5,[R1, #+16]
   \   000000A2   0x6255             STR      R5,[R2, #+36]
    527              CRYP_ContextSave->CRYP_K2RR = CRYP_KeyInitStruct->CRYP_Key2Right; 
   \   000000A4   0x694D             LDR      R5,[R1, #+20]
   \   000000A6   0x6295             STR      R5,[R2, #+40]
    528              CRYP_ContextSave->CRYP_K3LR = CRYP_KeyInitStruct->CRYP_Key3Left; 
   \   000000A8   0x698D             LDR      R5,[R1, #+24]
   \   000000AA   0x62D5             STR      R5,[R2, #+44]
    529              CRYP_ContextSave->CRYP_K3RR = CRYP_KeyInitStruct->CRYP_Key3Right; 
   \   000000AC   0x69CD             LDR      R5,[R1, #+28]
   \   000000AE   0x6315             STR      R5,[R2, #+48]
    530          
    531             /* When needed, save the DMA status (pointers for IN and OUT messages, 
    532                number of remaining bytes, etc.) */
    533               
    534              status = SUCCESS;
   \   000000B0   0x2501             MOVS     R5,#+1
   \   000000B2   0x0028             MOVS     R0,R5
    535            }
    536          
    537             return status;
   \                     ??CRYP_SaveContext_4: (+1)
   \   000000B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B6   0xBC72             POP      {R1,R4-R6}
   \   000000B8   0x4770             BX       LR               ;; return
    538          }
    539          
    540          /**
    541            * @brief  Restores the CRYP peripheral Context.
    542            * @note   Since teh DMA transfer is stopped in CRYP_SaveContext() function,
    543            *         after restoring the context, you have to enable the DMA again (if the
    544            *         DMA was previously used).  
    545            * @param  CRYP_ContextRestore: pointer to a CRYP_Context structure that contains
    546            *         the repository for saved context.
    547            * @note   The data that were saved during context saving must be rewrited into
    548            *         the IN FIFO.
    549            * @retval None
    550            */

   \                                 In section .text, align 2, keep-with-next
    551          void CRYP_RestoreContext(CRYP_Context* CRYP_ContextRestore)  
    552          {
    553          
    554            /* Configure the processor with the saved configuration */
    555            CRYP->CR = CRYP_ContextRestore->CR_bits9to2;
   \                     CRYP_RestoreContext: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x....             LDR.N    R2,??DataTable12_1  ;; 0x50060000
   \   00000004   0x6011             STR      R1,[R2, #+0]
    556          
    557            /* restore The key value */
    558            CRYP->K0LR = CRYP_ContextRestore->CRYP_K0LR; 
   \   00000006   0x6941             LDR      R1,[R0, #+20]
   \   00000008   0x....             LDR.N    R2,??DataTable12_2  ;; 0x50060020
   \   0000000A   0x6011             STR      R1,[R2, #+0]
    559            CRYP->K0RR = CRYP_ContextRestore->CRYP_K0RR;
   \   0000000C   0x6981             LDR      R1,[R0, #+24]
   \   0000000E   0x....             LDR.N    R2,??DataTable12_3  ;; 0x50060024
   \   00000010   0x6011             STR      R1,[R2, #+0]
    560            CRYP->K1LR = CRYP_ContextRestore->CRYP_K1LR;
   \   00000012   0x69C1             LDR      R1,[R0, #+28]
   \   00000014   0x....             LDR.N    R2,??DataTable12_4  ;; 0x50060028
   \   00000016   0x6011             STR      R1,[R2, #+0]
    561            CRYP->K1RR = CRYP_ContextRestore->CRYP_K1RR;
   \   00000018   0x6A01             LDR      R1,[R0, #+32]
   \   0000001A   0x....             LDR.N    R2,??DataTable12_5  ;; 0x5006002c
   \   0000001C   0x6011             STR      R1,[R2, #+0]
    562            CRYP->K2LR = CRYP_ContextRestore->CRYP_K2LR;
   \   0000001E   0x6A41             LDR      R1,[R0, #+36]
   \   00000020   0x....             LDR.N    R2,??DataTable12_6  ;; 0x50060030
   \   00000022   0x6011             STR      R1,[R2, #+0]
    563            CRYP->K2RR = CRYP_ContextRestore->CRYP_K2RR;
   \   00000024   0x6A81             LDR      R1,[R0, #+40]
   \   00000026   0x....             LDR.N    R2,??DataTable12_7  ;; 0x50060034
   \   00000028   0x6011             STR      R1,[R2, #+0]
    564            CRYP->K3LR = CRYP_ContextRestore->CRYP_K3LR;
   \   0000002A   0x6AC1             LDR      R1,[R0, #+44]
   \   0000002C   0x....             LDR.N    R2,??DataTable12_8  ;; 0x50060038
   \   0000002E   0x6011             STR      R1,[R2, #+0]
    565            CRYP->K3RR = CRYP_ContextRestore->CRYP_K3RR;
   \   00000030   0x6B01             LDR      R1,[R0, #+48]
   \   00000032   0x....             LDR.N    R2,??DataTable12_9  ;; 0x5006003c
   \   00000034   0x6011             STR      R1,[R2, #+0]
    566          
    567            /* and the initialization vectors. */
    568            CRYP->IV0LR = CRYP_ContextRestore->CRYP_IV0LR;
   \   00000036   0x6841             LDR      R1,[R0, #+4]
   \   00000038   0x....             LDR.N    R2,??DataTable12_10  ;; 0x50060040
   \   0000003A   0x6011             STR      R1,[R2, #+0]
    569            CRYP->IV0RR = CRYP_ContextRestore->CRYP_IV0RR;
   \   0000003C   0x6881             LDR      R1,[R0, #+8]
   \   0000003E   0x....             LDR.N    R2,??DataTable12_11  ;; 0x50060044
   \   00000040   0x6011             STR      R1,[R2, #+0]
    570            CRYP->IV1LR = CRYP_ContextRestore->CRYP_IV1LR;
   \   00000042   0x68C1             LDR      R1,[R0, #+12]
   \   00000044   0x....             LDR.N    R2,??DataTable12_12  ;; 0x50060048
   \   00000046   0x6011             STR      R1,[R2, #+0]
    571            CRYP->IV1RR = CRYP_ContextRestore->CRYP_IV1RR;
   \   00000048   0x6901             LDR      R1,[R0, #+16]
   \   0000004A   0x....             LDR.N    R2,??DataTable12_13  ;; 0x5006004c
   \   0000004C   0x6011             STR      R1,[R2, #+0]
    572          
    573            /* Enable the cryptographic processor */
    574            CRYP->CR |= CRYP_CR_CRYPEN;
   \   0000004E   0x....             LDR.N    R1,??DataTable12_1  ;; 0x50060000
   \   00000050   0x6809             LDR      R1,[R1, #+0]
   \   00000052   0xF451 0x4100      ORRS     R1,R1,#0x8000
   \   00000056   0x....             LDR.N    R2,??DataTable12_1  ;; 0x50060000
   \   00000058   0x6011             STR      R1,[R2, #+0]
    575          }
   \   0000005A   0x4770             BX       LR               ;; return
    576          /**
    577            * @}
    578            */
    579          
    580          /** @defgroup CRYP_Group4 CRYP's DMA interface Configuration function
    581           *  @brief   CRYP's DMA interface Configuration function 
    582           *
    583          @verbatim   
    584           ===============================================================================
    585                             CRYP's DMA interface Configuration function
    586           ===============================================================================  
    587          
    588            This section provides functions allowing to configure the DMA interface for 
    589            CRYP data input and output transfer.
    590             
    591            When the DMA mode is enabled (using the CRYP_DMACmd() function), data can be 
    592            transferred:
    593            - From memory to the CRYP IN FIFO using the DMA peripheral by enabling 
    594              the CRYP_DMAReq_DataIN request.
    595            - From the CRYP OUT FIFO to the memory using the DMA peripheral by enabling 
    596              the CRYP_DMAReq_DataOUT request.
    597          
    598          @endverbatim
    599            * @{
    600            */
    601          
    602          /**
    603            * @brief  Enables or disables the CRYP DMA interface.
    604            * @param  CRYP_DMAReq: specifies the CRYP DMA transfer request to be enabled or disabled.
    605            *           This parameter can be any combination of the following values:
    606            *            @arg CRYP_DMAReq_DataOUT: DMA for outgoing(Tx) data transfer
    607            *            @arg CRYP_DMAReq_DataIN: DMA for incoming(Rx) data transfer
    608            * @param  NewState: new state of the selected CRYP DMA transfer request.
    609            *          This parameter can be: ENABLE or DISABLE.
    610            * @retval None
    611            */

   \                                 In section .text, align 2, keep-with-next
    612          void CRYP_DMACmd(uint8_t CRYP_DMAReq, FunctionalState NewState)
    613          {
   \                     CRYP_DMACmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    614            /* Check the parameters */
    615            assert_param(IS_CRYP_DMAREQ(CRYP_DMAReq));
   \   00000006   0x20FC             MOVS     R0,#+252
   \   00000008   0x4204             TST      R4,R0
   \   0000000A   0xD102             BNE.N    ??CRYP_DMACmd_0
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD104             BNE.N    ??CRYP_DMACmd_1
   \                     ??CRYP_DMACmd_0: (+1)
   \   00000012   0xF240 0x2167      MOVW     R1,#+615
   \   00000016   0x....             LDR.N    R0,??DataTable12
   \   00000018   0x.... 0x....      BL       assert_failed
    616            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??CRYP_DMACmd_1: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??CRYP_DMACmd_2
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD004             BEQ.N    ??CRYP_DMACmd_2
   \   00000028   0xF44F 0x711A      MOV      R1,#+616
   \   0000002C   0x....             LDR.N    R0,??DataTable12
   \   0000002E   0x.... 0x....      BL       assert_failed
    617          
    618            if (NewState != DISABLE)
   \                     ??CRYP_DMACmd_2: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD006             BEQ.N    ??CRYP_DMACmd_3
    619            {
    620              /* Enable the selected CRYP DMA request */
    621              CRYP->DMACR |= CRYP_DMAReq;
   \   00000038   0x....             LDR.N    R0,??DataTable12_16  ;; 0x50060010
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   0x4320             ORRS     R0,R4,R0
   \   00000040   0x....             LDR.N    R1,??DataTable12_16  ;; 0x50060010
   \   00000042   0x6008             STR      R0,[R1, #+0]
   \   00000044   0xE006             B.N      ??CRYP_DMACmd_4
    622            }
    623            else
    624            {
    625              /* Disable the selected CRYP DMA request */
    626              CRYP->DMACR &= (uint8_t)~CRYP_DMAReq;
   \                     ??CRYP_DMACmd_3: (+1)
   \   00000046   0x....             LDR.N    R0,??DataTable12_16  ;; 0x50060010
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x43E1             MVNS     R1,R4
   \   0000004C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004E   0x4008             ANDS     R0,R1,R0
   \   00000050   0x....             LDR.N    R1,??DataTable12_16  ;; 0x50060010
   \   00000052   0x6008             STR      R0,[R1, #+0]
    627            }
    628          }
   \                     ??CRYP_DMACmd_4: (+1)
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    629          /**
    630            * @}
    631            */
    632          
    633          /** @defgroup CRYP_Group5 Interrupts and flags management functions
    634           *  @brief   Interrupts and flags management functions
    635           *
    636          @verbatim   
    637           ===============================================================================
    638                             Interrupts and flags management functions
    639           ===============================================================================  
    640          
    641            This section provides functions allowing to configure the CRYP Interrupts and 
    642            to get the status and Interrupts pending bits.
    643          
    644            The CRYP provides 2 Interrupts sources and 7 Flags:
    645          
    646            Flags :
    647            ------- 
    648                                    
    649               1. CRYP_FLAG_IFEM :  Set when Input FIFO is empty.
    650                                    This Flag is cleared only by hardware.
    651                
    652               2. CRYP_FLAG_IFNF :  Set when Input FIFO is not full.
    653                                    This Flag is cleared only by hardware.
    654          
    655          
    656               3. CRYP_FLAG_INRIS  : Set when Input FIFO Raw interrupt is pending 
    657                                     it gives the raw interrupt state prior to masking 
    658                                     of the input FIFO service interrupt.
    659                                     This Flag is cleared only by hardware.
    660               
    661               4. CRYP_FLAG_OFNE   : Set when Output FIFO not empty.
    662                                     This Flag is cleared only by hardware.
    663                  
    664               5. CRYP_FLAG_OFFU   : Set when Output FIFO is full.
    665                                     This Flag is cleared only by hardware.
    666                                     
    667               6. CRYP_FLAG_OUTRIS : Set when Output FIFO Raw interrupt is pending 
    668                                     it gives the raw interrupt state prior to masking 
    669                                     of the output FIFO service interrupt.
    670                                     This Flag is cleared only by hardware.
    671                                         
    672               7. CRYP_FLAG_BUSY   : Set when the CRYP core is currently processing a 
    673                                     block of data or a key preparation (for AES 
    674                                     decryption).
    675                                     This Flag is cleared only by hardware.
    676                                     To clear it, the CRYP core must be disabled and the 
    677                                     last processing has completed. 
    678          
    679            Interrupts :
    680            ------------
    681          
    682             1. CRYP_IT_INI   : The input FIFO service interrupt is asserted when there 
    683                                are less than 4 words in the input FIFO.
    684                                This interrupt is associated to CRYP_FLAG_INRIS flag.
    685          
    686                          @note This interrupt is cleared by performing write operations 
    687                                to the input FIFO until it holds 4 or more words. The 
    688                                input FIFO service interrupt INMIS is enabled with the 
    689                                CRYP enable bit. Consequently, when CRYP is disabled, the 
    690                                INMIS signal is low even if the input FIFO is empty.
    691          
    692          
    693          
    694             2. CRYP_IT_OUTI  : The output FIFO service interrupt is asserted when there 
    695                                is one or more (32-bit word) data items in the output FIFO.
    696                                This interrupt is associated to CRYP_FLAG_OUTRIS flag.
    697          
    698                          @note This interrupt is cleared by reading data from the output 
    699                                FIFO until there is no valid (32-bit) word left (that is, 
    700                                the interrupt follows the state of the OFNE (output FIFO 
    701                                not empty) flag).
    702          
    703          
    704            Managing the CRYP controller events :
    705            ------------------------------------ 
    706            The user should identify which mode will be used in his application to manage 
    707            the CRYP controller events: Polling mode or Interrupt mode.
    708          
    709            1.  In the Polling Mode it is advised to use the following functions:
    710                - CRYP_GetFlagStatus() : to check if flags events occur. 
    711          
    712            @note  The CRYPT flags do not need to be cleared since they are cleared as 
    713                   soon as the associated event are reset.   
    714          
    715          
    716            2.  In the Interrupt Mode it is advised to use the following functions:
    717                - CRYP_ITConfig()       : to enable or disable the interrupt source.
    718                - CRYP_GetITStatus()    : to check if Interrupt occurs.
    719          
    720            @note  The CRYPT interrupts have no pending bits, the interrupt is cleared as 
    721                   soon as the associated event is reset. 
    722          
    723          @endverbatim
    724            * @{
    725            */ 
    726          
    727          /**
    728            * @brief  Enables or disables the specified CRYP interrupts.
    729            * @param  CRYP_IT: specifies the CRYP interrupt source to be enabled or disabled.
    730            *          This parameter can be any combination of the following values:
    731            *            @arg CRYP_IT_INI: Input FIFO interrupt
    732            *            @arg CRYP_IT_OUTI: Output FIFO interrupt
    733            * @param  NewState: new state of the specified CRYP interrupt.
    734            *           This parameter can be: ENABLE or DISABLE.
    735            * @retval None
    736            */

   \                                 In section .text, align 2, keep-with-next
    737          void CRYP_ITConfig(uint8_t CRYP_IT, FunctionalState NewState)
    738          {
   \                     CRYP_ITConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    739            /* Check the parameters */
    740            assert_param(IS_CRYP_CONFIG_IT(CRYP_IT));
   \   00000006   0x20FC             MOVS     R0,#+252
   \   00000008   0x4204             TST      R4,R0
   \   0000000A   0xD102             BNE.N    ??CRYP_ITConfig_0
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD104             BNE.N    ??CRYP_ITConfig_1
   \                     ??CRYP_ITConfig_0: (+1)
   \   00000012   0xF44F 0x7139      MOV      R1,#+740
   \   00000016   0x....             LDR.N    R0,??DataTable12
   \   00000018   0x.... 0x....      BL       assert_failed
    741            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??CRYP_ITConfig_1: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??CRYP_ITConfig_2
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD004             BEQ.N    ??CRYP_ITConfig_2
   \   00000028   0xF240 0x21E5      MOVW     R1,#+741
   \   0000002C   0x....             LDR.N    R0,??DataTable12
   \   0000002E   0x.... 0x....      BL       assert_failed
    742          
    743            if (NewState != DISABLE)
   \                     ??CRYP_ITConfig_2: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD006             BEQ.N    ??CRYP_ITConfig_3
    744            {
    745              /* Enable the selected CRYP interrupt */
    746              CRYP->IMSCR |= CRYP_IT;
   \   00000038   0x....             LDR.N    R0,??DataTable12_18  ;; 0x50060014
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   0x4320             ORRS     R0,R4,R0
   \   00000040   0x....             LDR.N    R1,??DataTable12_18  ;; 0x50060014
   \   00000042   0x6008             STR      R0,[R1, #+0]
   \   00000044   0xE006             B.N      ??CRYP_ITConfig_4
    747            }
    748            else
    749            {
    750              /* Disable the selected CRYP interrupt */
    751              CRYP->IMSCR &= (uint8_t)~CRYP_IT;
   \                     ??CRYP_ITConfig_3: (+1)
   \   00000046   0x....             LDR.N    R0,??DataTable12_18  ;; 0x50060014
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x43E1             MVNS     R1,R4
   \   0000004C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004E   0x4008             ANDS     R0,R1,R0
   \   00000050   0x....             LDR.N    R1,??DataTable12_18  ;; 0x50060014
   \   00000052   0x6008             STR      R0,[R1, #+0]
    752            }
    753          }
   \                     ??CRYP_ITConfig_4: (+1)
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    754          
    755          /**
    756            * @brief  Checks whether the specified CRYP interrupt has occurred or not.
    757            * @note   This function checks the status of the masked interrupt (i.e the 
    758            *         interrupt should be previously enabled).     
    759            * @param  CRYP_IT: specifies the CRYP (masked) interrupt source to check.
    760            *           This parameter can be one of the following values:
    761            *            @arg CRYP_IT_INI: Input FIFO interrupt
    762            *            @arg CRYP_IT_OUTI: Output FIFO interrupt
    763            * @retval The new state of CRYP_IT (SET or RESET).
    764            */

   \                                 In section .text, align 2, keep-with-next
    765          ITStatus CRYP_GetITStatus(uint8_t CRYP_IT)
    766          {
   \                     CRYP_GetITStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    767            ITStatus bitstatus = RESET;
   \   00000004   0x2500             MOVS     R5,#+0
    768            /* Check the parameters */
    769            assert_param(IS_CRYP_GET_IT(CRYP_IT));
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD007             BEQ.N    ??CRYP_GetITStatus_0
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C02             CMP      R4,#+2
   \   00000010   0xD004             BEQ.N    ??CRYP_GetITStatus_0
   \   00000012   0xF240 0x3101      MOVW     R1,#+769
   \   00000016   0x....             LDR.N    R0,??DataTable12
   \   00000018   0x.... 0x....      BL       assert_failed
    770          
    771            /* Check the status of the specified CRYP interrupt */
    772            if ((CRYP->MISR &  CRYP_IT) != (uint8_t)RESET)
   \                     ??CRYP_GetITStatus_0: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable12_19  ;; 0x5006001c
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x4220             TST      R0,R4
   \   00000024   0xD002             BEQ.N    ??CRYP_GetITStatus_1
    773            {
    774              /* CRYP_IT is set */
    775              bitstatus = SET;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x0005             MOVS     R5,R0
   \   0000002A   0xE001             B.N      ??CRYP_GetITStatus_2
    776            }
    777            else
    778            {
    779              /* CRYP_IT is reset */
    780              bitstatus = RESET;
   \                     ??CRYP_GetITStatus_1: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x0005             MOVS     R5,R0
    781            }
    782            /* Return the CRYP_IT status */
    783            return bitstatus;
   \                     ??CRYP_GetITStatus_2: (+1)
   \   00000030   0x0028             MOVS     R0,R5
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    784          }
    785          
    786          /**
    787            * @brief  Checks whether the specified CRYP flag is set or not.
    788            * @param  CRYP_FLAG: specifies the CRYP flag to check.
    789            *          This parameter can be one of the following values:
    790            *            @arg CRYP_FLAG_IFEM: Input FIFO Empty flag.
    791            *            @arg CRYP_FLAG_IFNF: Input FIFO Not Full flag.
    792            *            @arg CRYP_FLAG_OFNE: Output FIFO Not Empty flag.
    793            *            @arg CRYP_FLAG_OFFU: Output FIFO Full flag.
    794            *            @arg CRYP_FLAG_BUSY: Busy flag.
    795            *            @arg CRYP_FLAG_OUTRIS: Output FIFO raw interrupt flag.
    796            *            @arg CRYP_FLAG_INRIS: Input FIFO raw interrupt flag.
    797            * @retval The new state of CRYP_FLAG (SET or RESET).
    798            */

   \                                 In section .text, align 2, keep-with-next
    799          FlagStatus CRYP_GetFlagStatus(uint8_t CRYP_FLAG)
    800          {
   \                     CRYP_GetFlagStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    801            FlagStatus bitstatus = RESET;
   \   00000004   0x2500             MOVS     R5,#+0
    802            uint32_t tempreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    803          
    804            /* Check the parameters */
    805            assert_param(IS_CRYP_GET_FLAG(CRYP_FLAG));
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x2C01             CMP      R4,#+1
   \   0000000C   0xD016             BEQ.N    ??CRYP_GetFlagStatus_0
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x2C02             CMP      R4,#+2
   \   00000012   0xD013             BEQ.N    ??CRYP_GetFlagStatus_0
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0x2C04             CMP      R4,#+4
   \   00000018   0xD010             BEQ.N    ??CRYP_GetFlagStatus_0
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C08             CMP      R4,#+8
   \   0000001E   0xD00D             BEQ.N    ??CRYP_GetFlagStatus_0
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x2C10             CMP      R4,#+16
   \   00000024   0xD00A             BEQ.N    ??CRYP_GetFlagStatus_0
   \   00000026   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000028   0x2C21             CMP      R4,#+33
   \   0000002A   0xD007             BEQ.N    ??CRYP_GetFlagStatus_0
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x2C22             CMP      R4,#+34
   \   00000030   0xD004             BEQ.N    ??CRYP_GetFlagStatus_0
   \   00000032   0xF240 0x3125      MOVW     R1,#+805
   \   00000036   0x....             LDR.N    R0,??DataTable12
   \   00000038   0x.... 0x....      BL       assert_failed
    806          
    807            /* check if the FLAG is in RISR register */
    808            if ((CRYP_FLAG & FLAG_MASK) != 0x00) 
   \                     ??CRYP_GetFlagStatus_0: (+1)
   \   0000003C   0x06A0             LSLS     R0,R4,#+26
   \   0000003E   0xD503             BPL.N    ??CRYP_GetFlagStatus_1
    809            {
    810              tempreg = CRYP->RISR;
   \   00000040   0x....             LDR.N    R0,??DataTable12_20  ;; 0x50060018
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x0006             MOVS     R6,R0
   \   00000046   0xE002             B.N      ??CRYP_GetFlagStatus_2
    811            }
    812            else  /* The FLAG is in SR register */
    813            {
    814              tempreg = CRYP->SR;
   \                     ??CRYP_GetFlagStatus_1: (+1)
   \   00000048   0x....             LDR.N    R0,??DataTable12_17  ;; 0x50060004
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x0006             MOVS     R6,R0
    815            }
    816          
    817          
    818            /* Check the status of the specified CRYP flag */
    819            if ((tempreg & CRYP_FLAG ) != (uint8_t)RESET)
   \                     ??CRYP_GetFlagStatus_2: (+1)
   \   0000004E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000050   0x4226             TST      R6,R4
   \   00000052   0xD002             BEQ.N    ??CRYP_GetFlagStatus_3
    820            {
    821              /* CRYP_FLAG is set */
    822              bitstatus = SET;
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0x0005             MOVS     R5,R0
   \   00000058   0xE001             B.N      ??CRYP_GetFlagStatus_4
    823            }
    824            else
    825            {
    826              /* CRYP_FLAG is reset */
    827              bitstatus = RESET;
   \                     ??CRYP_GetFlagStatus_3: (+1)
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x0005             MOVS     R5,R0
    828            }
    829          
    830            /* Return the CRYP_FLAG status */
    831            return  bitstatus;
   \                     ??CRYP_GetFlagStatus_4: (+1)
   \   0000005E   0x0028             MOVS     R0,R5
   \   00000060   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000062   0xBD70             POP      {R4-R6,PC}       ;; return
    832          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x50060000         DC32     0x50060000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x50060020         DC32     0x50060020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x50060024         DC32     0x50060024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x50060028         DC32     0x50060028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x5006002C         DC32     0x5006002c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \   00000000   0x50060030         DC32     0x50060030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \   00000000   0x50060034         DC32     0x50060034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \   00000000   0x50060038         DC32     0x50060038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \   00000000   0x5006003C         DC32     0x5006003c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_10:
   \   00000000   0x50060040         DC32     0x50060040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_11:
   \   00000000   0x50060044         DC32     0x50060044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_12:
   \   00000000   0x50060048         DC32     0x50060048

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_13:
   \   00000000   0x5006004C         DC32     0x5006004c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_14:
   \   00000000   0x50060008         DC32     0x50060008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_15:
   \   00000000   0x5006000C         DC32     0x5006000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_16:
   \   00000000   0x50060010         DC32     0x50060010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_17:
   \   00000000   0x50060004         DC32     0x50060004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_18:
   \   00000000   0x50060014         DC32     0x50060014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_19:
   \   00000000   0x5006001C         DC32     0x5006001c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_20:
   \   00000000   0x50060018         DC32     0x50060018

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 49H, 41H, 52H, 20H, 57H
   \              0x5C 0x49    
   \              0x41 0x52    
   \              0x20 0x57    
   \   00000008   0x6F 0x72          DC8 6FH, 72H, 6BH, 73H, 70H, 61H, 63H, 65H
   \              0x6B 0x73    
   \              0x70 0x61    
   \              0x63 0x65    
   \   00000010   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 46H, 34H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x46 0x34    
   \   00000018   0x30 0x37          DC8 30H, 37H, 5CH, 53H, 54H, 4DH, 33H, 32H
   \              0x5C 0x53    
   \              0x54 0x4D    
   \              0x33 0x32    
   \   00000020   0x46 0x34          DC8 46H, 34H, 2DH, 44H, 69H, 73H, 63H, 6FH
   \              0x2D 0x44    
   \              0x69 0x73    
   \              0x63 0x6F    
   \   00000028   0x76 0x65          DC8 76H, 65H, 72H, 79H, 5FH, 46H, 57H, 5FH
   \              0x72 0x79    
   \              0x5F 0x46    
   \              0x57 0x5F    
   \   00000030   0x56 0x31          DC8 56H, 31H, 2EH, 31H, 2EH, 30H, 5CH, 4CH
   \              0x2E 0x31    
   \              0x2E 0x30    
   \              0x5C 0x4C    
   \   00000038   0x69 0x62          DC8 69H, 62H, 72H, 61H, 72H, 69H, 65H, 73H
   \              0x72 0x61    
   \              0x72 0x69    
   \              0x65 0x73    
   \   00000040   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 46H, 34H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x46 0x34    
   \   00000048   0x78 0x78          DC8 78H, 78H, 5FH, 53H, 74H, 64H, 50H, 65H
   \              0x5F 0x53    
   \              0x74 0x64    
   \              0x50 0x65    
   \   00000050   0x72 0x69          DC8 72H, 69H, 70H, 68H, 5FH, 44H, 72H, 69H
   \              0x70 0x68    
   \              0x5F 0x44    
   \              0x72 0x69    
   \   00000058   0x76 0x65          DC8 76H, 65H, 72H, 5CH, 73H, 72H, 63H, 5CH
   \              0x72 0x5C    
   \              0x73 0x72    
   \              0x63 0x5C    
   \   00000060   0x73 0x74          DC8 73H, 74H, 6DH, 33H, 32H, 66H, 34H, 78H
   \              0x6D 0x33    
   \              0x32 0x66    
   \              0x34 0x78    
   \   00000068   0x78 0x5F          DC8 78H, 5FH, 63H, 72H, 79H, 70H, 2EH, 63H
   \              0x63 0x72    
   \              0x79 0x70    
   \              0x2E 0x63    
   \   00000070   0x00               DC8 0
   \   00000071   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    833          
    834          /**
    835            * @}
    836            */
    837          
    838          /**
    839            * @}
    840            */ 
    841          
    842          /**
    843            * @}
    844            */ 
    845          
    846          /**
    847            * @}
    848            */ 
    849          
    850          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   CRYP_Cmd
         8   -> assert_failed
      16   CRYP_DMACmd
        16   -> assert_failed
       0   CRYP_DataIn
       0   CRYP_DataOut
       8   CRYP_DeInit
         8   -> RCC_AHB2PeriphResetCmd
       0   CRYP_FIFOFlush
      16   CRYP_GetFlagStatus
        16   -> assert_failed
      16   CRYP_GetITStatus
        16   -> assert_failed
      16   CRYP_ITConfig
        16   -> assert_failed
       0   CRYP_IVInit
       0   CRYP_IVStructInit
       8   CRYP_Init
         8   -> assert_failed
       0   CRYP_KeyInit
       0   CRYP_KeyStructInit
       0   CRYP_RestoreContext
      16   CRYP_SaveContext
       0   CRYP_StructInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_11
       4  ??DataTable12_12
       4  ??DataTable12_13
       4  ??DataTable12_14
       4  ??DataTable12_15
       4  ??DataTable12_16
       4  ??DataTable12_17
       4  ??DataTable12_18
       4  ??DataTable12_19
       4  ??DataTable12_2
       4  ??DataTable12_20
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
     116  ?_0
      60  CRYP_Cmd
      86  CRYP_DMACmd
       6  CRYP_DataIn
       6  CRYP_DataOut
      20  CRYP_DeInit
      14  CRYP_FIFOFlush
     100  CRYP_GetFlagStatus
      54  CRYP_GetITStatus
      86  CRYP_ITConfig
      26  CRYP_IVInit
      18  CRYP_IVStructInit
     304  CRYP_Init
      66  CRYP_KeyInit
      34  CRYP_KeyStructInit
      92  CRYP_RestoreContext
     186  CRYP_SaveContext
      18  CRYP_StructInit

 
   116 bytes in section .rodata
 1 260 bytes in section .text
 
 1 260 bytes of CODE  memory
   116 bytes of CONST memory

Errors: none
Warnings: none
