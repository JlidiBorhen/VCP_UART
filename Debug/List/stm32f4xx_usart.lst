###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       06/May/2016  23:31:36
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\IAR
#        Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_usart.c
#    Command line =  
#        "D:\IAR
#        Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_usart.c"
#        -D USE_STDPERIPH_DRIVER -D STM32F4XX -D USE_FULL_ASSERT -lCN "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\List" -o "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\Obj" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\Include\" -I
#        "D:\IAR Workspace\STM32F407\VCP_ESP\..\Utilities\STM32F4-Discovery\"
#        -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\ST\STM32F4xx\Include\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_conf\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\cdc\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\otg\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\core\" -On --use_c++_inline -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    List file    =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\Debug\List\stm32f4xx_usart.lst
#    Object file  =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\Debug\Obj\stm32f4xx_usart.o
#
###############################################################################

D:\IAR Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_usart.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_usart.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    30-September-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Universal synchronous asynchronous receiver
      9            *          transmitter (USART):           
     10            *           - Initialization and Configuration
     11            *           - Data transfers
     12            *           - Multi-Processor Communication
     13            *           - LIN mode
     14            *           - Half-duplex mode
     15            *           - Smartcard mode
     16            *           - IrDA mode
     17            *           - DMA transfers management
     18            *           - Interrupts and flags management 
     19            *           
     20            *  @verbatim
     21            *      
     22            *          ===================================================================
     23            *                                 How to use this driver
     24            *          ===================================================================
     25            *          1. Enable peripheral clock using the follwoing functions
     26            *             RCC_APB2PeriphClockCmd(RCC_APB2Periph_USARTx, ENABLE) for USART1 and USART6 
     27            *             RCC_APB1PeriphClockCmd(RCC_APB1Periph_USARTx, ENABLE) for USART2, USART3, UART4 or UART5.
     28            *
     29            *          2.  According to the USART mode, enable the GPIO clocks using 
     30            *              RCC_AHB1PeriphClockCmd() function. (The I/O can be TX, RX, CTS, 
     31            *              or/and SCLK). 
     32            *
     33            *          3. Peripheral's alternate function: 
     34            *                 - Connect the pin to the desired peripherals' Alternate 
     35            *                   Function (AF) using GPIO_PinAFConfig() function
     36            *                 - Configure the desired pin in alternate function by:
     37            *                   GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     38            *                 - Select the type, pull-up/pull-down and output speed via 
     39            *                   GPIO_PuPd, GPIO_OType and GPIO_Speed members
     40            *                 - Call GPIO_Init() function
     41            *        
     42            *          4. Program the Baud Rate, Word Length , Stop Bit, Parity, Hardware 
     43            *             flow control and Mode(Receiver/Transmitter) using the USART_Init()
     44            *             function.
     45            *
     46            *          5. For synchronous mode, enable the clock and program the polarity,
     47            *             phase and last bit using the USART_ClockInit() function.
     48            *
     49            *          5. Enable the NVIC and the corresponding interrupt using the function 
     50            *             USART_ITConfig() if you need to use interrupt mode. 
     51            *
     52            *          6. When using the DMA mode 
     53            *                   - Configure the DMA using DMA_Init() function
     54            *                   - Active the needed channel Request using USART_DMACmd() function
     55            * 
     56            *          7. Enable the USART using the USART_Cmd() function.
     57            * 
     58            *          8. Enable the DMA using the DMA_Cmd() function, when using DMA mode. 
     59            *
     60            *          Refer to Multi-Processor, LIN, half-duplex, Smartcard, IrDA sub-sections
     61            *          for more details
     62            *          
     63            *          In order to reach higher communication baudrates, it is possible to
     64            *          enable the oversampling by 8 mode using the function USART_OverSampling8Cmd().
     65            *          This function should be called after enabling the USART clock (RCC_APBxPeriphClockCmd())
     66            *          and before calling the function USART_Init().
     67            *          
     68            *  @endverbatim
     69            *        
     70            ******************************************************************************
     71            * @attention
     72            *
     73            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     74            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     75            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     76            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     77            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     78            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     79            *
     80            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     81            ******************************************************************************  
     82            */ 
     83          
     84          /* Includes ------------------------------------------------------------------*/
     85          #include "stm32f4xx_usart.h"
     86          #include "stm32f4xx_rcc.h"
     87          
     88          /** @addtogroup STM32F4xx_StdPeriph_Driver
     89            * @{
     90            */
     91          
     92          /** @defgroup USART 
     93            * @brief USART driver modules
     94            * @{
     95            */
     96          
     97          /* Private typedef -----------------------------------------------------------*/
     98          /* Private define ------------------------------------------------------------*/
     99          
    100          /*!< USART CR1 register clear Mask ((~(uint16_t)0xE9F3)) */
    101          #define CR1_CLEAR_MASK            ((uint16_t)(USART_CR1_M | USART_CR1_PCE | \
    102                                                        USART_CR1_PS | USART_CR1_TE | \
    103                                                        USART_CR1_RE))
    104          
    105          /*!< USART CR2 register clock bits clear Mask ((~(uint16_t)0xF0FF)) */
    106          #define CR2_CLOCK_CLEAR_MASK      ((uint16_t)(USART_CR2_CLKEN | USART_CR2_CPOL | \
    107                                                        USART_CR2_CPHA | USART_CR2_LBCL))
    108          
    109          /*!< USART CR3 register clear Mask ((~(uint16_t)0xFCFF)) */
    110          #define CR3_CLEAR_MASK            ((uint16_t)(USART_CR3_RTSE | USART_CR3_CTSE))
    111          
    112          /*!< USART Interrupts mask */
    113          #define IT_MASK                   ((uint16_t)0x001F)
    114          
    115          /* Private macro -------------------------------------------------------------*/
    116          /* Private variables ---------------------------------------------------------*/
    117          /* Private function prototypes -----------------------------------------------*/
    118          /* Private functions ---------------------------------------------------------*/
    119          
    120          /** @defgroup USART_Private_Functions
    121            * @{
    122            */
    123          
    124          /** @defgroup USART_Group1 Initialization and Configuration functions
    125           *  @brief   Initialization and Configuration functions 
    126           *
    127          @verbatim   
    128           ===============================================================================
    129                            Initialization and Configuration functions
    130           ===============================================================================  
    131          
    132            This subsection provides a set of functions allowing to initialize the USART 
    133            in asynchronous and in synchronous modes.
    134             - For the asynchronous mode only these parameters can be configured: 
    135                  - Baud Rate
    136                  - Word Length 
    137                  - Stop Bit
    138                  - Parity: If the parity is enabled, then the MSB bit of the data written
    139                    in the data register is transmitted but is changed by the parity bit.
    140                    Depending on the frame length defined by the M bit (8-bits or 9-bits),
    141                    the possible USART frame formats are as listed in the following table:
    142             +-------------------------------------------------------------+     
    143             |   M bit |  PCE bit  |            USART frame                |
    144             |---------------------|---------------------------------------|             
    145             |    0    |    0      |    | SB | 8 bit data | STB |          |
    146             |---------|-----------|---------------------------------------|  
    147             |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
    148             |---------|-----------|---------------------------------------|  
    149             |    1    |    0      |    | SB | 9 bit data | STB |          |
    150             |---------|-----------|---------------------------------------|  
    151             |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
    152             +-------------------------------------------------------------+            
    153                  - Hardware flow control
    154                  - Receiver/transmitter modes
    155          
    156            The USART_Init() function follows the USART  asynchronous configuration procedure
    157            (details for the procedure are available in reference manual (RM0090)).
    158          
    159            - For the synchronous mode in addition to the asynchronous mode parameters these 
    160              parameters should be also configured:
    161                  - USART Clock Enabled
    162                  - USART polarity
    163                  - USART phase
    164                  - USART LastBit
    165            
    166            These parameters can be configured using the USART_ClockInit() function.
    167          
    168          @endverbatim
    169            * @{
    170            */
    171            
    172          /**
    173            * @brief  Deinitializes the USARTx peripheral registers to their default reset values.
    174            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    175            *         UART peripheral.
    176            * @retval None
    177            */

   \                                 In section .text, align 2, keep-with-next
    178          void USART_DeInit(USART_TypeDef* USARTx)
    179          {
   \                     USART_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    180            /* Check the parameters */
    181            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40011000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD018             BEQ.N    ??USART_DeInit_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40004400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD014             BEQ.N    ??USART_DeInit_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable17_1  ;; 0x40004800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD010             BEQ.N    ??USART_DeInit_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable17_2  ;; 0x40004c00
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD00C             BEQ.N    ??USART_DeInit_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable17_3  ;; 0x40005000
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD008             BEQ.N    ??USART_DeInit_0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0x40011400
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD004             BEQ.N    ??USART_DeInit_0
   \   00000034   0x21B5             MOVS     R1,#+181
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   0000003A   0x.... 0x....      BL       assert_failed
    182          
    183            if (USARTx == USART1)
   \                     ??USART_DeInit_0: (+1)
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40011000
   \   00000042   0x4284             CMP      R4,R0
   \   00000044   0xD108             BNE.N    ??USART_DeInit_1
    184            {
    185              RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0x2010             MOVS     R0,#+16
   \   0000004A   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    186              RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
   \   0000004E   0x2100             MOVS     R1,#+0
   \   00000050   0x2010             MOVS     R0,#+16
   \   00000052   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
   \   00000056   0xE047             B.N      ??USART_DeInit_2
    187            }
    188            else if (USARTx == USART2)
   \                     ??USART_DeInit_1: (+1)
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40004400
   \   0000005C   0x4284             CMP      R4,R0
   \   0000005E   0xD10A             BNE.N    ??USART_DeInit_3
    189            {
    190              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
   \   00000060   0x2101             MOVS     R1,#+1
   \   00000062   0xF45F 0x3000      MOVS     R0,#+131072
   \   00000066   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    191              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0xF45F 0x3000      MOVS     R0,#+131072
   \   00000070   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \   00000074   0xE038             B.N      ??USART_DeInit_2
    192            }
    193            else if (USARTx == USART3)
   \                     ??USART_DeInit_3: (+1)
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable17_1  ;; 0x40004800
   \   0000007A   0x4284             CMP      R4,R0
   \   0000007C   0xD10A             BNE.N    ??USART_DeInit_4
    194            {
    195              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
   \   0000007E   0x2101             MOVS     R1,#+1
   \   00000080   0xF45F 0x2080      MOVS     R0,#+262144
   \   00000084   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    196              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
   \   00000088   0x2100             MOVS     R1,#+0
   \   0000008A   0xF45F 0x2080      MOVS     R0,#+262144
   \   0000008E   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \   00000092   0xE029             B.N      ??USART_DeInit_2
    197            }    
    198            else if (USARTx == UART4)
   \                     ??USART_DeInit_4: (+1)
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable17_2  ;; 0x40004c00
   \   00000098   0x4284             CMP      R4,R0
   \   0000009A   0xD10A             BNE.N    ??USART_DeInit_5
    199            {
    200              RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
   \   0000009C   0x2101             MOVS     R1,#+1
   \   0000009E   0xF45F 0x2000      MOVS     R0,#+524288
   \   000000A2   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    201              RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
   \   000000A6   0x2100             MOVS     R1,#+0
   \   000000A8   0xF45F 0x2000      MOVS     R0,#+524288
   \   000000AC   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \   000000B0   0xE01A             B.N      ??USART_DeInit_2
    202            }
    203            else if (USARTx == UART5)
   \                     ??USART_DeInit_5: (+1)
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable17_3  ;; 0x40005000
   \   000000B6   0x4284             CMP      R4,R0
   \   000000B8   0xD10A             BNE.N    ??USART_DeInit_6
    204            {
    205              RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
   \   000000BA   0x2101             MOVS     R1,#+1
   \   000000BC   0xF45F 0x1080      MOVS     R0,#+1048576
   \   000000C0   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    206              RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
   \   000000C4   0x2100             MOVS     R1,#+0
   \   000000C6   0xF45F 0x1080      MOVS     R0,#+1048576
   \   000000CA   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \   000000CE   0xE00B             B.N      ??USART_DeInit_2
    207            }     
    208            else
    209            {
    210              if (USARTx == USART6)
   \                     ??USART_DeInit_6: (+1)
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0x40011400
   \   000000D4   0x4284             CMP      R4,R0
   \   000000D6   0xD107             BNE.N    ??USART_DeInit_2
    211              { 
    212                RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
   \   000000D8   0x2101             MOVS     R1,#+1
   \   000000DA   0x2020             MOVS     R0,#+32
   \   000000DC   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    213                RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
   \   000000E0   0x2100             MOVS     R1,#+0
   \   000000E2   0x2020             MOVS     R0,#+32
   \   000000E4   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    214              }
    215            }
    216          }
   \                     ??USART_DeInit_2: (+1)
   \   000000E8   0xBD10             POP      {R4,PC}          ;; return
    217          
    218          /**
    219            * @brief  Initializes the USARTx peripheral according to the specified
    220            *         parameters in the USART_InitStruct .
    221            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    222            *         UART peripheral.
    223            * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
    224            *         the configuration information for the specified USART peripheral.
    225            * @retval None
    226            */

   \                                 In section .text, align 2, keep-with-next
    227          void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
    228          {
   \                     USART_Init: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
    229            uint32_t tmpreg = 0x00, apbclock = 0x00;
   \   0000000A   0x2600             MOVS     R6,#+0
   \   0000000C   0x2700             MOVS     R7,#+0
    230            uint32_t integerdivider = 0x00;
   \   0000000E   0xF05F 0x0800      MOVS     R8,#+0
    231            uint32_t fractionaldivider = 0x00;
   \   00000012   0xF05F 0x0900      MOVS     R9,#+0
    232            RCC_ClocksTypeDef RCC_ClocksStatus;
    233          
    234            /* Check the parameters */
    235            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40011000
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD018             BEQ.N    ??USART_Init_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40004400
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD014             BEQ.N    ??USART_Init_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable17_1  ;; 0x40004800
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD010             BEQ.N    ??USART_Init_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable17_2  ;; 0x40004c00
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD00C             BEQ.N    ??USART_Init_0
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable17_3  ;; 0x40005000
   \   0000003A   0x4284             CMP      R4,R0
   \   0000003C   0xD008             BEQ.N    ??USART_Init_0
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0x40011400
   \   00000042   0x4284             CMP      R4,R0
   \   00000044   0xD004             BEQ.N    ??USART_Init_0
   \   00000046   0x21EB             MOVS     R1,#+235
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   0000004C   0x.... 0x....      BL       assert_failed
    236            assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
   \                     ??USART_Init_0: (+1)
   \   00000050   0x6828             LDR      R0,[R5, #+0]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD004             BEQ.N    ??USART_Init_1
   \   00000056   0x6828             LDR      R0,[R5, #+0]
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable19  ;; 0x7270e1
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD304             BCC.N    ??USART_Init_2
   \                     ??USART_Init_1: (+1)
   \   00000060   0x21EC             MOVS     R1,#+236
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   00000066   0x.... 0x....      BL       assert_failed
    237            assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
   \                     ??USART_Init_2: (+1)
   \   0000006A   0x88A8             LDRH     R0,[R5, #+4]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD008             BEQ.N    ??USART_Init_3
   \   00000070   0x88A8             LDRH     R0,[R5, #+4]
   \   00000072   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000076   0xD004             BEQ.N    ??USART_Init_3
   \   00000078   0x21ED             MOVS     R1,#+237
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   0000007E   0x.... 0x....      BL       assert_failed
    238            assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
   \                     ??USART_Init_3: (+1)
   \   00000082   0x88E8             LDRH     R0,[R5, #+6]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD010             BEQ.N    ??USART_Init_4
   \   00000088   0x88E8             LDRH     R0,[R5, #+6]
   \   0000008A   0xF5B0 0x5F80      CMP      R0,#+4096
   \   0000008E   0xD00C             BEQ.N    ??USART_Init_4
   \   00000090   0x88E8             LDRH     R0,[R5, #+6]
   \   00000092   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000096   0xD008             BEQ.N    ??USART_Init_4
   \   00000098   0x88E8             LDRH     R0,[R5, #+6]
   \   0000009A   0xF5B0 0x5F40      CMP      R0,#+12288
   \   0000009E   0xD004             BEQ.N    ??USART_Init_4
   \   000000A0   0x21EE             MOVS     R1,#+238
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   000000A6   0x.... 0x....      BL       assert_failed
    239            assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
   \                     ??USART_Init_4: (+1)
   \   000000AA   0x8928             LDRH     R0,[R5, #+8]
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD00C             BEQ.N    ??USART_Init_5
   \   000000B0   0x8928             LDRH     R0,[R5, #+8]
   \   000000B2   0xF5B0 0x6F80      CMP      R0,#+1024
   \   000000B6   0xD008             BEQ.N    ??USART_Init_5
   \   000000B8   0x8928             LDRH     R0,[R5, #+8]
   \   000000BA   0xF5B0 0x6FC0      CMP      R0,#+1536
   \   000000BE   0xD004             BEQ.N    ??USART_Init_5
   \   000000C0   0x21EF             MOVS     R1,#+239
   \   000000C2   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   000000C6   0x.... 0x....      BL       assert_failed
    240            assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
   \                     ??USART_Init_5: (+1)
   \   000000CA   0x8968             LDRH     R0,[R5, #+10]
   \   000000CC   0xF64F 0x71F3      MOVW     R1,#+65523
   \   000000D0   0x4208             TST      R0,R1
   \   000000D2   0xD102             BNE.N    ??USART_Init_6
   \   000000D4   0x8968             LDRH     R0,[R5, #+10]
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD104             BNE.N    ??USART_Init_7
   \                     ??USART_Init_6: (+1)
   \   000000DA   0x21F0             MOVS     R1,#+240
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   000000E0   0x.... 0x....      BL       assert_failed
    241            assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
   \                     ??USART_Init_7: (+1)
   \   000000E4   0x89A8             LDRH     R0,[R5, #+12]
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD010             BEQ.N    ??USART_Init_8
   \   000000EA   0x89A8             LDRH     R0,[R5, #+12]
   \   000000EC   0xF5B0 0x7F80      CMP      R0,#+256
   \   000000F0   0xD00C             BEQ.N    ??USART_Init_8
   \   000000F2   0x89A8             LDRH     R0,[R5, #+12]
   \   000000F4   0xF5B0 0x7F00      CMP      R0,#+512
   \   000000F8   0xD008             BEQ.N    ??USART_Init_8
   \   000000FA   0x89A8             LDRH     R0,[R5, #+12]
   \   000000FC   0xF5B0 0x7F40      CMP      R0,#+768
   \   00000100   0xD004             BEQ.N    ??USART_Init_8
   \   00000102   0x21F1             MOVS     R1,#+241
   \   00000104   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   00000108   0x.... 0x....      BL       assert_failed
    242          
    243            /* The hardware flow control is available only for USART1, USART2, USART3 and USART6 */
    244            if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
   \                     ??USART_Init_8: (+1)
   \   0000010C   0x89A8             LDRH     R0,[R5, #+12]
   \   0000010E   0x2800             CMP      R0,#+0
   \   00000110   0xD014             BEQ.N    ??USART_Init_9
    245            {
    246              assert_param(IS_USART_1236_PERIPH(USARTx));
   \   00000112   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40011000
   \   00000116   0x4284             CMP      R4,R0
   \   00000118   0xD010             BEQ.N    ??USART_Init_9
   \   0000011A   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40004400
   \   0000011E   0x4284             CMP      R4,R0
   \   00000120   0xD00C             BEQ.N    ??USART_Init_9
   \   00000122   0x.... 0x....      LDR.W    R0,??DataTable17_1  ;; 0x40004800
   \   00000126   0x4284             CMP      R4,R0
   \   00000128   0xD008             BEQ.N    ??USART_Init_9
   \   0000012A   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0x40011400
   \   0000012E   0x4284             CMP      R4,R0
   \   00000130   0xD004             BEQ.N    ??USART_Init_9
   \   00000132   0x21F6             MOVS     R1,#+246
   \   00000134   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   00000138   0x.... 0x....      BL       assert_failed
    247            }
    248          
    249          /*---------------------------- USART CR2 Configuration -----------------------*/
    250            tmpreg = USARTx->CR2;
   \                     ??USART_Init_9: (+1)
   \   0000013C   0x8A20             LDRH     R0,[R4, #+16]
   \   0000013E   0x0006             MOVS     R6,R0
    251          
    252            /* Clear STOP[13:12] bits */
    253            tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
   \   00000140   0xF436 0x5640      BICS     R6,R6,#0x3000
    254          
    255            /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
    256                Set STOP[13:12] bits according to USART_StopBits value */
    257            tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
   \   00000144   0x88E8             LDRH     R0,[R5, #+6]
   \   00000146   0x4306             ORRS     R6,R0,R6
    258            
    259            /* Write to USART CR2 */
    260            USARTx->CR2 = (uint16_t)tmpreg;
   \   00000148   0x8226             STRH     R6,[R4, #+16]
    261          
    262          /*---------------------------- USART CR1 Configuration -----------------------*/
    263            tmpreg = USARTx->CR1;
   \   0000014A   0x89A0             LDRH     R0,[R4, #+12]
   \   0000014C   0x0006             MOVS     R6,R0
    264          
    265            /* Clear M, PCE, PS, TE and RE bits */
    266            tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
   \   0000014E   0x.... 0x....      LDR.W    R0,??DataTable20  ;; 0xffffe9f3
   \   00000152   0x4006             ANDS     R6,R0,R6
    267          
    268            /* Configure the USART Word Length, Parity and mode: 
    269               Set the M bits according to USART_WordLength value 
    270               Set PCE and PS bits according to USART_Parity value
    271               Set TE and RE bits according to USART_Mode value */
    272            tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
    273                      USART_InitStruct->USART_Mode;
   \   00000154   0x88A8             LDRH     R0,[R5, #+4]
   \   00000156   0x8929             LDRH     R1,[R5, #+8]
   \   00000158   0x4308             ORRS     R0,R1,R0
   \   0000015A   0x8969             LDRH     R1,[R5, #+10]
   \   0000015C   0x4308             ORRS     R0,R1,R0
   \   0000015E   0x4306             ORRS     R6,R0,R6
    274          
    275            /* Write to USART CR1 */
    276            USARTx->CR1 = (uint16_t)tmpreg;
   \   00000160   0x81A6             STRH     R6,[R4, #+12]
    277          
    278          /*---------------------------- USART CR3 Configuration -----------------------*/  
    279            tmpreg = USARTx->CR3;
   \   00000162   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000164   0x0006             MOVS     R6,R0
    280          
    281            /* Clear CTSE and RTSE bits */
    282            tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
   \   00000166   0xF436 0x7640      BICS     R6,R6,#0x300
    283          
    284            /* Configure the USART HFC : 
    285                Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
    286            tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
   \   0000016A   0x89A8             LDRH     R0,[R5, #+12]
   \   0000016C   0x4306             ORRS     R6,R0,R6
    287          
    288            /* Write to USART CR3 */
    289            USARTx->CR3 = (uint16_t)tmpreg;
   \   0000016E   0x82A6             STRH     R6,[R4, #+20]
    290          
    291          /*---------------------------- USART BRR Configuration -----------------------*/
    292            /* Configure the USART Baud Rate */
    293            RCC_GetClocksFreq(&RCC_ClocksStatus);
   \   00000170   0x4668             MOV      R0,SP
   \   00000172   0x.... 0x....      BL       RCC_GetClocksFreq
    294          
    295            if ((USARTx == USART1) || (USARTx == USART6))
   \   00000176   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40011000
   \   0000017A   0x4284             CMP      R4,R0
   \   0000017C   0xD003             BEQ.N    ??USART_Init_10
   \   0000017E   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0x40011400
   \   00000182   0x4284             CMP      R4,R0
   \   00000184   0xD102             BNE.N    ??USART_Init_11
    296            {
    297              apbclock = RCC_ClocksStatus.PCLK2_Frequency;
   \                     ??USART_Init_10: (+1)
   \   00000186   0x9803             LDR      R0,[SP, #+12]
   \   00000188   0x0007             MOVS     R7,R0
   \   0000018A   0xE001             B.N      ??USART_Init_12
    298            }
    299            else
    300            {
    301              apbclock = RCC_ClocksStatus.PCLK1_Frequency;
   \                     ??USART_Init_11: (+1)
   \   0000018C   0x9802             LDR      R0,[SP, #+8]
   \   0000018E   0x0007             MOVS     R7,R0
    302            }
    303            
    304            /* Determine the integer part */
    305            if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
   \                     ??USART_Init_12: (+1)
   \   00000190   0x89A0             LDRH     R0,[R4, #+12]
   \   00000192   0x0400             LSLS     R0,R0,#+16
   \   00000194   0xD508             BPL.N    ??USART_Init_13
    306            {
    307              /* Integer part computing in case Oversampling mode is 8 Samples */
    308              integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
   \   00000196   0x2019             MOVS     R0,#+25
   \   00000198   0xFB00 0xF007      MUL      R0,R0,R7
   \   0000019C   0x6829             LDR      R1,[R5, #+0]
   \   0000019E   0x0049             LSLS     R1,R1,#+1
   \   000001A0   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000001A4   0x4680             MOV      R8,R0
   \   000001A6   0xE007             B.N      ??USART_Init_14
    309            }
    310            else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
    311            {
    312              /* Integer part computing in case Oversampling mode is 16 Samples */
    313              integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
   \                     ??USART_Init_13: (+1)
   \   000001A8   0x2019             MOVS     R0,#+25
   \   000001AA   0xFB00 0xF007      MUL      R0,R0,R7
   \   000001AE   0x6829             LDR      R1,[R5, #+0]
   \   000001B0   0x0089             LSLS     R1,R1,#+2
   \   000001B2   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000001B6   0x4680             MOV      R8,R0
    314            }
    315            tmpreg = (integerdivider / 100) << 4;
   \                     ??USART_Init_14: (+1)
   \   000001B8   0x2064             MOVS     R0,#+100
   \   000001BA   0xFBB8 0xF0F0      UDIV     R0,R8,R0
   \   000001BE   0x0100             LSLS     R0,R0,#+4
   \   000001C0   0x0006             MOVS     R6,R0
    316          
    317            /* Determine the fractional part */
    318            fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
   \   000001C2   0x0930             LSRS     R0,R6,#+4
   \   000001C4   0x2164             MOVS     R1,#+100
   \   000001C6   0xFB01 0x8010      MLS      R0,R1,R0,R8
   \   000001CA   0x4681             MOV      R9,R0
    319          
    320            /* Implement the fractional part in the register */
    321            if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
   \   000001CC   0x89A0             LDRH     R0,[R4, #+12]
   \   000001CE   0x0400             LSLS     R0,R0,#+16
   \   000001D0   0xD509             BPL.N    ??USART_Init_15
    322            {
    323              tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
   \   000001D2   0xEA5F 0x00C9      LSLS     R0,R9,#+3
   \   000001D6   0x3032             ADDS     R0,R0,#+50
   \   000001D8   0x2164             MOVS     R1,#+100
   \   000001DA   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000001DE   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   000001E2   0x4306             ORRS     R6,R0,R6
   \   000001E4   0xE008             B.N      ??USART_Init_16
    324            }
    325            else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
    326            {
    327              tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
   \                     ??USART_Init_15: (+1)
   \   000001E6   0xEA5F 0x1009      LSLS     R0,R9,#+4
   \   000001EA   0x3032             ADDS     R0,R0,#+50
   \   000001EC   0x2164             MOVS     R1,#+100
   \   000001EE   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000001F2   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   000001F6   0x4306             ORRS     R6,R0,R6
    328            }
    329            
    330            /* Write to USART BRR register */
    331            USARTx->BRR = (uint16_t)tmpreg;
   \                     ??USART_Init_16: (+1)
   \   000001F8   0x8126             STRH     R6,[R4, #+8]
    332          }
   \   000001FA   0xB005             ADD      SP,SP,#+20
   \   000001FC   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    333          
    334          /**
    335            * @brief  Fills each USART_InitStruct member with its default value.
    336            * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure which will
    337            *         be initialized.
    338            * @retval None
    339            */

   \                                 In section .text, align 2, keep-with-next
    340          void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
    341          {
    342            /* USART_InitStruct members default value */
    343            USART_InitStruct->USART_BaudRate = 9600;
   \                     USART_StructInit: (+1)
   \   00000000   0xF44F 0x5116      MOV      R1,#+9600
   \   00000004   0x6001             STR      R1,[R0, #+0]
    344            USART_InitStruct->USART_WordLength = USART_WordLength_8b;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x8081             STRH     R1,[R0, #+4]
    345            USART_InitStruct->USART_StopBits = USART_StopBits_1;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x80C1             STRH     R1,[R0, #+6]
    346            USART_InitStruct->USART_Parity = USART_Parity_No ;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x8101             STRH     R1,[R0, #+8]
    347            USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \   00000012   0x210C             MOVS     R1,#+12
   \   00000014   0x8141             STRH     R1,[R0, #+10]
    348            USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x8181             STRH     R1,[R0, #+12]
    349          }
   \   0000001A   0x4770             BX       LR               ;; return
    350          
    351          /**
    352            * @brief  Initializes the USARTx peripheral Clock according to the 
    353            *         specified parameters in the USART_ClockInitStruct .
    354            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART peripheral.
    355            * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure that
    356            *         contains the configuration information for the specified  USART peripheral.
    357            * @note   The Smart Card and Synchronous modes are not available for UART4 and UART5.    
    358            * @retval None
    359            */

   \                                 In section .text, align 2, keep-with-next
    360          void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
    361          {
   \                     USART_ClockInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    362            uint32_t tmpreg = 0x00;
   \   00000006   0x2600             MOVS     R6,#+0
    363            /* Check the parameters */
    364            assert_param(IS_USART_1236_PERIPH(USARTx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40011000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD011             BEQ.N    ??USART_ClockInit_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40004400
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD00D             BEQ.N    ??USART_ClockInit_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable17_1  ;; 0x40004800
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD009             BEQ.N    ??USART_ClockInit_0
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0x40011400
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD005             BEQ.N    ??USART_ClockInit_0
   \   00000028   0xF44F 0x71B6      MOV      R1,#+364
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   00000030   0x.... 0x....      BL       assert_failed
    365            assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
   \                     ??USART_ClockInit_0: (+1)
   \   00000034   0x8828             LDRH     R0,[R5, #+0]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD009             BEQ.N    ??USART_ClockInit_1
   \   0000003A   0x8828             LDRH     R0,[R5, #+0]
   \   0000003C   0xF5B0 0x6F00      CMP      R0,#+2048
   \   00000040   0xD005             BEQ.N    ??USART_ClockInit_1
   \   00000042   0xF240 0x116D      MOVW     R1,#+365
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   0000004A   0x.... 0x....      BL       assert_failed
    366            assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
   \                     ??USART_ClockInit_1: (+1)
   \   0000004E   0x8868             LDRH     R0,[R5, #+2]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD009             BEQ.N    ??USART_ClockInit_2
   \   00000054   0x8868             LDRH     R0,[R5, #+2]
   \   00000056   0xF5B0 0x6F80      CMP      R0,#+1024
   \   0000005A   0xD005             BEQ.N    ??USART_ClockInit_2
   \   0000005C   0xF44F 0x71B7      MOV      R1,#+366
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   00000064   0x.... 0x....      BL       assert_failed
    367            assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
   \                     ??USART_ClockInit_2: (+1)
   \   00000068   0x88A8             LDRH     R0,[R5, #+4]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD009             BEQ.N    ??USART_ClockInit_3
   \   0000006E   0x88A8             LDRH     R0,[R5, #+4]
   \   00000070   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000074   0xD005             BEQ.N    ??USART_ClockInit_3
   \   00000076   0xF240 0x116F      MOVW     R1,#+367
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   0000007E   0x.... 0x....      BL       assert_failed
    368            assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
   \                     ??USART_ClockInit_3: (+1)
   \   00000082   0x88E8             LDRH     R0,[R5, #+6]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD009             BEQ.N    ??USART_ClockInit_4
   \   00000088   0x88E8             LDRH     R0,[R5, #+6]
   \   0000008A   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000008E   0xD005             BEQ.N    ??USART_ClockInit_4
   \   00000090   0xF44F 0x71B8      MOV      R1,#+368
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   00000098   0x.... 0x....      BL       assert_failed
    369            
    370          /*---------------------------- USART CR2 Configuration -----------------------*/
    371            tmpreg = USARTx->CR2;
   \                     ??USART_ClockInit_4: (+1)
   \   0000009C   0x8A20             LDRH     R0,[R4, #+16]
   \   0000009E   0x0006             MOVS     R6,R0
    372            /* Clear CLKEN, CPOL, CPHA and LBCL bits */
    373            tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
   \   000000A0   0xF436 0x6670      BICS     R6,R6,#0xF00
    374            /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
    375            /* Set CLKEN bit according to USART_Clock value */
    376            /* Set CPOL bit according to USART_CPOL value */
    377            /* Set CPHA bit according to USART_CPHA value */
    378            /* Set LBCL bit according to USART_LastBit value */
    379            tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
    380                           USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
   \   000000A4   0x8828             LDRH     R0,[R5, #+0]
   \   000000A6   0x8869             LDRH     R1,[R5, #+2]
   \   000000A8   0x4308             ORRS     R0,R1,R0
   \   000000AA   0x88A9             LDRH     R1,[R5, #+4]
   \   000000AC   0x4308             ORRS     R0,R1,R0
   \   000000AE   0x88E9             LDRH     R1,[R5, #+6]
   \   000000B0   0x4308             ORRS     R0,R1,R0
   \   000000B2   0x4306             ORRS     R6,R0,R6
    381            /* Write to USART CR2 */
    382            USARTx->CR2 = (uint16_t)tmpreg;
   \   000000B4   0x8226             STRH     R6,[R4, #+16]
    383          }
   \   000000B6   0xBD70             POP      {R4-R6,PC}       ;; return
    384          
    385          /**
    386            * @brief  Fills each USART_ClockInitStruct member with its default value.
    387            * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure
    388            *         which will be initialized.
    389            * @retval None
    390            */

   \                                 In section .text, align 2, keep-with-next
    391          void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
    392          {
    393            /* USART_ClockInitStruct members default value */
    394            USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
   \                     USART_ClockStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    395            USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x8041             STRH     R1,[R0, #+2]
    396            USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x8081             STRH     R1,[R0, #+4]
    397            USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x80C1             STRH     R1,[R0, #+6]
    398          }
   \   00000010   0x4770             BX       LR               ;; return
    399          
    400          /**
    401            * @brief  Enables or disables the specified USART peripheral.
    402            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    403            *         UART peripheral.
    404            * @param  NewState: new state of the USARTx peripheral.
    405            *          This parameter can be: ENABLE or DISABLE.
    406            * @retval None
    407            */

   \                                 In section .text, align 2, keep-with-next
    408          void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
    409          {
   \                     USART_Cmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    410            /* Check the parameters */
    411            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40011000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD019             BEQ.N    ??USART_Cmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD015             BEQ.N    ??USART_Cmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable17_1  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD011             BEQ.N    ??USART_Cmd_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable17_2  ;; 0x40004c00
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD00D             BEQ.N    ??USART_Cmd_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable17_3  ;; 0x40005000
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD009             BEQ.N    ??USART_Cmd_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0x40011400
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD005             BEQ.N    ??USART_Cmd_0
   \   00000036   0xF240 0x119B      MOVW     R1,#+411
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   0000003E   0x.... 0x....      BL       assert_failed
    412            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??USART_Cmd_0: (+1)
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD008             BEQ.N    ??USART_Cmd_1
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x2D01             CMP      R5,#+1
   \   0000004C   0xD005             BEQ.N    ??USART_Cmd_1
   \   0000004E   0xF44F 0x71CE      MOV      R1,#+412
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   00000056   0x.... 0x....      BL       assert_failed
    413            
    414            if (NewState != DISABLE)
   \                     ??USART_Cmd_1: (+1)
   \   0000005A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005C   0x2D00             CMP      R5,#+0
   \   0000005E   0xD004             BEQ.N    ??USART_Cmd_2
    415            {
    416              /* Enable the selected USART by setting the UE bit in the CR1 register */
    417              USARTx->CR1 |= USART_CR1_UE;
   \   00000060   0x89A0             LDRH     R0,[R4, #+12]
   \   00000062   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000066   0x81A0             STRH     R0,[R4, #+12]
   \   00000068   0xE004             B.N      ??USART_Cmd_3
    418            }
    419            else
    420            {
    421              /* Disable the selected USART by clearing the UE bit in the CR1 register */
    422              USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
   \                     ??USART_Cmd_2: (+1)
   \   0000006A   0x89A0             LDRH     R0,[R4, #+12]
   \   0000006C   0xF64D 0x71FF      MOVW     R1,#+57343
   \   00000070   0x4008             ANDS     R0,R1,R0
   \   00000072   0x81A0             STRH     R0,[R4, #+12]
    423            }
    424          }
   \                     ??USART_Cmd_3: (+1)
   \   00000074   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    425          
    426          /**
    427            * @brief  Sets the system clock prescaler.
    428            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    429            *         UART peripheral.
    430            * @param  USART_Prescaler: specifies the prescaler clock. 
    431            * @note   The function is used for IrDA mode with UART4 and UART5.   
    432            * @retval None
    433            */

   \                                 In section .text, align 2, keep-with-next
    434          void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
    435          { 
   \                     USART_SetPrescaler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    436            /* Check the parameters */
    437            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40011000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD019             BEQ.N    ??USART_SetPrescaler_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD015             BEQ.N    ??USART_SetPrescaler_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable17_1  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD011             BEQ.N    ??USART_SetPrescaler_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable17_2  ;; 0x40004c00
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD00D             BEQ.N    ??USART_SetPrescaler_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable17_3  ;; 0x40005000
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD009             BEQ.N    ??USART_SetPrescaler_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0x40011400
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD005             BEQ.N    ??USART_SetPrescaler_0
   \   00000036   0xF240 0x11B5      MOVW     R1,#+437
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   0000003E   0x.... 0x....      BL       assert_failed
    438            
    439            /* Clear the USART prescaler */
    440            USARTx->GTPR &= USART_GTPR_GT;
   \                     ??USART_SetPrescaler_0: (+1)
   \   00000042   0x8B20             LDRH     R0,[R4, #+24]
   \   00000044   0xF410 0x407F      ANDS     R0,R0,#0xFF00
   \   00000048   0x8320             STRH     R0,[R4, #+24]
    441            /* Set the USART prescaler */
    442            USARTx->GTPR |= USART_Prescaler;
   \   0000004A   0x8B20             LDRH     R0,[R4, #+24]
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x4328             ORRS     R0,R5,R0
   \   00000050   0x8320             STRH     R0,[R4, #+24]
    443          }
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    444          
    445          /**
    446            * @brief  Enables or disables the USART's 8x oversampling mode.
    447            * @note   This function has to be called before calling USART_Init() function
    448            *         in order to have correct baudrate Divider value.
    449            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    450            *         UART peripheral.
    451            * @param  NewState: new state of the USART 8x oversampling mode.
    452            *          This parameter can be: ENABLE or DISABLE.
    453            * @retval None
    454            */

   \                                 In section .text, align 2, keep-with-next
    455          void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
    456          {
   \                     USART_OverSampling8Cmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    457            /* Check the parameters */
    458            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40011000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD019             BEQ.N    ??USART_OverSampling8Cmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD015             BEQ.N    ??USART_OverSampling8Cmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable17_1  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD011             BEQ.N    ??USART_OverSampling8Cmd_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable17_2  ;; 0x40004c00
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD00D             BEQ.N    ??USART_OverSampling8Cmd_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable17_3  ;; 0x40005000
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD009             BEQ.N    ??USART_OverSampling8Cmd_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0x40011400
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD005             BEQ.N    ??USART_OverSampling8Cmd_0
   \   00000036   0xF44F 0x71E5      MOV      R1,#+458
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   0000003E   0x.... 0x....      BL       assert_failed
    459            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??USART_OverSampling8Cmd_0: (+1)
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD008             BEQ.N    ??USART_OverSampling8Cmd_1
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x2D01             CMP      R5,#+1
   \   0000004C   0xD005             BEQ.N    ??USART_OverSampling8Cmd_1
   \   0000004E   0xF240 0x11CB      MOVW     R1,#+459
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   00000056   0x.... 0x....      BL       assert_failed
    460            
    461            if (NewState != DISABLE)
   \                     ??USART_OverSampling8Cmd_1: (+1)
   \   0000005A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005C   0x2D00             CMP      R5,#+0
   \   0000005E   0xD004             BEQ.N    ??USART_OverSampling8Cmd_2
    462            {
    463              /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
    464              USARTx->CR1 |= USART_CR1_OVER8;
   \   00000060   0x89A0             LDRH     R0,[R4, #+12]
   \   00000062   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000066   0x81A0             STRH     R0,[R4, #+12]
   \   00000068   0xE003             B.N      ??USART_OverSampling8Cmd_3
    465            }
    466            else
    467            {
    468              /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
    469              USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_OVER8);
   \                     ??USART_OverSampling8Cmd_2: (+1)
   \   0000006A   0x89A0             LDRH     R0,[R4, #+12]
   \   0000006C   0x0440             LSLS     R0,R0,#+17       ;; ZeroExtS R0,R0,#+17,#+17
   \   0000006E   0x0C40             LSRS     R0,R0,#+17
   \   00000070   0x81A0             STRH     R0,[R4, #+12]
    470            }
    471          }  
   \                     ??USART_OverSampling8Cmd_3: (+1)
   \   00000072   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    472          
    473          /**
    474            * @brief  Enables or disables the USART's one bit sampling method.
    475            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    476            *         UART peripheral.
    477            * @param  NewState: new state of the USART one bit sampling method.
    478            *          This parameter can be: ENABLE or DISABLE.
    479            * @retval None
    480            */

   \                                 In section .text, align 2, keep-with-next
    481          void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    482          {
   \                     USART_OneBitMethodCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    483            /* Check the parameters */
    484            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40011000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD019             BEQ.N    ??USART_OneBitMethodCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD015             BEQ.N    ??USART_OneBitMethodCmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable17_1  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD011             BEQ.N    ??USART_OneBitMethodCmd_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable17_2  ;; 0x40004c00
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD00D             BEQ.N    ??USART_OneBitMethodCmd_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable17_3  ;; 0x40005000
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD009             BEQ.N    ??USART_OneBitMethodCmd_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0x40011400
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD005             BEQ.N    ??USART_OneBitMethodCmd_0
   \   00000036   0xF44F 0x71F2      MOV      R1,#+484
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   0000003E   0x.... 0x....      BL       assert_failed
    485            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??USART_OneBitMethodCmd_0: (+1)
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD008             BEQ.N    ??USART_OneBitMethodCmd_1
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x2D01             CMP      R5,#+1
   \   0000004C   0xD005             BEQ.N    ??USART_OneBitMethodCmd_1
   \   0000004E   0xF240 0x11E5      MOVW     R1,#+485
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   00000056   0x.... 0x....      BL       assert_failed
    486            
    487            if (NewState != DISABLE)
   \                     ??USART_OneBitMethodCmd_1: (+1)
   \   0000005A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005C   0x2D00             CMP      R5,#+0
   \   0000005E   0xD004             BEQ.N    ??USART_OneBitMethodCmd_2
    488            {
    489              /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
    490              USARTx->CR3 |= USART_CR3_ONEBIT;
   \   00000060   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000062   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   00000066   0x82A0             STRH     R0,[R4, #+20]
   \   00000068   0xE004             B.N      ??USART_OneBitMethodCmd_3
    491            }
    492            else
    493            {
    494              /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
    495              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT);
   \                     ??USART_OneBitMethodCmd_2: (+1)
   \   0000006A   0x8AA0             LDRH     R0,[R4, #+20]
   \   0000006C   0xF24F 0x71FF      MOVW     R1,#+63487
   \   00000070   0x4008             ANDS     R0,R1,R0
   \   00000072   0x82A0             STRH     R0,[R4, #+20]
    496            }
    497          }
   \                     ??USART_OneBitMethodCmd_3: (+1)
   \   00000074   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    498          
    499          /**
    500            * @}
    501            */
    502          
    503          /** @defgroup USART_Group2 Data transfers functions
    504           *  @brief   Data transfers functions 
    505           *
    506          @verbatim   
    507           ===============================================================================
    508                                      Data transfers functions
    509           ===============================================================================  
    510          
    511            This subsection provides a set of functions allowing to manage the USART data 
    512            transfers.
    513            
    514            During an USART reception, data shifts in least significant bit first through 
    515            the RX pin. In this mode, the USART_DR register consists of a buffer (RDR) 
    516            between the internal bus and the received shift register.
    517          
    518            When a transmission is taking place, a write instruction to the USART_DR register 
    519            stores the data in the TDR register and which is copied in the shift register 
    520            at the end of the current transmission.
    521          
    522            The read access of the USART_DR register can be done using the USART_ReceiveData()
    523            function and returns the RDR buffered value. Whereas a write access to the USART_DR 
    524            can be done using USART_SendData() function and stores the written data into 
    525            TDR buffer.
    526          
    527          @endverbatim
    528            * @{
    529            */
    530          
    531          /**
    532            * @brief  Transmits single data through the USARTx peripheral.
    533            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    534            *         UART peripheral.
    535            * @param  Data: the data to transmit.
    536            * @retval None
    537            */

   \                                 In section .text, align 2, keep-with-next
    538          void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
    539          {
   \                     USART_SendData: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    540            /* Check the parameters */
    541            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40011000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD019             BEQ.N    ??USART_SendData_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD015             BEQ.N    ??USART_SendData_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable17_1  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD011             BEQ.N    ??USART_SendData_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable17_2  ;; 0x40004c00
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD00D             BEQ.N    ??USART_SendData_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable17_3  ;; 0x40005000
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD009             BEQ.N    ??USART_SendData_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0x40011400
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD005             BEQ.N    ??USART_SendData_0
   \   00000036   0xF240 0x211D      MOVW     R1,#+541
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   0000003E   0x.... 0x....      BL       assert_failed
    542            assert_param(IS_USART_DATA(Data)); 
   \                     ??USART_SendData_0: (+1)
   \   00000042   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000048   0xDB05             BLT.N    ??USART_SendData_1
   \   0000004A   0xF240 0x211E      MOVW     R1,#+542
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   00000052   0x.... 0x....      BL       assert_failed
    543              
    544            /* Transmit Data */
    545            USARTx->DR = (Data & (uint16_t)0x01FF);
   \                     ??USART_SendData_1: (+1)
   \   00000056   0x05E8             LSLS     R0,R5,#+23       ;; ZeroExtS R0,R5,#+23,#+23
   \   00000058   0x0DC0             LSRS     R0,R0,#+23
   \   0000005A   0x80A0             STRH     R0,[R4, #+4]
    546          }
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    547          
    548          /**
    549            * @brief  Returns the most recent received data by the USARTx peripheral.
    550            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    551            *         UART peripheral.
    552            * @retval The received data.
    553            */

   \                                 In section .text, align 2, keep-with-next
    554          uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
    555          {
   \                     USART_ReceiveData: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    556            /* Check the parameters */
    557            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40011000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD019             BEQ.N    ??USART_ReceiveData_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40004400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD015             BEQ.N    ??USART_ReceiveData_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable17_1  ;; 0x40004800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD011             BEQ.N    ??USART_ReceiveData_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable17_2  ;; 0x40004c00
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD00D             BEQ.N    ??USART_ReceiveData_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable17_3  ;; 0x40005000
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD009             BEQ.N    ??USART_ReceiveData_0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0x40011400
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD005             BEQ.N    ??USART_ReceiveData_0
   \   00000034   0xF240 0x212D      MOVW     R1,#+557
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   0000003C   0x.... 0x....      BL       assert_failed
    558            
    559            /* Receive Data */
    560            return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
   \                     ??USART_ReceiveData_0: (+1)
   \   00000040   0x88A0             LDRH     R0,[R4, #+4]
   \   00000042   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   00000044   0x0DC0             LSRS     R0,R0,#+23
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
    561          }
    562          
    563          /**
    564            * @}
    565            */
    566          
    567          /** @defgroup USART_Group3 MultiProcessor Communication functions
    568           *  @brief   Multi-Processor Communication functions 
    569           *
    570          @verbatim   
    571           ===============================================================================
    572                              Multi-Processor Communication functions
    573           ===============================================================================  
    574          
    575            This subsection provides a set of functions allowing to manage the USART 
    576            multiprocessor communication.
    577            
    578            For instance one of the USARTs can be the master, its TX output is connected to 
    579            the RX input of the other USART. The others are slaves, their respective TX outputs 
    580            are logically ANDed together and connected to the RX input of the master.
    581          
    582            USART multiprocessor communication is possible through the following procedure:
    583               1. Program the Baud rate, Word length = 9 bits, Stop bits, Parity, Mode transmitter 
    584                  or Mode receiver and hardware flow control values using the USART_Init()
    585                  function.
    586               2. Configures the USART address using the USART_SetAddress() function.
    587               3. Configures the wake up method (USART_WakeUp_IdleLine or USART_WakeUp_AddressMark)
    588                  using USART_WakeUpConfig() function only for the slaves.
    589               4. Enable the USART using the USART_Cmd() function.
    590               5. Enter the USART slaves in mute mode using USART_ReceiverWakeUpCmd() function.
    591          
    592            The USART Slave exit from mute mode when receive the wake up condition.
    593          
    594          @endverbatim
    595            * @{
    596            */
    597          
    598          /**
    599            * @brief  Sets the address of the USART node.
    600            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    601            *         UART peripheral.
    602            * @param  USART_Address: Indicates the address of the USART node.
    603            * @retval None
    604            */

   \                                 In section .text, align 2, keep-with-next
    605          void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
    606          {
   \                     USART_SetAddress: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    607            /* Check the parameters */
    608            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x....             LDR.N    R0,??DataTable16  ;; 0x40011000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD019             BEQ.N    ??USART_SetAddress_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40004400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD015             BEQ.N    ??USART_SetAddress_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable17_1  ;; 0x40004800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD011             BEQ.N    ??USART_SetAddress_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable17_2  ;; 0x40004c00
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD00D             BEQ.N    ??USART_SetAddress_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable17_3  ;; 0x40005000
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD009             BEQ.N    ??USART_SetAddress_0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0x40011400
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD005             BEQ.N    ??USART_SetAddress_0
   \   00000034   0xF44F 0x7118      MOV      R1,#+608
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   0000003C   0x.... 0x....      BL       assert_failed
    609            assert_param(IS_USART_ADDRESS(USART_Address)); 
   \                     ??USART_SetAddress_0: (+1)
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x2D10             CMP      R5,#+16
   \   00000044   0xDB05             BLT.N    ??USART_SetAddress_1
   \   00000046   0xF240 0x2161      MOVW     R1,#+609
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   0000004E   0x.... 0x....      BL       assert_failed
    610              
    611            /* Clear the USART address */
    612            USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_ADD);
   \                     ??USART_SetAddress_1: (+1)
   \   00000052   0x8A20             LDRH     R0,[R4, #+16]
   \   00000054   0xF64F 0x71F0      MOVW     R1,#+65520
   \   00000058   0x4008             ANDS     R0,R1,R0
   \   0000005A   0x8220             STRH     R0,[R4, #+16]
    613            /* Set the USART address node */
    614            USARTx->CR2 |= USART_Address;
   \   0000005C   0x8A20             LDRH     R0,[R4, #+16]
   \   0000005E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000060   0x4328             ORRS     R0,R5,R0
   \   00000062   0x8220             STRH     R0,[R4, #+16]
    615          }
   \   00000064   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    616          
    617          /**
    618            * @brief  Determines if the USART is in mute mode or not.
    619            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    620            *         UART peripheral.
    621            * @param  NewState: new state of the USART mute mode.
    622            *          This parameter can be: ENABLE or DISABLE.
    623            * @retval None
    624            */

   \                                 In section .text, align 2, keep-with-next
    625          void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    626          {
   \                     USART_ReceiverWakeUpCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    627            /* Check the parameters */
    628            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x....             LDR.N    R0,??DataTable16  ;; 0x40011000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD014             BEQ.N    ??USART_ReceiverWakeUpCmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable17  ;; 0x40004400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD011             BEQ.N    ??USART_ReceiverWakeUpCmd_0
   \   00000012   0x....             LDR.N    R0,??DataTable17_1  ;; 0x40004800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD00E             BEQ.N    ??USART_ReceiverWakeUpCmd_0
   \   00000018   0x....             LDR.N    R0,??DataTable17_2  ;; 0x40004c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD00B             BEQ.N    ??USART_ReceiverWakeUpCmd_0
   \   0000001E   0x....             LDR.N    R0,??DataTable17_3  ;; 0x40005000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD008             BEQ.N    ??USART_ReceiverWakeUpCmd_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0x40011400
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD004             BEQ.N    ??USART_ReceiverWakeUpCmd_0
   \   0000002C   0xF44F 0x711D      MOV      R1,#+628
   \   00000030   0x....             LDR.N    R0,??DataTable17_4
   \   00000032   0x.... 0x....      BL       assert_failed
    629            assert_param(IS_FUNCTIONAL_STATE(NewState)); 
   \                     ??USART_ReceiverWakeUpCmd_0: (+1)
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD007             BEQ.N    ??USART_ReceiverWakeUpCmd_1
   \   0000003C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003E   0x2D01             CMP      R5,#+1
   \   00000040   0xD004             BEQ.N    ??USART_ReceiverWakeUpCmd_1
   \   00000042   0xF240 0x2175      MOVW     R1,#+629
   \   00000046   0x....             LDR.N    R0,??DataTable17_4
   \   00000048   0x.... 0x....      BL       assert_failed
    630            
    631            if (NewState != DISABLE)
   \                     ??USART_ReceiverWakeUpCmd_1: (+1)
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x2D00             CMP      R5,#+0
   \   00000050   0xD004             BEQ.N    ??USART_ReceiverWakeUpCmd_2
    632            {
    633              /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
    634              USARTx->CR1 |= USART_CR1_RWU;
   \   00000052   0x89A0             LDRH     R0,[R4, #+12]
   \   00000054   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000058   0x81A0             STRH     R0,[R4, #+12]
   \   0000005A   0xE004             B.N      ??USART_ReceiverWakeUpCmd_3
    635            }
    636            else
    637            {
    638              /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
    639              USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_RWU);
   \                     ??USART_ReceiverWakeUpCmd_2: (+1)
   \   0000005C   0x89A0             LDRH     R0,[R4, #+12]
   \   0000005E   0xF64F 0x71FD      MOVW     R1,#+65533
   \   00000062   0x4008             ANDS     R0,R1,R0
   \   00000064   0x81A0             STRH     R0,[R4, #+12]
    640            }
    641          }
   \                     ??USART_ReceiverWakeUpCmd_3: (+1)
   \   00000066   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    642          /**
    643            * @brief  Selects the USART WakeUp method.
    644            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    645            *         UART peripheral.
    646            * @param  USART_WakeUp: specifies the USART wakeup method.
    647            *          This parameter can be one of the following values:
    648            *            @arg USART_WakeUp_IdleLine: WakeUp by an idle line detection
    649            *            @arg USART_WakeUp_AddressMark: WakeUp by an address mark
    650            * @retval None
    651            */

   \                                 In section .text, align 2, keep-with-next
    652          void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
    653          {
   \                     USART_WakeUpConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    654            /* Check the parameters */
    655            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x....             LDR.N    R0,??DataTable16  ;; 0x40011000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD014             BEQ.N    ??USART_WakeUpConfig_0
   \   0000000C   0x....             LDR.N    R0,??DataTable17  ;; 0x40004400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD011             BEQ.N    ??USART_WakeUpConfig_0
   \   00000012   0x....             LDR.N    R0,??DataTable17_1  ;; 0x40004800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD00E             BEQ.N    ??USART_WakeUpConfig_0
   \   00000018   0x....             LDR.N    R0,??DataTable17_2  ;; 0x40004c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD00B             BEQ.N    ??USART_WakeUpConfig_0
   \   0000001E   0x....             LDR.N    R0,??DataTable17_3  ;; 0x40005000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD008             BEQ.N    ??USART_WakeUpConfig_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0x40011400
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD004             BEQ.N    ??USART_WakeUpConfig_0
   \   0000002C   0xF240 0x218F      MOVW     R1,#+655
   \   00000030   0x....             LDR.N    R0,??DataTable17_4
   \   00000032   0x.... 0x....      BL       assert_failed
    656            assert_param(IS_USART_WAKEUP(USART_WakeUp));
   \                     ??USART_WakeUpConfig_0: (+1)
   \   00000036   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD008             BEQ.N    ??USART_WakeUpConfig_1
   \   0000003C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003E   0xF5B5 0x6F00      CMP      R5,#+2048
   \   00000042   0xD004             BEQ.N    ??USART_WakeUpConfig_1
   \   00000044   0xF44F 0x7124      MOV      R1,#+656
   \   00000048   0x....             LDR.N    R0,??DataTable17_4
   \   0000004A   0x.... 0x....      BL       assert_failed
    657            
    658            USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_WAKE);
   \                     ??USART_WakeUpConfig_1: (+1)
   \   0000004E   0x89A0             LDRH     R0,[R4, #+12]
   \   00000050   0xF24F 0x71FF      MOVW     R1,#+63487
   \   00000054   0x4008             ANDS     R0,R1,R0
   \   00000056   0x81A0             STRH     R0,[R4, #+12]
    659            USARTx->CR1 |= USART_WakeUp;
   \   00000058   0x89A0             LDRH     R0,[R4, #+12]
   \   0000005A   0x4328             ORRS     R0,R5,R0
   \   0000005C   0x81A0             STRH     R0,[R4, #+12]
    660          }
   \   0000005E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    661          
    662          /**
    663            * @}
    664            */
    665          
    666          /** @defgroup USART_Group4 LIN mode functions
    667           *  @brief   LIN mode functions 
    668           *
    669          @verbatim   
    670           ===============================================================================
    671                                          LIN mode functions
    672           ===============================================================================  
    673          
    674            This subsection provides a set of functions allowing to manage the USART LIN 
    675            Mode communication.
    676            
    677            In LIN mode, 8-bit data format with 1 stop bit is required in accordance with 
    678            the LIN standard.
    679          
    680            Only this LIN Feature is supported by the USART IP:
    681              - LIN Master Synchronous Break send capability and LIN slave break detection
    682                capability :  13-bit break generation and 10/11 bit break detection
    683          
    684          
    685            USART LIN Master transmitter communication is possible through the following procedure:
    686               1. Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
    687                  Mode transmitter or Mode receiver and hardware flow control values using 
    688                  the USART_Init() function.
    689               2. Enable the USART using the USART_Cmd() function.
    690               3. Enable the LIN mode using the USART_LINCmd() function.
    691               4. Send the break character using USART_SendBreak() function.
    692          
    693            USART LIN Master receiver communication is possible through the following procedure:
    694               1. Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
    695                  Mode transmitter or Mode receiver and hardware flow control values using 
    696                  the USART_Init() function.
    697               2. Enable the USART using the USART_Cmd() function.
    698               3. Configures the break detection length using the USART_LINBreakDetectLengthConfig()
    699                  function.
    700               4. Enable the LIN mode using the USART_LINCmd() function.
    701          
    702          
    703          @note In LIN mode, the following bits must be kept cleared:
    704                  - CLKEN in the USART_CR2 register,
    705                  - STOP[1:0], SCEN, HDSEL and IREN in the USART_CR3 register.
    706          
    707          @endverbatim
    708            * @{
    709            */
    710          
    711          /**
    712            * @brief  Sets the USART LIN Break detection length.
    713            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    714            *         UART peripheral.
    715            * @param  USART_LINBreakDetectLength: specifies the LIN break detection length.
    716            *          This parameter can be one of the following values:
    717            *            @arg USART_LINBreakDetectLength_10b: 10-bit break detection
    718            *            @arg USART_LINBreakDetectLength_11b: 11-bit break detection
    719            * @retval None
    720            */

   \                                 In section .text, align 2, keep-with-next
    721          void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
    722          {
   \                     USART_LINBreakDetectLengthConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    723            /* Check the parameters */
    724            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x....             LDR.N    R0,??DataTable16  ;; 0x40011000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD014             BEQ.N    ??USART_LINBreakDetectLengthConfig_0
   \   0000000C   0x....             LDR.N    R0,??DataTable17  ;; 0x40004400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD011             BEQ.N    ??USART_LINBreakDetectLengthConfig_0
   \   00000012   0x....             LDR.N    R0,??DataTable17_1  ;; 0x40004800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD00E             BEQ.N    ??USART_LINBreakDetectLengthConfig_0
   \   00000018   0x....             LDR.N    R0,??DataTable17_2  ;; 0x40004c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD00B             BEQ.N    ??USART_LINBreakDetectLengthConfig_0
   \   0000001E   0x....             LDR.N    R0,??DataTable17_3  ;; 0x40005000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD008             BEQ.N    ??USART_LINBreakDetectLengthConfig_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0x40011400
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD004             BEQ.N    ??USART_LINBreakDetectLengthConfig_0
   \   0000002C   0xF44F 0x7135      MOV      R1,#+724
   \   00000030   0x....             LDR.N    R0,??DataTable17_4
   \   00000032   0x.... 0x....      BL       assert_failed
    725            assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
   \                     ??USART_LINBreakDetectLengthConfig_0: (+1)
   \   00000036   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD007             BEQ.N    ??USART_LINBreakDetectLengthConfig_1
   \   0000003C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003E   0x2D20             CMP      R5,#+32
   \   00000040   0xD004             BEQ.N    ??USART_LINBreakDetectLengthConfig_1
   \   00000042   0xF240 0x21D5      MOVW     R1,#+725
   \   00000046   0x....             LDR.N    R0,??DataTable17_4
   \   00000048   0x.... 0x....      BL       assert_failed
    726            
    727            USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LBDL);
   \                     ??USART_LINBreakDetectLengthConfig_1: (+1)
   \   0000004C   0x8A20             LDRH     R0,[R4, #+16]
   \   0000004E   0xF64F 0x71DF      MOVW     R1,#+65503
   \   00000052   0x4008             ANDS     R0,R1,R0
   \   00000054   0x8220             STRH     R0,[R4, #+16]
    728            USARTx->CR2 |= USART_LINBreakDetectLength;  
   \   00000056   0x8A20             LDRH     R0,[R4, #+16]
   \   00000058   0x4328             ORRS     R0,R5,R0
   \   0000005A   0x8220             STRH     R0,[R4, #+16]
    729          }
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    730          
    731          /**
    732            * @brief  Enables or disables the USART's LIN mode.
    733            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    734            *         UART peripheral.
    735            * @param  NewState: new state of the USART LIN mode.
    736            *          This parameter can be: ENABLE or DISABLE.
    737            * @retval None
    738            */

   \                                 In section .text, align 2, keep-with-next
    739          void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    740          {
   \                     USART_LINCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    741            /* Check the parameters */
    742            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x....             LDR.N    R0,??DataTable16  ;; 0x40011000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD014             BEQ.N    ??USART_LINCmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable17  ;; 0x40004400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD011             BEQ.N    ??USART_LINCmd_0
   \   00000012   0x....             LDR.N    R0,??DataTable17_1  ;; 0x40004800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD00E             BEQ.N    ??USART_LINCmd_0
   \   00000018   0x....             LDR.N    R0,??DataTable17_2  ;; 0x40004c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD00B             BEQ.N    ??USART_LINCmd_0
   \   0000001E   0x....             LDR.N    R0,??DataTable17_3  ;; 0x40005000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD008             BEQ.N    ??USART_LINCmd_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0x40011400
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD004             BEQ.N    ??USART_LINCmd_0
   \   0000002C   0xF240 0x21E6      MOVW     R1,#+742
   \   00000030   0x....             LDR.N    R0,??DataTable17_4
   \   00000032   0x.... 0x....      BL       assert_failed
    743            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??USART_LINCmd_0: (+1)
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD007             BEQ.N    ??USART_LINCmd_1
   \   0000003C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003E   0x2D01             CMP      R5,#+1
   \   00000040   0xD004             BEQ.N    ??USART_LINCmd_1
   \   00000042   0xF240 0x21E7      MOVW     R1,#+743
   \   00000046   0x....             LDR.N    R0,??DataTable17_4
   \   00000048   0x.... 0x....      BL       assert_failed
    744            
    745            if (NewState != DISABLE)
   \                     ??USART_LINCmd_1: (+1)
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x2D00             CMP      R5,#+0
   \   00000050   0xD004             BEQ.N    ??USART_LINCmd_2
    746            {
    747              /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    748              USARTx->CR2 |= USART_CR2_LINEN;
   \   00000052   0x8A20             LDRH     R0,[R4, #+16]
   \   00000054   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   00000058   0x8220             STRH     R0,[R4, #+16]
   \   0000005A   0xE004             B.N      ??USART_LINCmd_3
    749            }
    750            else
    751            {
    752              /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
    753              USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LINEN);
   \                     ??USART_LINCmd_2: (+1)
   \   0000005C   0x8A20             LDRH     R0,[R4, #+16]
   \   0000005E   0xF64B 0x71FF      MOVW     R1,#+49151
   \   00000062   0x4008             ANDS     R0,R1,R0
   \   00000064   0x8220             STRH     R0,[R4, #+16]
    754            }
    755          }
   \                     ??USART_LINCmd_3: (+1)
   \   00000066   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    756          
    757          /**
    758            * @brief  Transmits break characters.
    759            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    760            *         UART peripheral.
    761            * @retval None
    762            */

   \                                 In section .text, align 2, keep-with-next
    763          void USART_SendBreak(USART_TypeDef* USARTx)
    764          {
   \                     USART_SendBreak: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    765            /* Check the parameters */
    766            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000004   0x....             LDR.N    R0,??DataTable16  ;; 0x40011000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD013             BEQ.N    ??USART_SendBreak_0
   \   0000000A   0x....             LDR.N    R0,??DataTable17  ;; 0x40004400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD010             BEQ.N    ??USART_SendBreak_0
   \   00000010   0x....             LDR.N    R0,??DataTable17_1  ;; 0x40004800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD00D             BEQ.N    ??USART_SendBreak_0
   \   00000016   0x....             LDR.N    R0,??DataTable17_2  ;; 0x40004c00
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD00A             BEQ.N    ??USART_SendBreak_0
   \   0000001C   0x....             LDR.N    R0,??DataTable17_3  ;; 0x40005000
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD007             BEQ.N    ??USART_SendBreak_0
   \   00000022   0x....             LDR.N    R0,??DataTable21  ;; 0x40011400
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD004             BEQ.N    ??USART_SendBreak_0
   \   00000028   0xF240 0x21FE      MOVW     R1,#+766
   \   0000002C   0x....             LDR.N    R0,??DataTable17_4
   \   0000002E   0x.... 0x....      BL       assert_failed
    767            
    768            /* Send break characters */
    769            USARTx->CR1 |= USART_CR1_SBK;
   \                     ??USART_SendBreak_0: (+1)
   \   00000032   0x89A0             LDRH     R0,[R4, #+12]
   \   00000034   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000038   0x81A0             STRH     R0,[R4, #+12]
    770          }
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    771          
    772          /**
    773            * @}
    774            */
    775          
    776          /** @defgroup USART_Group5 Halfduplex mode function
    777           *  @brief   Half-duplex mode function 
    778           *
    779          @verbatim   
    780           ===============================================================================
    781                                   Half-duplex mode function
    782           ===============================================================================  
    783          
    784            This subsection provides a set of functions allowing to manage the USART 
    785            Half-duplex communication.
    786            
    787            The USART can be configured to follow a single-wire half-duplex protocol where 
    788            the TX and RX lines are internally connected.
    789          
    790            USART Half duplex communication is possible through the following procedure:
    791               1. Program the Baud rate, Word length, Stop bits, Parity, Mode transmitter 
    792                  or Mode receiver and hardware flow control values using the USART_Init()
    793                  function.
    794               2. Configures the USART address using the USART_SetAddress() function.
    795               3. Enable the USART using the USART_Cmd() function.
    796               4. Enable the half duplex mode using USART_HalfDuplexCmd() function.
    797          
    798          
    799          @note The RX pin is no longer used
    800          @note In Half-duplex mode the following bits must be kept cleared:
    801                  - LINEN and CLKEN bits in the USART_CR2 register.
    802                  - SCEN and IREN bits in the USART_CR3 register.
    803          
    804          @endverbatim
    805            * @{
    806            */
    807          
    808          /**
    809            * @brief  Enables or disables the USART's Half Duplex communication.
    810            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    811            *         UART peripheral.
    812            * @param  NewState: new state of the USART Communication.
    813            *          This parameter can be: ENABLE or DISABLE.
    814            * @retval None
    815            */

   \                                 In section .text, align 2, keep-with-next
    816          void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    817          {
   \                     USART_HalfDuplexCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    818            /* Check the parameters */
    819            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x....             LDR.N    R0,??DataTable16  ;; 0x40011000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD013             BEQ.N    ??USART_HalfDuplexCmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable17  ;; 0x40004400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD010             BEQ.N    ??USART_HalfDuplexCmd_0
   \   00000012   0x....             LDR.N    R0,??DataTable17_1  ;; 0x40004800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD00D             BEQ.N    ??USART_HalfDuplexCmd_0
   \   00000018   0x....             LDR.N    R0,??DataTable17_2  ;; 0x40004c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD00A             BEQ.N    ??USART_HalfDuplexCmd_0
   \   0000001E   0x....             LDR.N    R0,??DataTable17_3  ;; 0x40005000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD007             BEQ.N    ??USART_HalfDuplexCmd_0
   \   00000024   0x....             LDR.N    R0,??DataTable21  ;; 0x40011400
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD004             BEQ.N    ??USART_HalfDuplexCmd_0
   \   0000002A   0xF240 0x3133      MOVW     R1,#+819
   \   0000002E   0x....             LDR.N    R0,??DataTable17_4
   \   00000030   0x.... 0x....      BL       assert_failed
    820            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??USART_HalfDuplexCmd_0: (+1)
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0xD007             BEQ.N    ??USART_HalfDuplexCmd_1
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D01             CMP      R5,#+1
   \   0000003E   0xD004             BEQ.N    ??USART_HalfDuplexCmd_1
   \   00000040   0xF44F 0x714D      MOV      R1,#+820
   \   00000044   0x....             LDR.N    R0,??DataTable17_4
   \   00000046   0x.... 0x....      BL       assert_failed
    821            
    822            if (NewState != DISABLE)
   \                     ??USART_HalfDuplexCmd_1: (+1)
   \   0000004A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004C   0x2D00             CMP      R5,#+0
   \   0000004E   0xD004             BEQ.N    ??USART_HalfDuplexCmd_2
    823            {
    824              /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    825              USARTx->CR3 |= USART_CR3_HDSEL;
   \   00000050   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000052   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000056   0x82A0             STRH     R0,[R4, #+20]
   \   00000058   0xE004             B.N      ??USART_HalfDuplexCmd_3
    826            }
    827            else
    828            {
    829              /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
    830              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_HDSEL);
   \                     ??USART_HalfDuplexCmd_2: (+1)
   \   0000005A   0x8AA0             LDRH     R0,[R4, #+20]
   \   0000005C   0xF64F 0x71F7      MOVW     R1,#+65527
   \   00000060   0x4008             ANDS     R0,R1,R0
   \   00000062   0x82A0             STRH     R0,[R4, #+20]
    831            }
    832          }
   \                     ??USART_HalfDuplexCmd_3: (+1)
   \   00000064   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    833          
    834          /**
    835            * @}
    836            */
    837          
    838          
    839          /** @defgroup USART_Group6 Smartcard mode functions
    840           *  @brief   Smartcard mode functions 
    841           *
    842          @verbatim   
    843           ===============================================================================
    844                                         Smartcard mode functions
    845           ===============================================================================  
    846          
    847            This subsection provides a set of functions allowing to manage the USART 
    848            Smartcard communication.
    849            
    850            The Smartcard interface is designed to support asynchronous protocol Smartcards as
    851            defined in the ISO 7816-3 standard.
    852          
    853            The USART can provide a clock to the smartcard through the SCLK output.
    854            In smartcard mode, SCLK is not associated to the communication but is simply derived 
    855            from the internal peripheral input clock through a 5-bit prescaler.
    856          
    857            Smartcard communication is possible through the following procedure:
    858               1. Configures the Smartcard Prescaler using the USART_SetPrescaler() function.
    859               2. Configures the Smartcard Guard Time using the USART_SetGuardTime() function.
    860               3. Program the USART clock using the USART_ClockInit() function as following:
    861                  - USART Clock enabled
    862                  - USART CPOL Low
    863                  - USART CPHA on first edge
    864                  - USART Last Bit Clock Enabled
    865               4. Program the Smartcard interface using the USART_Init() function as following:
    866                  - Word Length = 9 Bits
    867                  - 1.5 Stop Bit
    868                  - Even parity
    869                  - BaudRate = 12096 baud
    870                  - Hardware flow control disabled (RTS and CTS signals)
    871                  - Tx and Rx enabled
    872               5. Optionally you can enable the parity error interrupt using the USART_ITConfig()
    873                  function
    874               6. Enable the USART using the USART_Cmd() function.
    875               7. Enable the Smartcard NACK using the USART_SmartCardNACKCmd() function.
    876               8. Enable the Smartcard interface using the USART_SmartCardCmd() function.
    877          
    878            Please refer to the ISO 7816-3 specification for more details.
    879          
    880          
    881          @note It is also possible to choose 0.5 stop bit for receiving but it is recommended 
    882                to use 1.5 stop bits for both transmitting and receiving to avoid switching 
    883                between the two configurations.
    884          @note In smartcard mode, the following bits must be kept cleared:
    885                  - LINEN bit in the USART_CR2 register.
    886                  - HDSEL and IREN bits in the USART_CR3 register.
    887          @note Smartcard mode is available on USART peripherals only (not available on UART4 
    888                and UART5 peripherals).
    889          
    890          @endverbatim
    891            * @{
    892            */
    893          
    894          /**
    895            * @brief  Sets the specified USART guard time.
    896            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
    897            *         UART peripheral.
    898            * @param  USART_GuardTime: specifies the guard time.   
    899            * @retval None
    900            */

   \                                 In section .text, align 2, keep-with-next
    901          void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
    902          {    
   \                     USART_SetGuardTime: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    903            /* Check the parameters */
    904            assert_param(IS_USART_1236_PERIPH(USARTx));
   \   00000006   0x....             LDR.N    R0,??DataTable16  ;; 0x40011000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00D             BEQ.N    ??USART_SetGuardTime_0
   \   0000000C   0x....             LDR.N    R0,??DataTable17  ;; 0x40004400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD00A             BEQ.N    ??USART_SetGuardTime_0
   \   00000012   0x....             LDR.N    R0,??DataTable17_1  ;; 0x40004800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD007             BEQ.N    ??USART_SetGuardTime_0
   \   00000018   0x....             LDR.N    R0,??DataTable21  ;; 0x40011400
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD004             BEQ.N    ??USART_SetGuardTime_0
   \   0000001E   0xF44F 0x7162      MOV      R1,#+904
   \   00000022   0x....             LDR.N    R0,??DataTable17_4
   \   00000024   0x.... 0x....      BL       assert_failed
    905            
    906            /* Clear the USART Guard time */
    907            USARTx->GTPR &= USART_GTPR_PSC;
   \                     ??USART_SetGuardTime_0: (+1)
   \   00000028   0x8B20             LDRH     R0,[R4, #+24]
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x8320             STRH     R0,[R4, #+24]
    908            /* Set the USART guard time */
    909            USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
   \   0000002E   0x8B20             LDRH     R0,[R4, #+24]
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0xEA50 0x2005      ORRS     R0,R0,R5, LSL #+8
   \   00000036   0x8320             STRH     R0,[R4, #+24]
    910          }
   \   00000038   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    911          
    912          /**
    913            * @brief  Enables or disables the USART's Smart Card mode.
    914            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
    915            *         UART peripheral.
    916            * @param  NewState: new state of the Smart Card mode.
    917            *          This parameter can be: ENABLE or DISABLE.      
    918            * @retval None
    919            */

   \                                 In section .text, align 2, keep-with-next
    920          void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    921          {
   \                     USART_SmartCardCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    922            /* Check the parameters */
    923            assert_param(IS_USART_1236_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40011000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??USART_SmartCardCmd_0
   \   0000000E   0x....             LDR.N    R0,??DataTable17  ;; 0x40004400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD00A             BEQ.N    ??USART_SmartCardCmd_0
   \   00000014   0x....             LDR.N    R0,??DataTable17_1  ;; 0x40004800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD007             BEQ.N    ??USART_SmartCardCmd_0
   \   0000001A   0x....             LDR.N    R0,??DataTable21  ;; 0x40011400
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD004             BEQ.N    ??USART_SmartCardCmd_0
   \   00000020   0xF240 0x319B      MOVW     R1,#+923
   \   00000024   0x....             LDR.N    R0,??DataTable17_4
   \   00000026   0x.... 0x....      BL       assert_failed
    924            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??USART_SmartCardCmd_0: (+1)
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD007             BEQ.N    ??USART_SmartCardCmd_1
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D01             CMP      R5,#+1
   \   00000034   0xD004             BEQ.N    ??USART_SmartCardCmd_1
   \   00000036   0xF44F 0x7167      MOV      R1,#+924
   \   0000003A   0x....             LDR.N    R0,??DataTable17_4
   \   0000003C   0x.... 0x....      BL       assert_failed
    925            if (NewState != DISABLE)
   \                     ??USART_SmartCardCmd_1: (+1)
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x2D00             CMP      R5,#+0
   \   00000044   0xD004             BEQ.N    ??USART_SmartCardCmd_2
    926            {
    927              /* Enable the SC mode by setting the SCEN bit in the CR3 register */
    928              USARTx->CR3 |= USART_CR3_SCEN;
   \   00000046   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000048   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000004C   0x82A0             STRH     R0,[R4, #+20]
   \   0000004E   0xE004             B.N      ??USART_SmartCardCmd_3
    929            }
    930            else
    931            {
    932              /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
    933              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_SCEN);
   \                     ??USART_SmartCardCmd_2: (+1)
   \   00000050   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000052   0xF64F 0x71DF      MOVW     R1,#+65503
   \   00000056   0x4008             ANDS     R0,R1,R0
   \   00000058   0x82A0             STRH     R0,[R4, #+20]
    934            }
    935          }
   \                     ??USART_SmartCardCmd_3: (+1)
   \   0000005A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    936          
    937          /**
    938            * @brief  Enables or disables NACK transmission.
    939            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
    940            *         UART peripheral.
    941            * @param  NewState: new state of the NACK transmission.
    942            *          This parameter can be: ENABLE or DISABLE.  
    943            * @retval None
    944            */

   \                                 In section .text, align 2, keep-with-next
    945          void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    946          {
   \                     USART_SmartCardNACKCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    947            /* Check the parameters */
    948            assert_param(IS_USART_1236_PERIPH(USARTx)); 
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40011000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD010             BEQ.N    ??USART_SmartCardNACKCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD00C             BEQ.N    ??USART_SmartCardNACKCmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable26_2  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD008             BEQ.N    ??USART_SmartCardNACKCmd_0
   \   0000001E   0x....             LDR.N    R0,??DataTable21  ;; 0x40011400
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD005             BEQ.N    ??USART_SmartCardNACKCmd_0
   \   00000024   0xF44F 0x716D      MOV      R1,#+948
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable26_3
   \   0000002C   0x.... 0x....      BL       assert_failed
    949            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??USART_SmartCardNACKCmd_0: (+1)
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD008             BEQ.N    ??USART_SmartCardNACKCmd_1
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x2D01             CMP      R5,#+1
   \   0000003A   0xD005             BEQ.N    ??USART_SmartCardNACKCmd_1
   \   0000003C   0xF240 0x31B5      MOVW     R1,#+949
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable26_3
   \   00000044   0x.... 0x....      BL       assert_failed
    950            if (NewState != DISABLE)
   \                     ??USART_SmartCardNACKCmd_1: (+1)
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x2D00             CMP      R5,#+0
   \   0000004C   0xD004             BEQ.N    ??USART_SmartCardNACKCmd_2
    951            {
    952              /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
    953              USARTx->CR3 |= USART_CR3_NACK;
   \   0000004E   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000050   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000054   0x82A0             STRH     R0,[R4, #+20]
   \   00000056   0xE004             B.N      ??USART_SmartCardNACKCmd_3
    954            }
    955            else
    956            {
    957              /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
    958              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_NACK);
   \                     ??USART_SmartCardNACKCmd_2: (+1)
   \   00000058   0x8AA0             LDRH     R0,[R4, #+20]
   \   0000005A   0xF64F 0x71EF      MOVW     R1,#+65519
   \   0000005E   0x4008             ANDS     R0,R1,R0
   \   00000060   0x82A0             STRH     R0,[R4, #+20]
    959            }
    960          }
   \                     ??USART_SmartCardNACKCmd_3: (+1)
   \   00000062   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    961          
    962          /**
    963            * @}
    964            */
    965          
    966          /** @defgroup USART_Group7 IrDA mode functions
    967           *  @brief   IrDA mode functions 
    968           *
    969          @verbatim   
    970           ===============================================================================
    971                                          IrDA mode functions
    972           ===============================================================================  
    973          
    974            This subsection provides a set of functions allowing to manage the USART 
    975            IrDA communication.
    976            
    977            IrDA is a half duplex communication protocol. If the Transmitter is busy, any data
    978            on the IrDA receive line will be ignored by the IrDA decoder and if the Receiver 
    979            is busy, data on the TX from the USART to IrDA will not be encoded by IrDA.
    980            While receiving data, transmission should be avoided as the data to be transmitted
    981            could be corrupted.
    982          
    983            IrDA communication is possible through the following procedure:
    984               1. Program the Baud rate, Word length = 8 bits, Stop bits, Parity, Transmitter/Receiver 
    985                  modes and hardware flow control values using the USART_Init() function.
    986               2. Enable the USART using the USART_Cmd() function.
    987               3. Configures the IrDA pulse width by configuring the prescaler using  
    988                  the USART_SetPrescaler() function.
    989               4. Configures the IrDA  USART_IrDAMode_LowPower or USART_IrDAMode_Normal mode
    990                  using the USART_IrDAConfig() function.
    991               5. Enable the IrDA using the USART_IrDACmd() function.
    992          
    993          @note A pulse of width less than two and greater than one PSC period(s) may or may
    994                not be rejected.
    995          @note The receiver set up time should be managed by software. The IrDA physical layer
    996                specification specifies a minimum of 10 ms delay between transmission and 
    997                reception (IrDA is a half duplex protocol).
    998          @note In IrDA mode, the following bits must be kept cleared:
    999                  - LINEN, STOP and CLKEN bits in the USART_CR2 register.
   1000                  - SCEN and HDSEL bits in the USART_CR3 register.
   1001          
   1002          @endverbatim
   1003            * @{
   1004            */
   1005          
   1006          /**
   1007            * @brief  Configures the USART's IrDA interface.
   1008            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1009            *         UART peripheral.
   1010            * @param  USART_IrDAMode: specifies the IrDA mode.
   1011            *          This parameter can be one of the following values:
   1012            *            @arg USART_IrDAMode_LowPower
   1013            *            @arg USART_IrDAMode_Normal
   1014            * @retval None
   1015            */

   \                                 In section .text, align 2, keep-with-next
   1016          void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
   1017          {
   \                     USART_IrDAConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1018            /* Check the parameters */
   1019            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40011000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD018             BEQ.N    ??USART_IrDAConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD014             BEQ.N    ??USART_IrDAConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable26_2  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD010             BEQ.N    ??USART_IrDAConfig_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable26_4  ;; 0x40004c00
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD00C             BEQ.N    ??USART_IrDAConfig_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable26_5  ;; 0x40005000
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD008             BEQ.N    ??USART_IrDAConfig_0
   \   0000002E   0x....             LDR.N    R0,??DataTable21  ;; 0x40011400
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD005             BEQ.N    ??USART_IrDAConfig_0
   \   00000034   0xF240 0x31FB      MOVW     R1,#+1019
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable26_3
   \   0000003C   0x.... 0x....      BL       assert_failed
   1020            assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
   \                     ??USART_IrDAConfig_0: (+1)
   \   00000040   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000042   0x2D04             CMP      R5,#+4
   \   00000044   0xD008             BEQ.N    ??USART_IrDAConfig_1
   \   00000046   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000048   0x2D00             CMP      R5,#+0
   \   0000004A   0xD005             BEQ.N    ??USART_IrDAConfig_1
   \   0000004C   0xF44F 0x717F      MOV      R1,#+1020
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable26_3
   \   00000054   0x.... 0x....      BL       assert_failed
   1021              
   1022            USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IRLP);
   \                     ??USART_IrDAConfig_1: (+1)
   \   00000058   0x8AA0             LDRH     R0,[R4, #+20]
   \   0000005A   0xF64F 0x71FB      MOVW     R1,#+65531
   \   0000005E   0x4008             ANDS     R0,R1,R0
   \   00000060   0x82A0             STRH     R0,[R4, #+20]
   1023            USARTx->CR3 |= USART_IrDAMode;
   \   00000062   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000064   0x4328             ORRS     R0,R5,R0
   \   00000066   0x82A0             STRH     R0,[R4, #+20]
   1024          }
   \   00000068   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1025          
   1026          /**
   1027            * @brief  Enables or disables the USART's IrDA interface.
   1028            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1029            *         UART peripheral.
   1030            * @param  NewState: new state of the IrDA mode.
   1031            *          This parameter can be: ENABLE or DISABLE.
   1032            * @retval None
   1033            */

   \                                 In section .text, align 2, keep-with-next
   1034          void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
   1035          {
   \                     USART_IrDACmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1036            /* Check the parameters */
   1037            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40011000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD018             BEQ.N    ??USART_IrDACmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD014             BEQ.N    ??USART_IrDACmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable26_2  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD010             BEQ.N    ??USART_IrDACmd_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable26_4  ;; 0x40004c00
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD00C             BEQ.N    ??USART_IrDACmd_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable26_5  ;; 0x40005000
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD008             BEQ.N    ??USART_IrDACmd_0
   \   0000002E   0x....             LDR.N    R0,??DataTable21  ;; 0x40011400
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD005             BEQ.N    ??USART_IrDACmd_0
   \   00000034   0xF240 0x410D      MOVW     R1,#+1037
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable26_3
   \   0000003C   0x.... 0x....      BL       assert_failed
   1038            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??USART_IrDACmd_0: (+1)
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x2D00             CMP      R5,#+0
   \   00000044   0xD008             BEQ.N    ??USART_IrDACmd_1
   \   00000046   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   0x2D01             CMP      R5,#+1
   \   0000004A   0xD005             BEQ.N    ??USART_IrDACmd_1
   \   0000004C   0xF240 0x410E      MOVW     R1,#+1038
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable26_3
   \   00000054   0x.... 0x....      BL       assert_failed
   1039              
   1040            if (NewState != DISABLE)
   \                     ??USART_IrDACmd_1: (+1)
   \   00000058   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005A   0x2D00             CMP      R5,#+0
   \   0000005C   0xD004             BEQ.N    ??USART_IrDACmd_2
   1041            {
   1042              /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
   1043              USARTx->CR3 |= USART_CR3_IREN;
   \   0000005E   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000060   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000064   0x82A0             STRH     R0,[R4, #+20]
   \   00000066   0xE004             B.N      ??USART_IrDACmd_3
   1044            }
   1045            else
   1046            {
   1047              /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
   1048              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IREN);
   \                     ??USART_IrDACmd_2: (+1)
   \   00000068   0x8AA0             LDRH     R0,[R4, #+20]
   \   0000006A   0xF64F 0x71FD      MOVW     R1,#+65533
   \   0000006E   0x4008             ANDS     R0,R1,R0
   \   00000070   0x82A0             STRH     R0,[R4, #+20]
   1049            }
   1050          }
   \                     ??USART_IrDACmd_3: (+1)
   \   00000072   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1051          
   1052          /**
   1053            * @}
   1054            */
   1055          
   1056          /** @defgroup USART_Group8 DMA transfers management functions
   1057           *  @brief   DMA transfers management functions
   1058           *
   1059          @verbatim   
   1060           ===============================================================================
   1061                                DMA transfers management functions
   1062           ===============================================================================  
   1063          
   1064          @endverbatim
   1065            * @{
   1066            */
   1067            
   1068          /**
   1069            * @brief  Enables or disables the USART's DMA interface.
   1070            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1071            *         UART peripheral.
   1072            * @param  USART_DMAReq: specifies the DMA request.
   1073            *          This parameter can be any combination of the following values:
   1074            *            @arg USART_DMAReq_Tx: USART DMA transmit request
   1075            *            @arg USART_DMAReq_Rx: USART DMA receive request
   1076            * @param  NewState: new state of the DMA Request sources.
   1077            *          This parameter can be: ENABLE or DISABLE.   
   1078            * @retval None
   1079            */

   \                                 In section .text, align 2, keep-with-next
   1080          void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
   1081          {
   \                     USART_DMACmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1082            /* Check the parameters */
   1083            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40011000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD018             BEQ.N    ??USART_DMACmd_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40004400
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD014             BEQ.N    ??USART_DMACmd_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable26_2  ;; 0x40004800
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD010             BEQ.N    ??USART_DMACmd_0
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable26_4  ;; 0x40004c00
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD00C             BEQ.N    ??USART_DMACmd_0
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable26_5  ;; 0x40005000
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD008             BEQ.N    ??USART_DMACmd_0
   \   00000030   0x....             LDR.N    R0,??DataTable21  ;; 0x40011400
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD005             BEQ.N    ??USART_DMACmd_0
   \   00000036   0xF240 0x413B      MOVW     R1,#+1083
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable26_3
   \   0000003E   0x.... 0x....      BL       assert_failed
   1084            assert_param(IS_USART_DMAREQ(USART_DMAReq));  
   \                     ??USART_DMACmd_0: (+1)
   \   00000042   0xF64F 0x703F      MOVW     R0,#+65343
   \   00000046   0x4205             TST      R5,R0
   \   00000048   0xD102             BNE.N    ??USART_DMACmd_1
   \   0000004A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004C   0x2D00             CMP      R5,#+0
   \   0000004E   0xD105             BNE.N    ??USART_DMACmd_2
   \                     ??USART_DMACmd_1: (+1)
   \   00000050   0xF240 0x413C      MOVW     R1,#+1084
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable26_3
   \   00000058   0x.... 0x....      BL       assert_failed
   1085            assert_param(IS_FUNCTIONAL_STATE(NewState)); 
   \                     ??USART_DMACmd_2: (+1)
   \   0000005C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000005E   0x2E00             CMP      R6,#+0
   \   00000060   0xD008             BEQ.N    ??USART_DMACmd_3
   \   00000062   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000064   0x2E01             CMP      R6,#+1
   \   00000066   0xD005             BEQ.N    ??USART_DMACmd_3
   \   00000068   0xF240 0x413D      MOVW     R1,#+1085
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable26_3
   \   00000070   0x.... 0x....      BL       assert_failed
   1086          
   1087            if (NewState != DISABLE)
   \                     ??USART_DMACmd_3: (+1)
   \   00000074   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000076   0x2E00             CMP      R6,#+0
   \   00000078   0xD003             BEQ.N    ??USART_DMACmd_4
   1088            {
   1089              /* Enable the DMA transfer for selected requests by setting the DMAT and/or
   1090                 DMAR bits in the USART CR3 register */
   1091              USARTx->CR3 |= USART_DMAReq;
   \   0000007A   0x8AA0             LDRH     R0,[R4, #+20]
   \   0000007C   0x4328             ORRS     R0,R5,R0
   \   0000007E   0x82A0             STRH     R0,[R4, #+20]
   \   00000080   0xE002             B.N      ??USART_DMACmd_5
   1092            }
   1093            else
   1094            {
   1095              /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
   1096                 DMAR bits in the USART CR3 register */
   1097              USARTx->CR3 &= (uint16_t)~USART_DMAReq;
   \                     ??USART_DMACmd_4: (+1)
   \   00000082   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000084   0x43A8             BICS     R0,R0,R5
   \   00000086   0x82A0             STRH     R0,[R4, #+20]
   1098            }
   1099          }
   \                     ??USART_DMACmd_5: (+1)
   \   00000088   0xBD70             POP      {R4-R6,PC}       ;; return
   1100          
   1101          /**
   1102            * @}
   1103            */
   1104            
   1105          /** @defgroup USART_Group9 Interrupts and flags management functions
   1106           *  @brief   Interrupts and flags management functions 
   1107           *
   1108          @verbatim   
   1109           ===============================================================================
   1110                             Interrupts and flags management functions
   1111           ===============================================================================  
   1112          
   1113            This subsection provides a set of functions allowing to configure the USART 
   1114            Interrupts sources, DMA channels requests and check or clear the flags or 
   1115            pending bits status.
   1116            The user should identify which mode will be used in his application to manage 
   1117            the communication: Polling mode, Interrupt mode or DMA mode. 
   1118              
   1119            Polling Mode
   1120            =============
   1121            In Polling Mode, the SPI communication can be managed by 10 flags:
   1122               1. USART_FLAG_TXE : to indicate the status of the transmit buffer register
   1123               2. USART_FLAG_RXNE : to indicate the status of the receive buffer register
   1124               3. USART_FLAG_TC : to indicate the status of the transmit operation
   1125               4. USART_FLAG_IDLE : to indicate the status of the Idle Line             
   1126               5. USART_FLAG_CTS : to indicate the status of the nCTS input
   1127               6. USART_FLAG_LBD : to indicate the status of the LIN break detection
   1128               7. USART_FLAG_NE : to indicate if a noise error occur
   1129               8. USART_FLAG_FE : to indicate if a frame error occur
   1130               9. USART_FLAG_PE : to indicate if a parity error occur
   1131               10. USART_FLAG_ORE : to indicate if an Overrun error occur
   1132          
   1133            In this Mode it is advised to use the following functions:
   1134                - FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);
   1135                - void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG);
   1136          
   1137            Interrupt Mode
   1138            ===============
   1139            In Interrupt Mode, the USART communication can be managed by 8 interrupt sources
   1140            and 10 pending bits: 
   1141          
   1142            Pending Bits:
   1143            ------------- 
   1144               1. USART_IT_TXE : to indicate the status of the transmit buffer register
   1145               2. USART_IT_RXNE : to indicate the status of the receive buffer register
   1146               3. USART_IT_TC : to indicate the status of the transmit operation
   1147               4. USART_IT_IDLE : to indicate the status of the Idle Line             
   1148               5. USART_IT_CTS : to indicate the status of the nCTS input
   1149               6. USART_IT_LBD : to indicate the status of the LIN break detection
   1150               7. USART_IT_NE : to indicate if a noise error occur
   1151               8. USART_IT_FE : to indicate if a frame error occur
   1152               9. USART_IT_PE : to indicate if a parity error occur
   1153               10. USART_IT_ORE : to indicate if an Overrun error occur
   1154          
   1155            Interrupt Source:
   1156            -----------------
   1157               1. USART_IT_TXE : specifies the interrupt source for the Tx buffer empty 
   1158                                 interrupt. 
   1159               2. USART_IT_RXNE : specifies the interrupt source for the Rx buffer not 
   1160                                  empty interrupt.
   1161               3. USART_IT_TC : specifies the interrupt source for the Transmit complete 
   1162                                 interrupt. 
   1163               4. USART_IT_IDLE : specifies the interrupt source for the Idle Line interrupt.             
   1164               5. USART_IT_CTS : specifies the interrupt source for the CTS interrupt. 
   1165               6. USART_IT_LBD : specifies the interrupt source for the LIN break detection
   1166                                 interrupt. 
   1167               7. USART_IT_PE : specifies the interrupt source for the parity error interrupt. 
   1168               8. USART_IT_ERR :  specifies the interrupt source for the errors interrupt.
   1169          
   1170          @note Some parameters are coded in order to use them as interrupt source or as pending bits.
   1171          
   1172            In this Mode it is advised to use the following functions:
   1173               - void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);
   1174               - ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
   1175               - void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
   1176          
   1177            DMA Mode
   1178            ========
   1179            In DMA Mode, the USART communication can be managed by 2 DMA Channel requests:
   1180               1. USART_DMAReq_Tx: specifies the Tx buffer DMA transfer request
   1181               2. USART_DMAReq_Rx: specifies the Rx buffer DMA transfer request
   1182          
   1183            In this Mode it is advised to use the following function:
   1184               - void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState);
   1185          
   1186          @endverbatim
   1187            * @{
   1188            */
   1189          
   1190          /**
   1191            * @brief  Enables or disables the specified USART interrupts.
   1192            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1193            *         UART peripheral.
   1194            * @param  USART_IT: specifies the USART interrupt sources to be enabled or disabled.
   1195            *          This parameter can be one of the following values:
   1196            *            @arg USART_IT_CTS:  CTS change interrupt
   1197            *            @arg USART_IT_LBD:  LIN Break detection interrupt
   1198            *            @arg USART_IT_TXE:  Transmit Data Register empty interrupt
   1199            *            @arg USART_IT_TC:   Transmission complete interrupt
   1200            *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
   1201            *            @arg USART_IT_IDLE: Idle line detection interrupt
   1202            *            @arg USART_IT_PE:   Parity Error interrupt
   1203            *            @arg USART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
   1204            * @param  NewState: new state of the specified USARTx interrupts.
   1205            *          This parameter can be: ENABLE or DISABLE.
   1206            * @retval None
   1207            */

   \                                 In section .text, align 2, keep-with-next
   1208          void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
   1209          {
   \                     USART_ITConfig: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1210            uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
   1211            uint32_t usartxbase = 0x00;
   \   00000014   0xF05F 0x0A00      MOVS     R10,#+0
   1212            /* Check the parameters */
   1213            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40011000
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD019             BEQ.N    ??USART_ITConfig_0
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40004400
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD015             BEQ.N    ??USART_ITConfig_0
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable26_2  ;; 0x40004800
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD011             BEQ.N    ??USART_ITConfig_0
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable26_4  ;; 0x40004c00
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD00D             BEQ.N    ??USART_ITConfig_0
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable26_5  ;; 0x40005000
   \   0000003C   0x4284             CMP      R4,R0
   \   0000003E   0xD009             BEQ.N    ??USART_ITConfig_0
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable26_6  ;; 0x40011400
   \   00000044   0x4284             CMP      R4,R0
   \   00000046   0xD005             BEQ.N    ??USART_ITConfig_0
   \   00000048   0xF240 0x41BD      MOVW     R1,#+1213
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable26_3
   \   00000050   0x.... 0x....      BL       assert_failed
   1214            assert_param(IS_USART_CONFIG_IT(USART_IT));
   \                     ??USART_ITConfig_0: (+1)
   \   00000054   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000056   0x2D28             CMP      R5,#+40
   \   00000058   0xD026             BEQ.N    ??USART_ITConfig_1
   \   0000005A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005C   0xF240 0x7027      MOVW     R0,#+1831
   \   00000060   0x4285             CMP      R5,R0
   \   00000062   0xD021             BEQ.N    ??USART_ITConfig_1
   \   00000064   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000066   0xF240 0x6026      MOVW     R0,#+1574
   \   0000006A   0x4285             CMP      R5,R0
   \   0000006C   0xD01C             BEQ.N    ??USART_ITConfig_1
   \   0000006E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000070   0xF240 0x5025      MOVW     R0,#+1317
   \   00000074   0x4285             CMP      R5,R0
   \   00000076   0xD017             BEQ.N    ??USART_ITConfig_1
   \   00000078   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000007A   0xF240 0x4024      MOVW     R0,#+1060
   \   0000007E   0x4285             CMP      R5,R0
   \   00000080   0xD012             BEQ.N    ??USART_ITConfig_1
   \   00000082   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000084   0xF640 0x0046      MOVW     R0,#+2118
   \   00000088   0x4285             CMP      R5,R0
   \   0000008A   0xD00D             BEQ.N    ??USART_ITConfig_1
   \   0000008C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000008E   0xF640 0x106A      MOVW     R0,#+2410
   \   00000092   0x4285             CMP      R5,R0
   \   00000094   0xD008             BEQ.N    ??USART_ITConfig_1
   \   00000096   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000098   0x2D60             CMP      R5,#+96
   \   0000009A   0xD005             BEQ.N    ??USART_ITConfig_1
   \   0000009C   0xF240 0x41BE      MOVW     R1,#+1214
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable26_3
   \   000000A4   0x.... 0x....      BL       assert_failed
   1215            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??USART_ITConfig_1: (+1)
   \   000000A8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000AA   0x2E00             CMP      R6,#+0
   \   000000AC   0xD008             BEQ.N    ??USART_ITConfig_2
   \   000000AE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000B0   0x2E01             CMP      R6,#+1
   \   000000B2   0xD005             BEQ.N    ??USART_ITConfig_2
   \   000000B4   0xF240 0x41BF      MOVW     R1,#+1215
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable26_3
   \   000000BC   0x.... 0x....      BL       assert_failed
   1216          
   1217            /* The CTS interrupt is not available for UART4 and UART5 */
   1218            if (USART_IT == USART_IT_CTS)
   \                     ??USART_ITConfig_2: (+1)
   \   000000C0   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000C2   0xF640 0x106A      MOVW     R0,#+2410
   \   000000C6   0x4285             CMP      R5,R0
   \   000000C8   0xD115             BNE.N    ??USART_ITConfig_3
   1219            {
   1220              assert_param(IS_USART_1236_PERIPH(USARTx));
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40011000
   \   000000CE   0x4284             CMP      R4,R0
   \   000000D0   0xD011             BEQ.N    ??USART_ITConfig_3
   \   000000D2   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40004400
   \   000000D6   0x4284             CMP      R4,R0
   \   000000D8   0xD00D             BEQ.N    ??USART_ITConfig_3
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable26_2  ;; 0x40004800
   \   000000DE   0x4284             CMP      R4,R0
   \   000000E0   0xD009             BEQ.N    ??USART_ITConfig_3
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable26_6  ;; 0x40011400
   \   000000E6   0x4284             CMP      R4,R0
   \   000000E8   0xD005             BEQ.N    ??USART_ITConfig_3
   \   000000EA   0xF240 0x41C4      MOVW     R1,#+1220
   \   000000EE   0x.... 0x....      LDR.W    R0,??DataTable26_3
   \   000000F2   0x.... 0x....      BL       assert_failed
   1221            } 
   1222              
   1223            usartxbase = (uint32_t)USARTx;
   \                     ??USART_ITConfig_3: (+1)
   \   000000F6   0x46A2             MOV      R10,R4
   1224          
   1225            /* Get the USART register index */
   1226            usartreg = (((uint8_t)USART_IT) >> 0x05);
   \   000000F8   0x0028             MOVS     R0,R5
   \   000000FA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000FC   0x0940             LSRS     R0,R0,#+5
   \   000000FE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000100   0x0007             MOVS     R7,R0
   1227          
   1228            /* Get the interrupt position */
   1229            itpos = USART_IT & IT_MASK;
   \   00000102   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000104   0xF015 0x001F      ANDS     R0,R5,#0x1F
   \   00000108   0x4680             MOV      R8,R0
   1230            itmask = (((uint32_t)0x01) << itpos);
   \   0000010A   0x2001             MOVS     R0,#+1
   \   0000010C   0xFA10 0xF008      LSLS     R0,R0,R8
   \   00000110   0x4681             MOV      R9,R0
   1231              
   1232            if (usartreg == 0x01) /* The IT is in CR1 register */
   \   00000112   0x2F01             CMP      R7,#+1
   \   00000114   0xD102             BNE.N    ??USART_ITConfig_4
   1233            {
   1234              usartxbase += 0x0C;
   \   00000116   0xF11A 0x0A0C      ADDS     R10,R10,#+12
   \   0000011A   0xE006             B.N      ??USART_ITConfig_5
   1235            }
   1236            else if (usartreg == 0x02) /* The IT is in CR2 register */
   \                     ??USART_ITConfig_4: (+1)
   \   0000011C   0x2F02             CMP      R7,#+2
   \   0000011E   0xD102             BNE.N    ??USART_ITConfig_6
   1237            {
   1238              usartxbase += 0x10;
   \   00000120   0xF11A 0x0A10      ADDS     R10,R10,#+16
   \   00000124   0xE001             B.N      ??USART_ITConfig_5
   1239            }
   1240            else /* The IT is in CR3 register */
   1241            {
   1242              usartxbase += 0x14; 
   \                     ??USART_ITConfig_6: (+1)
   \   00000126   0xF11A 0x0A14      ADDS     R10,R10,#+20
   1243            }
   1244            if (NewState != DISABLE)
   \                     ??USART_ITConfig_5: (+1)
   \   0000012A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000012C   0x2E00             CMP      R6,#+0
   \   0000012E   0xD006             BEQ.N    ??USART_ITConfig_7
   1245            {
   1246              *(__IO uint32_t*)usartxbase  |= itmask;
   \   00000130   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000134   0xEA59 0x0000      ORRS     R0,R9,R0
   \   00000138   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   0000013C   0xE005             B.N      ??USART_ITConfig_8
   1247            }
   1248            else
   1249            {
   1250              *(__IO uint32_t*)usartxbase &= ~itmask;
   \                     ??USART_ITConfig_7: (+1)
   \   0000013E   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000142   0xEA30 0x0009      BICS     R0,R0,R9
   \   00000146   0xF8CA 0x0000      STR      R0,[R10, #+0]
   1251            }
   1252          }
   \                     ??USART_ITConfig_8: (+1)
   \   0000014A   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1253          
   1254          /**
   1255            * @brief  Checks whether the specified USART flag is set or not.
   1256            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1257            *         UART peripheral.
   1258            * @param  USART_FLAG: specifies the flag to check.
   1259            *          This parameter can be one of the following values:
   1260            *            @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5)
   1261            *            @arg USART_FLAG_LBD:  LIN Break detection flag
   1262            *            @arg USART_FLAG_TXE:  Transmit data register empty flag
   1263            *            @arg USART_FLAG_TC:   Transmission Complete flag
   1264            *            @arg USART_FLAG_RXNE: Receive data register not empty flag
   1265            *            @arg USART_FLAG_IDLE: Idle Line detection flag
   1266            *            @arg USART_FLAG_ORE:  OverRun Error flag
   1267            *            @arg USART_FLAG_NE:   Noise Error flag
   1268            *            @arg USART_FLAG_FE:   Framing Error flag
   1269            *            @arg USART_FLAG_PE:   Parity Error flag
   1270            * @retval The new state of USART_FLAG (SET or RESET).
   1271            */

   \                                 In section .text, align 2, keep-with-next
   1272          FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
   1273          {
   \                     USART_GetFlagStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1274            FlagStatus bitstatus = RESET;
   \   00000006   0x2600             MOVS     R6,#+0
   1275            /* Check the parameters */
   1276            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40011000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD019             BEQ.N    ??USART_GetFlagStatus_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40004400
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD015             BEQ.N    ??USART_GetFlagStatus_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable26_2  ;; 0x40004800
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD011             BEQ.N    ??USART_GetFlagStatus_0
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable26_4  ;; 0x40004c00
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD00D             BEQ.N    ??USART_GetFlagStatus_0
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable26_5  ;; 0x40005000
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD009             BEQ.N    ??USART_GetFlagStatus_0
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable26_6  ;; 0x40011400
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD005             BEQ.N    ??USART_GetFlagStatus_0
   \   00000038   0xF240 0x41FC      MOVW     R1,#+1276
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable26_3
   \   00000040   0x.... 0x....      BL       assert_failed
   1277            assert_param(IS_USART_FLAG(USART_FLAG));
   \                     ??USART_GetFlagStatus_0: (+1)
   \   00000044   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000046   0x2D01             CMP      R5,#+1
   \   00000048   0xD021             BEQ.N    ??USART_GetFlagStatus_1
   \   0000004A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004C   0x2D80             CMP      R5,#+128
   \   0000004E   0xD01E             BEQ.N    ??USART_GetFlagStatus_1
   \   00000050   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000052   0x2D40             CMP      R5,#+64
   \   00000054   0xD01B             BEQ.N    ??USART_GetFlagStatus_1
   \   00000056   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000058   0x2D20             CMP      R5,#+32
   \   0000005A   0xD018             BEQ.N    ??USART_GetFlagStatus_1
   \   0000005C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005E   0x2D10             CMP      R5,#+16
   \   00000060   0xD015             BEQ.N    ??USART_GetFlagStatus_1
   \   00000062   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000064   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000068   0xD011             BEQ.N    ??USART_GetFlagStatus_1
   \   0000006A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000006C   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000070   0xD00D             BEQ.N    ??USART_GetFlagStatus_1
   \   00000072   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000074   0x2D08             CMP      R5,#+8
   \   00000076   0xD00A             BEQ.N    ??USART_GetFlagStatus_1
   \   00000078   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000007A   0x2D04             CMP      R5,#+4
   \   0000007C   0xD007             BEQ.N    ??USART_GetFlagStatus_1
   \   0000007E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000080   0x2D02             CMP      R5,#+2
   \   00000082   0xD004             BEQ.N    ??USART_GetFlagStatus_1
   \   00000084   0xF240 0x41FD      MOVW     R1,#+1277
   \   00000088   0x....             LDR.N    R0,??DataTable26_3
   \   0000008A   0x.... 0x....      BL       assert_failed
   1278          
   1279            /* The CTS flag is not available for UART4 and UART5 */
   1280            if (USART_FLAG == USART_FLAG_CTS)
   \                     ??USART_GetFlagStatus_1: (+1)
   \   0000008E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000090   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000094   0xD110             BNE.N    ??USART_GetFlagStatus_2
   1281            {
   1282              assert_param(IS_USART_1236_PERIPH(USARTx));
   \   00000096   0x....             LDR.N    R0,??DataTable26  ;; 0x40011000
   \   00000098   0x4284             CMP      R4,R0
   \   0000009A   0xD00D             BEQ.N    ??USART_GetFlagStatus_2
   \   0000009C   0x....             LDR.N    R0,??DataTable26_1  ;; 0x40004400
   \   0000009E   0x4284             CMP      R4,R0
   \   000000A0   0xD00A             BEQ.N    ??USART_GetFlagStatus_2
   \   000000A2   0x....             LDR.N    R0,??DataTable26_2  ;; 0x40004800
   \   000000A4   0x4284             CMP      R4,R0
   \   000000A6   0xD007             BEQ.N    ??USART_GetFlagStatus_2
   \   000000A8   0x....             LDR.N    R0,??DataTable26_6  ;; 0x40011400
   \   000000AA   0x4284             CMP      R4,R0
   \   000000AC   0xD004             BEQ.N    ??USART_GetFlagStatus_2
   \   000000AE   0xF240 0x5102      MOVW     R1,#+1282
   \   000000B2   0x....             LDR.N    R0,??DataTable26_3
   \   000000B4   0x.... 0x....      BL       assert_failed
   1283            } 
   1284              
   1285            if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
   \                     ??USART_GetFlagStatus_2: (+1)
   \   000000B8   0x8820             LDRH     R0,[R4, #+0]
   \   000000BA   0x4228             TST      R0,R5
   \   000000BC   0xD002             BEQ.N    ??USART_GetFlagStatus_3
   1286            {
   1287              bitstatus = SET;
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0x0006             MOVS     R6,R0
   \   000000C2   0xE001             B.N      ??USART_GetFlagStatus_4
   1288            }
   1289            else
   1290            {
   1291              bitstatus = RESET;
   \                     ??USART_GetFlagStatus_3: (+1)
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0x0006             MOVS     R6,R0
   1292            }
   1293            return bitstatus;
   \                     ??USART_GetFlagStatus_4: (+1)
   \   000000C8   0x0030             MOVS     R0,R6
   \   000000CA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000CC   0xBD70             POP      {R4-R6,PC}       ;; return
   1294          }
   1295          
   1296          /**
   1297            * @brief  Clears the USARTx's pending flags.
   1298            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1299            *         UART peripheral.
   1300            * @param  USART_FLAG: specifies the flag to clear.
   1301            *          This parameter can be any combination of the following values:
   1302            *            @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5).
   1303            *            @arg USART_FLAG_LBD:  LIN Break detection flag.
   1304            *            @arg USART_FLAG_TC:   Transmission Complete flag.
   1305            *            @arg USART_FLAG_RXNE: Receive data register not empty flag.
   1306            *   
   1307            * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
   1308            *          error) and IDLE (Idle line detected) flags are cleared by software 
   1309            *          sequence: a read operation to USART_SR register (USART_GetFlagStatus()) 
   1310            *          followed by a read operation to USART_DR register (USART_ReceiveData()).
   1311            * @note   RXNE flag can be also cleared by a read to the USART_DR register 
   1312            *          (USART_ReceiveData()).
   1313            * @note   TC flag can be also cleared by software sequence: a read operation to 
   1314            *          USART_SR register (USART_GetFlagStatus()) followed by a write operation
   1315            *          to USART_DR register (USART_SendData()).
   1316            * @note   TXE flag is cleared only by a write to the USART_DR register 
   1317            *          (USART_SendData()).
   1318            *   
   1319            * @retval None
   1320            */

   \                                 In section .text, align 2, keep-with-next
   1321          void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
   1322          {
   \                     USART_ClearFlag: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1323            /* Check the parameters */
   1324            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x....             LDR.N    R0,??DataTable26  ;; 0x40011000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD013             BEQ.N    ??USART_ClearFlag_0
   \   0000000C   0x....             LDR.N    R0,??DataTable26_1  ;; 0x40004400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD010             BEQ.N    ??USART_ClearFlag_0
   \   00000012   0x....             LDR.N    R0,??DataTable26_2  ;; 0x40004800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD00D             BEQ.N    ??USART_ClearFlag_0
   \   00000018   0x....             LDR.N    R0,??DataTable26_4  ;; 0x40004c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD00A             BEQ.N    ??USART_ClearFlag_0
   \   0000001E   0x....             LDR.N    R0,??DataTable26_5  ;; 0x40005000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD007             BEQ.N    ??USART_ClearFlag_0
   \   00000024   0x....             LDR.N    R0,??DataTable26_6  ;; 0x40011400
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD004             BEQ.N    ??USART_ClearFlag_0
   \   0000002A   0xF240 0x512C      MOVW     R1,#+1324
   \   0000002E   0x....             LDR.N    R0,??DataTable26_3
   \   00000030   0x.... 0x....      BL       assert_failed
   1325            assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
   \                     ??USART_ClearFlag_0: (+1)
   \   00000034   0xF64F 0x409F      MOVW     R0,#+64671
   \   00000038   0x4205             TST      R5,R0
   \   0000003A   0xD102             BNE.N    ??USART_ClearFlag_1
   \   0000003C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0xD104             BNE.N    ??USART_ClearFlag_2
   \                     ??USART_ClearFlag_1: (+1)
   \   00000042   0xF240 0x512D      MOVW     R1,#+1325
   \   00000046   0x....             LDR.N    R0,??DataTable26_3
   \   00000048   0x.... 0x....      BL       assert_failed
   1326          
   1327            /* The CTS flag is not available for UART4 and UART5 */
   1328            if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
   \                     ??USART_ClearFlag_2: (+1)
   \   0000004C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004E   0x05A8             LSLS     R0,R5,#+22
   \   00000050   0xD510             BPL.N    ??USART_ClearFlag_3
   1329            {
   1330              assert_param(IS_USART_1236_PERIPH(USARTx));
   \   00000052   0x....             LDR.N    R0,??DataTable26  ;; 0x40011000
   \   00000054   0x4284             CMP      R4,R0
   \   00000056   0xD00D             BEQ.N    ??USART_ClearFlag_3
   \   00000058   0x....             LDR.N    R0,??DataTable26_1  ;; 0x40004400
   \   0000005A   0x4284             CMP      R4,R0
   \   0000005C   0xD00A             BEQ.N    ??USART_ClearFlag_3
   \   0000005E   0x....             LDR.N    R0,??DataTable26_2  ;; 0x40004800
   \   00000060   0x4284             CMP      R4,R0
   \   00000062   0xD007             BEQ.N    ??USART_ClearFlag_3
   \   00000064   0x....             LDR.N    R0,??DataTable26_6  ;; 0x40011400
   \   00000066   0x4284             CMP      R4,R0
   \   00000068   0xD004             BEQ.N    ??USART_ClearFlag_3
   \   0000006A   0xF240 0x5132      MOVW     R1,#+1330
   \   0000006E   0x....             LDR.N    R0,??DataTable26_3
   \   00000070   0x.... 0x....      BL       assert_failed
   1331            } 
   1332                 
   1333            USARTx->SR = (uint16_t)~USART_FLAG;
   \                     ??USART_ClearFlag_3: (+1)
   \   00000074   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000076   0x43E8             MVNS     R0,R5
   \   00000078   0x8020             STRH     R0,[R4, #+0]
   1334          }
   \   0000007A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1335          
   1336          /**
   1337            * @brief  Checks whether the specified USART interrupt has occurred or not.
   1338            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1339            *         UART peripheral.
   1340            * @param  USART_IT: specifies the USART interrupt source to check.
   1341            *          This parameter can be one of the following values:
   1342            *            @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
   1343            *            @arg USART_IT_LBD:  LIN Break detection interrupt
   1344            *            @arg USART_IT_TXE:  Transmit Data Register empty interrupt
   1345            *            @arg USART_IT_TC:   Transmission complete interrupt
   1346            *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
   1347            *            @arg USART_IT_IDLE: Idle line detection interrupt
   1348            *            @arg USART_IT_ORE_RX : OverRun Error interrupt if the RXNEIE bit is set
   1349            *            @arg USART_IT_ORE_ER : OverRun Error interrupt if the EIE bit is set  
   1350            *            @arg USART_IT_NE:   Noise Error interrupt
   1351            *            @arg USART_IT_FE:   Framing Error interrupt
   1352            *            @arg USART_IT_PE:   Parity Error interrupt
   1353            * @retval The new state of USART_IT (SET or RESET).
   1354            */

   \                                 In section .text, align 2, keep-with-next
   1355          ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
   1356          {
   \                     USART_GetITStatus: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1357            uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
   \   00000008   0x2600             MOVS     R6,#+0
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1358            ITStatus bitstatus = RESET;
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
   1359            /* Check the parameters */
   1360            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000014   0x....             LDR.N    R0,??DataTable26  ;; 0x40011000
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD013             BEQ.N    ??USART_GetITStatus_0
   \   0000001A   0x....             LDR.N    R0,??DataTable26_1  ;; 0x40004400
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD010             BEQ.N    ??USART_GetITStatus_0
   \   00000020   0x....             LDR.N    R0,??DataTable26_2  ;; 0x40004800
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD00D             BEQ.N    ??USART_GetITStatus_0
   \   00000026   0x....             LDR.N    R0,??DataTable26_4  ;; 0x40004c00
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD00A             BEQ.N    ??USART_GetITStatus_0
   \   0000002C   0x....             LDR.N    R0,??DataTable26_5  ;; 0x40005000
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xD007             BEQ.N    ??USART_GetITStatus_0
   \   00000032   0x....             LDR.N    R0,??DataTable26_6  ;; 0x40011400
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD004             BEQ.N    ??USART_GetITStatus_0
   \   00000038   0xF44F 0x61AA      MOV      R1,#+1360
   \   0000003C   0x....             LDR.N    R0,??DataTable26_3
   \   0000003E   0x.... 0x....      BL       assert_failed
   1361            assert_param(IS_USART_GET_IT(USART_IT)); 
   \                     ??USART_GetITStatus_0: (+1)
   \   00000042   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   0x2D28             CMP      R5,#+40
   \   00000046   0xD037             BEQ.N    ??USART_GetITStatus_1
   \   00000048   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004A   0xF240 0x7027      MOVW     R0,#+1831
   \   0000004E   0x4285             CMP      R5,R0
   \   00000050   0xD032             BEQ.N    ??USART_GetITStatus_1
   \   00000052   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000054   0xF240 0x6026      MOVW     R0,#+1574
   \   00000058   0x4285             CMP      R5,R0
   \   0000005A   0xD02D             BEQ.N    ??USART_GetITStatus_1
   \   0000005C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005E   0xF240 0x5025      MOVW     R0,#+1317
   \   00000062   0x4285             CMP      R5,R0
   \   00000064   0xD028             BEQ.N    ??USART_GetITStatus_1
   \   00000066   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000068   0xF240 0x4024      MOVW     R0,#+1060
   \   0000006C   0x4285             CMP      R5,R0
   \   0000006E   0xD023             BEQ.N    ??USART_GetITStatus_1
   \   00000070   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000072   0xF640 0x0046      MOVW     R0,#+2118
   \   00000076   0x4285             CMP      R5,R0
   \   00000078   0xD01E             BEQ.N    ??USART_GetITStatus_1
   \   0000007A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000007C   0xF640 0x106A      MOVW     R0,#+2410
   \   00000080   0x4285             CMP      R5,R0
   \   00000082   0xD019             BEQ.N    ??USART_GetITStatus_1
   \   00000084   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000086   0xF5B5 0x7F58      CMP      R5,#+864
   \   0000008A   0xD015             BEQ.N    ??USART_GetITStatus_1
   \   0000008C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000008E   0xF240 0x3025      MOVW     R0,#+805
   \   00000092   0x4285             CMP      R5,R0
   \   00000094   0xD010             BEQ.N    ??USART_GetITStatus_1
   \   00000096   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000098   0xF5B5 0x7F58      CMP      R5,#+864
   \   0000009C   0xD00C             BEQ.N    ??USART_GetITStatus_1
   \   0000009E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000A0   0xF5B5 0x7F18      CMP      R5,#+608
   \   000000A4   0xD008             BEQ.N    ??USART_GetITStatus_1
   \   000000A6   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000A8   0xF5B5 0x7FB0      CMP      R5,#+352
   \   000000AC   0xD004             BEQ.N    ??USART_GetITStatus_1
   \   000000AE   0xF240 0x5151      MOVW     R1,#+1361
   \   000000B2   0x....             LDR.N    R0,??DataTable26_3
   \   000000B4   0x.... 0x....      BL       assert_failed
   1362          
   1363            /* The CTS interrupt is not available for UART4 and UART5 */ 
   1364            if (USART_IT == USART_IT_CTS)
   \                     ??USART_GetITStatus_1: (+1)
   \   000000B8   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000BA   0xF640 0x106A      MOVW     R0,#+2410
   \   000000BE   0x4285             CMP      R5,R0
   \   000000C0   0xD110             BNE.N    ??USART_GetITStatus_2
   1365            {
   1366              assert_param(IS_USART_1236_PERIPH(USARTx));
   \   000000C2   0x....             LDR.N    R0,??DataTable26  ;; 0x40011000
   \   000000C4   0x4284             CMP      R4,R0
   \   000000C6   0xD00D             BEQ.N    ??USART_GetITStatus_2
   \   000000C8   0x....             LDR.N    R0,??DataTable26_1  ;; 0x40004400
   \   000000CA   0x4284             CMP      R4,R0
   \   000000CC   0xD00A             BEQ.N    ??USART_GetITStatus_2
   \   000000CE   0x....             LDR.N    R0,??DataTable26_2  ;; 0x40004800
   \   000000D0   0x4284             CMP      R4,R0
   \   000000D2   0xD007             BEQ.N    ??USART_GetITStatus_2
   \   000000D4   0x....             LDR.N    R0,??DataTable26_6  ;; 0x40011400
   \   000000D6   0x4284             CMP      R4,R0
   \   000000D8   0xD004             BEQ.N    ??USART_GetITStatus_2
   \   000000DA   0xF240 0x5156      MOVW     R1,#+1366
   \   000000DE   0x....             LDR.N    R0,??DataTable26_3
   \   000000E0   0x.... 0x....      BL       assert_failed
   1367            } 
   1368              
   1369            /* Get the USART register index */
   1370            usartreg = (((uint8_t)USART_IT) >> 0x05);
   \                     ??USART_GetITStatus_2: (+1)
   \   000000E4   0x0028             MOVS     R0,R5
   \   000000E6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E8   0x0940             LSRS     R0,R0,#+5
   \   000000EA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000EC   0x4680             MOV      R8,R0
   1371            /* Get the interrupt position */
   1372            itmask = USART_IT & IT_MASK;
   \   000000EE   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000F0   0xF015 0x001F      ANDS     R0,R5,#0x1F
   \   000000F4   0x0007             MOVS     R7,R0
   1373            itmask = (uint32_t)0x01 << itmask;
   \   000000F6   0x2001             MOVS     R0,#+1
   \   000000F8   0xFA10 0xF707      LSLS     R7,R0,R7
   1374            
   1375            if (usartreg == 0x01) /* The IT  is in CR1 register */
   \   000000FC   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000100   0xD102             BNE.N    ??USART_GetITStatus_3
   1376            {
   1377              itmask &= USARTx->CR1;
   \   00000102   0x89A0             LDRH     R0,[R4, #+12]
   \   00000104   0x4007             ANDS     R7,R0,R7
   \   00000106   0xE007             B.N      ??USART_GetITStatus_4
   1378            }
   1379            else if (usartreg == 0x02) /* The IT  is in CR2 register */
   \                     ??USART_GetITStatus_3: (+1)
   \   00000108   0xF1B8 0x0F02      CMP      R8,#+2
   \   0000010C   0xD102             BNE.N    ??USART_GetITStatus_5
   1380            {
   1381              itmask &= USARTx->CR2;
   \   0000010E   0x8A20             LDRH     R0,[R4, #+16]
   \   00000110   0x4007             ANDS     R7,R0,R7
   \   00000112   0xE001             B.N      ??USART_GetITStatus_4
   1382            }
   1383            else /* The IT  is in CR3 register */
   1384            {
   1385              itmask &= USARTx->CR3;
   \                     ??USART_GetITStatus_5: (+1)
   \   00000114   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000116   0x4007             ANDS     R7,R0,R7
   1386            }
   1387            
   1388            bitpos = USART_IT >> 0x08;
   \                     ??USART_GetITStatus_4: (+1)
   \   00000118   0x0028             MOVS     R0,R5
   \   0000011A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000011C   0x0A00             LSRS     R0,R0,#+8
   \   0000011E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000120   0x0006             MOVS     R6,R0
   1389            bitpos = (uint32_t)0x01 << bitpos;
   \   00000122   0x2001             MOVS     R0,#+1
   \   00000124   0xFA10 0xF606      LSLS     R6,R0,R6
   1390            bitpos &= USARTx->SR;
   \   00000128   0x8820             LDRH     R0,[R4, #+0]
   \   0000012A   0x4006             ANDS     R6,R0,R6
   1391            if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
   \   0000012C   0x2F00             CMP      R7,#+0
   \   0000012E   0xD004             BEQ.N    ??USART_GetITStatus_6
   \   00000130   0x2E00             CMP      R6,#+0
   \   00000132   0xD002             BEQ.N    ??USART_GetITStatus_6
   1392            {
   1393              bitstatus = SET;
   \   00000134   0x2001             MOVS     R0,#+1
   \   00000136   0x4681             MOV      R9,R0
   \   00000138   0xE001             B.N      ??USART_GetITStatus_7
   1394            }
   1395            else
   1396            {
   1397              bitstatus = RESET;
   \                     ??USART_GetITStatus_6: (+1)
   \   0000013A   0x2000             MOVS     R0,#+0
   \   0000013C   0x4681             MOV      R9,R0
   1398            }
   1399            
   1400            return bitstatus;  
   \                     ??USART_GetITStatus_7: (+1)
   \   0000013E   0x4648             MOV      R0,R9
   \   00000140   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000142   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1401          }
   1402          
   1403          /**
   1404            * @brief  Clears the USARTx's interrupt pending bits.
   1405            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1406            *         UART peripheral.
   1407            * @param  USART_IT: specifies the interrupt pending bit to clear.
   1408            *          This parameter can be one of the following values:
   1409            *            @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
   1410            *            @arg USART_IT_LBD:  LIN Break detection interrupt
   1411            *            @arg USART_IT_TC:   Transmission complete interrupt. 
   1412            *            @arg USART_IT_RXNE: Receive Data register not empty interrupt.
   1413            *
   1414            * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
   1415            *          error) and IDLE (Idle line detected) pending bits are cleared by 
   1416            *          software sequence: a read operation to USART_SR register 
   1417            *          (USART_GetITStatus()) followed by a read operation to USART_DR register 
   1418            *          (USART_ReceiveData()).
   1419            * @note   RXNE pending bit can be also cleared by a read to the USART_DR register 
   1420            *          (USART_ReceiveData()).
   1421            * @note   TC pending bit can be also cleared by software sequence: a read 
   1422            *          operation to USART_SR register (USART_GetITStatus()) followed by a write 
   1423            *          operation to USART_DR register (USART_SendData()).
   1424            * @note   TXE pending bit is cleared only by a write to the USART_DR register 
   1425            *          (USART_SendData()).
   1426            *  
   1427            * @retval None
   1428            */

   \                                 In section .text, align 2, keep-with-next
   1429          void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
   1430          {
   \                     USART_ClearITPendingBit: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1431            uint16_t bitpos = 0x00, itmask = 0x00;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x2700             MOVS     R7,#+0
   1432            /* Check the parameters */
   1433            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   0000000A   0x....             LDR.N    R0,??DataTable26  ;; 0x40011000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD013             BEQ.N    ??USART_ClearITPendingBit_0
   \   00000010   0x....             LDR.N    R0,??DataTable26_1  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD010             BEQ.N    ??USART_ClearITPendingBit_0
   \   00000016   0x....             LDR.N    R0,??DataTable26_2  ;; 0x40004800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD00D             BEQ.N    ??USART_ClearITPendingBit_0
   \   0000001C   0x....             LDR.N    R0,??DataTable26_4  ;; 0x40004c00
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD00A             BEQ.N    ??USART_ClearITPendingBit_0
   \   00000022   0x....             LDR.N    R0,??DataTable26_5  ;; 0x40005000
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD007             BEQ.N    ??USART_ClearITPendingBit_0
   \   00000028   0x....             LDR.N    R0,??DataTable26_6  ;; 0x40011400
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD004             BEQ.N    ??USART_ClearITPendingBit_0
   \   0000002E   0xF240 0x5199      MOVW     R1,#+1433
   \   00000032   0x....             LDR.N    R0,??DataTable26_3
   \   00000034   0x.... 0x....      BL       assert_failed
   1434            assert_param(IS_USART_CLEAR_IT(USART_IT)); 
   \                     ??USART_ClearITPendingBit_0: (+1)
   \   00000038   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003A   0xF240 0x6026      MOVW     R0,#+1574
   \   0000003E   0x4285             CMP      R5,R0
   \   00000040   0xD013             BEQ.N    ??USART_ClearITPendingBit_1
   \   00000042   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   0xF240 0x5025      MOVW     R0,#+1317
   \   00000048   0x4285             CMP      R5,R0
   \   0000004A   0xD00E             BEQ.N    ??USART_ClearITPendingBit_1
   \   0000004C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004E   0xF640 0x0046      MOVW     R0,#+2118
   \   00000052   0x4285             CMP      R5,R0
   \   00000054   0xD009             BEQ.N    ??USART_ClearITPendingBit_1
   \   00000056   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000058   0xF640 0x106A      MOVW     R0,#+2410
   \   0000005C   0x4285             CMP      R5,R0
   \   0000005E   0xD004             BEQ.N    ??USART_ClearITPendingBit_1
   \   00000060   0xF240 0x519A      MOVW     R1,#+1434
   \   00000064   0x....             LDR.N    R0,??DataTable26_3
   \   00000066   0x.... 0x....      BL       assert_failed
   1435          
   1436            /* The CTS interrupt is not available for UART4 and UART5 */
   1437            if (USART_IT == USART_IT_CTS)
   \                     ??USART_ClearITPendingBit_1: (+1)
   \   0000006A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000006C   0xF640 0x106A      MOVW     R0,#+2410
   \   00000070   0x4285             CMP      R5,R0
   \   00000072   0xD110             BNE.N    ??USART_ClearITPendingBit_2
   1438            {
   1439              assert_param(IS_USART_1236_PERIPH(USARTx));
   \   00000074   0x....             LDR.N    R0,??DataTable26  ;; 0x40011000
   \   00000076   0x4284             CMP      R4,R0
   \   00000078   0xD00D             BEQ.N    ??USART_ClearITPendingBit_2
   \   0000007A   0x....             LDR.N    R0,??DataTable26_1  ;; 0x40004400
   \   0000007C   0x4284             CMP      R4,R0
   \   0000007E   0xD00A             BEQ.N    ??USART_ClearITPendingBit_2
   \   00000080   0x....             LDR.N    R0,??DataTable26_2  ;; 0x40004800
   \   00000082   0x4284             CMP      R4,R0
   \   00000084   0xD007             BEQ.N    ??USART_ClearITPendingBit_2
   \   00000086   0x....             LDR.N    R0,??DataTable26_6  ;; 0x40011400
   \   00000088   0x4284             CMP      R4,R0
   \   0000008A   0xD004             BEQ.N    ??USART_ClearITPendingBit_2
   \   0000008C   0xF240 0x519F      MOVW     R1,#+1439
   \   00000090   0x....             LDR.N    R0,??DataTable26_3
   \   00000092   0x.... 0x....      BL       assert_failed
   1440            } 
   1441              
   1442            bitpos = USART_IT >> 0x08;
   \                     ??USART_ClearITPendingBit_2: (+1)
   \   00000096   0x0028             MOVS     R0,R5
   \   00000098   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000009A   0x0A00             LSRS     R0,R0,#+8
   \   0000009C   0x0006             MOVS     R6,R0
   1443            itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0x40B0             LSLS     R0,R0,R6
   \   000000A2   0x0007             MOVS     R7,R0
   1444            USARTx->SR = (uint16_t)~itmask;
   \   000000A4   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000A6   0x43F8             MVNS     R0,R7
   \   000000A8   0x8020             STRH     R0,[R4, #+0]
   1445          }
   \   000000AA   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x40004800         DC32     0x40004800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x40004C00         DC32     0x40004c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x40005000         DC32     0x40005000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x007270E1         DC32     0x7270e1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0xFFFFE9F3         DC32     0xffffe9f3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_2:
   \   00000000   0x40004800         DC32     0x40004800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_3:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_4:
   \   00000000   0x40004C00         DC32     0x40004c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_5:
   \   00000000   0x40005000         DC32     0x40005000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_6:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 49H, 41H, 52H, 20H, 57H
   \              0x5C 0x49    
   \              0x41 0x52    
   \              0x20 0x57    
   \   00000008   0x6F 0x72          DC8 6FH, 72H, 6BH, 73H, 70H, 61H, 63H, 65H
   \              0x6B 0x73    
   \              0x70 0x61    
   \              0x63 0x65    
   \   00000010   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 46H, 34H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x46 0x34    
   \   00000018   0x30 0x37          DC8 30H, 37H, 5CH, 53H, 54H, 4DH, 33H, 32H
   \              0x5C 0x53    
   \              0x54 0x4D    
   \              0x33 0x32    
   \   00000020   0x46 0x34          DC8 46H, 34H, 2DH, 44H, 69H, 73H, 63H, 6FH
   \              0x2D 0x44    
   \              0x69 0x73    
   \              0x63 0x6F    
   \   00000028   0x76 0x65          DC8 76H, 65H, 72H, 79H, 5FH, 46H, 57H, 5FH
   \              0x72 0x79    
   \              0x5F 0x46    
   \              0x57 0x5F    
   \   00000030   0x56 0x31          DC8 56H, 31H, 2EH, 31H, 2EH, 30H, 5CH, 4CH
   \              0x2E 0x31    
   \              0x2E 0x30    
   \              0x5C 0x4C    
   \   00000038   0x69 0x62          DC8 69H, 62H, 72H, 61H, 72H, 69H, 65H, 73H
   \              0x72 0x61    
   \              0x72 0x69    
   \              0x65 0x73    
   \   00000040   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 46H, 34H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x46 0x34    
   \   00000048   0x78 0x78          DC8 78H, 78H, 5FH, 53H, 74H, 64H, 50H, 65H
   \              0x5F 0x53    
   \              0x74 0x64    
   \              0x50 0x65    
   \   00000050   0x72 0x69          DC8 72H, 69H, 70H, 68H, 5FH, 44H, 72H, 69H
   \              0x70 0x68    
   \              0x5F 0x44    
   \              0x72 0x69    
   \   00000058   0x76 0x65          DC8 76H, 65H, 72H, 5CH, 73H, 72H, 63H, 5CH
   \              0x72 0x5C    
   \              0x73 0x72    
   \              0x63 0x5C    
   \   00000060   0x73 0x74          DC8 73H, 74H, 6DH, 33H, 32H, 66H, 34H, 78H
   \              0x6D 0x33    
   \              0x32 0x66    
   \              0x34 0x78    
   \   00000068   0x78 0x5F          DC8 78H, 5FH, 75H, 73H, 61H, 72H, 74H, 2EH
   \              0x75 0x73    
   \              0x61 0x72    
   \              0x74 0x2E    
   \   00000070   0x63 0x00          DC8 63H, 0
   \   00000072   0x00 0x00          DC8 0, 0
   1446          
   1447          /**
   1448            * @}
   1449            */
   1450          
   1451          /**
   1452            * @}
   1453            */
   1454          
   1455          /**
   1456            * @}
   1457            */
   1458          
   1459          /**
   1460            * @}
   1461            */
   1462          
   1463          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   USART_ClearFlag
        16   -> assert_failed
      24   USART_ClearITPendingBit
        24   -> assert_failed
      16   USART_ClockInit
        16   -> assert_failed
       0   USART_ClockStructInit
      16   USART_Cmd
        16   -> assert_failed
      16   USART_DMACmd
        16   -> assert_failed
       8   USART_DeInit
         8   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
         8   -> assert_failed
      16   USART_GetFlagStatus
        16   -> assert_failed
      32   USART_GetITStatus
        32   -> assert_failed
      16   USART_HalfDuplexCmd
        16   -> assert_failed
      32   USART_ITConfig
        32   -> assert_failed
      48   USART_Init
        48   -> RCC_GetClocksFreq
        48   -> assert_failed
      16   USART_IrDACmd
        16   -> assert_failed
      16   USART_IrDAConfig
        16   -> assert_failed
      16   USART_LINBreakDetectLengthConfig
        16   -> assert_failed
      16   USART_LINCmd
        16   -> assert_failed
      16   USART_OneBitMethodCmd
        16   -> assert_failed
      16   USART_OverSampling8Cmd
        16   -> assert_failed
       8   USART_ReceiveData
         8   -> assert_failed
      16   USART_ReceiverWakeUpCmd
        16   -> assert_failed
       8   USART_SendBreak
         8   -> assert_failed
      16   USART_SendData
        16   -> assert_failed
      16   USART_SetAddress
        16   -> assert_failed
      16   USART_SetGuardTime
        16   -> assert_failed
      16   USART_SetPrescaler
        16   -> assert_failed
      16   USART_SmartCardCmd
        16   -> assert_failed
      16   USART_SmartCardNACKCmd
        16   -> assert_failed
       0   USART_StructInit
      16   USART_WakeUpConfig
        16   -> assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable19
       4  ??DataTable20
       4  ??DataTable21
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_2
       4  ??DataTable26_3
       4  ??DataTable26_4
       4  ??DataTable26_5
       4  ??DataTable26_6
     116  ?_0
     124  USART_ClearFlag
     172  USART_ClearITPendingBit
     184  USART_ClockInit
      18  USART_ClockStructInit
     118  USART_Cmd
     138  USART_DMACmd
     234  USART_DeInit
     206  USART_GetFlagStatus
     326  USART_GetITStatus
     102  USART_HalfDuplexCmd
     334  USART_ITConfig
     512  USART_Init
     116  USART_IrDACmd
     106  USART_IrDAConfig
      94  USART_LINBreakDetectLengthConfig
     104  USART_LINCmd
     118  USART_OneBitMethodCmd
     116  USART_OverSampling8Cmd
      72  USART_ReceiveData
     104  USART_ReceiverWakeUpCmd
      60  USART_SendBreak
      94  USART_SendData
     102  USART_SetAddress
      58  USART_SetGuardTime
      84  USART_SetPrescaler
      92  USART_SmartCardCmd
     100  USART_SmartCardNACKCmd
      28  USART_StructInit
      96  USART_WakeUpConfig

 
   116 bytes in section .rodata
 4 076 bytes in section .text
 
 4 076 bytes of CODE  memory
   116 bytes of CONST memory

Errors: none
Warnings: none
