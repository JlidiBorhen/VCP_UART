###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       06/May/2016  23:31:35
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\IAR
#        Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rtc.c
#    Command line =  
#        "D:\IAR
#        Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rtc.c"
#        -D USE_STDPERIPH_DRIVER -D STM32F4XX -D USE_FULL_ASSERT -lCN "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\List" -o "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\Obj" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\Include\" -I
#        "D:\IAR Workspace\STM32F407\VCP_ESP\..\Utilities\STM32F4-Discovery\"
#        -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\ST\STM32F4xx\Include\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_conf\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\cdc\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\otg\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\core\" -On --use_c++_inline -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    List file    =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\Debug\List\stm32f4xx_rtc.lst
#    Object file  =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\Debug\Obj\stm32f4xx_rtc.o
#
###############################################################################

D:\IAR Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rtc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_rtc.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    30-September-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Real-Time Clock (RTC) peripheral:
      9            *           - Initialization
     10            *           - Calendar (Time and Date) configuration
     11            *           - Alarms (Alarm A and Alarm B) configuration
     12            *           - WakeUp Timer configuration
     13            *           - Daylight Saving configuration
     14            *           - Output pin Configuration
     15            *           - Coarse digital Calibration configuration
     16            *           - Smooth digital Calibration configuration
     17            *           - TimeStamp configuration
     18            *           - Tampers configuration
     19            *           - Backup Data Registers configuration
     20            *           - Shift control synchronisation    
     21            *           - RTC Tamper and TimeStamp Pins Selection and Output Type Config configuration
     22            *           - Interrupts and flags management
     23            *
     24            *  @verbatim
     25            *
     26            *          ===================================================================
     27            *                               Backup Domain Operating Condition
     28            *          ===================================================================
     29            *          The real-time clock (RTC), the RTC backup registers, and the backup 
     30            *          SRAM (BKP SRAM) can be powered from the VBAT voltage when the main 
     31            *          VDD supply is powered off.
     32            *          To retain the content of the RTC backup registers, backup SRAM, 
     33            *          and supply the RTC when VDD is turned off, VBAT pin can be connected 
     34            *          to an optional standby voltage supplied by a battery or by another 
     35            *          source.
     36            *
     37            *          To allow the RTC to operate even when the main digital supply (VDD) 
     38            *          is turned off, the VBAT pin powers the following blocks:
     39            *            1 - The RTC
     40            *            2 - The LSE oscillator
     41            *            3 - The backup SRAM when the low power backup regulator is enabled
     42            *            4 - PC13 to PC15 I/Os, plus PI8 I/O (when available)
     43            *
     44            *          When the backup domain is supplied by VDD (analog switch connected 
     45            *          to VDD), the following functions are available:
     46            *            1 - PC14 and PC15 can be used as either GPIO or LSE pins
     47            *            2 - PC13 can be used as a GPIO or as the RTC_AF1 pin
     48            *            3 - PI8 can be used as a GPIO or as the RTC_AF2 pin
     49            *
     50            *          When the backup domain is supplied by VBAT (analog switch connected 
     51            *          to VBAT because VDD is not present), the following functions are available:
     52            *            1 - PC14 and PC15 can be used as LSE pins only
     53            *            2 - PC13 can be used as the RTC_AF1 pin 
     54            *            3 - PI8 can be used as the RTC_AF2 pin
     55            *
     56            *          ===================================================================
     57            *                                    Backup Domain Reset
     58            *          ===================================================================
     59            *          The backup domain reset sets all RTC registers and the RCC_BDCR 
     60            *          register to their reset values. The BKPSRAM is not affected by this
     61            *          reset. The only way of resetting the BKPSRAM is through the Flash 
     62            *          interface by requesting a protection level change from 1 to 0.
     63            *          A backup domain reset is generated when one of the following events
     64            *          occurs:
     65            *            1 - Software reset, triggered by setting the BDRST bit in the 
     66            *                RCC Backup domain control register (RCC_BDCR). You can use the
     67            *                RCC_BackupResetCmd().
     68            *            2 - VDD or VBAT power on, if both supplies have previously been
     69            *                powered off.
     70            *
     71            *          ===================================================================
     72            *                                   Backup Domain Access
     73            *          ===================================================================
     74            *          After reset, the backup domain (RTC registers, RTC backup data 
     75            *          registers and backup SRAM) is protected against possible unwanted 
     76            *          write accesses. 
     77            *          To enable access to the RTC Domain and RTC registers, proceed as follows:
     78            *            - Enable the Power Controller (PWR) APB1 interface clock using the
     79            *              RCC_APB1PeriphClockCmd() function.
     80            *            - Enable access to RTC domain using the PWR_BackupAccessCmd() function.
     81            *            - Select the RTC clock source using the RCC_RTCCLKConfig() function.
     82            *            - Enable RTC Clock using the RCC_RTCCLKCmd() function.
     83            *
     84            *          ===================================================================
     85            *                                   RTC Driver: how to use it
     86            *          ===================================================================
     87            *            - Enable the RTC domain access (see description in the section above)
     88            *            - Configure the RTC Prescaler (Asynchronous and Synchronous) and
     89            *              RTC hour format using the RTC_Init() function.
     90            *
     91            *          Time and Date configuration
     92            *          ===========================
     93            *            - To configure the RTC Calendar (Time and Date) use the RTC_SetTime()
     94            *              and RTC_SetDate() functions.
     95            *            - To read the RTC Calendar, use the RTC_GetTime() and RTC_GetDate()
     96            *              functions.
     97            *            - Use the RTC_DayLightSavingConfig() function to add or sub one
     98            *              hour to the RTC Calendar.    
     99            *
    100            *          Alarm configuration
    101            *          ===================
    102            *            - To configure the RTC Alarm use the RTC_SetAlarm() function.
    103            *            - Enable the selected RTC Alarm using the RTC_AlarmCmd() function
    104            *            - To read the RTC Alarm, use the RTC_GetAlarm() function.
    105            *            - To read the RTC alarm SubSecond, use the RTC_GetAlarmSubSecond() function.
    106            *
    107            *          RTC Wakeup configuration
    108            *          ========================
    109            *            - Configure the RTC Wakeup Clock source use the RTC_WakeUpClockConfig()
    110            *              function.
    111            *            - Configure the RTC WakeUp Counter using the RTC_SetWakeUpCounter() 
    112            *              function  
    113            *            - Enable the RTC WakeUp using the RTC_WakeUpCmd() function  
    114            *            - To read the RTC WakeUp Counter register, use the RTC_GetWakeUpCounter() 
    115            *              function.
    116            *
    117            *          Outputs configuration
    118            *          =====================
    119            *          The RTC has 2 different outputs:
    120            *            - AFO_ALARM: this output is used to manage the RTC Alarm A, Alarm B
    121            *              and WaKeUp signals.          
    122            *              To output the selected RTC signal on RTC_AF1 pin, use the 
    123            *              RTC_OutputConfig() function.                
    124            *            - AFO_CALIB: this output is 512Hz signal or 1Hz .  
    125            *              To output the RTC Clock on RTC_AF1 pin, use the RTC_CalibOutputCmd()
    126            *              function.
    127            *
    128            *          Smooth digital Calibration configuration
    129            *          =================================    
    130            *            - Configure the RTC Original Digital Calibration Value and the corresponding
    131            *              calibration cycle period (32s,16s and 8s) using the RTC_SmoothCalibConfig() 
    132            *              function.
    133            *
    134            *          Coarse digital Calibration configuration
    135            *          =================================
    136            *            - Configure the RTC Coarse Calibration Value and the corresponding
    137            *              sign using the RTC_CoarseCalibConfig() function.
    138            *            - Enable the RTC Coarse Calibration using the RTC_CoarseCalibCmd() 
    139            *              function  
    140            *
    141            *          TimeStamp configuration
    142            *          =======================
    143            *            - Configure the RTC_AF1 trigger and enables the RTC TimeStamp 
    144            *              using the RTC_TimeStampCmd() function.
    145            *            - To read the RTC TimeStamp Time and Date register, use the 
    146            *              RTC_GetTimeStamp() function.
    147            *            - To read the RTC TimeStamp SubSecond register, use the 
    148            *              RTC_GetTimeStampSubSecond() function.
    149            *            - The TAMPER1 alternate function can be mapped either to RTC_AF1(PC13)
    150            *              or RTC_AF2 (PI8) depending on the value of TAMP1INSEL bit in 
    151            *              RTC_TAFCR register. You can use the  RTC_TamperPinSelection()
    152            *              function to select the corresponding pin.     
    153            *
    154            *          Tamper configuration
    155            *          ====================
    156            *            - Enable the RTC Tamper using the RTC_TamperCmd() function.
    157            *             - Configure the Tamper filter count using RTC_TamperFilterConfig()
    158            *              function. 
    159            *            - Configure the RTC Tamper trigger Edge or Level according to the Tamper 
    160            *              filter (if equal to 0 Edge else Level) value using the RTC_TamperConfig() function.
    161            *            - Configure the Tamper sampling frequency using RTC_TamperSamplingFreqConfig()
    162            *              function.
    163            *            - Configure the Tamper precharge or discharge duration using 
    164            *              RTC_TamperPinsPrechargeDuration() function.
    165            *            - Enable the Tamper Pull-UP using RTC_TamperPullUpDisableCmd() function.
    166            *            - Enable the Time stamp on Tamper detection event using  
    167            *              RTC_TSOnTamperDetecCmd() function.
    168            *            - The TIMESTAMP alternate function can be mapped to either RTC_AF1 
    169            *              or RTC_AF2 depending on the value of the TSINSEL bit in the 
    170            *              RTC_TAFCR register. You can use the  RTC_TimeStampPinSelection()
    171            *              function to select the corresponding pin. 
    172            *
    173            *          Backup Data Registers configuration
    174            *          ===================================
    175            *            - To write to the RTC Backup Data registers, use the RTC_WriteBackupRegister()
    176            *              function.  
    177            *            - To read the RTC Backup Data registers, use the RTC_ReadBackupRegister()
    178            *              function.
    179            * 
    180            *          ===================================================================
    181            *                                  RTC and low power modes
    182            *          ===================================================================
    183            *           The MCU can be woken up from a low power mode by an RTC alternate 
    184            *           function.
    185            *           The RTC alternate functions are the RTC alarms (Alarm A and Alarm B), 
    186            *           RTC wakeup, RTC tamper event detection and RTC time stamp event detection.
    187            *           These RTC alternate functions can wake up the system from the Stop 
    188            *           and Standby lowpower modes.
    189            *           The system can also wake up from low power modes without depending 
    190            *           on an external interrupt (Auto-wakeup mode), by using the RTC alarm 
    191            *           or the RTC wakeup events.
    192            *           The RTC provides a programmable time base for waking up from the 
    193            *           Stop or Standby mode at regular intervals.
    194            *           Wakeup from STOP and Standby modes is possible only when the RTC 
    195            *           clock source is LSE or LSI.
    196            *
    197            *          ===================================================================
    198            *                            Selection of RTC_AF1 alternate functions
    199            *          ===================================================================
    200            *          The RTC_AF1 pin (PC13) can be used for the following purposes:
    201            *            - AFO_ALARM output
    202            *            - AFO_CALIB output
    203            *            - AFI_TAMPER
    204            *            - AFI_TIMESTAMP
    205            *
    206            * +-------------------------------------------------------------------------------------------------------------+
    207            * |     Pin         |AFO_ALARM |AFO_CALIB |AFI_TAMPER |AFI_TIMESTAMP | TAMP1INSEL |   TSINSEL    |ALARMOUTTYPE  |
    208            * |  configuration  | ENABLED  | ENABLED  |  ENABLED  |   ENABLED    |TAMPER1 pin |TIMESTAMP pin |  AFO_ALARM   |
    209            * |  and function   |          |          |           |              | selection  |  selection   |Configuration |
    210            * |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    211            * |   Alarm out     |          |          |           |              |    Don't   |     Don't    |              |
    212            * |   output OD     |     1    |Don't care|Don't care | Don't care   |    care    |     care     |      0       |
    213            * |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    214            * |   Alarm out     |          |          |           |              |    Don't   |     Don't    |              |
    215            * |   output PP     |     1    |Don't care|Don't care | Don't care   |    care    |     care     |      1       |
    216            * |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    217            * | Calibration out |          |          |           |              |    Don't   |     Don't    |              |
    218            * |   output PP     |     0    |    1     |Don't care | Don't care   |    care    |     care     |  Don't care  |
    219            * |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    220            * |  TAMPER input   |          |          |           |              |            |     Don't    |              |
    221            * |   floating      |     0    |    0     |     1     |      0       |      0     |     care     |  Don't care  |
    222            * |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    223            * |  TIMESTAMP and  |          |          |           |              |            |              |              |
    224            * |  TAMPER input   |     0    |    0     |     1     |      1       |      0     |      0       |  Don't care  |
    225            * |   floating      |          |          |           |              |            |              |              |
    226            * |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    227            * | TIMESTAMP input |          |          |           |              |    Don't   |              |              |
    228            * |    floating     |     0    |    0     |     0     |      1       |    care    |      0       |  Don't care  |
    229            * |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    230            * |  Standard GPIO  |     0    |    0     |     0     |      0       | Don't care |  Don't care  |  Don't care  |
    231            * +-------------------------------------------------------------------------------------------------------------+
    232            *
    233            *
    234            *          ===================================================================
    235            *                            Selection of RTC_AF2 alternate functions
    236            *          ===================================================================
    237            *          The RTC_AF2 pin (PI8) can be used for the following purposes:
    238            *            - AFI_TAMPER
    239            *            - AFI_TIMESTAMP
    240            *
    241            * +---------------------------------------------------------------------------------------+
    242            * |     Pin         |AFI_TAMPER |AFI_TIMESTAMP | TAMP1INSEL |   TSINSEL    |ALARMOUTTYPE  |
    243            * |  configuration  |  ENABLED  |   ENABLED    |TAMPER1 pin |TIMESTAMP pin |  AFO_ALARM   |
    244            * |  and function   |           |              | selection  |  selection   |Configuration |
    245            * |-----------------|-----------|--------------|------------|--------------|--------------|
    246            * |  TAMPER input   |           |              |            |     Don't    |              |
    247            * |   floating      |     1     |      0       |      1     |     care     |  Don't care  |
    248            * |-----------------|-----------|--------------|------------|--------------|--------------|
    249            * |  TIMESTAMP and  |           |              |            |              |              |
    250            * |  TAMPER input   |     1     |      1       |      1     |      1       |  Don't care  |
    251            * |   floating      |           |              |            |              |              |
    252            * |-----------------|-----------|--------------|------------|--------------|--------------|
    253            * | TIMESTAMP input |           |              |    Don't   |              |              |
    254            * |    floating     |     0     |      1       |    care    |      1       |  Don't care  |
    255            * |-----------------|-----------|--------------|------------|--------------|--------------|
    256            * |  Standard GPIO  |     0     |      0       | Don't care |  Don't care  |  Don't care  |
    257            * +---------------------------------------------------------------------------------------+
    258            * 
    259            *
    260            *  @endverbatim
    261            *
    262            ******************************************************************************
    263            * @attention
    264            *
    265            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
    266            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
    267            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
    268            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
    269            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
    270            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
    271            *
    272            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
    273            ******************************************************************************
    274            */ 
    275          
    276          /* Includes ------------------------------------------------------------------*/
    277          #include "stm32f4xx_rtc.h"
    278          #include "stm32f4xx_rcc.h"
    279          
    280          /** @addtogroup STM32F4xx_StdPeriph_Driver
    281            * @{
    282            */
    283          
    284          /** @defgroup RTC 
    285            * @brief RTC driver modules
    286            * @{
    287            */
    288          
    289          /* Private typedef -----------------------------------------------------------*/
    290          /* Private define ------------------------------------------------------------*/
    291          
    292          /* Masks Definition */
    293          #define RTC_TR_RESERVED_MASK    ((uint32_t)0x007F7F7F)
    294          #define RTC_DR_RESERVED_MASK    ((uint32_t)0x00FFFF3F) 
    295          #define RTC_INIT_MASK           ((uint32_t)0xFFFFFFFF)  
    296          #define RTC_RSF_MASK            ((uint32_t)0xFFFFFF5F)
    297          #define RTC_FLAGS_MASK          ((uint32_t)(RTC_FLAG_TSOVF | RTC_FLAG_TSF | RTC_FLAG_WUTF | \
    298                                                      RTC_FLAG_ALRBF | RTC_FLAG_ALRAF | RTC_FLAG_INITF | \
    299                                                      RTC_FLAG_RSF | RTC_FLAG_INITS | RTC_FLAG_WUTWF | \
    300                                                      RTC_FLAG_ALRBWF | RTC_FLAG_ALRAWF | RTC_FLAG_TAMP1F ))
    301          
    302          #define INITMODE_TIMEOUT         ((uint32_t) 0x00010000)
    303          #define SYNCHRO_TIMEOUT          ((uint32_t) 0x00020000)
    304          #define RECALPF_TIMEOUT          ((uint32_t) 0x00020000)
    305          #define SHPF_TIMEOUT             ((uint32_t) 0x00001000)
    306          
    307          /* Private macro -------------------------------------------------------------*/
    308          /* Private variables ---------------------------------------------------------*/
    309          /* Private function prototypes -----------------------------------------------*/
    310          static uint8_t RTC_ByteToBcd2(uint8_t Value);
    311          static uint8_t RTC_Bcd2ToByte(uint8_t Value);
    312          
    313          /* Private functions ---------------------------------------------------------*/
    314          
    315          /** @defgroup RTC_Private_Functions
    316            * @{
    317            */ 
    318          
    319          /** @defgroup RTC_Group1 Initialization and Configuration functions
    320           *  @brief   Initialization and Configuration functions 
    321           *
    322          @verbatim   
    323           ===============================================================================
    324                           Initialization and Configuration functions
    325           ===============================================================================
    326          
    327            This section provide functions allowing to initialize and configure the RTC
    328            Prescaler (Synchronous and Asynchronous), RTC Hour format, disable RTC registers
    329            Write protection, enter and exit the RTC initialization mode, RTC registers
    330            synchronization check and reference clock detection enable.
    331            
    332            1. The RTC Prescaler is programmed to generate the RTC 1Hz time base. It is
    333               split into 2 programmable prescalers to minimize power consumption.
    334               - A 7-bit asynchronous prescaler and A 13-bit synchronous prescaler.
    335               - When both prescalers are used, it is recommended to configure the asynchronous
    336                 prescaler to a high value to minimize consumption.
    337          
    338            2. All RTC registers are Write protected. Writing to the RTC registers
    339               is enabled by writing a key into the Write Protection register, RTC_WPR.
    340          
    341            3. To Configure the RTC Calendar, user application should enter initialization
    342               mode. In this mode, the calendar counter is stopped and its value can be 
    343               updated. When the initialization sequence is complete, the calendar restarts 
    344               counting after 4 RTCCLK cycles.
    345          
    346            4. To read the calendar through the shadow registers after Calendar initialization,
    347               calendar update or after wakeup from low power modes the software must first 
    348               clear the RSF flag. The software must then wait until it is set again before 
    349               reading the calendar, which means that the calendar registers have been 
    350               correctly copied into the RTC_TR and RTC_DR shadow registers.
    351               The RTC_WaitForSynchro() function implements the above software sequence 
    352               (RSF clear and RSF check).
    353          
    354          @endverbatim
    355            * @{
    356            */
    357          
    358          /**
    359            * @brief  Deinitializes the RTC registers to their default reset values.
    360            * @note   This function doesn't reset the RTC Clock source and RTC Backup Data
    361            *         registers.       
    362            * @param  None
    363            * @retval An ErrorStatus enumeration value:
    364            *          - SUCCESS: RTC registers are deinitialized
    365            *          - ERROR: RTC registers are not deinitialized
    366            */

   \                                 In section .text, align 2, keep-with-next
    367          ErrorStatus RTC_DeInit(void)
    368          {
   \                     RTC_DeInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    369            __IO uint32_t wutcounter = 0x00;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9000             STR      R0,[SP, #+0]
    370            uint32_t wutwfstatus = 0x00;
   \   00000006   0x2400             MOVS     R4,#+0
    371            ErrorStatus status = ERROR;
   \   00000008   0x2500             MOVS     R5,#+0
    372            
    373            /* Disable the write protection for RTC registers */
    374            RTC->WPR = 0xCA;
   \   0000000A   0x20CA             MOVS     R0,#+202
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40002824
   \   00000010   0x6008             STR      R0,[R1, #+0]
    375            RTC->WPR = 0x53;
   \   00000012   0x2053             MOVS     R0,#+83
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40002824
   \   00000018   0x6008             STR      R0,[R1, #+0]
    376          
    377            /* Set Initialization mode */
    378            if (RTC_EnterInitMode() == ERROR)
   \   0000001A   0x.... 0x....      BL       RTC_EnterInitMode
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD102             BNE.N    ??RTC_DeInit_0
    379            {
    380              status = ERROR;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x0005             MOVS     R5,R0
   \   00000026   0xE055             B.N      ??RTC_DeInit_1
    381            }  
    382            else
    383            {
    384              /* Reset TR, DR and CR registers */
    385              RTC->TR = (uint32_t)0x00000000;
   \                     ??RTC_DeInit_0: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x40002800
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    386              RTC->DR = (uint32_t)0x00002101;
   \   00000030   0xF242 0x1001      MOVW     R0,#+8449
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable15_1  ;; 0x40002804
   \   00000038   0x6008             STR      R0,[R1, #+0]
    387              /* Reset All CR bits except CR[2:0] */
    388              RTC->CR &= (uint32_t)0x00000007;
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x40002808
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable15_2  ;; 0x40002808
   \   00000048   0x6008             STR      R0,[R1, #+0]
    389            
    390              /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
    391              do
    392              {
    393                wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
   \                     ??RTC_DeInit_2: (+1)
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x4000280c
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0xF010 0x0004      ANDS     R0,R0,#0x4
   \   00000054   0x0004             MOVS     R4,R0
    394                wutcounter++;  
   \   00000056   0x9800             LDR      R0,[SP, #+0]
   \   00000058   0x1C40             ADDS     R0,R0,#+1
   \   0000005A   0x9000             STR      R0,[SP, #+0]
    395              } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
   \   0000005C   0x9800             LDR      R0,[SP, #+0]
   \   0000005E   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000062   0xD001             BEQ.N    ??RTC_DeInit_3
   \   00000064   0x2C00             CMP      R4,#+0
   \   00000066   0xD0F0             BEQ.N    ??RTC_DeInit_2
    396              
    397              if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
   \                     ??RTC_DeInit_3: (+1)
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x4000280c
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x0740             LSLS     R0,R0,#+29
   \   00000070   0xD402             BMI.N    ??RTC_DeInit_4
    398              {
    399                status = ERROR;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x0005             MOVS     R5,R0
   \   00000076   0xE02D             B.N      ??RTC_DeInit_1
    400              }
    401              else
    402              {
    403                /* Reset all RTC CR register bits */
    404                RTC->CR &= (uint32_t)0x00000000;
   \                     ??RTC_DeInit_4: (+1)
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x40002808
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable15_2  ;; 0x40002808
   \   00000084   0x6008             STR      R0,[R1, #+0]
    405                RTC->WUTR = (uint32_t)0x0000FFFF;
   \   00000086   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable15_3  ;; 0x40002814
   \   0000008E   0x6008             STR      R0,[R1, #+0]
    406                RTC->PRER = (uint32_t)0x007F00FF;
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x7f00ff
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable15_5  ;; 0x40002810
   \   00000098   0x6008             STR      R0,[R1, #+0]
    407                RTC->CALIBR = (uint32_t)0x00000000;
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable15_6  ;; 0x40002818
   \   000000A0   0x6008             STR      R0,[R1, #+0]
    408                RTC->ALRMAR = (uint32_t)0x00000000;        
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable15_7  ;; 0x4000281c
   \   000000A8   0x6008             STR      R0,[R1, #+0]
    409                RTC->ALRMBR = (uint32_t)0x00000000;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x40002820
   \   000000B0   0x6008             STR      R0,[R1, #+0]
    410                
    411                /* Reset ISR register and exit initialization mode */
    412                RTC->ISR = (uint32_t)0x00000000;
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x4000280c
   \   000000B8   0x6008             STR      R0,[R1, #+0]
    413                
    414                /* Reset Tamper and alternate functions configuration register */
    415                RTC->TAFCR = 0x00000000;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable16_1  ;; 0x40002840
   \   000000C0   0x6008             STR      R0,[R1, #+0]
    416            
    417                if(RTC_WaitForSynchro() == ERROR)
   \   000000C2   0x.... 0x....      BL       RTC_WaitForSynchro
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD102             BNE.N    ??RTC_DeInit_5
    418                {
    419                  status = ERROR;
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x0005             MOVS     R5,R0
   \   000000CE   0xE001             B.N      ??RTC_DeInit_1
    420                }
    421                else
    422                {
    423                  status = SUCCESS;      
   \                     ??RTC_DeInit_5: (+1)
   \   000000D0   0x2001             MOVS     R0,#+1
   \   000000D2   0x0005             MOVS     R5,R0
    424                }
    425              }
    426            }
    427            
    428            /* Enable the write protection for RTC registers */
    429            RTC->WPR = 0xFF;  
   \                     ??RTC_DeInit_1: (+1)
   \   000000D4   0x20FF             MOVS     R0,#+255
   \   000000D6   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40002824
   \   000000DA   0x6008             STR      R0,[R1, #+0]
    430            
    431            return status;
   \   000000DC   0x0028             MOVS     R0,R5
   \   000000DE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E0   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    432          }
    433          
    434          /**
    435            * @brief  Initializes the RTC registers according to the specified parameters 
    436            *         in RTC_InitStruct.
    437            * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure that contains 
    438            *         the configuration information for the RTC peripheral.
    439            * @note   The RTC Prescaler register is write protected and can be written in 
    440            *         initialization mode only.  
    441            * @retval An ErrorStatus enumeration value:
    442            *          - SUCCESS: RTC registers are initialized
    443            *          - ERROR: RTC registers are not initialized  
    444            */

   \                                 In section .text, align 2, keep-with-next
    445          ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
    446          {
   \                     RTC_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    447            ErrorStatus status = ERROR;
   \   00000004   0x2500             MOVS     R5,#+0
    448            
    449            /* Check the parameters */
    450            assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x2840             CMP      R0,#+64
   \   0000000A   0xD008             BEQ.N    ??RTC_Init_0
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD005             BEQ.N    ??RTC_Init_0
   \   00000012   0xF44F 0x71E1      MOV      R1,#+450
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000001A   0x.... 0x....      BL       assert_failed
    451            assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
   \                     ??RTC_Init_0: (+1)
   \   0000001E   0x6860             LDR      R0,[R4, #+4]
   \   00000020   0x2880             CMP      R0,#+128
   \   00000022   0xD305             BCC.N    ??RTC_Init_1
   \   00000024   0xF240 0x11C3      MOVW     R1,#+451
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000002C   0x.... 0x....      BL       assert_failed
    452            assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));
   \                     ??RTC_Init_1: (+1)
   \   00000030   0x68A0             LDR      R0,[R4, #+8]
   \   00000032   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000036   0xD305             BCC.N    ??RTC_Init_2
   \   00000038   0xF44F 0x71E2      MOV      R1,#+452
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000040   0x.... 0x....      BL       assert_failed
    453          
    454            /* Disable the write protection for RTC registers */
    455            RTC->WPR = 0xCA;
   \                     ??RTC_Init_2: (+1)
   \   00000044   0x20CA             MOVS     R0,#+202
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40002824
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    456            RTC->WPR = 0x53;
   \   0000004C   0x2053             MOVS     R0,#+83
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40002824
   \   00000052   0x6008             STR      R0,[R1, #+0]
    457          
    458            /* Set Initialization mode */
    459            if (RTC_EnterInitMode() == ERROR)
   \   00000054   0x.... 0x....      BL       RTC_EnterInitMode
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD102             BNE.N    ??RTC_Init_3
    460            {
    461              status = ERROR;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x0005             MOVS     R5,R0
   \   00000060   0xE020             B.N      ??RTC_Init_4
    462            } 
    463            else
    464            {
    465              /* Clear RTC CR FMT Bit */
    466              RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
   \                     ??RTC_Init_3: (+1)
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x40002808
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0xF030 0x0040      BICS     R0,R0,#0x40
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable15_2  ;; 0x40002808
   \   00000070   0x6008             STR      R0,[R1, #+0]
    467              /* Set RTC_CR register */
    468              RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x40002808
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x6821             LDR      R1,[R4, #+0]
   \   0000007A   0x4308             ORRS     R0,R1,R0
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable15_2  ;; 0x40002808
   \   00000080   0x6008             STR      R0,[R1, #+0]
    469            
    470              /* Configure the RTC PRER */
    471              RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
   \   00000082   0x68A0             LDR      R0,[R4, #+8]
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable15_5  ;; 0x40002810
   \   00000088   0x6008             STR      R0,[R1, #+0]
    472              RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0x40002810
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0x6861             LDR      R1,[R4, #+4]
   \   00000092   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable15_5  ;; 0x40002810
   \   0000009A   0x6008             STR      R0,[R1, #+0]
    473          
    474              /* Exit Initialization mode */
    475              RTC_ExitInitMode();
   \   0000009C   0x.... 0x....      BL       RTC_ExitInitMode
    476          
    477              status = SUCCESS;    
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0x0005             MOVS     R5,R0
    478            }
    479            /* Enable the write protection for RTC registers */
    480            RTC->WPR = 0xFF; 
   \                     ??RTC_Init_4: (+1)
   \   000000A4   0x20FF             MOVS     R0,#+255
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40002824
   \   000000AA   0x6008             STR      R0,[R1, #+0]
    481            
    482            return status;
   \   000000AC   0x0028             MOVS     R0,R5
   \   000000AE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B0   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    483          }
    484          
    485          /**
    486            * @brief  Fills each RTC_InitStruct member with its default value.
    487            * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure which will be 
    488            *         initialized.
    489            * @retval None
    490            */

   \                                 In section .text, align 2, keep-with-next
    491          void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
    492          {
    493            /* Initialize the RTC_HourFormat member */
    494            RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
   \                     RTC_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    495              
    496            /* Initialize the RTC_AsynchPrediv member */
    497            RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
   \   00000004   0x217F             MOVS     R1,#+127
   \   00000006   0x6041             STR      R1,[R0, #+4]
    498          
    499            /* Initialize the RTC_SynchPrediv member */
    500            RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
   \   00000008   0x21FF             MOVS     R1,#+255
   \   0000000A   0x6081             STR      R1,[R0, #+8]
    501          }
   \   0000000C   0x4770             BX       LR               ;; return
    502          
    503          /**
    504            * @brief  Enables or disables the RTC registers write protection.
    505            * @note   All the RTC registers are write protected except for RTC_ISR[13:8], 
    506            *         RTC_TAFCR and RTC_BKPxR.
    507            * @note   Writing a wrong key reactivates the write protection.
    508            * @note   The protection mechanism is not affected by system reset.  
    509            * @param  NewState: new state of the write protection.
    510            *          This parameter can be: ENABLE or DISABLE.
    511            * @retval None
    512            */

   \                                 In section .text, align 2, keep-with-next
    513          void RTC_WriteProtectionCmd(FunctionalState NewState)
    514          {
   \                     RTC_WriteProtectionCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    515            /* Check the parameters */
    516            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??RTC_WriteProtectionCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??RTC_WriteProtectionCmd_0
   \   00000010   0xF44F 0x7101      MOV      R1,#+516
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000018   0x.... 0x....      BL       assert_failed
    517              
    518            if (NewState != DISABLE)
   \                     ??RTC_WriteProtectionCmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD004             BEQ.N    ??RTC_WriteProtectionCmd_1
    519            {
    520              /* Enable the write protection for RTC registers */
    521              RTC->WPR = 0xFF;   
   \   00000022   0x20FF             MOVS     R0,#+255
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40002824
   \   00000028   0x6008             STR      R0,[R1, #+0]
   \   0000002A   0xE007             B.N      ??RTC_WriteProtectionCmd_2
    522            }
    523            else
    524            {
    525              /* Disable the write protection for RTC registers */
    526              RTC->WPR = 0xCA;
   \                     ??RTC_WriteProtectionCmd_1: (+1)
   \   0000002C   0x20CA             MOVS     R0,#+202
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40002824
   \   00000032   0x6008             STR      R0,[R1, #+0]
    527              RTC->WPR = 0x53;    
   \   00000034   0x2053             MOVS     R0,#+83
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40002824
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    528            }
    529          }
   \                     ??RTC_WriteProtectionCmd_2: (+1)
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
    530          
    531          /**
    532            * @brief  Enters the RTC Initialization mode.
    533            * @note   The RTC Initialization mode is write protected, use the 
    534            *         RTC_WriteProtectionCmd(DISABLE) before calling this function.    
    535            * @param  None
    536            * @retval An ErrorStatus enumeration value:
    537            *          - SUCCESS: RTC is in Init mode
    538            *          - ERROR: RTC is not in Init mode  
    539            */

   \                                 In section .text, align 2, keep-with-next
    540          ErrorStatus RTC_EnterInitMode(void)
    541          {
   \                     RTC_EnterInitMode: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    542            __IO uint32_t initcounter = 0x00;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9000             STR      R0,[SP, #+0]
    543            ErrorStatus status = ERROR;
   \   00000006   0x2000             MOVS     R0,#+0
    544            uint32_t initstatus = 0x00;
   \   00000008   0x2100             MOVS     R1,#+0
    545               
    546            /* Check if the Initialization mode is set */
    547            if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable18  ;; 0x4000280c
   \   0000000E   0x6812             LDR      R2,[R2, #+0]
   \   00000010   0x0652             LSLS     R2,R2,#+25
   \   00000012   0xD41E             BMI.N    ??RTC_EnterInitMode_0
    548            {
    549              /* Set the Initialization mode */
    550              RTC->ISR = (uint32_t)RTC_INIT_MASK;
   \   00000014   0xF05F 0x32FF      MOVS     R2,#-1
   \   00000018   0x.... 0x....      LDR.W    R3,??DataTable18  ;; 0x4000280c
   \   0000001C   0x601A             STR      R2,[R3, #+0]
    551              
    552              /* Wait till RTC is in INIT state and if Time out is reached exit */
    553              do
    554              {
    555                initstatus = RTC->ISR & RTC_ISR_INITF;
   \                     ??RTC_EnterInitMode_1: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R2,??DataTable18  ;; 0x4000280c
   \   00000022   0x6812             LDR      R2,[R2, #+0]
   \   00000024   0xF012 0x0240      ANDS     R2,R2,#0x40
   \   00000028   0x0011             MOVS     R1,R2
    556                initcounter++;  
   \   0000002A   0x9A00             LDR      R2,[SP, #+0]
   \   0000002C   0x1C52             ADDS     R2,R2,#+1
   \   0000002E   0x9200             STR      R2,[SP, #+0]
    557              } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
   \   00000030   0x9A00             LDR      R2,[SP, #+0]
   \   00000032   0xF5B2 0x3F80      CMP      R2,#+65536
   \   00000036   0xD001             BEQ.N    ??RTC_EnterInitMode_2
   \   00000038   0x2900             CMP      R1,#+0
   \   0000003A   0xD0F0             BEQ.N    ??RTC_EnterInitMode_1
    558              
    559              if ((RTC->ISR & RTC_ISR_INITF) != RESET)
   \                     ??RTC_EnterInitMode_2: (+1)
   \   0000003C   0x.... 0x....      LDR.W    R2,??DataTable18  ;; 0x4000280c
   \   00000040   0x6812             LDR      R2,[R2, #+0]
   \   00000042   0x0652             LSLS     R2,R2,#+25
   \   00000044   0xD502             BPL.N    ??RTC_EnterInitMode_3
    560              {
    561                status = SUCCESS;
   \   00000046   0x2201             MOVS     R2,#+1
   \   00000048   0x0010             MOVS     R0,R2
   \   0000004A   0xE004             B.N      ??RTC_EnterInitMode_4
    562              }
    563              else
    564              {
    565                status = ERROR;
   \                     ??RTC_EnterInitMode_3: (+1)
   \   0000004C   0x2200             MOVS     R2,#+0
   \   0000004E   0x0010             MOVS     R0,R2
   \   00000050   0xE001             B.N      ??RTC_EnterInitMode_4
    566              }        
    567            }
    568            else
    569            {
    570              status = SUCCESS;  
   \                     ??RTC_EnterInitMode_0: (+1)
   \   00000052   0x2201             MOVS     R2,#+1
   \   00000054   0x0010             MOVS     R0,R2
    571            } 
    572              
    573            return (status);  
   \                     ??RTC_EnterInitMode_4: (+1)
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000058   0xB001             ADD      SP,SP,#+4
   \   0000005A   0x4770             BX       LR               ;; return
    574          }
    575          
    576          /**
    577            * @brief  Exits the RTC Initialization mode.
    578            * @note   When the initialization sequence is complete, the calendar restarts 
    579            *         counting after 4 RTCCLK cycles.  
    580            * @note   The RTC Initialization mode is write protected, use the 
    581            *         RTC_WriteProtectionCmd(DISABLE) before calling this function.      
    582            * @param  None
    583            * @retval None
    584            */

   \                                 In section .text, align 2, keep-with-next
    585          void RTC_ExitInitMode(void)
    586          { 
    587            /* Exit Initialization mode */
    588            RTC->ISR &= (uint32_t)~RTC_ISR_INIT;  
   \                     RTC_ExitInitMode: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0x4000280c
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF030 0x0080      BICS     R0,R0,#0x80
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable21  ;; 0x4000280c
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    589          }
   \   00000010   0x4770             BX       LR               ;; return
    590          
    591          /**
    592            * @brief  Waits until the RTC Time and Date registers (RTC_TR and RTC_DR) are 
    593            *         synchronized with RTC APB clock.
    594            * @note   The RTC Resynchronization mode is write protected, use the 
    595            *         RTC_WriteProtectionCmd(DISABLE) before calling this function. 
    596            * @note   To read the calendar through the shadow registers after Calendar 
    597            *         initialization, calendar update or after wakeup from low power modes 
    598            *         the software must first clear the RSF flag. 
    599            *         The software must then wait until it is set again before reading 
    600            *         the calendar, which means that the calendar registers have been 
    601            *         correctly copied into the RTC_TR and RTC_DR shadow registers.   
    602            * @param  None
    603            * @retval An ErrorStatus enumeration value:
    604            *          - SUCCESS: RTC registers are synchronised
    605            *          - ERROR: RTC registers are not synchronised
    606            */

   \                                 In section .text, align 2, keep-with-next
    607          ErrorStatus RTC_WaitForSynchro(void)
    608          {
   \                     RTC_WaitForSynchro: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    609            __IO uint32_t synchrocounter = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9000             STR      R0,[SP, #+0]
    610            ErrorStatus status = ERROR;
   \   00000006   0x2000             MOVS     R0,#+0
    611            uint32_t synchrostatus = 0x00;
   \   00000008   0x2100             MOVS     R1,#+0
    612          
    613            /* Disable the write protection for RTC registers */
    614            RTC->WPR = 0xCA;
   \   0000000A   0x22CA             MOVS     R2,#+202
   \   0000000C   0x.... 0x....      LDR.W    R3,??DataTable17  ;; 0x40002824
   \   00000010   0x601A             STR      R2,[R3, #+0]
    615            RTC->WPR = 0x53;
   \   00000012   0x2253             MOVS     R2,#+83
   \   00000014   0x.... 0x....      LDR.W    R3,??DataTable17  ;; 0x40002824
   \   00000018   0x601A             STR      R2,[R3, #+0]
    616              
    617            /* Clear RSF flag */
    618            RTC->ISR &= (uint32_t)RTC_RSF_MASK;
   \   0000001A   0x.... 0x....      LDR.W    R2,??DataTable18  ;; 0x4000280c
   \   0000001E   0x6812             LDR      R2,[R2, #+0]
   \   00000020   0xF032 0x02A0      BICS     R2,R2,#0xA0
   \   00000024   0x.... 0x....      LDR.W    R3,??DataTable18  ;; 0x4000280c
   \   00000028   0x601A             STR      R2,[R3, #+0]
    619              
    620            /* Wait the registers to be synchronised */
    621            do
    622            {
    623              synchrostatus = RTC->ISR & RTC_ISR_RSF;
   \                     ??RTC_WaitForSynchro_0: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R2,??DataTable18  ;; 0x4000280c
   \   0000002E   0x6812             LDR      R2,[R2, #+0]
   \   00000030   0xF012 0x0220      ANDS     R2,R2,#0x20
   \   00000034   0x0011             MOVS     R1,R2
    624              synchrocounter++;  
   \   00000036   0x9A00             LDR      R2,[SP, #+0]
   \   00000038   0x1C52             ADDS     R2,R2,#+1
   \   0000003A   0x9200             STR      R2,[SP, #+0]
    625            } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
   \   0000003C   0x9A00             LDR      R2,[SP, #+0]
   \   0000003E   0xF5B2 0x3F00      CMP      R2,#+131072
   \   00000042   0xD001             BEQ.N    ??RTC_WaitForSynchro_1
   \   00000044   0x2900             CMP      R1,#+0
   \   00000046   0xD0F0             BEQ.N    ??RTC_WaitForSynchro_0
    626              
    627            if ((RTC->ISR & RTC_ISR_RSF) != RESET)
   \                     ??RTC_WaitForSynchro_1: (+1)
   \   00000048   0x.... 0x....      LDR.W    R2,??DataTable18  ;; 0x4000280c
   \   0000004C   0x6812             LDR      R2,[R2, #+0]
   \   0000004E   0x0692             LSLS     R2,R2,#+26
   \   00000050   0xD502             BPL.N    ??RTC_WaitForSynchro_2
    628            {
    629              status = SUCCESS;
   \   00000052   0x2201             MOVS     R2,#+1
   \   00000054   0x0010             MOVS     R0,R2
   \   00000056   0xE001             B.N      ??RTC_WaitForSynchro_3
    630            }
    631            else
    632            {
    633              status = ERROR;
   \                     ??RTC_WaitForSynchro_2: (+1)
   \   00000058   0x2200             MOVS     R2,#+0
   \   0000005A   0x0010             MOVS     R0,R2
    634            }        
    635          
    636            /* Enable the write protection for RTC registers */
    637            RTC->WPR = 0xFF; 
   \                     ??RTC_WaitForSynchro_3: (+1)
   \   0000005C   0x22FF             MOVS     R2,#+255
   \   0000005E   0x.... 0x....      LDR.W    R3,??DataTable17  ;; 0x40002824
   \   00000062   0x601A             STR      R2,[R3, #+0]
    638              
    639            return (status); 
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000066   0xB001             ADD      SP,SP,#+4
   \   00000068   0x4770             BX       LR               ;; return
    640          }
    641          
    642          /**
    643            * @brief  Enables or disables the RTC reference clock detection.
    644            * @param  NewState: new state of the RTC reference clock.
    645            *          This parameter can be: ENABLE or DISABLE.
    646            * @retval An ErrorStatus enumeration value:
    647            *          - SUCCESS: RTC reference clock detection is enabled
    648            *          - ERROR: RTC reference clock detection is disabled  
    649            */

   \                                 In section .text, align 2, keep-with-next
    650          ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
    651          { 
   \                     RTC_RefClockCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    652            ErrorStatus status = ERROR;
   \   00000004   0x2500             MOVS     R5,#+0
    653            
    654            /* Check the parameters */
    655            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD008             BEQ.N    ??RTC_RefClockCmd_0
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C01             CMP      R4,#+1
   \   00000010   0xD005             BEQ.N    ??RTC_RefClockCmd_0
   \   00000012   0xF240 0x218F      MOVW     R1,#+655
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000001A   0x.... 0x....      BL       assert_failed
    656            
    657            /* Disable the write protection for RTC registers */
    658            RTC->WPR = 0xCA;
   \                     ??RTC_RefClockCmd_0: (+1)
   \   0000001E   0x20CA             MOVS     R0,#+202
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable20  ;; 0x40002824
   \   00000024   0x6008             STR      R0,[R1, #+0]
    659            RTC->WPR = 0x53;
   \   00000026   0x2053             MOVS     R0,#+83
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable20  ;; 0x40002824
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    660              
    661            /* Set Initialization mode */
    662            if (RTC_EnterInitMode() == ERROR)
   \   0000002E   0x.... 0x....      BL       RTC_EnterInitMode
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD102             BNE.N    ??RTC_RefClockCmd_1
    663            {
    664              status = ERROR;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x0005             MOVS     R5,R0
   \   0000003A   0xE017             B.N      ??RTC_RefClockCmd_2
    665            } 
    666            else
    667            {  
    668              if (NewState != DISABLE)
   \                     ??RTC_RefClockCmd_1: (+1)
   \   0000003C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   0x2C00             CMP      R4,#+0
   \   00000040   0xD008             BEQ.N    ??RTC_RefClockCmd_3
    669              {
    670                /* Enable the RTC reference clock detection */
    671                RTC->CR |= RTC_CR_REFCKON;   
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x40002808
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable15_2  ;; 0x40002808
   \   00000050   0x6008             STR      R0,[R1, #+0]
   \   00000052   0xE007             B.N      ??RTC_RefClockCmd_4
    672              }
    673              else
    674              {
    675                /* Disable the RTC reference clock detection */
    676                RTC->CR &= ~RTC_CR_REFCKON;    
   \                     ??RTC_RefClockCmd_3: (+1)
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x40002808
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xF030 0x0010      BICS     R0,R0,#0x10
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable15_2  ;; 0x40002808
   \   00000062   0x6008             STR      R0,[R1, #+0]
    677              }
    678              /* Exit Initialization mode */
    679              RTC_ExitInitMode();
   \                     ??RTC_RefClockCmd_4: (+1)
   \   00000064   0x.... 0x....      BL       RTC_ExitInitMode
    680              
    681              status = SUCCESS;
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0x0005             MOVS     R5,R0
    682            }
    683            
    684            /* Enable the write protection for RTC registers */
    685            RTC->WPR = 0xFF;  
   \                     ??RTC_RefClockCmd_2: (+1)
   \   0000006C   0x20FF             MOVS     R0,#+255
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable20  ;; 0x40002824
   \   00000072   0x6008             STR      R0,[R1, #+0]
    686            
    687            return status; 
   \   00000074   0x0028             MOVS     R0,R5
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    688          }
    689          
    690          /**
    691            * @brief  Enables or Disables the Bypass Shadow feature.
    692            * @note   When the Bypass Shadow is enabled the calendar value are taken 
    693            *         directly from the Calendar counter.
    694            * @param  NewState: new state of the Bypass Shadow feature.
    695            *         This parameter can be: ENABLE or DISABLE.
    696            * @retval None
    697          */

   \                                 In section .text, align 2, keep-with-next
    698          void RTC_BypassShadowCmd(FunctionalState NewState)
    699          {
   \                     RTC_BypassShadowCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    700            /* Check the parameters */
    701            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??RTC_BypassShadowCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??RTC_BypassShadowCmd_0
   \   00000010   0xF240 0x21BD      MOVW     R1,#+701
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000018   0x.... 0x....      BL       assert_failed
    702          
    703            /* Disable the write protection for RTC registers */
    704            RTC->WPR = 0xCA;
   \                     ??RTC_BypassShadowCmd_0: (+1)
   \   0000001C   0x20CA             MOVS     R0,#+202
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable20  ;; 0x40002824
   \   00000022   0x6008             STR      R0,[R1, #+0]
    705            RTC->WPR = 0x53;
   \   00000024   0x2053             MOVS     R0,#+83
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable20  ;; 0x40002824
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    706            
    707            if (NewState != DISABLE)
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x2C00             CMP      R4,#+0
   \   00000030   0xD008             BEQ.N    ??RTC_BypassShadowCmd_1
    708            {
    709              /* Set the BYPSHAD bit */
    710              RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x40002808
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable15_2  ;; 0x40002808
   \   00000040   0x6008             STR      R0,[R1, #+0]
   \   00000042   0xE007             B.N      ??RTC_BypassShadowCmd_2
    711            }
    712            else
    713            {
    714              /* Reset the BYPSHAD bit */
    715              RTC->CR &= (uint8_t)~RTC_CR_BYPSHAD;
   \                     ??RTC_BypassShadowCmd_1: (+1)
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x40002808
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable15_2  ;; 0x40002808
   \   00000052   0x6008             STR      R0,[R1, #+0]
    716            }
    717          
    718            /* Enable the write protection for RTC registers */
    719            RTC->WPR = 0xFF;
   \                     ??RTC_BypassShadowCmd_2: (+1)
   \   00000054   0x20FF             MOVS     R0,#+255
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable20  ;; 0x40002824
   \   0000005A   0x6008             STR      R0,[R1, #+0]
    720          }
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
    721          
    722          /**
    723            * @}
    724            */
    725          
    726          /** @defgroup RTC_Group2 Time and Date configuration functions
    727           *  @brief   Time and Date configuration functions 
    728           *
    729          @verbatim   
    730           ===============================================================================
    731                             Time and Date configuration functions
    732           ===============================================================================  
    733          
    734            This section provide functions allowing to program and read the RTC Calendar
    735            (Time and Date).
    736          
    737          @endverbatim
    738            * @{
    739            */
    740          
    741          /**
    742            * @brief  Set the RTC current time.
    743            * @param  RTC_Format: specifies the format of the entered parameters.
    744            *          This parameter can be  one of the following values:
    745            *            @arg RTC_Format_BIN:  Binary data format 
    746            *            @arg RTC_Format_BCD:  BCD data format
    747            * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that contains 
    748            *                        the time configuration information for the RTC.     
    749            * @retval An ErrorStatus enumeration value:
    750            *          - SUCCESS: RTC Time register is configured
    751            *          - ERROR: RTC Time register is not configured
    752            */

   \                                 In section .text, align 2, keep-with-next
    753          ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
    754          {
   \                     RTC_SetTime: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    755            uint32_t tmpreg = 0;
   \   00000008   0x2600             MOVS     R6,#+0
    756            ErrorStatus status = ERROR;
   \   0000000A   0x2700             MOVS     R7,#+0
    757              
    758            /* Check the parameters */
    759            assert_param(IS_RTC_FORMAT(RTC_Format));
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD007             BEQ.N    ??RTC_SetTime_0
   \   00000010   0x2C01             CMP      R4,#+1
   \   00000012   0xD005             BEQ.N    ??RTC_SetTime_0
   \   00000014   0xF240 0x21F7      MOVW     R1,#+759
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000001C   0x.... 0x....      BL       assert_failed
    760            
    761            if (RTC_Format == RTC_Format_BIN)
   \                     ??RTC_SetTime_0: (+1)
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD13B             BNE.N    ??RTC_SetTime_1
    762            {
    763              if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x40002808
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x0640             LSLS     R0,R0,#+25
   \   0000002C   0xD518             BPL.N    ??RTC_SetTime_2
    764              {
    765                assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
   \   0000002E   0x7828             LDRB     R0,[R5, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD002             BEQ.N    ??RTC_SetTime_3
   \   00000034   0x7828             LDRB     R0,[R5, #+0]
   \   00000036   0x280D             CMP      R0,#+13
   \   00000038   0xDB05             BLT.N    ??RTC_SetTime_4
   \                     ??RTC_SetTime_3: (+1)
   \   0000003A   0xF240 0x21FD      MOVW     R1,#+765
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000042   0x.... 0x....      BL       assert_failed
    766                assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
   \                     ??RTC_SetTime_4: (+1)
   \   00000046   0x78E8             LDRB     R0,[R5, #+3]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD014             BEQ.N    ??RTC_SetTime_5
   \   0000004C   0x78E8             LDRB     R0,[R5, #+3]
   \   0000004E   0x2840             CMP      R0,#+64
   \   00000050   0xD011             BEQ.N    ??RTC_SetTime_5
   \   00000052   0xF240 0x21FE      MOVW     R1,#+766
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000005A   0x.... 0x....      BL       assert_failed
   \   0000005E   0xE00A             B.N      ??RTC_SetTime_5
    767              } 
    768              else
    769              {
    770                RTC_TimeStruct->RTC_H12 = 0x00;
   \                     ??RTC_SetTime_2: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x70E8             STRB     R0,[R5, #+3]
    771                assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
   \   00000064   0x7828             LDRB     R0,[R5, #+0]
   \   00000066   0x2818             CMP      R0,#+24
   \   00000068   0xDB05             BLT.N    ??RTC_SetTime_5
   \   0000006A   0xF240 0x3103      MOVW     R1,#+771
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000072   0x.... 0x....      BL       assert_failed
    772              }
    773              assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
   \                     ??RTC_SetTime_5: (+1)
   \   00000076   0x7868             LDRB     R0,[R5, #+1]
   \   00000078   0x283C             CMP      R0,#+60
   \   0000007A   0xDB05             BLT.N    ??RTC_SetTime_6
   \   0000007C   0xF240 0x3105      MOVW     R1,#+773
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000084   0x.... 0x....      BL       assert_failed
    774              assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
   \                     ??RTC_SetTime_6: (+1)
   \   00000088   0x78A8             LDRB     R0,[R5, #+2]
   \   0000008A   0x283C             CMP      R0,#+60
   \   0000008C   0xDB49             BLT.N    ??RTC_SetTime_7
   \   0000008E   0xF240 0x3106      MOVW     R1,#+774
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000096   0x.... 0x....      BL       assert_failed
   \   0000009A   0xE042             B.N      ??RTC_SetTime_7
    775            }
    776            else
    777            {
    778              if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
   \                     ??RTC_SetTime_1: (+1)
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x40002808
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x0640             LSLS     R0,R0,#+25
   \   000000A4   0xD51A             BPL.N    ??RTC_SetTime_8
    779              {
    780                tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
   \   000000A6   0x7828             LDRB     R0,[R5, #+0]
   \   000000A8   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   000000AC   0x0006             MOVS     R6,R0
    781                assert_param(IS_RTC_HOUR12(tmpreg));
   \   000000AE   0x2E00             CMP      R6,#+0
   \   000000B0   0xD001             BEQ.N    ??RTC_SetTime_9
   \   000000B2   0x2E0D             CMP      R6,#+13
   \   000000B4   0xD305             BCC.N    ??RTC_SetTime_10
   \                     ??RTC_SetTime_9: (+1)
   \   000000B6   0xF240 0x310D      MOVW     R1,#+781
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000000BE   0x.... 0x....      BL       assert_failed
    782                assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
   \                     ??RTC_SetTime_10: (+1)
   \   000000C2   0x78E8             LDRB     R0,[R5, #+3]
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD016             BEQ.N    ??RTC_SetTime_11
   \   000000C8   0x78E8             LDRB     R0,[R5, #+3]
   \   000000CA   0x2840             CMP      R0,#+64
   \   000000CC   0xD013             BEQ.N    ??RTC_SetTime_11
   \   000000CE   0xF240 0x310E      MOVW     R1,#+782
   \   000000D2   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000000D6   0x.... 0x....      BL       assert_failed
   \   000000DA   0xE00C             B.N      ??RTC_SetTime_11
    783              } 
    784              else
    785              {
    786                RTC_TimeStruct->RTC_H12 = 0x00;
   \                     ??RTC_SetTime_8: (+1)
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x70E8             STRB     R0,[R5, #+3]
    787                assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
   \   000000E0   0x7828             LDRB     R0,[R5, #+0]
   \   000000E2   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   000000E6   0x2818             CMP      R0,#+24
   \   000000E8   0xDB05             BLT.N    ??RTC_SetTime_11
   \   000000EA   0xF240 0x3113      MOVW     R1,#+787
   \   000000EE   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000000F2   0x.... 0x....      BL       assert_failed
    788              }
    789              assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
   \                     ??RTC_SetTime_11: (+1)
   \   000000F6   0x7868             LDRB     R0,[R5, #+1]
   \   000000F8   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   000000FC   0x283C             CMP      R0,#+60
   \   000000FE   0xDB05             BLT.N    ??RTC_SetTime_12
   \   00000100   0xF240 0x3115      MOVW     R1,#+789
   \   00000104   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000108   0x.... 0x....      BL       assert_failed
    790              assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
   \                     ??RTC_SetTime_12: (+1)
   \   0000010C   0x78A8             LDRB     R0,[R5, #+2]
   \   0000010E   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000112   0x283C             CMP      R0,#+60
   \   00000114   0xDB05             BLT.N    ??RTC_SetTime_7
   \   00000116   0xF240 0x3116      MOVW     R1,#+790
   \   0000011A   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000011E   0x.... 0x....      BL       assert_failed
    791            }
    792            
    793            /* Check the input parameters format */
    794            if (RTC_Format != RTC_Format_BIN)
   \                     ??RTC_SetTime_7: (+1)
   \   00000122   0x2C00             CMP      R4,#+0
   \   00000124   0xD00B             BEQ.N    ??RTC_SetTime_13
    795            {
    796              tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
    797                       ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
    798                       ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
    799                       ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
   \   00000126   0x7828             LDRB     R0,[R5, #+0]
   \   00000128   0x7869             LDRB     R1,[R5, #+1]
   \   0000012A   0x0209             LSLS     R1,R1,#+8
   \   0000012C   0xEA51 0x4000      ORRS     R0,R1,R0, LSL #+16
   \   00000130   0x78A9             LDRB     R1,[R5, #+2]
   \   00000132   0x4308             ORRS     R0,R1,R0
   \   00000134   0x78E9             LDRB     R1,[R5, #+3]
   \   00000136   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   0000013A   0x0006             MOVS     R6,R0
   \   0000013C   0xE018             B.N      ??RTC_SetTime_14
    800            }  
    801            else
    802            {
    803              tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
    804                             ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
    805                             ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
    806                             (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
   \                     ??RTC_SetTime_13: (+1)
   \   0000013E   0x7828             LDRB     R0,[R5, #+0]
   \   00000140   0x.... 0x....      BL       RTC_ByteToBcd2
   \   00000144   0x4680             MOV      R8,R0
   \   00000146   0x7868             LDRB     R0,[R5, #+1]
   \   00000148   0x.... 0x....      BL       RTC_ByteToBcd2
   \   0000014C   0x4681             MOV      R9,R0
   \   0000014E   0x78A8             LDRB     R0,[R5, #+2]
   \   00000150   0x.... 0x....      BL       RTC_ByteToBcd2
   \   00000154   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000158   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000015C   0xEA5F 0x2109      LSLS     R1,R9,#+8
   \   00000160   0xEA51 0x4108      ORRS     R1,R1,R8, LSL #+16
   \   00000164   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000166   0x4308             ORRS     R0,R0,R1
   \   00000168   0x78E9             LDRB     R1,[R5, #+3]
   \   0000016A   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   0000016E   0x0006             MOVS     R6,R0
    807            }  
    808          
    809            /* Disable the write protection for RTC registers */
    810            RTC->WPR = 0xCA;
   \                     ??RTC_SetTime_14: (+1)
   \   00000170   0x20CA             MOVS     R0,#+202
   \   00000172   0x.... 0x....      LDR.W    R1,??DataTable20  ;; 0x40002824
   \   00000176   0x6008             STR      R0,[R1, #+0]
    811            RTC->WPR = 0x53;
   \   00000178   0x2053             MOVS     R0,#+83
   \   0000017A   0x.... 0x....      LDR.W    R1,??DataTable20  ;; 0x40002824
   \   0000017E   0x6008             STR      R0,[R1, #+0]
    812          
    813            /* Set Initialization mode */
    814            if (RTC_EnterInitMode() == ERROR)
   \   00000180   0x.... 0x....      BL       RTC_EnterInitMode
   \   00000184   0x2800             CMP      R0,#+0
   \   00000186   0xD102             BNE.N    ??RTC_SetTime_15
    815            {
    816              status = ERROR;
   \   00000188   0x2000             MOVS     R0,#+0
   \   0000018A   0x0007             MOVS     R7,R0
   \   0000018C   0xE010             B.N      ??RTC_SetTime_16
    817            } 
    818            else
    819            {
    820              /* Set the RTC_TR register */
    821              RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
   \                     ??RTC_SetTime_15: (+1)
   \   0000018E   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0x7f7f7f
   \   00000192   0x4030             ANDS     R0,R0,R6
   \   00000194   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x40002800
   \   00000198   0x6008             STR      R0,[R1, #+0]
    822          
    823              /* Exit Initialization mode */
    824              RTC_ExitInitMode(); 
   \   0000019A   0x.... 0x....      BL       RTC_ExitInitMode
    825          
    826              if(RTC_WaitForSynchro() == ERROR)
   \   0000019E   0x.... 0x....      BL       RTC_WaitForSynchro
   \   000001A2   0x2800             CMP      R0,#+0
   \   000001A4   0xD102             BNE.N    ??RTC_SetTime_17
    827              {
    828                status = ERROR;
   \   000001A6   0x2000             MOVS     R0,#+0
   \   000001A8   0x0007             MOVS     R7,R0
   \   000001AA   0xE001             B.N      ??RTC_SetTime_16
    829              }
    830              else
    831              {
    832                status = SUCCESS;
   \                     ??RTC_SetTime_17: (+1)
   \   000001AC   0x2001             MOVS     R0,#+1
   \   000001AE   0x0007             MOVS     R7,R0
    833              }
    834            
    835            }
    836            /* Enable the write protection for RTC registers */
    837            RTC->WPR = 0xFF; 
   \                     ??RTC_SetTime_16: (+1)
   \   000001B0   0x20FF             MOVS     R0,#+255
   \   000001B2   0x.... 0x....      LDR.W    R1,??DataTable20  ;; 0x40002824
   \   000001B6   0x6008             STR      R0,[R1, #+0]
    838              
    839            return status;
   \   000001B8   0x0038             MOVS     R0,R7
   \   000001BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001BC   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    840          }
    841          
    842          /**
    843            * @brief  Fills each RTC_TimeStruct member with its default value
    844            *         (Time = 00h:00min:00sec).
    845            * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure which will be 
    846            *         initialized.
    847            * @retval None
    848            */

   \                                 In section .text, align 2, keep-with-next
    849          void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
    850          {
    851            /* Time = 00h:00min:00sec */
    852            RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
   \                     RTC_TimeStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x70C1             STRB     R1,[R0, #+3]
    853            RTC_TimeStruct->RTC_Hours = 0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7001             STRB     R1,[R0, #+0]
    854            RTC_TimeStruct->RTC_Minutes = 0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7041             STRB     R1,[R0, #+1]
    855            RTC_TimeStruct->RTC_Seconds = 0; 
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x7081             STRB     R1,[R0, #+2]
    856          }
   \   00000010   0x4770             BX       LR               ;; return
    857          
    858          /**
    859            * @brief  Get the RTC current Time.
    860            * @param  RTC_Format: specifies the format of the returned parameters.
    861            *          This parameter can be  one of the following values:
    862            *            @arg RTC_Format_BIN:  Binary data format 
    863            *            @arg RTC_Format_BCD:  BCD data format
    864            * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that will 
    865            *                        contain the returned current time configuration.     
    866            * @retval None
    867            */

   \                                 In section .text, align 2, keep-with-next
    868          void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
    869          {
   \                     RTC_GetTime: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    870            uint32_t tmpreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    871          
    872            /* Check the parameters */
    873            assert_param(IS_RTC_FORMAT(RTC_Format));
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD007             BEQ.N    ??RTC_GetTime_0
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??RTC_GetTime_0
   \   00000010   0xF240 0x3169      MOVW     R1,#+873
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000018   0x.... 0x....      BL       assert_failed
    874          
    875            /* Get the RTC_TR register */
    876            tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
   \                     ??RTC_GetTime_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40002800
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable28  ;; 0x7f7f7f
   \   00000026   0x4008             ANDS     R0,R1,R0
   \   00000028   0x0006             MOVS     R6,R0
    877            
    878            /* Fill the structure fields with the read parameters */
    879            RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
   \   0000002A   0x0C30             LSRS     R0,R6,#+16
   \   0000002C   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   00000030   0x7028             STRB     R0,[R5, #+0]
    880            RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
   \   00000032   0x0A30             LSRS     R0,R6,#+8
   \   00000034   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000038   0x7068             STRB     R0,[R5, #+1]
    881            RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
   \   0000003A   0xF016 0x007F      ANDS     R0,R6,#0x7F
   \   0000003E   0x70A8             STRB     R0,[R5, #+2]
    882            RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
   \   00000040   0x0C30             LSRS     R0,R6,#+16
   \   00000042   0xF010 0x0040      ANDS     R0,R0,#0x40
   \   00000046   0x70E8             STRB     R0,[R5, #+3]
    883          
    884            /* Check the input parameters format */
    885            if (RTC_Format == RTC_Format_BIN)
   \   00000048   0x2C00             CMP      R4,#+0
   \   0000004A   0xD10B             BNE.N    ??RTC_GetTime_1
    886            {
    887              /* Convert the structure parameters to Binary format */
    888              RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
   \   0000004C   0x7828             LDRB     R0,[R5, #+0]
   \   0000004E   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000052   0x7028             STRB     R0,[R5, #+0]
    889              RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
   \   00000054   0x7868             LDRB     R0,[R5, #+1]
   \   00000056   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   0000005A   0x7068             STRB     R0,[R5, #+1]
    890              RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);   
   \   0000005C   0x78A8             LDRB     R0,[R5, #+2]
   \   0000005E   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000062   0x70A8             STRB     R0,[R5, #+2]
    891            }
    892          }
   \                     ??RTC_GetTime_1: (+1)
   \   00000064   0xBD70             POP      {R4-R6,PC}       ;; return
    893          
    894          /**
    895            * @brief  Gets the RTC current Calendar Subseconds value.
    896            * @note   This function freeze the Time and Date registers after reading the 
    897            *         SSR register.
    898            * @param  None
    899            * @retval RTC current Calendar Subseconds value.
    900            */

   \                                 In section .text, align 2, keep-with-next
    901          uint32_t RTC_GetSubSecond(void)
    902          {
    903            uint32_t tmpreg = 0;
   \                     RTC_GetSubSecond: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
    904            
    905            /* Get subseconds values from the correspondent registers*/
    906            tmpreg = (uint32_t)(RTC->SSR);
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable29  ;; 0x40002828
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x0008             MOVS     R0,R1
    907            
    908            /* Read DR register to unfroze calendar registers */
    909            (void) (RTC->DR);
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable15_1  ;; 0x40002804
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
    910            
    911            return (tmpreg);
   \   00000010   0x4770             BX       LR               ;; return
    912          }
    913          
    914          /**
    915            * @brief  Set the RTC current date.
    916            * @param  RTC_Format: specifies the format of the entered parameters.
    917            *          This parameter can be  one of the following values:
    918            *            @arg RTC_Format_BIN:  Binary data format 
    919            *            @arg RTC_Format_BCD:  BCD data format
    920            * @param  RTC_DateStruct: pointer to a RTC_DateTypeDef structure that contains 
    921            *                         the date configuration information for the RTC.
    922            * @retval An ErrorStatus enumeration value:
    923            *          - SUCCESS: RTC Date register is configured
    924            *          - ERROR: RTC Date register is not configured
    925            */

   \                                 In section .text, align 2, keep-with-next
    926          ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
    927          {
   \                     RTC_SetDate: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    928            uint32_t tmpreg = 0;
   \   00000008   0x2600             MOVS     R6,#+0
    929            ErrorStatus status = ERROR;
   \   0000000A   0x2700             MOVS     R7,#+0
    930            
    931            /* Check the parameters */
    932            assert_param(IS_RTC_FORMAT(RTC_Format));
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD007             BEQ.N    ??RTC_SetDate_0
   \   00000010   0x2C01             CMP      R4,#+1
   \   00000012   0xD005             BEQ.N    ??RTC_SetDate_0
   \   00000014   0xF44F 0x7169      MOV      R1,#+932
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000001C   0x.... 0x....      BL       assert_failed
    933          
    934            if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
   \                     ??RTC_SetDate_0: (+1)
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD107             BNE.N    ??RTC_SetDate_1
   \   00000024   0x7868             LDRB     R0,[R5, #+1]
   \   00000026   0x06C0             LSLS     R0,R0,#+27
   \   00000028   0xD504             BPL.N    ??RTC_SetDate_1
    935            {
    936              RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
   \   0000002A   0x7868             LDRB     R0,[R5, #+1]
   \   0000002C   0xF010 0x00EF      ANDS     R0,R0,#0xEF
   \   00000030   0x300A             ADDS     R0,R0,#+10
   \   00000032   0x7068             STRB     R0,[R5, #+1]
    937            }  
    938            if (RTC_Format == RTC_Format_BIN)
   \                     ??RTC_SetDate_1: (+1)
   \   00000034   0x2C00             CMP      R4,#+0
   \   00000036   0xD121             BNE.N    ??RTC_SetDate_2
    939            {
    940              assert_param(IS_RTC_YEAR(RTC_DateStruct->RTC_Year));
   \   00000038   0x78E8             LDRB     R0,[R5, #+3]
   \   0000003A   0x2864             CMP      R0,#+100
   \   0000003C   0xDB05             BLT.N    ??RTC_SetDate_3
   \   0000003E   0xF44F 0x716B      MOV      R1,#+940
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000046   0x.... 0x....      BL       assert_failed
    941              assert_param(IS_RTC_MONTH(RTC_DateStruct->RTC_Month));
   \                     ??RTC_SetDate_3: (+1)
   \   0000004A   0x7868             LDRB     R0,[R5, #+1]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD002             BEQ.N    ??RTC_SetDate_4
   \   00000050   0x7868             LDRB     R0,[R5, #+1]
   \   00000052   0x280D             CMP      R0,#+13
   \   00000054   0xDB05             BLT.N    ??RTC_SetDate_5
   \                     ??RTC_SetDate_4: (+1)
   \   00000056   0xF240 0x31AD      MOVW     R1,#+941
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000005E   0x.... 0x....      BL       assert_failed
    942              assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
   \                     ??RTC_SetDate_5: (+1)
   \   00000062   0x78A8             LDRB     R0,[R5, #+2]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD002             BEQ.N    ??RTC_SetDate_6
   \   00000068   0x78A8             LDRB     R0,[R5, #+2]
   \   0000006A   0x2820             CMP      R0,#+32
   \   0000006C   0xDB2D             BLT.N    ??RTC_SetDate_7
   \                     ??RTC_SetDate_6: (+1)
   \   0000006E   0xF240 0x31AE      MOVW     R1,#+942
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000076   0x.... 0x....      BL       assert_failed
   \   0000007A   0xE026             B.N      ??RTC_SetDate_7
    943            }
    944            else
    945            {
    946              assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
   \                     ??RTC_SetDate_2: (+1)
   \   0000007C   0x78E8             LDRB     R0,[R5, #+3]
   \   0000007E   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000082   0x2864             CMP      R0,#+100
   \   00000084   0xDB05             BLT.N    ??RTC_SetDate_8
   \   00000086   0xF240 0x31B2      MOVW     R1,#+946
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000008E   0x.... 0x....      BL       assert_failed
    947              tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
   \                     ??RTC_SetDate_8: (+1)
   \   00000092   0x7868             LDRB     R0,[R5, #+1]
   \   00000094   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000098   0x0006             MOVS     R6,R0
    948              assert_param(IS_RTC_MONTH(tmpreg));
   \   0000009A   0x2E00             CMP      R6,#+0
   \   0000009C   0xD001             BEQ.N    ??RTC_SetDate_9
   \   0000009E   0x2E0D             CMP      R6,#+13
   \   000000A0   0xD305             BCC.N    ??RTC_SetDate_10
   \                     ??RTC_SetDate_9: (+1)
   \   000000A2   0xF44F 0x716D      MOV      R1,#+948
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000000AA   0x.... 0x....      BL       assert_failed
    949              tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
   \                     ??RTC_SetDate_10: (+1)
   \   000000AE   0x78A8             LDRB     R0,[R5, #+2]
   \   000000B0   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   000000B4   0x0006             MOVS     R6,R0
    950              assert_param(IS_RTC_DATE(tmpreg));
   \   000000B6   0x2E00             CMP      R6,#+0
   \   000000B8   0xD001             BEQ.N    ??RTC_SetDate_11
   \   000000BA   0x2E20             CMP      R6,#+32
   \   000000BC   0xD305             BCC.N    ??RTC_SetDate_7
   \                     ??RTC_SetDate_11: (+1)
   \   000000BE   0xF240 0x31B6      MOVW     R1,#+950
   \   000000C2   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000000C6   0x.... 0x....      BL       assert_failed
    951            }
    952            assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));
   \                     ??RTC_SetDate_7: (+1)
   \   000000CA   0x7828             LDRB     R0,[R5, #+0]
   \   000000CC   0x2801             CMP      R0,#+1
   \   000000CE   0xD017             BEQ.N    ??RTC_SetDate_12
   \   000000D0   0x7828             LDRB     R0,[R5, #+0]
   \   000000D2   0x2802             CMP      R0,#+2
   \   000000D4   0xD014             BEQ.N    ??RTC_SetDate_12
   \   000000D6   0x7828             LDRB     R0,[R5, #+0]
   \   000000D8   0x2803             CMP      R0,#+3
   \   000000DA   0xD011             BEQ.N    ??RTC_SetDate_12
   \   000000DC   0x7828             LDRB     R0,[R5, #+0]
   \   000000DE   0x2804             CMP      R0,#+4
   \   000000E0   0xD00E             BEQ.N    ??RTC_SetDate_12
   \   000000E2   0x7828             LDRB     R0,[R5, #+0]
   \   000000E4   0x2805             CMP      R0,#+5
   \   000000E6   0xD00B             BEQ.N    ??RTC_SetDate_12
   \   000000E8   0x7828             LDRB     R0,[R5, #+0]
   \   000000EA   0x2806             CMP      R0,#+6
   \   000000EC   0xD008             BEQ.N    ??RTC_SetDate_12
   \   000000EE   0x7828             LDRB     R0,[R5, #+0]
   \   000000F0   0x2807             CMP      R0,#+7
   \   000000F2   0xD005             BEQ.N    ??RTC_SetDate_12
   \   000000F4   0xF44F 0x716E      MOV      R1,#+952
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000000FC   0x.... 0x....      BL       assert_failed
    953          
    954            /* Check the input parameters format */
    955            if (RTC_Format != RTC_Format_BIN)
   \                     ??RTC_SetDate_12: (+1)
   \   00000100   0x2C00             CMP      R4,#+0
   \   00000102   0xD00B             BEQ.N    ??RTC_SetDate_13
    956            {
    957              tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
    958                        (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
    959                        ((uint32_t)RTC_DateStruct->RTC_Date) | \
    960                        (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
   \   00000104   0x78E8             LDRB     R0,[R5, #+3]
   \   00000106   0x7869             LDRB     R1,[R5, #+1]
   \   00000108   0x0209             LSLS     R1,R1,#+8
   \   0000010A   0xEA51 0x4000      ORRS     R0,R1,R0, LSL #+16
   \   0000010E   0x78A9             LDRB     R1,[R5, #+2]
   \   00000110   0x4308             ORRS     R0,R1,R0
   \   00000112   0x7829             LDRB     R1,[R5, #+0]
   \   00000114   0xEA50 0x3041      ORRS     R0,R0,R1, LSL #+13
   \   00000118   0x0006             MOVS     R6,R0
   \   0000011A   0xE018             B.N      ??RTC_SetDate_14
    961            }  
    962            else
    963            {
    964              tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
    965                        ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
    966                        ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
    967                        ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
   \                     ??RTC_SetDate_13: (+1)
   \   0000011C   0x78E8             LDRB     R0,[R5, #+3]
   \   0000011E   0x.... 0x....      BL       RTC_ByteToBcd2
   \   00000122   0x4680             MOV      R8,R0
   \   00000124   0x7868             LDRB     R0,[R5, #+1]
   \   00000126   0x.... 0x....      BL       RTC_ByteToBcd2
   \   0000012A   0x4681             MOV      R9,R0
   \   0000012C   0x78A8             LDRB     R0,[R5, #+2]
   \   0000012E   0x.... 0x....      BL       RTC_ByteToBcd2
   \   00000132   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000136   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000013A   0xEA5F 0x2109      LSLS     R1,R9,#+8
   \   0000013E   0xEA51 0x4108      ORRS     R1,R1,R8, LSL #+16
   \   00000142   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000144   0x4308             ORRS     R0,R0,R1
   \   00000146   0x7829             LDRB     R1,[R5, #+0]
   \   00000148   0xEA50 0x3041      ORRS     R0,R0,R1, LSL #+13
   \   0000014C   0x0006             MOVS     R6,R0
    968            }
    969          
    970            /* Disable the write protection for RTC registers */
    971            RTC->WPR = 0xCA;
   \                     ??RTC_SetDate_14: (+1)
   \   0000014E   0x20CA             MOVS     R0,#+202
   \   00000150   0x.... 0x....      LDR.W    R1,??DataTable20  ;; 0x40002824
   \   00000154   0x6008             STR      R0,[R1, #+0]
    972            RTC->WPR = 0x53;
   \   00000156   0x2053             MOVS     R0,#+83
   \   00000158   0x.... 0x....      LDR.W    R1,??DataTable20  ;; 0x40002824
   \   0000015C   0x6008             STR      R0,[R1, #+0]
    973          
    974            /* Set Initialization mode */
    975            if (RTC_EnterInitMode() == ERROR)
   \   0000015E   0x.... 0x....      BL       RTC_EnterInitMode
   \   00000162   0x2800             CMP      R0,#+0
   \   00000164   0xD102             BNE.N    ??RTC_SetDate_15
    976            {
    977              status = ERROR;
   \   00000166   0x2000             MOVS     R0,#+0
   \   00000168   0x0007             MOVS     R7,R0
   \   0000016A   0xE010             B.N      ??RTC_SetDate_16
    978            } 
    979            else
    980            {
    981              /* Set the RTC_DR register */
    982              RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
   \                     ??RTC_SetDate_15: (+1)
   \   0000016C   0x.... 0x....      LDR.W    R0,??DataTable32  ;; 0xffff3f
   \   00000170   0x4030             ANDS     R0,R0,R6
   \   00000172   0x.... 0x....      LDR.W    R1,??DataTable15_1  ;; 0x40002804
   \   00000176   0x6008             STR      R0,[R1, #+0]
    983          
    984              /* Exit Initialization mode */
    985              RTC_ExitInitMode(); 
   \   00000178   0x.... 0x....      BL       RTC_ExitInitMode
    986          
    987              if(RTC_WaitForSynchro() == ERROR)
   \   0000017C   0x.... 0x....      BL       RTC_WaitForSynchro
   \   00000180   0x2800             CMP      R0,#+0
   \   00000182   0xD102             BNE.N    ??RTC_SetDate_17
    988              {
    989                status = ERROR;
   \   00000184   0x2000             MOVS     R0,#+0
   \   00000186   0x0007             MOVS     R7,R0
   \   00000188   0xE001             B.N      ??RTC_SetDate_16
    990              }
    991              else
    992              {
    993                status = SUCCESS;
   \                     ??RTC_SetDate_17: (+1)
   \   0000018A   0x2001             MOVS     R0,#+1
   \   0000018C   0x0007             MOVS     R7,R0
    994              }
    995            }
    996            /* Enable the write protection for RTC registers */
    997            RTC->WPR = 0xFF;   
   \                     ??RTC_SetDate_16: (+1)
   \   0000018E   0x20FF             MOVS     R0,#+255
   \   00000190   0x.... 0x....      LDR.W    R1,??DataTable20  ;; 0x40002824
   \   00000194   0x6008             STR      R0,[R1, #+0]
    998            
    999            return status;
   \   00000196   0x0038             MOVS     R0,R7
   \   00000198   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000019A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1000          }
   1001          
   1002          /**
   1003            * @brief  Fills each RTC_DateStruct member with its default value
   1004            *         (Monday, January 01 xx00).
   1005            * @param  RTC_DateStruct: pointer to a RTC_DateTypeDef structure which will be 
   1006            *         initialized.
   1007            * @retval None
   1008            */

   \                                 In section .text, align 2, keep-with-next
   1009          void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
   1010          {
   1011            /* Monday, January 01 xx00 */
   1012            RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
   \                     RTC_DateStructInit: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x7001             STRB     R1,[R0, #+0]
   1013            RTC_DateStruct->RTC_Date = 1;
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x7081             STRB     R1,[R0, #+2]
   1014            RTC_DateStruct->RTC_Month = RTC_Month_January;
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x7041             STRB     R1,[R0, #+1]
   1015            RTC_DateStruct->RTC_Year = 0;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x70C1             STRB     R1,[R0, #+3]
   1016          }
   \   00000010   0x4770             BX       LR               ;; return
   1017          
   1018          /**
   1019            * @brief  Get the RTC current date. 
   1020            * @param  RTC_Format: specifies the format of the returned parameters.
   1021            *          This parameter can be one of the following values:
   1022            *            @arg RTC_Format_BIN: Binary data format 
   1023            *            @arg RTC_Format_BCD: BCD data format
   1024            * @param RTC_DateStruct: pointer to a RTC_DateTypeDef structure that will 
   1025            *                        contain the returned current date configuration.     
   1026            * @retval None
   1027            */

   \                                 In section .text, align 2, keep-with-next
   1028          void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
   1029          {
   \                     RTC_GetDate: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1030            uint32_t tmpreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1031          
   1032            /* Check the parameters */
   1033            assert_param(IS_RTC_FORMAT(RTC_Format));
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD007             BEQ.N    ??RTC_GetDate_0
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??RTC_GetDate_0
   \   00000010   0xF240 0x4109      MOVW     R1,#+1033
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000018   0x.... 0x....      BL       assert_failed
   1034            
   1035            /* Get the RTC_TR register */
   1036            tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
   \                     ??RTC_GetDate_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0x40002804
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable32  ;; 0xffff3f
   \   00000026   0x4008             ANDS     R0,R1,R0
   \   00000028   0x0006             MOVS     R6,R0
   1037          
   1038            /* Fill the structure fields with the read parameters */
   1039            RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
   \   0000002A   0x0C30             LSRS     R0,R6,#+16
   \   0000002C   0x70E8             STRB     R0,[R5, #+3]
   1040            RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
   \   0000002E   0x0A30             LSRS     R0,R6,#+8
   \   00000030   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   00000034   0x7068             STRB     R0,[R5, #+1]
   1041            RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
   \   00000036   0xF016 0x003F      ANDS     R0,R6,#0x3F
   \   0000003A   0x70A8             STRB     R0,[R5, #+2]
   1042            RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);
   \   0000003C   0x0B70             LSRS     R0,R6,#+13
   \   0000003E   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000042   0x7028             STRB     R0,[R5, #+0]
   1043          
   1044            /* Check the input parameters format */
   1045            if (RTC_Format == RTC_Format_BIN)
   \   00000044   0x2C00             CMP      R4,#+0
   \   00000046   0xD10B             BNE.N    ??RTC_GetDate_1
   1046            {
   1047              /* Convert the structure parameters to Binary format */
   1048              RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
   \   00000048   0x78E8             LDRB     R0,[R5, #+3]
   \   0000004A   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   0000004E   0x70E8             STRB     R0,[R5, #+3]
   1049              RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
   \   00000050   0x7868             LDRB     R0,[R5, #+1]
   \   00000052   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000056   0x7068             STRB     R0,[R5, #+1]
   1050              RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
   \   00000058   0x78A8             LDRB     R0,[R5, #+2]
   \   0000005A   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   0000005E   0x70A8             STRB     R0,[R5, #+2]
   1051            }
   1052          }
   \                     ??RTC_GetDate_1: (+1)
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
   1053          
   1054          /**
   1055            * @}
   1056            */
   1057          
   1058          /** @defgroup RTC_Group3 Alarms configuration functions
   1059           *  @brief   Alarms (Alarm A and Alarm B) configuration functions 
   1060           *
   1061          @verbatim   
   1062           ===============================================================================
   1063                        Alarms (Alarm A and Alarm B) configuration functions
   1064           ===============================================================================  
   1065          
   1066            This section provide functions allowing to program and read the RTC Alarms.
   1067          
   1068          @endverbatim
   1069            * @{
   1070            */
   1071          
   1072          /**
   1073            * @brief  Set the specified RTC Alarm.
   1074            * @note   The Alarm register can only be written when the corresponding Alarm
   1075            *         is disabled (Use the RTC_AlarmCmd(DISABLE)).    
   1076            * @param  RTC_Format: specifies the format of the returned parameters.
   1077            *          This parameter can be one of the following values:
   1078            *            @arg RTC_Format_BIN: Binary data format 
   1079            *            @arg RTC_Format_BCD: BCD data format
   1080            * @param  RTC_Alarm: specifies the alarm to be configured.
   1081            *          This parameter can be one of the following values:
   1082            *            @arg RTC_Alarm_A: to select Alarm A
   1083            *            @arg RTC_Alarm_B: to select Alarm B  
   1084            * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that 
   1085            *                          contains the alarm configuration parameters.     
   1086            * @retval None
   1087            */

   \                                 In section .text, align 2, keep-with-next
   1088          void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
   1089          {
   \                     RTC_SetAlarm: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1090            uint32_t tmpreg = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   1091            
   1092            /* Check the parameters */
   1093            assert_param(IS_RTC_FORMAT(RTC_Format));
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD007             BEQ.N    ??RTC_SetAlarm_0
   \   00000010   0x2C01             CMP      R4,#+1
   \   00000012   0xD005             BEQ.N    ??RTC_SetAlarm_0
   \   00000014   0xF240 0x4145      MOVW     R1,#+1093
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000001C   0x.... 0x....      BL       assert_failed
   1094            assert_param(IS_RTC_ALARM(RTC_Alarm));
   \                     ??RTC_SetAlarm_0: (+1)
   \   00000020   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000024   0xD008             BEQ.N    ??RTC_SetAlarm_1
   \   00000026   0xF5B5 0x7F00      CMP      R5,#+512
   \   0000002A   0xD005             BEQ.N    ??RTC_SetAlarm_1
   \   0000002C   0xF240 0x4146      MOVW     R1,#+1094
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000034   0x.... 0x....      BL       assert_failed
   1095            assert_param(IS_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
   \                     ??RTC_SetAlarm_1: (+1)
   \   00000038   0x6870             LDR      R0,[R6, #+4]
   \   0000003A   0xF010 0x3F7F      TST      R0,#0x7F7F7F7F
   \   0000003E   0xD005             BEQ.N    ??RTC_SetAlarm_2
   \   00000040   0xF240 0x4147      MOVW     R1,#+1095
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000048   0x.... 0x....      BL       assert_failed
   1096            assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));
   \                     ??RTC_SetAlarm_2: (+1)
   \   0000004C   0x68B0             LDR      R0,[R6, #+8]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD009             BEQ.N    ??RTC_SetAlarm_3
   \   00000052   0x68B0             LDR      R0,[R6, #+8]
   \   00000054   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \   00000058   0xD005             BEQ.N    ??RTC_SetAlarm_3
   \   0000005A   0xF44F 0x6189      MOV      R1,#+1096
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000062   0x.... 0x....      BL       assert_failed
   1097          
   1098            if (RTC_Format == RTC_Format_BIN)
   \                     ??RTC_SetAlarm_3: (+1)
   \   00000066   0x2C00             CMP      R4,#+0
   \   00000068   0xD169             BNE.N    ??RTC_SetAlarm_4
   1099            {
   1100              if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x40002808
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0x0640             LSLS     R0,R0,#+25
   \   00000072   0xD518             BPL.N    ??RTC_SetAlarm_5
   1101              {
   1102                assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
   \   00000074   0x7830             LDRB     R0,[R6, #+0]
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD002             BEQ.N    ??RTC_SetAlarm_6
   \   0000007A   0x7830             LDRB     R0,[R6, #+0]
   \   0000007C   0x280D             CMP      R0,#+13
   \   0000007E   0xDB05             BLT.N    ??RTC_SetAlarm_7
   \                     ??RTC_SetAlarm_6: (+1)
   \   00000080   0xF240 0x414E      MOVW     R1,#+1102
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000088   0x.... 0x....      BL       assert_failed
   1103                assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
   \                     ??RTC_SetAlarm_7: (+1)
   \   0000008C   0x78F0             LDRB     R0,[R6, #+3]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD014             BEQ.N    ??RTC_SetAlarm_8
   \   00000092   0x78F0             LDRB     R0,[R6, #+3]
   \   00000094   0x2840             CMP      R0,#+64
   \   00000096   0xD011             BEQ.N    ??RTC_SetAlarm_8
   \   00000098   0xF240 0x414F      MOVW     R1,#+1103
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000000A0   0x.... 0x....      BL       assert_failed
   \   000000A4   0xE00A             B.N      ??RTC_SetAlarm_8
   1104              } 
   1105              else
   1106              {
   1107                RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
   \                     ??RTC_SetAlarm_5: (+1)
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x70F0             STRB     R0,[R6, #+3]
   1108                assert_param(IS_RTC_HOUR24(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
   \   000000AA   0x7830             LDRB     R0,[R6, #+0]
   \   000000AC   0x2818             CMP      R0,#+24
   \   000000AE   0xDB05             BLT.N    ??RTC_SetAlarm_8
   \   000000B0   0xF240 0x4154      MOVW     R1,#+1108
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000000B8   0x.... 0x....      BL       assert_failed
   1109              }
   1110              assert_param(IS_RTC_MINUTES(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes));
   \                     ??RTC_SetAlarm_8: (+1)
   \   000000BC   0x7870             LDRB     R0,[R6, #+1]
   \   000000BE   0x283C             CMP      R0,#+60
   \   000000C0   0xDB05             BLT.N    ??RTC_SetAlarm_9
   \   000000C2   0xF240 0x4156      MOVW     R1,#+1110
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000000CA   0x.... 0x....      BL       assert_failed
   1111              assert_param(IS_RTC_SECONDS(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds));
   \                     ??RTC_SetAlarm_9: (+1)
   \   000000CE   0x78B0             LDRB     R0,[R6, #+2]
   \   000000D0   0x283C             CMP      R0,#+60
   \   000000D2   0xDB05             BLT.N    ??RTC_SetAlarm_10
   \   000000D4   0xF240 0x4157      MOVW     R1,#+1111
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000000DC   0x.... 0x....      BL       assert_failed
   1112              
   1113              if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
   \                     ??RTC_SetAlarm_10: (+1)
   \   000000E0   0x68B0             LDR      R0,[R6, #+8]
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD10D             BNE.N    ??RTC_SetAlarm_11
   1114              {
   1115                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
   \   000000E6   0x7B30             LDRB     R0,[R6, #+12]
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD003             BEQ.N    ??RTC_SetAlarm_12
   \   000000EC   0x7B30             LDRB     R0,[R6, #+12]
   \   000000EE   0x2820             CMP      R0,#+32
   \   000000F0   0xF2C0 0x808F      BLT.W    ??RTC_SetAlarm_13
   \                     ??RTC_SetAlarm_12: (+1)
   \   000000F4   0xF240 0x415B      MOVW     R1,#+1115
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000000FC   0x.... 0x....      BL       assert_failed
   \   00000100   0xE087             B.N      ??RTC_SetAlarm_13
   1116              }
   1117              else
   1118              {
   1119                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
   \                     ??RTC_SetAlarm_11: (+1)
   \   00000102   0x7B30             LDRB     R0,[R6, #+12]
   \   00000104   0x2801             CMP      R0,#+1
   \   00000106   0xF000 0x8084      BEQ.W    ??RTC_SetAlarm_13
   \   0000010A   0x7B30             LDRB     R0,[R6, #+12]
   \   0000010C   0x2802             CMP      R0,#+2
   \   0000010E   0xF000 0x8080      BEQ.W    ??RTC_SetAlarm_13
   \   00000112   0x7B30             LDRB     R0,[R6, #+12]
   \   00000114   0x2803             CMP      R0,#+3
   \   00000116   0xD07C             BEQ.N    ??RTC_SetAlarm_13
   \   00000118   0x7B30             LDRB     R0,[R6, #+12]
   \   0000011A   0x2804             CMP      R0,#+4
   \   0000011C   0xD079             BEQ.N    ??RTC_SetAlarm_13
   \   0000011E   0x7B30             LDRB     R0,[R6, #+12]
   \   00000120   0x2805             CMP      R0,#+5
   \   00000122   0xD076             BEQ.N    ??RTC_SetAlarm_13
   \   00000124   0x7B30             LDRB     R0,[R6, #+12]
   \   00000126   0x2806             CMP      R0,#+6
   \   00000128   0xD073             BEQ.N    ??RTC_SetAlarm_13
   \   0000012A   0x7B30             LDRB     R0,[R6, #+12]
   \   0000012C   0x2807             CMP      R0,#+7
   \   0000012E   0xD070             BEQ.N    ??RTC_SetAlarm_13
   \   00000130   0xF240 0x415F      MOVW     R1,#+1119
   \   00000134   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000138   0x.... 0x....      BL       assert_failed
   \   0000013C   0xE069             B.N      ??RTC_SetAlarm_13
   1120              }
   1121            }
   1122            else
   1123            {
   1124              if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
   \                     ??RTC_SetAlarm_4: (+1)
   \   0000013E   0x....             LDR.N    R0,??DataTable15_2  ;; 0x40002808
   \   00000140   0x6800             LDR      R0,[R0, #+0]
   \   00000142   0x0640             LSLS     R0,R0,#+25
   \   00000144   0xD51A             BPL.N    ??RTC_SetAlarm_14
   1125              {
   1126                tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
   \   00000146   0x7830             LDRB     R0,[R6, #+0]
   \   00000148   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   0000014C   0x0007             MOVS     R7,R0
   1127                assert_param(IS_RTC_HOUR12(tmpreg));
   \   0000014E   0x2F00             CMP      R7,#+0
   \   00000150   0xD001             BEQ.N    ??RTC_SetAlarm_15
   \   00000152   0x2F0D             CMP      R7,#+13
   \   00000154   0xD305             BCC.N    ??RTC_SetAlarm_16
   \                     ??RTC_SetAlarm_15: (+1)
   \   00000156   0xF240 0x4167      MOVW     R1,#+1127
   \   0000015A   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000015E   0x.... 0x....      BL       assert_failed
   1128                assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
   \                     ??RTC_SetAlarm_16: (+1)
   \   00000162   0x78F0             LDRB     R0,[R6, #+3]
   \   00000164   0x2800             CMP      R0,#+0
   \   00000166   0xD016             BEQ.N    ??RTC_SetAlarm_17
   \   00000168   0x78F0             LDRB     R0,[R6, #+3]
   \   0000016A   0x2840             CMP      R0,#+64
   \   0000016C   0xD013             BEQ.N    ??RTC_SetAlarm_17
   \   0000016E   0xF44F 0x618D      MOV      R1,#+1128
   \   00000172   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000176   0x.... 0x....      BL       assert_failed
   \   0000017A   0xE00C             B.N      ??RTC_SetAlarm_17
   1129              } 
   1130              else
   1131              {
   1132                RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
   \                     ??RTC_SetAlarm_14: (+1)
   \   0000017C   0x2000             MOVS     R0,#+0
   \   0000017E   0x70F0             STRB     R0,[R6, #+3]
   1133                assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
   \   00000180   0x7830             LDRB     R0,[R6, #+0]
   \   00000182   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000186   0x2818             CMP      R0,#+24
   \   00000188   0xDB05             BLT.N    ??RTC_SetAlarm_17
   \   0000018A   0xF240 0x416D      MOVW     R1,#+1133
   \   0000018E   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000192   0x.... 0x....      BL       assert_failed
   1134              }
   1135              
   1136              assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
   \                     ??RTC_SetAlarm_17: (+1)
   \   00000196   0x7870             LDRB     R0,[R6, #+1]
   \   00000198   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   0000019C   0x283C             CMP      R0,#+60
   \   0000019E   0xDB05             BLT.N    ??RTC_SetAlarm_18
   \   000001A0   0xF44F 0x618E      MOV      R1,#+1136
   \   000001A4   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000001A8   0x.... 0x....      BL       assert_failed
   1137              assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
   \                     ??RTC_SetAlarm_18: (+1)
   \   000001AC   0x78B0             LDRB     R0,[R6, #+2]
   \   000001AE   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   000001B2   0x283C             CMP      R0,#+60
   \   000001B4   0xDB05             BLT.N    ??RTC_SetAlarm_19
   \   000001B6   0xF240 0x4171      MOVW     R1,#+1137
   \   000001BA   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000001BE   0x.... 0x....      BL       assert_failed
   1138              
   1139              if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
   \                     ??RTC_SetAlarm_19: (+1)
   \   000001C2   0x68B0             LDR      R0,[R6, #+8]
   \   000001C4   0x2800             CMP      R0,#+0
   \   000001C6   0xD10D             BNE.N    ??RTC_SetAlarm_20
   1140              {
   1141                tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
   \   000001C8   0x7B30             LDRB     R0,[R6, #+12]
   \   000001CA   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   000001CE   0x0007             MOVS     R7,R0
   1142                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
   \   000001D0   0x2F00             CMP      R7,#+0
   \   000001D2   0xD001             BEQ.N    ??RTC_SetAlarm_21
   \   000001D4   0x2F20             CMP      R7,#+32
   \   000001D6   0xD31C             BCC.N    ??RTC_SetAlarm_13
   \                     ??RTC_SetAlarm_21: (+1)
   \   000001D8   0xF240 0x4176      MOVW     R1,#+1142
   \   000001DC   0x....             LDR.N    R0,??DataTable17_1
   \   000001DE   0x.... 0x....      BL       assert_failed
   \   000001E2   0xE016             B.N      ??RTC_SetAlarm_13
   1143              }
   1144              else
   1145              {
   1146                tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
   \                     ??RTC_SetAlarm_20: (+1)
   \   000001E4   0x7B30             LDRB     R0,[R6, #+12]
   \   000001E6   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   000001EA   0x0007             MOVS     R7,R0
   1147                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
   \   000001EC   0x2F01             CMP      R7,#+1
   \   000001EE   0xD010             BEQ.N    ??RTC_SetAlarm_13
   \   000001F0   0x2F02             CMP      R7,#+2
   \   000001F2   0xD00E             BEQ.N    ??RTC_SetAlarm_13
   \   000001F4   0x2F03             CMP      R7,#+3
   \   000001F6   0xD00C             BEQ.N    ??RTC_SetAlarm_13
   \   000001F8   0x2F04             CMP      R7,#+4
   \   000001FA   0xD00A             BEQ.N    ??RTC_SetAlarm_13
   \   000001FC   0x2F05             CMP      R7,#+5
   \   000001FE   0xD008             BEQ.N    ??RTC_SetAlarm_13
   \   00000200   0x2F06             CMP      R7,#+6
   \   00000202   0xD006             BEQ.N    ??RTC_SetAlarm_13
   \   00000204   0x2F07             CMP      R7,#+7
   \   00000206   0xD004             BEQ.N    ??RTC_SetAlarm_13
   \   00000208   0xF240 0x417B      MOVW     R1,#+1147
   \   0000020C   0x....             LDR.N    R0,??DataTable17_1
   \   0000020E   0x.... 0x....      BL       assert_failed
   1148              }    
   1149            }
   1150          
   1151            /* Check the input parameters format */
   1152            if (RTC_Format != RTC_Format_BIN)
   \                     ??RTC_SetAlarm_13: (+1)
   \   00000212   0x2C00             CMP      R4,#+0
   \   00000214   0xD012             BEQ.N    ??RTC_SetAlarm_22
   1153            {
   1154              tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
   1155                        ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
   1156                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
   1157                        ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
   1158                        ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
   1159                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
   1160                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
   \   00000216   0x7830             LDRB     R0,[R6, #+0]
   \   00000218   0x7871             LDRB     R1,[R6, #+1]
   \   0000021A   0x0209             LSLS     R1,R1,#+8
   \   0000021C   0xEA51 0x4000      ORRS     R0,R1,R0, LSL #+16
   \   00000220   0x78B1             LDRB     R1,[R6, #+2]
   \   00000222   0x4308             ORRS     R0,R1,R0
   \   00000224   0x78F1             LDRB     R1,[R6, #+3]
   \   00000226   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   0000022A   0x7B31             LDRB     R1,[R6, #+12]
   \   0000022C   0xEA50 0x6001      ORRS     R0,R0,R1, LSL #+24
   \   00000230   0x68B1             LDR      R1,[R6, #+8]
   \   00000232   0x4308             ORRS     R0,R1,R0
   \   00000234   0x6871             LDR      R1,[R6, #+4]
   \   00000236   0x4308             ORRS     R0,R1,R0
   \   00000238   0x0007             MOVS     R7,R0
   \   0000023A   0xE025             B.N      ??RTC_SetAlarm_23
   1161            }  
   1162            else
   1163            {
   1164              tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
   1165                        ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
   1166                        ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
   1167                        ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
   1168                        ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
   1169                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
   1170                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
   \                     ??RTC_SetAlarm_22: (+1)
   \   0000023C   0x7830             LDRB     R0,[R6, #+0]
   \   0000023E   0x.... 0x....      BL       RTC_ByteToBcd2
   \   00000242   0x4681             MOV      R9,R0
   \   00000244   0x7870             LDRB     R0,[R6, #+1]
   \   00000246   0x.... 0x....      BL       RTC_ByteToBcd2
   \   0000024A   0x4682             MOV      R10,R0
   \   0000024C   0x78B0             LDRB     R0,[R6, #+2]
   \   0000024E   0x.... 0x....      BL       RTC_ByteToBcd2
   \   00000252   0x4680             MOV      R8,R0
   \   00000254   0x7B30             LDRB     R0,[R6, #+12]
   \   00000256   0x.... 0x....      BL       RTC_ByteToBcd2
   \   0000025A   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000025E   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000262   0xEA5F 0x210A      LSLS     R1,R10,#+8
   \   00000266   0xEA51 0x4109      ORRS     R1,R1,R9, LSL #+16
   \   0000026A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000026E   0xEA58 0x0101      ORRS     R1,R8,R1
   \   00000272   0x78F2             LDRB     R2,[R6, #+3]
   \   00000274   0xEA51 0x4102      ORRS     R1,R1,R2, LSL #+16
   \   00000278   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000027A   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   0000027E   0x68B1             LDR      R1,[R6, #+8]
   \   00000280   0x4308             ORRS     R0,R1,R0
   \   00000282   0x6871             LDR      R1,[R6, #+4]
   \   00000284   0x4308             ORRS     R0,R1,R0
   \   00000286   0x0007             MOVS     R7,R0
   1171            } 
   1172          
   1173            /* Disable the write protection for RTC registers */
   1174            RTC->WPR = 0xCA;
   \                     ??RTC_SetAlarm_23: (+1)
   \   00000288   0x20CA             MOVS     R0,#+202
   \   0000028A   0x....             LDR.N    R1,??DataTable20  ;; 0x40002824
   \   0000028C   0x6008             STR      R0,[R1, #+0]
   1175            RTC->WPR = 0x53;
   \   0000028E   0x2053             MOVS     R0,#+83
   \   00000290   0x....             LDR.N    R1,??DataTable20  ;; 0x40002824
   \   00000292   0x6008             STR      R0,[R1, #+0]
   1176          
   1177            /* Configure the Alarm register */
   1178            if (RTC_Alarm == RTC_Alarm_A)
   \   00000294   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000298   0xD102             BNE.N    ??RTC_SetAlarm_24
   1179            {
   1180              RTC->ALRMAR = (uint32_t)tmpreg;
   \   0000029A   0x....             LDR.N    R0,??DataTable15_7  ;; 0x4000281c
   \   0000029C   0x6007             STR      R7,[R0, #+0]
   \   0000029E   0xE001             B.N      ??RTC_SetAlarm_25
   1181            }
   1182            else
   1183            {
   1184              RTC->ALRMBR = (uint32_t)tmpreg;
   \                     ??RTC_SetAlarm_24: (+1)
   \   000002A0   0x....             LDR.N    R0,??DataTable16  ;; 0x40002820
   \   000002A2   0x6007             STR      R7,[R0, #+0]
   1185            }
   1186          
   1187            /* Enable the write protection for RTC registers */
   1188            RTC->WPR = 0xFF;   
   \                     ??RTC_SetAlarm_25: (+1)
   \   000002A4   0x20FF             MOVS     R0,#+255
   \   000002A6   0x....             LDR.N    R1,??DataTable20  ;; 0x40002824
   \   000002A8   0x6008             STR      R0,[R1, #+0]
   1189          }
   \   000002AA   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1190          
   1191          /**
   1192            * @brief  Fills each RTC_AlarmStruct member with its default value
   1193            *         (Time = 00h:00mn:00sec / Date = 1st day of the month/Mask =
   1194            *         all fields are masked).
   1195            * @param  RTC_AlarmStruct: pointer to a @ref RTC_AlarmTypeDef structure which
   1196            *         will be initialized.
   1197            * @retval None
   1198            */

   \                                 In section .text, align 2, keep-with-next
   1199          void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
   1200          {
   1201            /* Alarm Time Settings : Time = 00h:00mn:00sec */
   1202            RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
   \                     RTC_AlarmStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x70C1             STRB     R1,[R0, #+3]
   1203            RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7001             STRB     R1,[R0, #+0]
   1204            RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7041             STRB     R1,[R0, #+1]
   1205            RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x7081             STRB     R1,[R0, #+2]
   1206          
   1207            /* Alarm Date Settings : Date = 1st day of the month */
   1208            RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6081             STR      R1,[R0, #+8]
   1209            RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x7301             STRB     R1,[R0, #+12]
   1210          
   1211            /* Alarm Masks Settings : Mask =  all fields are not masked */
   1212            RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x6041             STR      R1,[R0, #+4]
   1213          }
   \   0000001C   0x4770             BX       LR               ;; return
   1214          
   1215          /**
   1216            * @brief  Get the RTC Alarm value and masks.
   1217            * @param  RTC_Format: specifies the format of the output parameters.
   1218            *          This parameter can be one of the following values:
   1219            *            @arg RTC_Format_BIN: Binary data format 
   1220            *            @arg RTC_Format_BCD: BCD data format
   1221            * @param  RTC_Alarm: specifies the alarm to be read.
   1222            *          This parameter can be one of the following values:
   1223            *            @arg RTC_Alarm_A: to select Alarm A
   1224            *            @arg RTC_Alarm_B: to select Alarm B  
   1225            * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that will 
   1226            *                          contains the output alarm configuration values.     
   1227            * @retval None
   1228            */

   \                                 In section .text, align 2, keep-with-next
   1229          void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
   1230          {
   \                     RTC_GetAlarm: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1231            uint32_t tmpreg = 0;
   \   00000008   0x2700             MOVS     R7,#+0
   1232          
   1233            /* Check the parameters */
   1234            assert_param(IS_RTC_FORMAT(RTC_Format));
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD006             BEQ.N    ??RTC_GetAlarm_0
   \   0000000E   0x2C01             CMP      R4,#+1
   \   00000010   0xD004             BEQ.N    ??RTC_GetAlarm_0
   \   00000012   0xF240 0x41D2      MOVW     R1,#+1234
   \   00000016   0x....             LDR.N    R0,??DataTable17_1
   \   00000018   0x.... 0x....      BL       assert_failed
   1235            assert_param(IS_RTC_ALARM(RTC_Alarm)); 
   \                     ??RTC_GetAlarm_0: (+1)
   \   0000001C   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000020   0xD007             BEQ.N    ??RTC_GetAlarm_1
   \   00000022   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000026   0xD004             BEQ.N    ??RTC_GetAlarm_1
   \   00000028   0xF240 0x41D3      MOVW     R1,#+1235
   \   0000002C   0x....             LDR.N    R0,??DataTable17_1
   \   0000002E   0x.... 0x....      BL       assert_failed
   1236          
   1237            /* Get the RTC_ALRMxR register */
   1238            if (RTC_Alarm == RTC_Alarm_A)
   \                     ??RTC_GetAlarm_1: (+1)
   \   00000032   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000036   0xD103             BNE.N    ??RTC_GetAlarm_2
   1239            {
   1240              tmpreg = (uint32_t)(RTC->ALRMAR);
   \   00000038   0x....             LDR.N    R0,??DataTable15_7  ;; 0x4000281c
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x0007             MOVS     R7,R0
   \   0000003E   0xE002             B.N      ??RTC_GetAlarm_3
   1241            }
   1242            else
   1243            {
   1244              tmpreg = (uint32_t)(RTC->ALRMBR);
   \                     ??RTC_GetAlarm_2: (+1)
   \   00000040   0x....             LDR.N    R0,??DataTable16  ;; 0x40002820
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x0007             MOVS     R7,R0
   1245            }
   1246          
   1247            /* Fill the structure with the read parameters */
   1248            RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
   1249                                                               RTC_ALRMAR_HU)) >> 16);
   \                     ??RTC_GetAlarm_3: (+1)
   \   00000046   0x0C38             LSRS     R0,R7,#+16
   \   00000048   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   0000004C   0x7030             STRB     R0,[R6, #+0]
   1250            RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
   1251                                                               RTC_ALRMAR_MNU)) >> 8);
   \   0000004E   0x0A38             LSRS     R0,R7,#+8
   \   00000050   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000054   0x7070             STRB     R0,[R6, #+1]
   1252            RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
   1253                                                               RTC_ALRMAR_SU));
   \   00000056   0xF017 0x007F      ANDS     R0,R7,#0x7F
   \   0000005A   0x70B0             STRB     R0,[R6, #+2]
   1254            RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
   \   0000005C   0x0C38             LSRS     R0,R7,#+16
   \   0000005E   0xF010 0x0040      ANDS     R0,R0,#0x40
   \   00000062   0x70F0             STRB     R0,[R6, #+3]
   1255            RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
   \   00000064   0x0E38             LSRS     R0,R7,#+24
   \   00000066   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   0000006A   0x7330             STRB     R0,[R6, #+12]
   1256            RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
   \   0000006C   0xF017 0x4080      ANDS     R0,R7,#0x40000000
   \   00000070   0x60B0             STR      R0,[R6, #+8]
   1257            RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
   \   00000072   0xF037 0x307F      BICS     R0,R7,#0x7F7F7F7F
   \   00000076   0x6070             STR      R0,[R6, #+4]
   1258          
   1259            if (RTC_Format == RTC_Format_BIN)
   \   00000078   0x2C00             CMP      R4,#+0
   \   0000007A   0xD10F             BNE.N    ??RTC_GetAlarm_4
   1260            {
   1261              RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
   1262                                                                  RTC_AlarmTime.RTC_Hours);
   \   0000007C   0x7830             LDRB     R0,[R6, #+0]
   \   0000007E   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000082   0x7030             STRB     R0,[R6, #+0]
   1263              RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
   1264                                                                  RTC_AlarmTime.RTC_Minutes);
   \   00000084   0x7870             LDRB     R0,[R6, #+1]
   \   00000086   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   0000008A   0x7070             STRB     R0,[R6, #+1]
   1265              RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
   1266                                                                  RTC_AlarmTime.RTC_Seconds);
   \   0000008C   0x78B0             LDRB     R0,[R6, #+2]
   \   0000008E   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000092   0x70B0             STRB     R0,[R6, #+2]
   1267              RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
   \   00000094   0x7B30             LDRB     R0,[R6, #+12]
   \   00000096   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   0000009A   0x7330             STRB     R0,[R6, #+12]
   1268            }  
   1269          }
   \                     ??RTC_GetAlarm_4: (+1)
   \   0000009C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1270          
   1271          /**
   1272            * @brief  Enables or disables the specified RTC Alarm.
   1273            * @param  RTC_Alarm: specifies the alarm to be configured.
   1274            *          This parameter can be any combination of the following values:
   1275            *            @arg RTC_Alarm_A: to select Alarm A
   1276            *            @arg RTC_Alarm_B: to select Alarm B  
   1277            * @param  NewState: new state of the specified alarm.
   1278            *          This parameter can be: ENABLE or DISABLE.
   1279            * @retval An ErrorStatus enumeration value:
   1280            *          - SUCCESS: RTC Alarm is enabled/disabled
   1281            *          - ERROR: RTC Alarm is not enabled/disabled  
   1282            */

   \                                 In section .text, align 2, keep-with-next
   1283          ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
   1284          {
   \                     RTC_AlarmCmd: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1285            __IO uint32_t alarmcounter = 0x00;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
   1286            uint32_t alarmstatus = 0x00;
   \   0000000A   0x2600             MOVS     R6,#+0
   1287            ErrorStatus status = ERROR;
   \   0000000C   0x2700             MOVS     R7,#+0
   1288              
   1289            /* Check the parameters */
   1290            assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
   \   0000000E   0xF414 0x7F40      TST      R4,#0x300
   \   00000012   0xD104             BNE.N    ??RTC_AlarmCmd_0
   \   00000014   0xF240 0x510A      MOVW     R1,#+1290
   \   00000018   0x....             LDR.N    R0,??DataTable17_1
   \   0000001A   0x.... 0x....      BL       assert_failed
   1291            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RTC_AlarmCmd_0: (+1)
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD007             BEQ.N    ??RTC_AlarmCmd_1
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D01             CMP      R5,#+1
   \   00000028   0xD004             BEQ.N    ??RTC_AlarmCmd_1
   \   0000002A   0xF240 0x510B      MOVW     R1,#+1291
   \   0000002E   0x....             LDR.N    R0,??DataTable17_1
   \   00000030   0x.... 0x....      BL       assert_failed
   1292          
   1293            /* Disable the write protection for RTC registers */
   1294            RTC->WPR = 0xCA;
   \                     ??RTC_AlarmCmd_1: (+1)
   \   00000034   0x20CA             MOVS     R0,#+202
   \   00000036   0x....             LDR.N    R1,??DataTable20  ;; 0x40002824
   \   00000038   0x6008             STR      R0,[R1, #+0]
   1295            RTC->WPR = 0x53;
   \   0000003A   0x2053             MOVS     R0,#+83
   \   0000003C   0x....             LDR.N    R1,??DataTable20  ;; 0x40002824
   \   0000003E   0x6008             STR      R0,[R1, #+0]
   1296          
   1297            /* Configure the Alarm state */
   1298            if (NewState != DISABLE)
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x2D00             CMP      R5,#+0
   \   00000044   0xD007             BEQ.N    ??RTC_AlarmCmd_2
   1299            {
   1300              RTC->CR |= (uint32_t)RTC_Alarm;
   \   00000046   0x....             LDR.N    R0,??DataTable15_2  ;; 0x40002808
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x4320             ORRS     R0,R4,R0
   \   0000004C   0x....             LDR.N    R1,??DataTable15_2  ;; 0x40002808
   \   0000004E   0x6008             STR      R0,[R1, #+0]
   1301          
   1302              status = SUCCESS;    
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x0007             MOVS     R7,R0
   \   00000054   0xE01C             B.N      ??RTC_AlarmCmd_3
   1303            }
   1304            else
   1305            { 
   1306              /* Disable the Alarm in RTC_CR register */
   1307              RTC->CR &= (uint32_t)~RTC_Alarm;
   \                     ??RTC_AlarmCmd_2: (+1)
   \   00000056   0x....             LDR.N    R0,??DataTable15_2  ;; 0x40002808
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x43A0             BICS     R0,R0,R4
   \   0000005C   0x....             LDR.N    R1,??DataTable15_2  ;; 0x40002808
   \   0000005E   0x6008             STR      R0,[R1, #+0]
   1308             
   1309              /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
   1310              do
   1311              {
   1312                alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
   \                     ??RTC_AlarmCmd_4: (+1)
   \   00000060   0x....             LDR.N    R0,??DataTable18  ;; 0x4000280c
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0xEA10 0x2014      ANDS     R0,R0,R4, LSR #+8
   \   00000068   0x0006             MOVS     R6,R0
   1313                alarmcounter++;  
   \   0000006A   0x9800             LDR      R0,[SP, #+0]
   \   0000006C   0x1C40             ADDS     R0,R0,#+1
   \   0000006E   0x9000             STR      R0,[SP, #+0]
   1314              } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
   \   00000070   0x9800             LDR      R0,[SP, #+0]
   \   00000072   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000076   0xD001             BEQ.N    ??RTC_AlarmCmd_5
   \   00000078   0x2E00             CMP      R6,#+0
   \   0000007A   0xD0F1             BEQ.N    ??RTC_AlarmCmd_4
   1315              
   1316              if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
   \                     ??RTC_AlarmCmd_5: (+1)
   \   0000007C   0x....             LDR.N    R0,??DataTable18  ;; 0x4000280c
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0xEA10 0x2F14      TST      R0,R4, LSR #+8
   \   00000084   0xD102             BNE.N    ??RTC_AlarmCmd_6
   1317              {
   1318                status = ERROR;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x0007             MOVS     R7,R0
   \   0000008A   0xE001             B.N      ??RTC_AlarmCmd_3
   1319              } 
   1320              else
   1321              {
   1322                status = SUCCESS;
   \                     ??RTC_AlarmCmd_6: (+1)
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0x0007             MOVS     R7,R0
   1323              }        
   1324            } 
   1325          
   1326            /* Enable the write protection for RTC registers */
   1327            RTC->WPR = 0xFF; 
   \                     ??RTC_AlarmCmd_3: (+1)
   \   00000090   0x20FF             MOVS     R0,#+255
   \   00000092   0x....             LDR.N    R1,??DataTable20  ;; 0x40002824
   \   00000094   0x6008             STR      R0,[R1, #+0]
   1328            
   1329            return status;
   \   00000096   0x0038             MOVS     R0,R7
   \   00000098   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1330          }
   1331          
   1332          /**
   1333            * @brief  Configure the RTC AlarmA/B Subseconds value and mask.*
   1334            * @note   This function is performed only when the Alarm is disabled. 
   1335            * @param  RTC_Alarm: specifies the alarm to be configured.
   1336            *   This parameter can be one of the following values:
   1337            *     @arg RTC_Alarm_A: to select Alarm A
   1338            *     @arg RTC_Alarm_B: to select Alarm B
   1339            * @param  RTC_AlarmSubSecondValue: specifies the Subseconds value.
   1340            *   This parameter can be a value from 0 to 0x00007FFF.
   1341            * @param  RTC_AlarmSubSecondMask:  specifies the Subseconds Mask.
   1342            *   This parameter can be any combination of the following values:
   1343            *     @arg RTC_AlarmSubSecondMask_All    : All Alarm SS fields are masked.
   1344            *                                          There is no comparison on sub seconds for Alarm.
   1345            *     @arg RTC_AlarmSubSecondMask_SS14_1 : SS[14:1] are don't care in Alarm comparison.
   1346            *                                          Only SS[0] is compared
   1347            *     @arg RTC_AlarmSubSecondMask_SS14_2 : SS[14:2] are don't care in Alarm comparison.
   1348            *                                          Only SS[1:0] are compared
   1349            *     @arg RTC_AlarmSubSecondMask_SS14_3 : SS[14:3] are don't care in Alarm comparison.
   1350            *                                          Only SS[2:0] are compared
   1351            *     @arg RTC_AlarmSubSecondMask_SS14_4 : SS[14:4] are don't care in Alarm comparison.
   1352            *                                          Only SS[3:0] are compared
   1353            *     @arg RTC_AlarmSubSecondMask_SS14_5 : SS[14:5] are don't care in Alarm comparison.
   1354            *                                          Only SS[4:0] are compared
   1355            *     @arg RTC_AlarmSubSecondMask_SS14_6 : SS[14:6] are don't care in Alarm comparison.
   1356            *                                          Only SS[5:0] are compared
   1357            *     @arg RTC_AlarmSubSecondMask_SS14_7 : SS[14:7] are don't care in Alarm comparison.
   1358            *                                          Only SS[6:0] are compared
   1359            *     @arg RTC_AlarmSubSecondMask_SS14_8 : SS[14:8] are don't care in Alarm comparison.
   1360            *                                          Only SS[7:0] are compared
   1361            *     @arg RTC_AlarmSubSecondMask_SS14_9 : SS[14:9] are don't care in Alarm comparison.
   1362            *                                          Only SS[8:0] are compared
   1363            *     @arg RTC_AlarmSubSecondMask_SS14_10: SS[14:10] are don't care in Alarm comparison.
   1364            *                                          Only SS[9:0] are compared
   1365            *     @arg RTC_AlarmSubSecondMask_SS14_11: SS[14:11] are don't care in Alarm comparison.
   1366            *                                          Only SS[10:0] are compared
   1367            *     @arg RTC_AlarmSubSecondMask_SS14_12: SS[14:12] are don't care in Alarm comparison.
   1368            *                                          Only SS[11:0] are compared
   1369            *     @arg RTC_AlarmSubSecondMask_SS14_13: SS[14:13] are don't care in Alarm comparison.
   1370            *                                          Only SS[12:0] are compared
   1371            *     @arg RTC_AlarmSubSecondMask_SS14   : SS[14] is don't care in Alarm comparison.
   1372            *                                          Only SS[13:0] are compared
   1373            *     @arg RTC_AlarmSubSecondMask_None   : SS[14:0] are compared and must match
   1374            *                                          to activate alarm
   1375            * @retval None
   1376            */

   \                                 In section .text, align 2, keep-with-next
   1377          void RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint32_t RTC_AlarmSubSecondMask)
   1378          {
   \                     RTC_AlarmSubSecondConfig: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1379            uint32_t tmpreg = 0;
   \   00000008   0x2700             MOVS     R7,#+0
   1380          
   1381            /* Check the parameters */
   1382            assert_param(IS_RTC_ALARM(RTC_Alarm));
   \   0000000A   0xF5B4 0x7F80      CMP      R4,#+256
   \   0000000E   0xD007             BEQ.N    ??RTC_AlarmSubSecondConfig_0
   \   00000010   0xF5B4 0x7F00      CMP      R4,#+512
   \   00000014   0xD004             BEQ.N    ??RTC_AlarmSubSecondConfig_0
   \   00000016   0xF240 0x5166      MOVW     R1,#+1382
   \   0000001A   0x....             LDR.N    R0,??DataTable17_1
   \   0000001C   0x.... 0x....      BL       assert_failed
   1383            assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
   \                     ??RTC_AlarmSubSecondConfig_0: (+1)
   \   00000020   0xF5B5 0x4F00      CMP      R5,#+32768
   \   00000024   0xD304             BCC.N    ??RTC_AlarmSubSecondConfig_1
   \   00000026   0xF240 0x5167      MOVW     R1,#+1383
   \   0000002A   0x....             LDR.N    R0,??DataTable17_1
   \   0000002C   0x.... 0x....      BL       assert_failed
   1384            assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
   \                     ??RTC_AlarmSubSecondConfig_1: (+1)
   \   00000030   0x2E00             CMP      R6,#+0
   \   00000032   0xD031             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   00000034   0xF1B6 0x7F80      CMP      R6,#+16777216
   \   00000038   0xD02E             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   0000003A   0xF1B6 0x7F00      CMP      R6,#+33554432
   \   0000003E   0xD02B             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   00000040   0xF1B6 0x7F40      CMP      R6,#+50331648
   \   00000044   0xD028             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   00000046   0xF1B6 0x6F80      CMP      R6,#+67108864
   \   0000004A   0xD025             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   0000004C   0xF1B6 0x6FA0      CMP      R6,#+83886080
   \   00000050   0xD022             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   00000052   0xF1B6 0x6FC0      CMP      R6,#+100663296
   \   00000056   0xD01F             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   00000058   0xF1B6 0x6FE0      CMP      R6,#+117440512
   \   0000005C   0xD01C             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   0000005E   0xF1B6 0x6F00      CMP      R6,#+134217728
   \   00000062   0xD019             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   00000064   0xF1B6 0x6F10      CMP      R6,#+150994944
   \   00000068   0xD016             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   0000006A   0xF1B6 0x6F20      CMP      R6,#+167772160
   \   0000006E   0xD013             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   00000070   0xF1B6 0x6F30      CMP      R6,#+184549376
   \   00000074   0xD010             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   00000076   0xF1B6 0x6F40      CMP      R6,#+201326592
   \   0000007A   0xD00D             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   0000007C   0xF1B6 0x6F50      CMP      R6,#+218103808
   \   00000080   0xD00A             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   00000082   0xF1B6 0x6F60      CMP      R6,#+234881024
   \   00000086   0xD007             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   00000088   0xF1B6 0x6F70      CMP      R6,#+251658240
   \   0000008C   0xD004             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   0000008E   0xF44F 0x61AD      MOV      R1,#+1384
   \   00000092   0x....             LDR.N    R0,??DataTable17_1
   \   00000094   0x.... 0x....      BL       assert_failed
   1385            
   1386            /* Disable the write protection for RTC registers */
   1387            RTC->WPR = 0xCA;
   \                     ??RTC_AlarmSubSecondConfig_2: (+1)
   \   00000098   0x20CA             MOVS     R0,#+202
   \   0000009A   0x....             LDR.N    R1,??DataTable20  ;; 0x40002824
   \   0000009C   0x6008             STR      R0,[R1, #+0]
   1388            RTC->WPR = 0x53;
   \   0000009E   0x2053             MOVS     R0,#+83
   \   000000A0   0x....             LDR.N    R1,??DataTable20  ;; 0x40002824
   \   000000A2   0x6008             STR      R0,[R1, #+0]
   1389            
   1390            /* Configure the Alarm A or Alarm B SubSecond registers */
   1391            tmpreg = (uint32_t) (uint32_t)(RTC_AlarmSubSecondValue) | (uint32_t)(RTC_AlarmSubSecondMask);
   \   000000A4   0xEA56 0x0005      ORRS     R0,R6,R5
   \   000000A8   0x0007             MOVS     R7,R0
   1392            
   1393            if (RTC_Alarm == RTC_Alarm_A)
   \   000000AA   0xF5B4 0x7F80      CMP      R4,#+256
   \   000000AE   0xD103             BNE.N    ??RTC_AlarmSubSecondConfig_3
   1394            {
   1395              /* Configure the AlarmA SubSecond register */
   1396              RTC->ALRMASSR = tmpreg;
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable46  ;; 0x40002844
   \   000000B4   0x6007             STR      R7,[R0, #+0]
   \   000000B6   0xE002             B.N      ??RTC_AlarmSubSecondConfig_4
   1397            }
   1398            else
   1399            {
   1400              /* Configure the Alarm B SubSecond register */
   1401              RTC->ALRMBSSR = tmpreg;
   \                     ??RTC_AlarmSubSecondConfig_3: (+1)
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable46_1  ;; 0x40002848
   \   000000BC   0x6007             STR      R7,[R0, #+0]
   1402            }
   1403          
   1404            /* Enable the write protection for RTC registers */
   1405            RTC->WPR = 0xFF;
   \                     ??RTC_AlarmSubSecondConfig_4: (+1)
   \   000000BE   0x20FF             MOVS     R0,#+255
   \   000000C0   0x....             LDR.N    R1,??DataTable20  ;; 0x40002824
   \   000000C2   0x6008             STR      R0,[R1, #+0]
   1406          
   1407          }
   \   000000C4   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1408          
   1409          /**
   1410            * @brief  Gets the RTC Alarm Subseconds value.
   1411            * @param  RTC_Alarm: specifies the alarm to be read.
   1412            *   This parameter can be one of the following values:
   1413            *     @arg RTC_Alarm_A: to select Alarm A
   1414            *     @arg RTC_Alarm_B: to select Alarm B
   1415            * @param  None
   1416            * @retval RTC Alarm Subseconds value.
   1417            */

   \                                 In section .text, align 2, keep-with-next
   1418          uint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm)
   1419          {
   \                     RTC_GetAlarmSubSecond: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1420            uint32_t tmpreg = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   1421            
   1422            /* Get the RTC_ALRMxR register */
   1423            if (RTC_Alarm == RTC_Alarm_A)
   \   00000004   0xF5B1 0x7F80      CMP      R1,#+256
   \   00000008   0xD106             BNE.N    ??RTC_GetAlarmSubSecond_0
   1424            {
   1425              tmpreg = (uint32_t)((RTC->ALRMASSR) & RTC_ALRMASSR_SS);
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable46  ;; 0x40002844
   \   0000000E   0x6812             LDR      R2,[R2, #+0]
   \   00000010   0x0452             LSLS     R2,R2,#+17       ;; ZeroExtS R2,R2,#+17,#+17
   \   00000012   0x0C52             LSRS     R2,R2,#+17
   \   00000014   0x0010             MOVS     R0,R2
   \   00000016   0xE005             B.N      ??RTC_GetAlarmSubSecond_1
   1426            }
   1427            else
   1428            {
   1429              tmpreg = (uint32_t)((RTC->ALRMBSSR) & RTC_ALRMBSSR_SS);
   \                     ??RTC_GetAlarmSubSecond_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R2,??DataTable46_1  ;; 0x40002848
   \   0000001C   0x6812             LDR      R2,[R2, #+0]
   \   0000001E   0x0452             LSLS     R2,R2,#+17       ;; ZeroExtS R2,R2,#+17,#+17
   \   00000020   0x0C52             LSRS     R2,R2,#+17
   \   00000022   0x0010             MOVS     R0,R2
   1430            } 
   1431            
   1432            return (tmpreg);
   \                     ??RTC_GetAlarmSubSecond_1: (+1)
   \   00000024   0x4770             BX       LR               ;; return
   1433          }
   1434          
   1435          /**
   1436            * @}
   1437            */
   1438          
   1439          /** @defgroup RTC_Group4 WakeUp Timer configuration functions
   1440           *  @brief   WakeUp Timer configuration functions 
   1441           *
   1442          @verbatim   
   1443           ===============================================================================
   1444                               WakeUp Timer configuration functions
   1445           ===============================================================================  
   1446          
   1447            This section provide functions allowing to program and read the RTC WakeUp.
   1448          
   1449          @endverbatim
   1450            * @{
   1451            */
   1452          
   1453          /**
   1454            * @brief  Configures the RTC Wakeup clock source.
   1455            * @note   The WakeUp Clock source can only be changed when the RTC WakeUp
   1456            *         is disabled (Use the RTC_WakeUpCmd(DISABLE)).      
   1457            * @param  RTC_WakeUpClock: Wakeup Clock source.
   1458            *          This parameter can be one of the following values:
   1459            *            @arg RTC_WakeUpClock_RTCCLK_Div16: RTC Wakeup Counter Clock = RTCCLK/16
   1460            *            @arg RTC_WakeUpClock_RTCCLK_Div8: RTC Wakeup Counter Clock = RTCCLK/8
   1461            *            @arg RTC_WakeUpClock_RTCCLK_Div4: RTC Wakeup Counter Clock = RTCCLK/4
   1462            *            @arg RTC_WakeUpClock_RTCCLK_Div2: RTC Wakeup Counter Clock = RTCCLK/2
   1463            *            @arg RTC_WakeUpClock_CK_SPRE_16bits: RTC Wakeup Counter Clock = CK_SPRE
   1464            *            @arg RTC_WakeUpClock_CK_SPRE_17bits: RTC Wakeup Counter Clock = CK_SPRE
   1465            * @retval None
   1466            */

   \                                 In section .text, align 2, keep-with-next
   1467          void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock)
   1468          {
   \                     RTC_WakeUpClockConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1469            /* Check the parameters */
   1470            assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD00F             BEQ.N    ??RTC_WakeUpClockConfig_0
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD00D             BEQ.N    ??RTC_WakeUpClockConfig_0
   \   0000000C   0x2C02             CMP      R4,#+2
   \   0000000E   0xD00B             BEQ.N    ??RTC_WakeUpClockConfig_0
   \   00000010   0x2C03             CMP      R4,#+3
   \   00000012   0xD009             BEQ.N    ??RTC_WakeUpClockConfig_0
   \   00000014   0x2C04             CMP      R4,#+4
   \   00000016   0xD007             BEQ.N    ??RTC_WakeUpClockConfig_0
   \   00000018   0x2C06             CMP      R4,#+6
   \   0000001A   0xD005             BEQ.N    ??RTC_WakeUpClockConfig_0
   \   0000001C   0xF240 0x51BE      MOVW     R1,#+1470
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable47
   \   00000024   0x.... 0x....      BL       assert_failed
   1471          
   1472            /* Disable the write protection for RTC registers */
   1473            RTC->WPR = 0xCA;
   \                     ??RTC_WakeUpClockConfig_0: (+1)
   \   00000028   0x20CA             MOVS     R0,#+202
   \   0000002A   0x....             LDR.N    R1,??DataTable20  ;; 0x40002824
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   1474            RTC->WPR = 0x53;
   \   0000002E   0x2053             MOVS     R0,#+83
   \   00000030   0x....             LDR.N    R1,??DataTable20  ;; 0x40002824
   \   00000032   0x6008             STR      R0,[R1, #+0]
   1475          
   1476            /* Clear the Wakeup Timer clock source bits in CR register */
   1477            RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable47_1  ;; 0x40002808
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x08C0             LSRS     R0,R0,#+3
   \   0000003C   0x00C0             LSLS     R0,R0,#+3
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable47_1  ;; 0x40002808
   \   00000042   0x6008             STR      R0,[R1, #+0]
   1478          
   1479            /* Configure the clock source */
   1480            RTC->CR |= (uint32_t)RTC_WakeUpClock;
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable47_1  ;; 0x40002808
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x4320             ORRS     R0,R4,R0
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable47_1  ;; 0x40002808
   \   00000050   0x6008             STR      R0,[R1, #+0]
   1481            
   1482            /* Enable the write protection for RTC registers */
   1483            RTC->WPR = 0xFF; 
   \   00000052   0x20FF             MOVS     R0,#+255
   \   00000054   0x....             LDR.N    R1,??DataTable20  ;; 0x40002824
   \   00000056   0x6008             STR      R0,[R1, #+0]
   1484          }
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
   1485          
   1486          /**
   1487            * @brief  Configures the RTC Wakeup counter.
   1488            * @note   The RTC WakeUp counter can only be written when the RTC WakeUp
   1489            *         is disabled (Use the RTC_WakeUpCmd(DISABLE)).        
   1490            * @param  RTC_WakeUpCounter: specifies the WakeUp counter.
   1491            *          This parameter can be a value from 0x0000 to 0xFFFF. 
   1492            * @retval None
   1493            */

   \                                 In section .text, align 2, keep-with-next
   1494          void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter)
   1495          {
   \                     RTC_SetWakeUpCounter: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1496            /* Check the parameters */
   1497            assert_param(IS_RTC_WAKEUP_COUNTER(RTC_WakeUpCounter));
   \   00000004   0xF5B4 0x3F80      CMP      R4,#+65536
   \   00000008   0xD305             BCC.N    ??RTC_SetWakeUpCounter_0
   \   0000000A   0xF240 0x51D9      MOVW     R1,#+1497
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable47
   \   00000012   0x.... 0x....      BL       assert_failed
   1498            
   1499            /* Disable the write protection for RTC registers */
   1500            RTC->WPR = 0xCA;
   \                     ??RTC_SetWakeUpCounter_0: (+1)
   \   00000016   0x20CA             MOVS     R0,#+202
   \   00000018   0x....             LDR.N    R1,??DataTable20  ;; 0x40002824
   \   0000001A   0x6008             STR      R0,[R1, #+0]
   1501            RTC->WPR = 0x53;
   \   0000001C   0x2053             MOVS     R0,#+83
   \   0000001E   0x....             LDR.N    R1,??DataTable20  ;; 0x40002824
   \   00000020   0x6008             STR      R0,[R1, #+0]
   1502            
   1503            /* Configure the Wakeup Timer counter */
   1504            RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable48  ;; 0x40002814
   \   00000026   0x6004             STR      R4,[R0, #+0]
   1505            
   1506            /* Enable the write protection for RTC registers */
   1507            RTC->WPR = 0xFF; 
   \   00000028   0x20FF             MOVS     R0,#+255
   \   0000002A   0x....             LDR.N    R1,??DataTable20  ;; 0x40002824
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   1508          }
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
   1509          
   1510          /**
   1511            * @brief  Returns the RTC WakeUp timer counter value.
   1512            * @param  None
   1513            * @retval The RTC WakeUp Counter value.
   1514            */

   \                                 In section .text, align 2, keep-with-next
   1515          uint32_t RTC_GetWakeUpCounter(void)
   1516          {
   1517            /* Get the counter value */
   1518            return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
   \                     RTC_GetWakeUpCounter: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable48  ;; 0x40002814
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000008   0x4770             BX       LR               ;; return
   1519          }
   1520          
   1521          /**
   1522            * @brief  Enables or Disables the RTC WakeUp timer.
   1523            * @param  NewState: new state of the WakeUp timer.
   1524            *          This parameter can be: ENABLE or DISABLE.
   1525            * @retval None
   1526            */

   \                                 In section .text, align 2, keep-with-next
   1527          ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
   1528          {
   \                     RTC_WakeUpCmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   1529            __IO uint32_t wutcounter = 0x00;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
   1530            uint32_t wutwfstatus = 0x00;
   \   0000000A   0x2500             MOVS     R5,#+0
   1531            ErrorStatus status = ERROR;
   \   0000000C   0x2600             MOVS     R6,#+0
   1532            
   1533            /* Check the parameters */
   1534            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD008             BEQ.N    ??RTC_WakeUpCmd_0
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0x2C01             CMP      R4,#+1
   \   00000018   0xD005             BEQ.N    ??RTC_WakeUpCmd_0
   \   0000001A   0xF240 0x51FE      MOVW     R1,#+1534
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable47
   \   00000022   0x.... 0x....      BL       assert_failed
   1535          
   1536            /* Disable the write protection for RTC registers */
   1537            RTC->WPR = 0xCA;
   \                     ??RTC_WakeUpCmd_0: (+1)
   \   00000026   0x20CA             MOVS     R0,#+202
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40002824
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   1538            RTC->WPR = 0x53;
   \   0000002E   0x2053             MOVS     R0,#+83
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40002824
   \   00000034   0x6008             STR      R0,[R1, #+0]
   1539          
   1540            if (NewState != DISABLE)
   \   00000036   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   0x2C00             CMP      R4,#+0
   \   0000003A   0xD00A             BEQ.N    ??RTC_WakeUpCmd_1
   1541            {
   1542              /* Enable the Wakeup Timer */
   1543              RTC->CR |= (uint32_t)RTC_CR_WUTE;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable47_1  ;; 0x40002808
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable47_1  ;; 0x40002808
   \   0000004A   0x6008             STR      R0,[R1, #+0]
   1544              status = SUCCESS;    
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0x0006             MOVS     R6,R0
   \   00000050   0xE01E             B.N      ??RTC_WakeUpCmd_2
   1545            }
   1546            else
   1547            {
   1548              /* Disable the Wakeup Timer */
   1549              RTC->CR &= (uint32_t)~RTC_CR_WUTE;
   \                     ??RTC_WakeUpCmd_1: (+1)
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable47_1  ;; 0x40002808
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0xF430 0x6080      BICS     R0,R0,#0x400
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable47_1  ;; 0x40002808
   \   00000060   0x6008             STR      R0,[R1, #+0]
   1550              /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
   1551              do
   1552              {
   1553                wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
   \                     ??RTC_WakeUpCmd_3: (+1)
   \   00000062   0x....             LDR.N    R0,??DataTable21  ;; 0x4000280c
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0xF010 0x0004      ANDS     R0,R0,#0x4
   \   0000006A   0x0005             MOVS     R5,R0
   1554                wutcounter++;  
   \   0000006C   0x9800             LDR      R0,[SP, #+0]
   \   0000006E   0x1C40             ADDS     R0,R0,#+1
   \   00000070   0x9000             STR      R0,[SP, #+0]
   1555              } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
   \   00000072   0x9800             LDR      R0,[SP, #+0]
   \   00000074   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000078   0xD001             BEQ.N    ??RTC_WakeUpCmd_4
   \   0000007A   0x2D00             CMP      R5,#+0
   \   0000007C   0xD0F1             BEQ.N    ??RTC_WakeUpCmd_3
   1556              
   1557              if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
   \                     ??RTC_WakeUpCmd_4: (+1)
   \   0000007E   0x....             LDR.N    R0,??DataTable21  ;; 0x4000280c
   \   00000080   0x6800             LDR      R0,[R0, #+0]
   \   00000082   0x0740             LSLS     R0,R0,#+29
   \   00000084   0xD402             BMI.N    ??RTC_WakeUpCmd_5
   1558              {
   1559                status = ERROR;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x0006             MOVS     R6,R0
   \   0000008A   0xE001             B.N      ??RTC_WakeUpCmd_2
   1560              }
   1561              else
   1562              {
   1563                status = SUCCESS;
   \                     ??RTC_WakeUpCmd_5: (+1)
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0x0006             MOVS     R6,R0
   1564              }    
   1565            }
   1566          
   1567            /* Enable the write protection for RTC registers */
   1568            RTC->WPR = 0xFF; 
   \                     ??RTC_WakeUpCmd_2: (+1)
   \   00000090   0x20FF             MOVS     R0,#+255
   \   00000092   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40002824
   \   00000096   0x6008             STR      R0,[R1, #+0]
   1569            
   1570            return status;
   \   00000098   0x0030             MOVS     R0,R6
   \   0000009A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009C   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1571          }
   1572          
   1573          /**
   1574            * @}
   1575            */
   1576          
   1577          /** @defgroup RTC_Group5 Daylight Saving configuration functions
   1578           *  @brief   Daylight Saving configuration functions 
   1579           *
   1580          @verbatim   
   1581           ===============================================================================
   1582                              Daylight Saving configuration functions
   1583           ===============================================================================  
   1584          
   1585            This section provide functions allowing to configure the RTC DayLight Saving.
   1586          
   1587          @endverbatim
   1588            * @{
   1589            */
   1590          
   1591          /**
   1592            * @brief  Adds or substract one hour from the current time.
   1593            * @param  RTC_DayLightSaveOperation: the value of hour adjustment. 
   1594            *          This parameter can be one of the following values:
   1595            *            @arg RTC_DayLightSaving_SUB1H: Substract one hour (winter time)
   1596            *            @arg RTC_DayLightSaving_ADD1H: Add one hour (summer time)
   1597            * @param  RTC_StoreOperation: Specifies the value to be written in the BCK bit 
   1598            *                            in CR register to store the operation.
   1599            *          This parameter can be one of the following values:
   1600            *            @arg RTC_StoreOperation_Reset: BCK Bit Reset
   1601            *            @arg RTC_StoreOperation_Set: BCK Bit Set
   1602            * @retval None
   1603            */

   \                                 In section .text, align 2, keep-with-next
   1604          void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
   1605          {
   \                     RTC_DayLightSavingConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1606            /* Check the parameters */
   1607            assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
   \   00000006   0xF5B4 0x3F00      CMP      R4,#+131072
   \   0000000A   0xD008             BEQ.N    ??RTC_DayLightSavingConfig_0
   \   0000000C   0xF5B4 0x3F80      CMP      R4,#+65536
   \   00000010   0xD005             BEQ.N    ??RTC_DayLightSavingConfig_0
   \   00000012   0xF240 0x6147      MOVW     R1,#+1607
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable47
   \   0000001A   0x.... 0x....      BL       assert_failed
   1608            assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));
   \                     ??RTC_DayLightSavingConfig_0: (+1)
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD008             BEQ.N    ??RTC_DayLightSavingConfig_1
   \   00000022   0xF5B5 0x2F80      CMP      R5,#+262144
   \   00000026   0xD005             BEQ.N    ??RTC_DayLightSavingConfig_1
   \   00000028   0xF44F 0x61C9      MOV      R1,#+1608
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable47
   \   00000030   0x.... 0x....      BL       assert_failed
   1609          
   1610            /* Disable the write protection for RTC registers */
   1611            RTC->WPR = 0xCA;
   \                     ??RTC_DayLightSavingConfig_1: (+1)
   \   00000034   0x20CA             MOVS     R0,#+202
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40002824
   \   0000003A   0x6008             STR      R0,[R1, #+0]
   1612            RTC->WPR = 0x53;
   \   0000003C   0x2053             MOVS     R0,#+83
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40002824
   \   00000042   0x6008             STR      R0,[R1, #+0]
   1613          
   1614            /* Clear the bits to be configured */
   1615            RTC->CR &= (uint32_t)~(RTC_CR_BCK);
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable47_1  ;; 0x40002808
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable47_1  ;; 0x40002808
   \   00000052   0x6008             STR      R0,[R1, #+0]
   1616          
   1617            /* Configure the RTC_CR register */
   1618            RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable47_1  ;; 0x40002808
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xEA55 0x0104      ORRS     R1,R5,R4
   \   0000005E   0x4308             ORRS     R0,R1,R0
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable47_1  ;; 0x40002808
   \   00000064   0x6008             STR      R0,[R1, #+0]
   1619          
   1620            /* Enable the write protection for RTC registers */
   1621            RTC->WPR = 0xFF; 
   \   00000066   0x20FF             MOVS     R0,#+255
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40002824
   \   0000006C   0x6008             STR      R0,[R1, #+0]
   1622          }
   \   0000006E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1623          
   1624          /**
   1625            * @brief  Returns the RTC Day Light Saving stored operation.
   1626            * @param  None
   1627            * @retval RTC Day Light Saving stored operation.
   1628            *          - RTC_StoreOperation_Reset
   1629            *          - RTC_StoreOperation_Set       
   1630            */

   \                                 In section .text, align 2, keep-with-next
   1631          uint32_t RTC_GetStoreOperation(void)
   1632          {
   1633            return (RTC->CR & RTC_CR_BCK);
   \                     RTC_GetStoreOperation: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable50_1  ;; 0x40002808
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF410 0x2080      ANDS     R0,R0,#0x40000
   \   0000000A   0x4770             BX       LR               ;; return
   1634          }
   1635          
   1636          /**
   1637            * @}
   1638            */
   1639          
   1640          /** @defgroup RTC_Group6 Output pin Configuration function
   1641           *  @brief   Output pin Configuration function 
   1642           *
   1643          @verbatim   
   1644           ===============================================================================
   1645                                   Output pin Configuration function
   1646           ===============================================================================  
   1647          
   1648            This section provide functions allowing to configure the RTC Output source.
   1649          
   1650          @endverbatim
   1651            * @{
   1652            */
   1653          
   1654          /**
   1655            * @brief  Configures the RTC output source (AFO_ALARM).
   1656            * @param  RTC_Output: Specifies which signal will be routed to the RTC output. 
   1657            *          This parameter can be one of the following values:
   1658            *            @arg RTC_Output_Disable: No output selected
   1659            *            @arg RTC_Output_AlarmA: signal of AlarmA mapped to output
   1660            *            @arg RTC_Output_AlarmB: signal of AlarmB mapped to output
   1661            *            @arg RTC_Output_WakeUp: signal of WakeUp mapped to output
   1662            * @param  RTC_OutputPolarity: Specifies the polarity of the output signal. 
   1663            *          This parameter can be one of the following:
   1664            *            @arg RTC_OutputPolarity_High: The output pin is high when the 
   1665            *                                 ALRAF/ALRBF/WUTF is high (depending on OSEL)
   1666            *            @arg RTC_OutputPolarity_Low: The output pin is low when the 
   1667            *                                 ALRAF/ALRBF/WUTF is high (depending on OSEL)
   1668            * @retval None
   1669            */

   \                                 In section .text, align 2, keep-with-next
   1670          void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
   1671          {
   \                     RTC_OutputConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1672            /* Check the parameters */
   1673            assert_param(IS_RTC_OUTPUT(RTC_Output));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00E             BEQ.N    ??RTC_OutputConfig_0
   \   0000000A   0xF5B4 0x1F00      CMP      R4,#+2097152
   \   0000000E   0xD00B             BEQ.N    ??RTC_OutputConfig_0
   \   00000010   0xF5B4 0x0F80      CMP      R4,#+4194304
   \   00000014   0xD008             BEQ.N    ??RTC_OutputConfig_0
   \   00000016   0xF5B4 0x0FC0      CMP      R4,#+6291456
   \   0000001A   0xD005             BEQ.N    ??RTC_OutputConfig_0
   \   0000001C   0xF240 0x6189      MOVW     R1,#+1673
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable47
   \   00000024   0x.... 0x....      BL       assert_failed
   1674            assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));
   \                     ??RTC_OutputConfig_0: (+1)
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD008             BEQ.N    ??RTC_OutputConfig_1
   \   0000002C   0xF5B5 0x1F80      CMP      R5,#+1048576
   \   00000030   0xD005             BEQ.N    ??RTC_OutputConfig_1
   \   00000032   0xF240 0x618A      MOVW     R1,#+1674
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable47
   \   0000003A   0x.... 0x....      BL       assert_failed
   1675          
   1676            /* Disable the write protection for RTC registers */
   1677            RTC->WPR = 0xCA;
   \                     ??RTC_OutputConfig_1: (+1)
   \   0000003E   0x20CA             MOVS     R0,#+202
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40002824
   \   00000044   0x6008             STR      R0,[R1, #+0]
   1678            RTC->WPR = 0x53;
   \   00000046   0x2053             MOVS     R0,#+83
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40002824
   \   0000004C   0x6008             STR      R0,[R1, #+0]
   1679          
   1680            /* Clear the bits to be configured */
   1681            RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable47_1  ;; 0x40002808
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0xF430 0x00E0      BICS     R0,R0,#0x700000
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable47_1  ;; 0x40002808
   \   0000005C   0x6008             STR      R0,[R1, #+0]
   1682          
   1683            /* Configure the output selection and polarity */
   1684            RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable47_1  ;; 0x40002808
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0xEA55 0x0104      ORRS     R1,R5,R4
   \   00000068   0x4308             ORRS     R0,R1,R0
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable47_1  ;; 0x40002808
   \   0000006E   0x6008             STR      R0,[R1, #+0]
   1685          
   1686            /* Enable the write protection for RTC registers */
   1687            RTC->WPR = 0xFF; 
   \   00000070   0x20FF             MOVS     R0,#+255
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40002824
   \   00000076   0x6008             STR      R0,[R1, #+0]
   1688          }
   \   00000078   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1689          
   1690          /**
   1691            * @}
   1692            */
   1693          
   1694          /** @defgroup RTC_Group7 Digital Calibration configuration functions
   1695           *  @brief   Coarse Calibration configuration functions 
   1696           *
   1697          @verbatim   
   1698           ===============================================================================
   1699                            Digital Calibration configuration functions
   1700           ===============================================================================  
   1701          
   1702          @endverbatim
   1703            * @{
   1704            */
   1705          
   1706          /**
   1707            * @brief  Configures the Coarse calibration parameters.
   1708            * @param  RTC_CalibSign: specifies the sign of the coarse calibration value.
   1709            *          This parameter can be  one of the following values:
   1710            *            @arg RTC_CalibSign_Positive: The value sign is positive 
   1711            *            @arg RTC_CalibSign_Negative: The value sign is negative
   1712            * @param  Value: value of coarse calibration expressed in ppm (coded on 5 bits).
   1713            *    
   1714            * @note   This Calibration value should be between 0 and 63 when using negative
   1715            *         sign with a 2-ppm step.
   1716            *           
   1717            * @note   This Calibration value should be between 0 and 126 when using positive
   1718            *         sign with a 4-ppm step.
   1719            *           
   1720            * @retval An ErrorStatus enumeration value:
   1721            *          - SUCCESS: RTC Coarse calibration are initialized
   1722            *          - ERROR: RTC Coarse calibration are not initialized     
   1723            */

   \                                 In section .text, align 2, keep-with-next
   1724          ErrorStatus RTC_CoarseCalibConfig(uint32_t RTC_CalibSign, uint32_t Value)
   1725          {
   \                     RTC_CoarseCalibConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1726            ErrorStatus status = ERROR;
   \   00000006   0x2600             MOVS     R6,#+0
   1727             
   1728            /* Check the parameters */
   1729            assert_param(IS_RTC_CALIB_SIGN(RTC_CalibSign));
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD007             BEQ.N    ??RTC_CoarseCalibConfig_0
   \   0000000C   0x2C80             CMP      R4,#+128
   \   0000000E   0xD005             BEQ.N    ??RTC_CoarseCalibConfig_0
   \   00000010   0xF240 0x61C1      MOVW     R1,#+1729
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable47
   \   00000018   0x.... 0x....      BL       assert_failed
   1730            assert_param(IS_RTC_CALIB_VALUE(Value)); 
   \                     ??RTC_CoarseCalibConfig_0: (+1)
   \   0000001C   0x2D20             CMP      R5,#+32
   \   0000001E   0xD305             BCC.N    ??RTC_CoarseCalibConfig_1
   \   00000020   0xF240 0x61C2      MOVW     R1,#+1730
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable47
   \   00000028   0x.... 0x....      BL       assert_failed
   1731          
   1732            /* Disable the write protection for RTC registers */
   1733            RTC->WPR = 0xCA;
   \                     ??RTC_CoarseCalibConfig_1: (+1)
   \   0000002C   0x20CA             MOVS     R0,#+202
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40002824
   \   00000032   0x6008             STR      R0,[R1, #+0]
   1734            RTC->WPR = 0x53;
   \   00000034   0x2053             MOVS     R0,#+83
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40002824
   \   0000003A   0x6008             STR      R0,[R1, #+0]
   1735          
   1736            /* Set Initialization mode */
   1737            if (RTC_EnterInitMode() == ERROR)
   \   0000003C   0x.... 0x....      BL       RTC_EnterInitMode
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD102             BNE.N    ??RTC_CoarseCalibConfig_2
   1738            {
   1739              status = ERROR;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x0006             MOVS     R6,R0
   \   00000048   0xE008             B.N      ??RTC_CoarseCalibConfig_3
   1740            } 
   1741            else
   1742            {
   1743              /* Set the coarse calibration value */
   1744              RTC->CALIBR = (uint32_t)(RTC_CalibSign | Value);
   \                     ??RTC_CoarseCalibConfig_2: (+1)
   \   0000004A   0xEA55 0x0004      ORRS     R0,R5,R4
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable50_2  ;; 0x40002818
   \   00000052   0x6008             STR      R0,[R1, #+0]
   1745              /* Exit Initialization mode */
   1746              RTC_ExitInitMode();
   \   00000054   0x.... 0x....      BL       RTC_ExitInitMode
   1747              
   1748              status = SUCCESS;
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x0006             MOVS     R6,R0
   1749            } 
   1750          
   1751            /* Enable the write protection for RTC registers */
   1752            RTC->WPR = 0xFF; 
   \                     ??RTC_CoarseCalibConfig_3: (+1)
   \   0000005C   0x20FF             MOVS     R0,#+255
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40002824
   \   00000062   0x6008             STR      R0,[R1, #+0]
   1753            
   1754            return status;
   \   00000064   0x0030             MOVS     R0,R6
   \   00000066   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000068   0xBD70             POP      {R4-R6,PC}       ;; return
   1755          }
   1756          
   1757          /**
   1758            * @brief  Enables or disables the Coarse calibration process.
   1759            * @param  NewState: new state of the Coarse calibration.
   1760            *          This parameter can be: ENABLE or DISABLE.
   1761            * @retval An ErrorStatus enumeration value:
   1762            *          - SUCCESS: RTC Coarse calibration are enabled/disabled
   1763            *          - ERROR: RTC Coarse calibration are not enabled/disabled    
   1764            */

   \                                 In section .text, align 2, keep-with-next
   1765          ErrorStatus RTC_CoarseCalibCmd(FunctionalState NewState)
   1766          {
   \                     RTC_CoarseCalibCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1767            ErrorStatus status = ERROR;
   \   00000004   0x2500             MOVS     R5,#+0
   1768            
   1769            /* Check the parameters */
   1770            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD008             BEQ.N    ??RTC_CoarseCalibCmd_0
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C01             CMP      R4,#+1
   \   00000010   0xD005             BEQ.N    ??RTC_CoarseCalibCmd_0
   \   00000012   0xF240 0x61EA      MOVW     R1,#+1770
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable47
   \   0000001A   0x.... 0x....      BL       assert_failed
   1771          
   1772            /* Disable the write protection for RTC registers */
   1773            RTC->WPR = 0xCA;
   \                     ??RTC_CoarseCalibCmd_0: (+1)
   \   0000001E   0x20CA             MOVS     R0,#+202
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40002824
   \   00000024   0x6008             STR      R0,[R1, #+0]
   1774            RTC->WPR = 0x53;
   \   00000026   0x2053             MOVS     R0,#+83
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40002824
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   1775            
   1776            /* Set Initialization mode */
   1777            if (RTC_EnterInitMode() == ERROR)
   \   0000002E   0x.... 0x....      BL       RTC_EnterInitMode
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD102             BNE.N    ??RTC_CoarseCalibCmd_1
   1778            {
   1779              status =  ERROR;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x0005             MOVS     R5,R0
   \   0000003A   0xE017             B.N      ??RTC_CoarseCalibCmd_2
   1780            }
   1781            else
   1782            {
   1783              if (NewState != DISABLE)
   \                     ??RTC_CoarseCalibCmd_1: (+1)
   \   0000003C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   0x2C00             CMP      R4,#+0
   \   00000040   0xD008             BEQ.N    ??RTC_CoarseCalibCmd_3
   1784              {
   1785                /* Enable the Coarse Calibration */
   1786                RTC->CR |= (uint32_t)RTC_CR_DCE;
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable47_1  ;; 0x40002808
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable47_1  ;; 0x40002808
   \   00000050   0x6008             STR      R0,[R1, #+0]
   \   00000052   0xE007             B.N      ??RTC_CoarseCalibCmd_4
   1787              }
   1788              else
   1789              { 
   1790                /* Disable the Coarse Calibration */
   1791                RTC->CR &= (uint32_t)~RTC_CR_DCE;
   \                     ??RTC_CoarseCalibCmd_3: (+1)
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable47_1  ;; 0x40002808
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xF030 0x0080      BICS     R0,R0,#0x80
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable47_1  ;; 0x40002808
   \   00000062   0x6008             STR      R0,[R1, #+0]
   1792              }
   1793              /* Exit Initialization mode */
   1794              RTC_ExitInitMode();
   \                     ??RTC_CoarseCalibCmd_4: (+1)
   \   00000064   0x.... 0x....      BL       RTC_ExitInitMode
   1795              
   1796              status = SUCCESS;
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0x0005             MOVS     R5,R0
   1797            } 
   1798            
   1799            /* Enable the write protection for RTC registers */
   1800            RTC->WPR = 0xFF; 
   \                     ??RTC_CoarseCalibCmd_2: (+1)
   \   0000006C   0x20FF             MOVS     R0,#+255
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40002824
   \   00000072   0x6008             STR      R0,[R1, #+0]
   1801            
   1802            return status;
   \   00000074   0x0028             MOVS     R0,R5
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1803          }
   1804          
   1805          /**
   1806            * @brief  Enables or disables the RTC clock to be output through the relative pin.
   1807            * @param  NewState: new state of the digital calibration Output.
   1808            *          This parameter can be: ENABLE or DISABLE.
   1809            * @retval None
   1810            */

   \                                 In section .text, align 2, keep-with-next
   1811          void RTC_CalibOutputCmd(FunctionalState NewState)
   1812          {
   \                     RTC_CalibOutputCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1813            /* Check the parameters */
   1814            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??RTC_CalibOutputCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??RTC_CalibOutputCmd_0
   \   00000010   0xF240 0x7116      MOVW     R1,#+1814
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable47
   \   00000018   0x.... 0x....      BL       assert_failed
   1815            
   1816            /* Disable the write protection for RTC registers */
   1817            RTC->WPR = 0xCA;
   \                     ??RTC_CalibOutputCmd_0: (+1)
   \   0000001C   0x20CA             MOVS     R0,#+202
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40002824
   \   00000022   0x6008             STR      R0,[R1, #+0]
   1818            RTC->WPR = 0x53;
   \   00000024   0x2053             MOVS     R0,#+83
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40002824
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   1819            
   1820            if (NewState != DISABLE)
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x2C00             CMP      R4,#+0
   \   00000030   0xD008             BEQ.N    ??RTC_CalibOutputCmd_1
   1821            {
   1822              /* Enable the RTC clock output */
   1823              RTC->CR |= (uint32_t)RTC_CR_COE;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable47_1  ;; 0x40002808
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF450 0x0000      ORRS     R0,R0,#0x800000
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable47_1  ;; 0x40002808
   \   00000040   0x6008             STR      R0,[R1, #+0]
   \   00000042   0xE007             B.N      ??RTC_CalibOutputCmd_2
   1824            }
   1825            else
   1826            { 
   1827              /* Disable the RTC clock output */
   1828              RTC->CR &= (uint32_t)~RTC_CR_COE;
   \                     ??RTC_CalibOutputCmd_1: (+1)
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable47_1  ;; 0x40002808
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF430 0x0000      BICS     R0,R0,#0x800000
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable47_1  ;; 0x40002808
   \   00000052   0x6008             STR      R0,[R1, #+0]
   1829            }
   1830            
   1831            /* Enable the write protection for RTC registers */
   1832            RTC->WPR = 0xFF; 
   \                     ??RTC_CalibOutputCmd_2: (+1)
   \   00000054   0x20FF             MOVS     R0,#+255
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40002824
   \   0000005A   0x6008             STR      R0,[R1, #+0]
   1833          }
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
   1834          
   1835          /**
   1836            * @brief  Configure the Calibration Pinout (RTC_CALIB) Selection (1Hz or 512Hz).
   1837            * @param  RTC_CalibOutput : Select the Calibration output Selection .
   1838            *   This parameter can be one of the following values:
   1839            *     @arg RTC_CalibOutput_512Hz: A signal has a regular waveform at 512Hz. 
   1840            *     @arg RTC_CalibOutput_1Hz  : A signal has a regular waveform at 1Hz.
   1841            * @retval None
   1842          */

   \                                 In section .text, align 2, keep-with-next
   1843          void RTC_CalibOutputConfig(uint32_t RTC_CalibOutput)
   1844          {
   \                     RTC_CalibOutputConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1845            /* Check the parameters */
   1846            assert_param(IS_RTC_CALIB_OUTPUT(RTC_CalibOutput));
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD008             BEQ.N    ??RTC_CalibOutputConfig_0
   \   00000008   0xF5B4 0x2F00      CMP      R4,#+524288
   \   0000000C   0xD005             BEQ.N    ??RTC_CalibOutputConfig_0
   \   0000000E   0xF240 0x7136      MOVW     R1,#+1846
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable47
   \   00000016   0x.... 0x....      BL       assert_failed
   1847          
   1848            /* Disable the write protection for RTC registers */
   1849            RTC->WPR = 0xCA;
   \                     ??RTC_CalibOutputConfig_0: (+1)
   \   0000001A   0x20CA             MOVS     R0,#+202
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40002824
   \   00000020   0x6008             STR      R0,[R1, #+0]
   1850            RTC->WPR = 0x53;
   \   00000022   0x2053             MOVS     R0,#+83
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40002824
   \   00000028   0x6008             STR      R0,[R1, #+0]
   1851            
   1852            /*clear flags before config*/
   1853            RTC->CR &= (uint32_t)~(RTC_CR_COSEL);
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable47_1  ;; 0x40002808
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF430 0x2000      BICS     R0,R0,#0x80000
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable47_1  ;; 0x40002808
   \   00000038   0x6008             STR      R0,[R1, #+0]
   1854          
   1855            /* Configure the RTC_CR register */
   1856            RTC->CR |= (uint32_t)RTC_CalibOutput;
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable47_1  ;; 0x40002808
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x4320             ORRS     R0,R4,R0
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable47_1  ;; 0x40002808
   \   00000046   0x6008             STR      R0,[R1, #+0]
   1857          
   1858            /* Enable the write protection for RTC registers */
   1859            RTC->WPR = 0xFF;
   \   00000048   0x20FF             MOVS     R0,#+255
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40002824
   \   0000004E   0x6008             STR      R0,[R1, #+0]
   1860          }
   \   00000050   0xBD10             POP      {R4,PC}          ;; return
   1861          
   1862          /**
   1863            * @brief  Configures the Smooth Calibration Settings.
   1864            * @param  RTC_SmoothCalibPeriod : Select the Smooth Calibration Period.
   1865            *   This parameter can be can be one of the following values:
   1866            *     @arg RTC_SmoothCalibPeriod_32sec : The smooth calibration periode is 32s.
   1867            *     @arg RTC_SmoothCalibPeriod_16sec : The smooth calibration periode is 16s.
   1868            *     @arg RTC_SmoothCalibPeriod_8sec  : The smooth calibartion periode is 8s.
   1869            * @param  RTC_SmoothCalibPlusPulses : Select to Set or reset the CALP bit.
   1870            *   This parameter can be one of the following values:
   1871            *     @arg RTC_SmoothCalibPlusPulses_Set  : Add one RTCCLK puls every 2**11 pulses.
   1872            *     @arg RTC_SmoothCalibPlusPulses_Reset: No RTCCLK pulses are added.
   1873            * @param  RTC_SmouthCalibMinusPulsesValue: Select the value of CALM[8:0] bits.
   1874            *   This parameter can be one any value from 0 to 0x000001FF.
   1875            * @retval An ErrorStatus enumeration value:
   1876            *          - SUCCESS: RTC Calib registers are configured
   1877            *          - ERROR: RTC Calib registers are not configured
   1878          */

   \                                 In section .text, align 2, keep-with-next
   1879          ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod,
   1880                                            uint32_t RTC_SmoothCalibPlusPulses,
   1881                                            uint32_t RTC_SmouthCalibMinusPulsesValue)
   1882          {
   \                     RTC_SmoothCalibConfig: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1883            ErrorStatus status = ERROR;
   \   0000000A   0x2700             MOVS     R7,#+0
   1884            uint32_t recalpfcount = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1885          
   1886            /* Check the parameters */
   1887            assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD00B             BEQ.N    ??RTC_SmoothCalibConfig_0
   \   00000014   0xF5B4 0x5F00      CMP      R4,#+8192
   \   00000018   0xD008             BEQ.N    ??RTC_SmoothCalibConfig_0
   \   0000001A   0xF5B4 0x4F80      CMP      R4,#+16384
   \   0000001E   0xD005             BEQ.N    ??RTC_SmoothCalibConfig_0
   \   00000020   0xF240 0x715F      MOVW     R1,#+1887
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable47
   \   00000028   0x.... 0x....      BL       assert_failed
   1888            assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
   \                     ??RTC_SmoothCalibConfig_0: (+1)
   \   0000002C   0xF5B5 0x4F00      CMP      R5,#+32768
   \   00000030   0xD007             BEQ.N    ??RTC_SmoothCalibConfig_1
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD005             BEQ.N    ??RTC_SmoothCalibConfig_1
   \   00000036   0xF44F 0x61EC      MOV      R1,#+1888
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable47
   \   0000003E   0x.... 0x....      BL       assert_failed
   1889            assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));
   \                     ??RTC_SmoothCalibConfig_1: (+1)
   \   00000042   0xF5B6 0x7F00      CMP      R6,#+512
   \   00000046   0xD305             BCC.N    ??RTC_SmoothCalibConfig_2
   \   00000048   0xF240 0x7161      MOVW     R1,#+1889
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable47
   \   00000050   0x.... 0x....      BL       assert_failed
   1890          
   1891            /* Disable the write protection for RTC registers */
   1892            RTC->WPR = 0xCA;
   \                     ??RTC_SmoothCalibConfig_2: (+1)
   \   00000054   0x20CA             MOVS     R0,#+202
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40002824
   \   0000005A   0x6008             STR      R0,[R1, #+0]
   1893            RTC->WPR = 0x53;
   \   0000005C   0x2053             MOVS     R0,#+83
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40002824
   \   00000062   0x6008             STR      R0,[R1, #+0]
   1894            
   1895            /* check if a calibration is pending*/
   1896            if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable50_3  ;; 0x4000280c
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x03C0             LSLS     R0,R0,#+15
   \   0000006C   0xD50A             BPL.N    ??RTC_SmoothCalibConfig_3
   1897            {
   1898              /* wait until the Calibration is completed*/
   1899              while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
   \                     ??RTC_SmoothCalibConfig_4: (+1)
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable50_3  ;; 0x4000280c
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x03C0             LSLS     R0,R0,#+15
   \   00000076   0xD505             BPL.N    ??RTC_SmoothCalibConfig_3
   \   00000078   0xF5B8 0x3F00      CMP      R8,#+131072
   \   0000007C   0xD002             BEQ.N    ??RTC_SmoothCalibConfig_3
   1900              {
   1901                recalpfcount++;
   \   0000007E   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000082   0xE7F4             B.N      ??RTC_SmoothCalibConfig_4
   1902              }
   1903            }
   1904          
   1905            /* check if the calibration pending is completed or if there is no calibration operation at all*/
   1906            if ((RTC->ISR & RTC_ISR_RECALPF) == RESET)
   \                     ??RTC_SmoothCalibConfig_3: (+1)
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable50_3  ;; 0x4000280c
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0x03C0             LSLS     R0,R0,#+15
   \   0000008C   0xD408             BMI.N    ??RTC_SmoothCalibConfig_5
   1907            {
   1908              /* Configure the Smooth calibration settings */
   1909              RTC->CALR = (uint32_t)((uint32_t)RTC_SmoothCalibPeriod | (uint32_t)RTC_SmoothCalibPlusPulses | (uint32_t)RTC_SmouthCalibMinusPulsesValue);
   \   0000008E   0xEA55 0x0004      ORRS     R0,R5,R4
   \   00000092   0x4330             ORRS     R0,R6,R0
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable50_4  ;; 0x4000283c
   \   00000098   0x6008             STR      R0,[R1, #+0]
   1910          
   1911              status = SUCCESS;
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0x0007             MOVS     R7,R0
   \   0000009E   0xE001             B.N      ??RTC_SmoothCalibConfig_6
   1912            }
   1913            else
   1914            {
   1915              status = ERROR;
   \                     ??RTC_SmoothCalibConfig_5: (+1)
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x0007             MOVS     R7,R0
   1916            }
   1917          
   1918            /* Enable the write protection for RTC registers */
   1919            RTC->WPR = 0xFF;
   \                     ??RTC_SmoothCalibConfig_6: (+1)
   \   000000A4   0x20FF             MOVS     R0,#+255
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40002824
   \   000000AA   0x6008             STR      R0,[R1, #+0]
   1920            
   1921            return (ErrorStatus)(status);
   \   000000AC   0x0038             MOVS     R0,R7
   \   000000AE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1922          }
   1923          
   1924          /**
   1925            * @}
   1926            */
   1927          
   1928          
   1929          /** @defgroup RTC_Group8 TimeStamp configuration functions
   1930           *  @brief   TimeStamp configuration functions 
   1931           *
   1932          @verbatim   
   1933           ===============================================================================
   1934                                 TimeStamp configuration functions
   1935           ===============================================================================  
   1936          
   1937          @endverbatim
   1938            * @{
   1939            */
   1940          
   1941          /**
   1942            * @brief  Enables or Disables the RTC TimeStamp functionality with the 
   1943            *         specified time stamp pin stimulating edge.
   1944            * @param  RTC_TimeStampEdge: Specifies the pin edge on which the TimeStamp is 
   1945            *         activated.
   1946            *          This parameter can be one of the following:
   1947            *            @arg RTC_TimeStampEdge_Rising: the Time stamp event occurs on the rising 
   1948            *                                    edge of the related pin.
   1949            *            @arg RTC_TimeStampEdge_Falling: the Time stamp event occurs on the 
   1950            *                                     falling edge of the related pin.
   1951            * @param  NewState: new state of the TimeStamp.
   1952            *          This parameter can be: ENABLE or DISABLE.
   1953            * @retval None
   1954            */

   \                                 In section .text, align 2, keep-with-next
   1955          void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState)
   1956          {
   \                     RTC_TimeStampCmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1957            uint32_t tmpreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1958          
   1959            /* Check the parameters */
   1960            assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD007             BEQ.N    ??RTC_TimeStampCmd_0
   \   0000000C   0x2C08             CMP      R4,#+8
   \   0000000E   0xD005             BEQ.N    ??RTC_TimeStampCmd_0
   \   00000010   0xF44F 0x61F5      MOV      R1,#+1960
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable47
   \   00000018   0x.... 0x....      BL       assert_failed
   1961            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RTC_TimeStampCmd_0: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD008             BEQ.N    ??RTC_TimeStampCmd_1
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD005             BEQ.N    ??RTC_TimeStampCmd_1
   \   00000028   0xF240 0x71A9      MOVW     R1,#+1961
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable47
   \   00000030   0x.... 0x....      BL       assert_failed
   1962          
   1963            /* Get the RTC_CR register and clear the bits to be configured */
   1964            tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
   \                     ??RTC_TimeStampCmd_1: (+1)
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable47_1  ;; 0x40002808
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable50_5  ;; 0xfffff7f7
   \   0000003E   0x4008             ANDS     R0,R1,R0
   \   00000040   0x0006             MOVS     R6,R0
   1965          
   1966            /* Get the new configuration */
   1967            if (NewState != DISABLE)
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD003             BEQ.N    ??RTC_TimeStampCmd_2
   1968            {
   1969              tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
   \   00000048   0xF454 0x6000      ORRS     R0,R4,#0x800
   \   0000004C   0x4306             ORRS     R6,R0,R6
   \   0000004E   0xE000             B.N      ??RTC_TimeStampCmd_3
   1970            }
   1971            else
   1972            {
   1973              tmpreg |= (uint32_t)(RTC_TimeStampEdge);
   \                     ??RTC_TimeStampCmd_2: (+1)
   \   00000050   0x4326             ORRS     R6,R4,R6
   1974            }
   1975          
   1976            /* Disable the write protection for RTC registers */
   1977            RTC->WPR = 0xCA;
   \                     ??RTC_TimeStampCmd_3: (+1)
   \   00000052   0x20CA             MOVS     R0,#+202
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40002824
   \   00000058   0x6008             STR      R0,[R1, #+0]
   1978            RTC->WPR = 0x53;
   \   0000005A   0x2053             MOVS     R0,#+83
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40002824
   \   00000060   0x6008             STR      R0,[R1, #+0]
   1979          
   1980            /* Configure the Time Stamp TSEDGE and Enable bits */
   1981            RTC->CR = (uint32_t)tmpreg;
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable47_1  ;; 0x40002808
   \   00000066   0x6006             STR      R6,[R0, #+0]
   1982          
   1983            /* Enable the write protection for RTC registers */
   1984            RTC->WPR = 0xFF; 
   \   00000068   0x20FF             MOVS     R0,#+255
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40002824
   \   0000006E   0x6008             STR      R0,[R1, #+0]
   1985          }
   \   00000070   0xBD70             POP      {R4-R6,PC}       ;; return
   1986          
   1987          /**
   1988            * @brief  Get the RTC TimeStamp value and masks.
   1989            * @param  RTC_Format: specifies the format of the output parameters.
   1990            *          This parameter can be one of the following values:
   1991            *            @arg RTC_Format_BIN: Binary data format 
   1992            *            @arg RTC_Format_BCD: BCD data format
   1993            * @param RTC_StampTimeStruct: pointer to a RTC_TimeTypeDef structure that will 
   1994            *                             contains the TimeStamp time values. 
   1995            * @param RTC_StampDateStruct: pointer to a RTC_DateTypeDef structure that will 
   1996            *                             contains the TimeStamp date values.     
   1997            * @retval None
   1998            */

   \                                 In section .text, align 2, keep-with-next
   1999          void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
   2000                                                RTC_DateTypeDef* RTC_StampDateStruct)
   2001          {
   \                     RTC_GetTimeStamp: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   2002            uint32_t tmptime = 0, tmpdate = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   2003          
   2004            /* Check the parameters */
   2005            assert_param(IS_RTC_FORMAT(RTC_Format));
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD007             BEQ.N    ??RTC_GetTimeStamp_0
   \   00000014   0x2C01             CMP      R4,#+1
   \   00000016   0xD005             BEQ.N    ??RTC_GetTimeStamp_0
   \   00000018   0xF240 0x71D5      MOVW     R1,#+2005
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable47
   \   00000020   0x.... 0x....      BL       assert_failed
   2006          
   2007            /* Get the TimeStamp time and date registers values */
   2008            tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
   \                     ??RTC_GetTimeStamp_0: (+1)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable50_6  ;; 0x40002830
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable50_7  ;; 0x7f7f7f
   \   0000002E   0x4008             ANDS     R0,R1,R0
   \   00000030   0x0007             MOVS     R7,R0
   2009            tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable50_8  ;; 0x40002834
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x....             LDR.N    R1,??DataTable32  ;; 0xffff3f
   \   0000003A   0x4008             ANDS     R0,R1,R0
   \   0000003C   0x4680             MOV      R8,R0
   2010          
   2011            /* Fill the Time structure fields with the read parameters */
   2012            RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
   \   0000003E   0x0C38             LSRS     R0,R7,#+16
   \   00000040   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   00000044   0x7028             STRB     R0,[R5, #+0]
   2013            RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
   \   00000046   0x0A38             LSRS     R0,R7,#+8
   \   00000048   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   0000004C   0x7068             STRB     R0,[R5, #+1]
   2014            RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
   \   0000004E   0xF017 0x007F      ANDS     R0,R7,#0x7F
   \   00000052   0x70A8             STRB     R0,[R5, #+2]
   2015            RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
   \   00000054   0x0C38             LSRS     R0,R7,#+16
   \   00000056   0xF010 0x0040      ANDS     R0,R0,#0x40
   \   0000005A   0x70E8             STRB     R0,[R5, #+3]
   2016          
   2017            /* Fill the Date structure fields with the read parameters */
   2018            RTC_StampDateStruct->RTC_Year = 0;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x70F0             STRB     R0,[R6, #+3]
   2019            RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
   \   00000060   0xEA5F 0x2018      LSRS     R0,R8,#+8
   \   00000064   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   00000068   0x7070             STRB     R0,[R6, #+1]
   2020            RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
   \   0000006A   0xF018 0x003F      ANDS     R0,R8,#0x3F
   \   0000006E   0x70B0             STRB     R0,[R6, #+2]
   2021            RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
   \   00000070   0xEA5F 0x3058      LSRS     R0,R8,#+13
   \   00000074   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000078   0x7030             STRB     R0,[R6, #+0]
   2022          
   2023            /* Check the input parameters format */
   2024            if (RTC_Format == RTC_Format_BIN)
   \   0000007A   0x2C00             CMP      R4,#+0
   \   0000007C   0xD117             BNE.N    ??RTC_GetTimeStamp_1
   2025            {
   2026              /* Convert the Time structure parameters to Binary format */
   2027              RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
   \   0000007E   0x7828             LDRB     R0,[R5, #+0]
   \   00000080   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000084   0x7028             STRB     R0,[R5, #+0]
   2028              RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
   \   00000086   0x7868             LDRB     R0,[R5, #+1]
   \   00000088   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   0000008C   0x7068             STRB     R0,[R5, #+1]
   2029              RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
   \   0000008E   0x78A8             LDRB     R0,[R5, #+2]
   \   00000090   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000094   0x70A8             STRB     R0,[R5, #+2]
   2030          
   2031              /* Convert the Date structure parameters to Binary format */
   2032              RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
   \   00000096   0x7870             LDRB     R0,[R6, #+1]
   \   00000098   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   0000009C   0x7070             STRB     R0,[R6, #+1]
   2033              RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
   \   0000009E   0x78B0             LDRB     R0,[R6, #+2]
   \   000000A0   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   000000A4   0x70B0             STRB     R0,[R6, #+2]
   2034              RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
   \   000000A6   0x7830             LDRB     R0,[R6, #+0]
   \   000000A8   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   000000AC   0x7030             STRB     R0,[R6, #+0]
   2035            }
   2036          }
   \                     ??RTC_GetTimeStamp_1: (+1)
   \   000000AE   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2037          
   2038          /**
   2039            * @brief  Get the RTC timestamp Subseconds value.
   2040            * @param  None
   2041            * @retval RTC current timestamp Subseconds value.
   2042            */

   \                                 In section .text, align 2, keep-with-next
   2043          uint32_t RTC_GetTimeStampSubSecond(void)
   2044          {
   2045            /* Get timestamp subseconds values from the correspondent registers */
   2046            return (uint32_t)(RTC->TSSSR);
   \                     RTC_GetTimeStampSubSecond: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable50_9  ;; 0x40002838
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return
   2047          }
   2048          
   2049          /**
   2050            * @}
   2051            */
   2052          
   2053          /** @defgroup RTC_Group9 Tampers configuration functions
   2054           *  @brief   Tampers configuration functions 
   2055           *
   2056          @verbatim   
   2057           ===============================================================================
   2058                                 Tampers configuration functions
   2059           ===============================================================================  
   2060          
   2061          @endverbatim
   2062            * @{
   2063            */
   2064          
   2065          /**
   2066            * @brief  Configures the select Tamper pin edge.
   2067            * @param  RTC_Tamper: Selected tamper pin.
   2068            *          This parameter can be RTC_Tamper_1.
   2069            * @param  RTC_TamperTrigger: Specifies the trigger on the tamper pin that 
   2070            *         stimulates tamper event. 
   2071            *   This parameter can be one of the following values:
   2072            *     @arg RTC_TamperTrigger_RisingEdge: Rising Edge of the tamper pin causes tamper event.
   2073            *     @arg RTC_TamperTrigger_FallingEdge: Falling Edge of the tamper pin causes tamper event.
   2074            *     @arg RTC_TamperTrigger_LowLevel: Low Level of the tamper pin causes tamper event.
   2075            *     @arg RTC_TamperTrigger_HighLevel: High Level of the tamper pin causes tamper event.
   2076            * @retval None
   2077            */

   \                                 In section .text, align 2, keep-with-next
   2078          void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
   2079          {
   \                     RTC_TamperTriggerConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2080            /* Check the parameters */
   2081            assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??RTC_TamperTriggerConfig_0
   \   0000000A   0xF640 0x0121      MOVW     R1,#+2081
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable47
   \   00000012   0x.... 0x....      BL       assert_failed
   2082            assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
   \                     ??RTC_TamperTriggerConfig_0: (+1)
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD00B             BEQ.N    ??RTC_TamperTriggerConfig_1
   \   0000001A   0x2D01             CMP      R5,#+1
   \   0000001C   0xD009             BEQ.N    ??RTC_TamperTriggerConfig_1
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??RTC_TamperTriggerConfig_1
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD005             BEQ.N    ??RTC_TamperTriggerConfig_1
   \   00000026   0xF640 0x0122      MOVW     R1,#+2082
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable47
   \   0000002E   0x.... 0x....      BL       assert_failed
   2083           
   2084            if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
   \                     ??RTC_TamperTriggerConfig_1: (+1)
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD108             BNE.N    ??RTC_TamperTriggerConfig_2
   2085            {  
   2086              /* Configure the RTC_TAFCR register */
   2087              RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable50_10  ;; 0x40002840
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xEA30 0x0044      BICS     R0,R0,R4, LSL #+1
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable50_10  ;; 0x40002840
   \   00000044   0x6008             STR      R0,[R1, #+0]
   \   00000046   0xE007             B.N      ??RTC_TamperTriggerConfig_3
   2088            }
   2089            else
   2090            { 
   2091              /* Configure the RTC_TAFCR register */
   2092              RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
   \                     ??RTC_TamperTriggerConfig_2: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable50_10  ;; 0x40002840
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0xEA50 0x0044      ORRS     R0,R0,R4, LSL #+1
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable50_10  ;; 0x40002840
   \   00000056   0x6008             STR      R0,[R1, #+0]
   2093            }  
   2094          }
   \                     ??RTC_TamperTriggerConfig_3: (+1)
   \   00000058   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2095          
   2096          /**
   2097            * @brief  Enables or Disables the Tamper detection.
   2098            * @param  RTC_Tamper: Selected tamper pin.
   2099            *          This parameter can be RTC_Tamper_1.
   2100            * @param  NewState: new state of the tamper pin.
   2101            *          This parameter can be: ENABLE or DISABLE.                   
   2102            * @retval None
   2103            */

   \                                 In section .text, align 2, keep-with-next
   2104          void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
   2105          {
   \                     RTC_TamperCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2106            /* Check the parameters */
   2107            assert_param(IS_RTC_TAMPER(RTC_Tamper));  
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??RTC_TamperCmd_0
   \   0000000A   0xF640 0x013B      MOVW     R1,#+2107
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable47
   \   00000012   0x.... 0x....      BL       assert_failed
   2108            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RTC_TamperCmd_0: (+1)
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD008             BEQ.N    ??RTC_TamperCmd_1
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D01             CMP      R5,#+1
   \   00000020   0xD005             BEQ.N    ??RTC_TamperCmd_1
   \   00000022   0xF640 0x013C      MOVW     R1,#+2108
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable47
   \   0000002A   0x.... 0x....      BL       assert_failed
   2109            
   2110            if (NewState != DISABLE)
   \                     ??RTC_TamperCmd_1: (+1)
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD007             BEQ.N    ??RTC_TamperCmd_2
   2111            {
   2112              /* Enable the selected Tamper pin */
   2113              RTC->TAFCR |= (uint32_t)RTC_Tamper;
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable50_10  ;; 0x40002840
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x4320             ORRS     R0,R4,R0
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable50_10  ;; 0x40002840
   \   00000040   0x6008             STR      R0,[R1, #+0]
   \   00000042   0xE006             B.N      ??RTC_TamperCmd_3
   2114            }
   2115            else
   2116            {
   2117              /* Disable the selected Tamper pin */
   2118              RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
   \                     ??RTC_TamperCmd_2: (+1)
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable50_10  ;; 0x40002840
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x43A0             BICS     R0,R0,R4
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable50_10  ;; 0x40002840
   \   00000050   0x6008             STR      R0,[R1, #+0]
   2119            }  
   2120          }
   \                     ??RTC_TamperCmd_3: (+1)
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2121          
   2122          /**
   2123            * @brief  Configures the Tampers Filter.
   2124            * @param  RTC_TamperFilter: Specifies the tampers filter.
   2125            *   This parameter can be one of the following values:
   2126            *     @arg RTC_TamperFilter_Disable: Tamper filter is disabled.
   2127            *     @arg RTC_TamperFilter_2Sample: Tamper is activated after 2 consecutive 
   2128            *                                    samples at the active level 
   2129            *     @arg RTC_TamperFilter_4Sample: Tamper is activated after 4 consecutive 
   2130            *                                    samples at the active level
   2131            *     @arg RTC_TamperFilter_8Sample: Tamper is activated after 8 consecutive 
   2132            *                                    samples at the active level 
   2133            * @retval None
   2134            */

   \                                 In section .text, align 2, keep-with-next
   2135          void RTC_TamperFilterConfig(uint32_t RTC_TamperFilter)
   2136          {
   \                     RTC_TamperFilterConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2137            /* Check the parameters */
   2138            assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD00E             BEQ.N    ??RTC_TamperFilterConfig_0
   \   00000008   0xF5B4 0x6F00      CMP      R4,#+2048
   \   0000000C   0xD00B             BEQ.N    ??RTC_TamperFilterConfig_0
   \   0000000E   0xF5B4 0x5F80      CMP      R4,#+4096
   \   00000012   0xD008             BEQ.N    ??RTC_TamperFilterConfig_0
   \   00000014   0xF5B4 0x5FC0      CMP      R4,#+6144
   \   00000018   0xD005             BEQ.N    ??RTC_TamperFilterConfig_0
   \   0000001A   0xF640 0x015A      MOVW     R1,#+2138
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable47
   \   00000022   0x.... 0x....      BL       assert_failed
   2139             
   2140            /* Clear TAMPFLT[1:0] bits in the RTC_TAFCR register */
   2141            RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFLT);
   \                     ??RTC_TamperFilterConfig_0: (+1)
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable50_10  ;; 0x40002840
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0xF430 0x50C0      BICS     R0,R0,#0x1800
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable50_10  ;; 0x40002840
   \   00000034   0x6008             STR      R0,[R1, #+0]
   2142          
   2143            /* Configure the RTC_TAFCR register */
   2144            RTC->TAFCR |= (uint32_t)RTC_TamperFilter;
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable50_10  ;; 0x40002840
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x4320             ORRS     R0,R4,R0
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable50_10  ;; 0x40002840
   \   00000042   0x6008             STR      R0,[R1, #+0]
   2145          }
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
   2146          
   2147          /**
   2148            * @brief  Configures the Tampers Sampling Frequency.
   2149            * @param  RTC_TamperSamplingFreq: Specifies the tampers Sampling Frequency.
   2150            *   This parameter can be one of the following values:
   2151            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div32768: Each of the tamper inputs are sampled
   2152            *                                           with a frequency =  RTCCLK / 32768
   2153            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div16384: Each of the tamper inputs are sampled
   2154            *                                           with a frequency =  RTCCLK / 16384
   2155            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div8192: Each of the tamper inputs are sampled
   2156            *                                           with a frequency =  RTCCLK / 8192
   2157            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div4096: Each of the tamper inputs are sampled
   2158            *                                           with a frequency =  RTCCLK / 4096
   2159            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div2048: Each of the tamper inputs are sampled
   2160            *                                           with a frequency =  RTCCLK / 2048
   2161            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div1024: Each of the tamper inputs are sampled
   2162            *                                           with a frequency =  RTCCLK / 1024
   2163            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div512: Each of the tamper inputs are sampled
   2164            *                                           with a frequency =  RTCCLK / 512  
   2165            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div256: Each of the tamper inputs are sampled
   2166            *                                           with a frequency =  RTCCLK / 256  
   2167            * @retval None
   2168            */

   \                                 In section .text, align 2, keep-with-next
   2169          void RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq)
   2170          {
   \                     RTC_TamperSamplingFreqConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2171            /* Check the parameters */
   2172            assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD01A             BEQ.N    ??RTC_TamperSamplingFreqConfig_0
   \   00000008   0xF5B4 0x7F80      CMP      R4,#+256
   \   0000000C   0xD017             BEQ.N    ??RTC_TamperSamplingFreqConfig_0
   \   0000000E   0xF5B4 0x7F00      CMP      R4,#+512
   \   00000012   0xD014             BEQ.N    ??RTC_TamperSamplingFreqConfig_0
   \   00000014   0xF5B4 0x7F40      CMP      R4,#+768
   \   00000018   0xD011             BEQ.N    ??RTC_TamperSamplingFreqConfig_0
   \   0000001A   0xF5B4 0x6F80      CMP      R4,#+1024
   \   0000001E   0xD00E             BEQ.N    ??RTC_TamperSamplingFreqConfig_0
   \   00000020   0xF5B4 0x6FA0      CMP      R4,#+1280
   \   00000024   0xD00B             BEQ.N    ??RTC_TamperSamplingFreqConfig_0
   \   00000026   0xF5B4 0x6FC0      CMP      R4,#+1536
   \   0000002A   0xD008             BEQ.N    ??RTC_TamperSamplingFreqConfig_0
   \   0000002C   0xF5B4 0x6FE0      CMP      R4,#+1792
   \   00000030   0xD005             BEQ.N    ??RTC_TamperSamplingFreqConfig_0
   \   00000032   0xF640 0x017C      MOVW     R1,#+2172
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable47
   \   0000003A   0x.... 0x....      BL       assert_failed
   2173           
   2174            /* Clear TAMPFREQ[2:0] bits in the RTC_TAFCR register */
   2175            RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFREQ);
   \                     ??RTC_TamperSamplingFreqConfig_0: (+1)
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable50_10  ;; 0x40002840
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0xF430 0x60E0      BICS     R0,R0,#0x700
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable50_10  ;; 0x40002840
   \   0000004C   0x6008             STR      R0,[R1, #+0]
   2176          
   2177            /* Configure the RTC_TAFCR register */
   2178            RTC->TAFCR |= (uint32_t)RTC_TamperSamplingFreq;
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable50_10  ;; 0x40002840
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x4320             ORRS     R0,R4,R0
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable50_10  ;; 0x40002840
   \   0000005A   0x6008             STR      R0,[R1, #+0]
   2179          }
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
   2180          
   2181          /**
   2182            * @brief  Configures the Tampers Pins input Precharge Duration.
   2183            * @param  RTC_TamperPrechargeDuration: Specifies the Tampers Pins input
   2184            *         Precharge Duration.
   2185            *   This parameter can be one of the following values:
   2186            *     @arg RTC_TamperPrechargeDuration_1RTCCLK: Tamper pins are pre-charged before sampling during 1 RTCCLK cycle
   2187            *     @arg RTC_TamperPrechargeDuration_2RTCCLK: Tamper pins are pre-charged before sampling during 2 RTCCLK cycle
   2188            *     @arg RTC_TamperPrechargeDuration_4RTCCLK: Tamper pins are pre-charged before sampling during 4 RTCCLK cycle    
   2189            *     @arg RTC_TamperPrechargeDuration_8RTCCLK: Tamper pins are pre-charged before sampling during 8 RTCCLK cycle
   2190            * @retval None
   2191            */

   \                                 In section .text, align 2, keep-with-next
   2192          void RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration)
   2193          {
   \                     RTC_TamperPinsPrechargeDuration: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2194            /* Check the parameters */
   2195            assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(RTC_TamperPrechargeDuration));
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD00E             BEQ.N    ??RTC_TamperPinsPrechargeDuration_0
   \   00000008   0xF5B4 0x5F00      CMP      R4,#+8192
   \   0000000C   0xD00B             BEQ.N    ??RTC_TamperPinsPrechargeDuration_0
   \   0000000E   0xF5B4 0x4F80      CMP      R4,#+16384
   \   00000012   0xD008             BEQ.N    ??RTC_TamperPinsPrechargeDuration_0
   \   00000014   0xF5B4 0x4FC0      CMP      R4,#+24576
   \   00000018   0xD005             BEQ.N    ??RTC_TamperPinsPrechargeDuration_0
   \   0000001A   0xF640 0x0193      MOVW     R1,#+2195
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable47
   \   00000022   0x.... 0x....      BL       assert_failed
   2196             
   2197            /* Clear TAMPPRCH[1:0] bits in the RTC_TAFCR register */
   2198            RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPPRCH);
   \                     ??RTC_TamperPinsPrechargeDuration_0: (+1)
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable50_10  ;; 0x40002840
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0xF430 0x40C0      BICS     R0,R0,#0x6000
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable50_10  ;; 0x40002840
   \   00000034   0x6008             STR      R0,[R1, #+0]
   2199          
   2200            /* Configure the RTC_TAFCR register */
   2201            RTC->TAFCR |= (uint32_t)RTC_TamperPrechargeDuration;
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable50_10  ;; 0x40002840
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x4320             ORRS     R0,R4,R0
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable50_10  ;; 0x40002840
   \   00000042   0x6008             STR      R0,[R1, #+0]
   2202          }
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
   2203          
   2204          /**
   2205            * @brief  Enables or Disables the TimeStamp on Tamper Detection Event.
   2206            * @note   The timestamp is valid even the TSE bit in tamper control register 
   2207            *         is reset.   
   2208            * @param  NewState: new state of the timestamp on tamper event.
   2209            *         This parameter can be: ENABLE or DISABLE.
   2210            * @retval None
   2211            */

   \                                 In section .text, align 2, keep-with-next
   2212          void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState)
   2213          {
   \                     RTC_TimeStampOnTamperDetectionCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2214            /* Check the parameters */
   2215            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??RTC_TimeStampOnTamperDetectionCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??RTC_TimeStampOnTamperDetectionCmd_0
   \   00000010   0xF640 0x01A7      MOVW     R1,#+2215
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable47
   \   00000018   0x.... 0x....      BL       assert_failed
   2216             
   2217            if (NewState != DISABLE)
   \                     ??RTC_TimeStampOnTamperDetectionCmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD008             BEQ.N    ??RTC_TimeStampOnTamperDetectionCmd_1
   2218            {
   2219              /* Save timestamp on tamper detection event */
   2220              RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable50_10  ;; 0x40002840
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable50_10  ;; 0x40002840
   \   00000030   0x6008             STR      R0,[R1, #+0]
   \   00000032   0xE007             B.N      ??RTC_TimeStampOnTamperDetectionCmd_2
   2221            }
   2222            else
   2223            {
   2224              /* Tamper detection does not cause a timestamp to be saved */
   2225              RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPTS;    
   \                     ??RTC_TimeStampOnTamperDetectionCmd_1: (+1)
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable50_10  ;; 0x40002840
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF030 0x0080      BICS     R0,R0,#0x80
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable50_10  ;; 0x40002840
   \   00000042   0x6008             STR      R0,[R1, #+0]
   2226            }
   2227          }
   \                     ??RTC_TimeStampOnTamperDetectionCmd_2: (+1)
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
   2228          
   2229          /**
   2230            * @brief  Enables or Disables the Precharge of Tamper pin.
   2231            * @param  NewState: new state of tamper pull up.
   2232            *   This parameter can be: ENABLE or DISABLE.                   
   2233            * @retval None
   2234            */

   \                                 In section .text, align 2, keep-with-next
   2235          void RTC_TamperPullUpCmd(FunctionalState NewState)
   2236          {
   \                     RTC_TamperPullUpCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2237            /* Check the parameters */
   2238            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??RTC_TamperPullUpCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??RTC_TamperPullUpCmd_0
   \   00000010   0xF640 0x01BE      MOVW     R1,#+2238
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable47
   \   00000018   0x.... 0x....      BL       assert_failed
   2239            
   2240           if (NewState != DISABLE)
   \                     ??RTC_TamperPullUpCmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD008             BEQ.N    ??RTC_TamperPullUpCmd_1
   2241            {
   2242              /* Enable precharge of the selected Tamper pin */
   2243              RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable50_10  ;; 0x40002840
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable50_10  ;; 0x40002840
   \   00000030   0x6008             STR      R0,[R1, #+0]
   \   00000032   0xE007             B.N      ??RTC_TamperPullUpCmd_2
   2244            }
   2245            else
   2246            {
   2247              /* Disable precharge of the selected Tamper pin */
   2248              RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPPUDIS;    
   \                     ??RTC_TamperPullUpCmd_1: (+1)
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable50_10  ;; 0x40002840
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable50_10  ;; 0x40002840
   \   00000042   0x6008             STR      R0,[R1, #+0]
   2249            } 
   2250          }
   \                     ??RTC_TamperPullUpCmd_2: (+1)
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
   2251          
   2252          /**
   2253            * @}
   2254            */
   2255          
   2256          /** @defgroup RTC_Group10 Backup Data Registers configuration functions
   2257           *  @brief   Backup Data Registers configuration functions  
   2258           *
   2259          @verbatim   
   2260           ===============================================================================
   2261                                 Backup Data Registers configuration functions 
   2262           ===============================================================================  
   2263          
   2264          @endverbatim
   2265            * @{
   2266            */
   2267          
   2268          /**
   2269            * @brief  Writes a data in a specified RTC Backup data register.
   2270            * @param  RTC_BKP_DR: RTC Backup data Register number.
   2271            *          This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
   2272            *                          specify the register.
   2273            * @param  Data: Data to be written in the specified RTC Backup data register.                     
   2274            * @retval None
   2275            */

   \                                 In section .text, align 2, keep-with-next
   2276          void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
   2277          {
   \                     RTC_WriteBackupRegister: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2278            __IO uint32_t tmp = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
   2279            
   2280            /* Check the parameters */
   2281            assert_param(IS_RTC_BKP(RTC_BKP_DR));
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD02A             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000000E   0x2C01             CMP      R4,#+1
   \   00000010   0xD028             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000012   0x2C02             CMP      R4,#+2
   \   00000014   0xD026             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000016   0x2C03             CMP      R4,#+3
   \   00000018   0xD024             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000001A   0x2C04             CMP      R4,#+4
   \   0000001C   0xD022             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000001E   0x2C05             CMP      R4,#+5
   \   00000020   0xD020             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000022   0x2C06             CMP      R4,#+6
   \   00000024   0xD01E             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000026   0x2C07             CMP      R4,#+7
   \   00000028   0xD01C             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000002A   0x2C08             CMP      R4,#+8
   \   0000002C   0xD01A             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000002E   0x2C09             CMP      R4,#+9
   \   00000030   0xD018             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000032   0x2C0A             CMP      R4,#+10
   \   00000034   0xD016             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000036   0x2C0B             CMP      R4,#+11
   \   00000038   0xD014             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000003A   0x2C0C             CMP      R4,#+12
   \   0000003C   0xD012             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000003E   0x2C0D             CMP      R4,#+13
   \   00000040   0xD010             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000042   0x2C0E             CMP      R4,#+14
   \   00000044   0xD00E             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000046   0x2C0F             CMP      R4,#+15
   \   00000048   0xD00C             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000004A   0x2C10             CMP      R4,#+16
   \   0000004C   0xD00A             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000004E   0x2C11             CMP      R4,#+17
   \   00000050   0xD008             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000052   0x2C12             CMP      R4,#+18
   \   00000054   0xD006             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000056   0x2C13             CMP      R4,#+19
   \   00000058   0xD004             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000005A   0xF640 0x01E9      MOVW     R1,#+2281
   \   0000005E   0x....             LDR.N    R0,??DataTable47
   \   00000060   0x.... 0x....      BL       assert_failed
   2282          
   2283            tmp = RTC_BASE + 0x50;
   \                     ??RTC_WriteBackupRegister_0: (+1)
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable50_11  ;; 0x40002850
   \   00000068   0x9000             STR      R0,[SP, #+0]
   2284            tmp += (RTC_BKP_DR * 4);
   \   0000006A   0x9800             LDR      R0,[SP, #+0]
   \   0000006C   0xEB10 0x0084      ADDS     R0,R0,R4, LSL #+2
   \   00000070   0x9000             STR      R0,[SP, #+0]
   2285          
   2286            /* Write the specified register */
   2287            *(__IO uint32_t *)tmp = (uint32_t)Data;
   \   00000072   0x9800             LDR      R0,[SP, #+0]
   \   00000074   0x6005             STR      R5,[R0, #+0]
   2288          }
   \   00000076   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2289          
   2290          /**
   2291            * @brief  Reads data from the specified RTC Backup data Register.
   2292            * @param  RTC_BKP_DR: RTC Backup data Register number.
   2293            *          This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
   2294            *                          specify the register.                   
   2295            * @retval None
   2296            */

   \                                 In section .text, align 2, keep-with-next
   2297          uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
   2298          {
   \                     RTC_ReadBackupRegister: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   2299            __IO uint32_t tmp = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
   2300            
   2301            /* Check the parameters */
   2302            assert_param(IS_RTC_BKP(RTC_BKP_DR));
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD02A             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000000E   0x2C01             CMP      R4,#+1
   \   00000010   0xD028             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000012   0x2C02             CMP      R4,#+2
   \   00000014   0xD026             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000016   0x2C03             CMP      R4,#+3
   \   00000018   0xD024             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000001A   0x2C04             CMP      R4,#+4
   \   0000001C   0xD022             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000001E   0x2C05             CMP      R4,#+5
   \   00000020   0xD020             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000022   0x2C06             CMP      R4,#+6
   \   00000024   0xD01E             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000026   0x2C07             CMP      R4,#+7
   \   00000028   0xD01C             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000002A   0x2C08             CMP      R4,#+8
   \   0000002C   0xD01A             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000002E   0x2C09             CMP      R4,#+9
   \   00000030   0xD018             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000032   0x2C0A             CMP      R4,#+10
   \   00000034   0xD016             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000036   0x2C0B             CMP      R4,#+11
   \   00000038   0xD014             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000003A   0x2C0C             CMP      R4,#+12
   \   0000003C   0xD012             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000003E   0x2C0D             CMP      R4,#+13
   \   00000040   0xD010             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000042   0x2C0E             CMP      R4,#+14
   \   00000044   0xD00E             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000046   0x2C0F             CMP      R4,#+15
   \   00000048   0xD00C             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000004A   0x2C10             CMP      R4,#+16
   \   0000004C   0xD00A             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000004E   0x2C11             CMP      R4,#+17
   \   00000050   0xD008             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000052   0x2C12             CMP      R4,#+18
   \   00000054   0xD006             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000056   0x2C13             CMP      R4,#+19
   \   00000058   0xD004             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000005A   0xF640 0x01FE      MOVW     R1,#+2302
   \   0000005E   0x....             LDR.N    R0,??DataTable47
   \   00000060   0x.... 0x....      BL       assert_failed
   2303          
   2304            tmp = RTC_BASE + 0x50;
   \                     ??RTC_ReadBackupRegister_0: (+1)
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable50_11  ;; 0x40002850
   \   00000068   0x9000             STR      R0,[SP, #+0]
   2305            tmp += (RTC_BKP_DR * 4);
   \   0000006A   0x9800             LDR      R0,[SP, #+0]
   \   0000006C   0xEB10 0x0084      ADDS     R0,R0,R4, LSL #+2
   \   00000070   0x9000             STR      R0,[SP, #+0]
   2306            
   2307            /* Read the specified register */
   2308            return (*(__IO uint32_t *)tmp);
   \   00000072   0x9800             LDR      R0,[SP, #+0]
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   2309          }
   2310          
   2311          /**
   2312            * @}
   2313            */
   2314          
   2315          /** @defgroup RTC_Group11 RTC Tamper and TimeStamp Pins Selection and Output Type Config configuration functions
   2316           *  @brief   RTC Tamper and TimeStamp Pins Selection and Output Type Config 
   2317           *           configuration functions  
   2318           *
   2319          @verbatim   
   2320           ===============================================================================
   2321            RTC Tamper and TimeStamp Pins Selection and Output Type Config configuration 
   2322            functions 
   2323           ===============================================================================  
   2324          
   2325          @endverbatim
   2326            * @{
   2327            */
   2328          
   2329          /**
   2330            * @brief  Selects the RTC Tamper Pin.
   2331            * @param  RTC_TamperPin: specifies the RTC Tamper Pin.
   2332            *          This parameter can be one of the following values:
   2333            *            @arg RTC_TamperPin_PC13: PC13 is selected as RTC Tamper Pin.
   2334            *            @arg RTC_TamperPin_PI8: PI8 is selected as RTC Tamper Pin.    
   2335            * @retval None
   2336            */

   \                                 In section .text, align 2, keep-with-next
   2337          void RTC_TamperPinSelection(uint32_t RTC_TamperPin)
   2338          {
   \                     RTC_TamperPinSelection: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2339            /* Check the parameters */
   2340            assert_param(IS_RTC_TAMPER_PIN(RTC_TamperPin));
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD007             BEQ.N    ??RTC_TamperPinSelection_0
   \   00000008   0xF5B4 0x3F80      CMP      R4,#+65536
   \   0000000C   0xD004             BEQ.N    ??RTC_TamperPinSelection_0
   \   0000000E   0xF640 0x1124      MOVW     R1,#+2340
   \   00000012   0x....             LDR.N    R0,??DataTable47
   \   00000014   0x.... 0x....      BL       assert_failed
   2341            
   2342            RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPINSEL);
   \                     ??RTC_TamperPinSelection_0: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable50_10  ;; 0x40002840
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   00000020   0x....             LDR.N    R1,??DataTable50_10  ;; 0x40002840
   \   00000022   0x6008             STR      R0,[R1, #+0]
   2343            RTC->TAFCR |= (uint32_t)(RTC_TamperPin);  
   \   00000024   0x....             LDR.N    R0,??DataTable50_10  ;; 0x40002840
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x4320             ORRS     R0,R4,R0
   \   0000002A   0x....             LDR.N    R1,??DataTable50_10  ;; 0x40002840
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   2344          }
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
   2345          
   2346          /**
   2347            * @brief  Selects the RTC TimeStamp Pin.
   2348            * @param  RTC_TimeStampPin: specifies the RTC TimeStamp Pin.
   2349            *          This parameter can be one of the following values:
   2350            *            @arg RTC_TimeStampPin_PC13: PC13 is selected as RTC TimeStamp Pin.
   2351            *            @arg RTC_TimeStampPin_PI8: PI8 is selected as RTC TimeStamp Pin.    
   2352            * @retval None
   2353            */

   \                                 In section .text, align 2, keep-with-next
   2354          void RTC_TimeStampPinSelection(uint32_t RTC_TimeStampPin)
   2355          {
   \                     RTC_TimeStampPinSelection: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2356            /* Check the parameters */
   2357            assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD007             BEQ.N    ??RTC_TimeStampPinSelection_0
   \   00000008   0xF5B4 0x3F00      CMP      R4,#+131072
   \   0000000C   0xD004             BEQ.N    ??RTC_TimeStampPinSelection_0
   \   0000000E   0xF640 0x1135      MOVW     R1,#+2357
   \   00000012   0x....             LDR.N    R0,??DataTable47
   \   00000014   0x.... 0x....      BL       assert_failed
   2358            
   2359            RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TSINSEL);
   \                     ??RTC_TimeStampPinSelection_0: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable50_10  ;; 0x40002840
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF430 0x3000      BICS     R0,R0,#0x20000
   \   00000020   0x....             LDR.N    R1,??DataTable50_10  ;; 0x40002840
   \   00000022   0x6008             STR      R0,[R1, #+0]
   2360            RTC->TAFCR |= (uint32_t)(RTC_TimeStampPin);  
   \   00000024   0x....             LDR.N    R0,??DataTable50_10  ;; 0x40002840
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x4320             ORRS     R0,R4,R0
   \   0000002A   0x....             LDR.N    R1,??DataTable50_10  ;; 0x40002840
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   2361          }
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
   2362          
   2363          /**
   2364            * @brief  Configures the RTC Output Pin mode. 
   2365            * @param  RTC_OutputType: specifies the RTC Output (PC13) pin mode.
   2366            *          This parameter can be one of the following values:
   2367            *            @arg RTC_OutputType_OpenDrain: RTC Output (PC13) is configured in 
   2368            *                                    Open Drain mode.
   2369            *            @arg RTC_OutputType_PushPull:  RTC Output (PC13) is configured in 
   2370            *                                    Push Pull mode.    
   2371            * @retval None
   2372            */

   \                                 In section .text, align 2, keep-with-next
   2373          void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
   2374          {
   \                     RTC_OutputTypeConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2375            /* Check the parameters */
   2376            assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD007             BEQ.N    ??RTC_OutputTypeConfig_0
   \   00000008   0xF5B4 0x2F80      CMP      R4,#+262144
   \   0000000C   0xD004             BEQ.N    ??RTC_OutputTypeConfig_0
   \   0000000E   0xF640 0x1148      MOVW     R1,#+2376
   \   00000012   0x....             LDR.N    R0,??DataTable47
   \   00000014   0x.... 0x....      BL       assert_failed
   2377            
   2378            RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
   \                     ??RTC_OutputTypeConfig_0: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable50_10  ;; 0x40002840
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   00000020   0x....             LDR.N    R1,??DataTable50_10  ;; 0x40002840
   \   00000022   0x6008             STR      R0,[R1, #+0]
   2379            RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
   \   00000024   0x....             LDR.N    R0,??DataTable50_10  ;; 0x40002840
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x4320             ORRS     R0,R4,R0
   \   0000002A   0x....             LDR.N    R1,??DataTable50_10  ;; 0x40002840
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   2380          }
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
   2381          
   2382          /**
   2383            * @}
   2384            */
   2385          
   2386          /** @defgroup RTC_Group12 Shift control synchronisation functions
   2387           *  @brief   Shift control synchronisation functions 
   2388           *
   2389          @verbatim   
   2390           ===============================================================================
   2391                             Shift control synchronisation functions
   2392           ===============================================================================  
   2393          
   2394          @endverbatim
   2395            * @{
   2396            */
   2397          
   2398          /**
   2399            * @brief  Configures the Synchronization Shift Control Settings.
   2400            * @note   When REFCKON is set, firmware must not write to Shift control register 
   2401            * @param  RTC_ShiftAdd1S : Select to add or not 1 second to the time Calendar.
   2402            *   This parameter can be one of the following values :
   2403            *     @arg RTC_ShiftAdd1S_Set  : Add one second to the clock calendar. 
   2404            *     @arg RTC_ShiftAdd1S_Reset: No effect.
   2405            * @param  RTC_ShiftSubFS: Select the number of Second Fractions to Substitute.
   2406            *         This parameter can be one any value from 0 to 0x7FFF.
   2407            * @retval An ErrorStatus enumeration value:
   2408            *          - SUCCESS: RTC Shift registers are configured
   2409            *          - ERROR: RTC Shift registers are not configured
   2410          */

   \                                 In section .text, align 2, keep-with-next
   2411          ErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS)
   2412          {
   \                     RTC_SynchroShiftConfig: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2413            ErrorStatus status = ERROR;
   \   00000006   0x2600             MOVS     R6,#+0
   2414            uint32_t shpfcount = 0;
   \   00000008   0x2700             MOVS     R7,#+0
   2415          
   2416            /* Check the parameters */
   2417            assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD007             BEQ.N    ??RTC_SynchroShiftConfig_0
   \   0000000E   0xF1B4 0x4F00      CMP      R4,#-2147483648
   \   00000012   0xD004             BEQ.N    ??RTC_SynchroShiftConfig_0
   \   00000014   0xF640 0x1171      MOVW     R1,#+2417
   \   00000018   0x....             LDR.N    R0,??DataTable47
   \   0000001A   0x.... 0x....      BL       assert_failed
   2418            assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));
   \                     ??RTC_SynchroShiftConfig_0: (+1)
   \   0000001E   0xF5B5 0x4F00      CMP      R5,#+32768
   \   00000022   0xD304             BCC.N    ??RTC_SynchroShiftConfig_1
   \   00000024   0xF640 0x1172      MOVW     R1,#+2418
   \   00000028   0x....             LDR.N    R0,??DataTable47
   \   0000002A   0x.... 0x....      BL       assert_failed
   2419          
   2420            /* Disable the write protection for RTC registers */
   2421            RTC->WPR = 0xCA;
   \                     ??RTC_SynchroShiftConfig_1: (+1)
   \   0000002E   0x20CA             MOVS     R0,#+202
   \   00000030   0x....             LDR.N    R1,??DataTable50  ;; 0x40002824
   \   00000032   0x6008             STR      R0,[R1, #+0]
   2422            RTC->WPR = 0x53;
   \   00000034   0x2053             MOVS     R0,#+83
   \   00000036   0x....             LDR.N    R1,??DataTable50  ;; 0x40002824
   \   00000038   0x6008             STR      R0,[R1, #+0]
   2423            
   2424            /* Check if a Shift is pending*/
   2425            if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
   \   0000003A   0x....             LDR.N    R0,??DataTable50_3  ;; 0x4000280c
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x0700             LSLS     R0,R0,#+28
   \   00000040   0xD508             BPL.N    ??RTC_SynchroShiftConfig_2
   2426            {
   2427              /* Wait until the shift is completed*/
   2428              while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
   \                     ??RTC_SynchroShiftConfig_3: (+1)
   \   00000042   0x....             LDR.N    R0,??DataTable50_3  ;; 0x4000280c
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x0700             LSLS     R0,R0,#+28
   \   00000048   0xD504             BPL.N    ??RTC_SynchroShiftConfig_2
   \   0000004A   0xF5B7 0x5F80      CMP      R7,#+4096
   \   0000004E   0xD001             BEQ.N    ??RTC_SynchroShiftConfig_2
   2429              {
   2430                shpfcount++;
   \   00000050   0x1C7F             ADDS     R7,R7,#+1
   \   00000052   0xE7F6             B.N      ??RTC_SynchroShiftConfig_3
   2431              }
   2432            }
   2433          
   2434            /* Check if the Shift pending is completed or if there is no Shift operation at all*/
   2435            if ((RTC->ISR & RTC_ISR_SHPF) == RESET)
   \                     ??RTC_SynchroShiftConfig_2: (+1)
   \   00000054   0x....             LDR.N    R0,??DataTable50_3  ;; 0x4000280c
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x0700             LSLS     R0,R0,#+28
   \   0000005A   0xD414             BMI.N    ??RTC_SynchroShiftConfig_4
   2436            {
   2437              /* check if the reference clock detection is disabled */
   2438              if((RTC->CR & RTC_CR_REFCKON) == RESET)
   \   0000005C   0x....             LDR.N    R0,??DataTable47_1  ;; 0x40002808
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x06C0             LSLS     R0,R0,#+27
   \   00000062   0xD40D             BMI.N    ??RTC_SynchroShiftConfig_5
   2439              {
   2440                /* Configure the Shift settings */
   2441                RTC->SHIFTR = (uint32_t)(uint32_t)(RTC_ShiftSubFS) | (uint32_t)(RTC_ShiftAdd1S);
   \   00000064   0xEA54 0x0005      ORRS     R0,R4,R5
   \   00000068   0x....             LDR.N    R1,??DataTable50_12  ;; 0x4000282c
   \   0000006A   0x6008             STR      R0,[R1, #+0]
   2442              
   2443                if(RTC_WaitForSynchro() == ERROR)
   \   0000006C   0x.... 0x....      BL       RTC_WaitForSynchro
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD102             BNE.N    ??RTC_SynchroShiftConfig_6
   2444                {
   2445                  status = ERROR;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x0006             MOVS     R6,R0
   \   00000078   0xE007             B.N      ??RTC_SynchroShiftConfig_7
   2446                }
   2447                else
   2448                {
   2449                  status = SUCCESS;
   \                     ??RTC_SynchroShiftConfig_6: (+1)
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0x0006             MOVS     R6,R0
   \   0000007E   0xE004             B.N      ??RTC_SynchroShiftConfig_7
   2450                }
   2451              }
   2452              else
   2453              {
   2454                status = ERROR;
   \                     ??RTC_SynchroShiftConfig_5: (+1)
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x0006             MOVS     R6,R0
   \   00000084   0xE001             B.N      ??RTC_SynchroShiftConfig_7
   2455              }
   2456            }
   2457            else
   2458            {
   2459              status = ERROR;
   \                     ??RTC_SynchroShiftConfig_4: (+1)
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x0006             MOVS     R6,R0
   2460            }
   2461          
   2462            /* Enable the write protection for RTC registers */
   2463            RTC->WPR = 0xFF;
   \                     ??RTC_SynchroShiftConfig_7: (+1)
   \   0000008A   0x20FF             MOVS     R0,#+255
   \   0000008C   0x....             LDR.N    R1,??DataTable50  ;; 0x40002824
   \   0000008E   0x6008             STR      R0,[R1, #+0]
   2464            
   2465            return (ErrorStatus)(status);
   \   00000090   0x0030             MOVS     R0,R6
   \   00000092   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000094   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2466          }
   2467          
   2468          /**
   2469            * @}
   2470            */
   2471          
   2472          /** @defgroup RTC_Group13 Interrupts and flags management functions
   2473           *  @brief   Interrupts and flags management functions  
   2474           *
   2475          @verbatim   
   2476           ===============================================================================
   2477                                 Interrupts and flags management functions
   2478           ===============================================================================  
   2479           All RTC interrupts are connected to the EXTI controller.
   2480           
   2481           - To enable the RTC Alarm interrupt, the following sequence is required:
   2482             - Configure and enable the EXTI Line 17 in interrupt mode and select the rising 
   2483               edge sensitivity using the EXTI_Init() function.
   2484             - Configure and enable the RTC_Alarm IRQ channel in the NVIC using the NVIC_Init()
   2485               function.
   2486             - Configure the RTC to generate RTC alarms (Alarm A and/or Alarm B) using
   2487               the RTC_SetAlarm() and RTC_AlarmCmd() functions.
   2488          
   2489           - To enable the RTC Wakeup interrupt, the following sequence is required:
   2490             - Configure and enable the EXTI Line 22 in interrupt mode and select the rising 
   2491               edge sensitivity using the EXTI_Init() function.
   2492             - Configure and enable the RTC_WKUP IRQ channel in the NVIC using the NVIC_Init()
   2493               function.
   2494             - Configure the RTC to generate the RTC wakeup timer event using the 
   2495               RTC_WakeUpClockConfig(), RTC_SetWakeUpCounter() and RTC_WakeUpCmd() functions.
   2496          
   2497           - To enable the RTC Tamper interrupt, the following sequence is required:
   2498             - Configure and enable the EXTI Line 21 in interrupt mode and select the rising 
   2499               edge sensitivity using the EXTI_Init() function.
   2500             - Configure and enable the TAMP_STAMP IRQ channel in the NVIC using the NVIC_Init()
   2501               function.
   2502             - Configure the RTC to detect the RTC tamper event using the 
   2503               RTC_TamperTriggerConfig() and RTC_TamperCmd() functions.
   2504          
   2505           - To enable the RTC TimeStamp interrupt, the following sequence is required:
   2506             - Configure and enable the EXTI Line 21 in interrupt mode and select the rising 
   2507               edge sensitivity using the EXTI_Init() function.
   2508             - Configure and enable the TAMP_STAMP IRQ channel in the NVIC using the NVIC_Init()
   2509               function.
   2510             - Configure the RTC to detect the RTC time-stamp event using the 
   2511               RTC_TimeStampCmd() functions.
   2512          
   2513          @endverbatim
   2514            * @{
   2515            */
   2516          
   2517          /**
   2518            * @brief  Enables or disables the specified RTC interrupts.
   2519            * @param  RTC_IT: specifies the RTC interrupt sources to be enabled or disabled. 
   2520            *          This parameter can be any combination of the following values:
   2521            *            @arg RTC_IT_TS:  Time Stamp interrupt mask
   2522            *            @arg RTC_IT_WUT:  WakeUp Timer interrupt mask
   2523            *            @arg RTC_IT_ALRB:  Alarm B interrupt mask
   2524            *            @arg RTC_IT_ALRA:  Alarm A interrupt mask
   2525            *            @arg RTC_IT_TAMP: Tamper event interrupt mask
   2526            * @param  NewState: new state of the specified RTC interrupts.
   2527            *          This parameter can be: ENABLE or DISABLE.
   2528            * @retval None
   2529            */

   \                                 In section .text, align 2, keep-with-next
   2530          void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
   2531          {
   \                     RTC_ITConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2532            /* Check the parameters */
   2533            assert_param(IS_RTC_CONFIG_IT(RTC_IT));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD002             BEQ.N    ??RTC_ITConfig_0
   \   0000000A   0x....             LDR.N    R0,??DataTable50_13  ;; 0xffff0ffb
   \   0000000C   0x4204             TST      R4,R0
   \   0000000E   0xD004             BEQ.N    ??RTC_ITConfig_1
   \                     ??RTC_ITConfig_0: (+1)
   \   00000010   0xF640 0x11E5      MOVW     R1,#+2533
   \   00000014   0x....             LDR.N    R0,??DataTable47
   \   00000016   0x.... 0x....      BL       assert_failed
   2534            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RTC_ITConfig_1: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD007             BEQ.N    ??RTC_ITConfig_2
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD004             BEQ.N    ??RTC_ITConfig_2
   \   00000026   0xF640 0x11E6      MOVW     R1,#+2534
   \   0000002A   0x....             LDR.N    R0,??DataTable47
   \   0000002C   0x.... 0x....      BL       assert_failed
   2535          
   2536            /* Disable the write protection for RTC registers */
   2537            RTC->WPR = 0xCA;
   \                     ??RTC_ITConfig_2: (+1)
   \   00000030   0x20CA             MOVS     R0,#+202
   \   00000032   0x....             LDR.N    R1,??DataTable50  ;; 0x40002824
   \   00000034   0x6008             STR      R0,[R1, #+0]
   2538            RTC->WPR = 0x53;
   \   00000036   0x2053             MOVS     R0,#+83
   \   00000038   0x....             LDR.N    R1,??DataTable50  ;; 0x40002824
   \   0000003A   0x6008             STR      R0,[R1, #+0]
   2539          
   2540            if (NewState != DISABLE)
   \   0000003C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0xD00E             BEQ.N    ??RTC_ITConfig_3
   2541            {
   2542              /* Configure the Interrupts in the RTC_CR register */
   2543              RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
   \   00000042   0x....             LDR.N    R0,??DataTable47_1  ;; 0x40002808
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF034 0x0104      BICS     R1,R4,#0x4
   \   0000004A   0x4308             ORRS     R0,R1,R0
   \   0000004C   0x....             LDR.N    R1,??DataTable47_1  ;; 0x40002808
   \   0000004E   0x6008             STR      R0,[R1, #+0]
   2544              /* Configure the Tamper Interrupt in the RTC_TAFCR */
   2545              RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
   \   00000050   0x....             LDR.N    R0,??DataTable50_10  ;; 0x40002840
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0xF014 0x0104      ANDS     R1,R4,#0x4
   \   00000058   0x4308             ORRS     R0,R1,R0
   \   0000005A   0x....             LDR.N    R1,??DataTable50_10  ;; 0x40002840
   \   0000005C   0x6008             STR      R0,[R1, #+0]
   \   0000005E   0xE00D             B.N      ??RTC_ITConfig_4
   2546            }
   2547            else
   2548            {
   2549              /* Configure the Interrupts in the RTC_CR register */
   2550              RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
   \                     ??RTC_ITConfig_3: (+1)
   \   00000060   0x....             LDR.N    R0,??DataTable47_1  ;; 0x40002808
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0xF034 0x0104      BICS     R1,R4,#0x4
   \   00000068   0x4388             BICS     R0,R0,R1
   \   0000006A   0x....             LDR.N    R1,??DataTable47_1  ;; 0x40002808
   \   0000006C   0x6008             STR      R0,[R1, #+0]
   2551              /* Configure the Tamper Interrupt in the RTC_TAFCR */
   2552              RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
   \   0000006E   0x....             LDR.N    R0,??DataTable50_10  ;; 0x40002840
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0xF014 0x0104      ANDS     R1,R4,#0x4
   \   00000076   0x4388             BICS     R0,R0,R1
   \   00000078   0x....             LDR.N    R1,??DataTable50_10  ;; 0x40002840
   \   0000007A   0x6008             STR      R0,[R1, #+0]
   2553            }
   2554            /* Enable the write protection for RTC registers */
   2555            RTC->WPR = 0xFF; 
   \                     ??RTC_ITConfig_4: (+1)
   \   0000007C   0x20FF             MOVS     R0,#+255
   \   0000007E   0x....             LDR.N    R1,??DataTable50  ;; 0x40002824
   \   00000080   0x6008             STR      R0,[R1, #+0]
   2556          }
   \   00000082   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2557          
   2558          /**
   2559            * @brief  Checks whether the specified RTC flag is set or not.
   2560            * @param  RTC_FLAG: specifies the flag to check.
   2561            *          This parameter can be one of the following values:
   2562            *            @arg RTC_FLAG_TAMP1F: Tamper 1 event flag
   2563            *            @arg RTC_FLAG_TSOVF: Time Stamp OverFlow flag
   2564            *            @arg RTC_FLAG_TSF: Time Stamp event flag
   2565            *            @arg RTC_FLAG_WUTF: WakeUp Timer flag
   2566            *            @arg RTC_FLAG_ALRBF: Alarm B flag
   2567            *            @arg RTC_FLAG_ALRAF: Alarm A flag
   2568            *            @arg RTC_FLAG_INITF: Initialization mode flag
   2569            *            @arg RTC_FLAG_RSF: Registers Synchronized flag
   2570            *            @arg RTC_FLAG_INITS: Registers Configured flag
   2571            *            @arg RTC_FLAG_WUTWF: WakeUp Timer Write flag
   2572            *            @arg RTC_FLAG_ALRBWF: Alarm B Write flag
   2573            *            @arg RTC_FLAG_ALRAWF: Alarm A write flag
   2574            * @retval The new state of RTC_FLAG (SET or RESET).
   2575            */

   \                                 In section .text, align 2, keep-with-next
   2576          FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
   2577          {
   \                     RTC_GetFlagStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2578            FlagStatus bitstatus = RESET;
   \   00000004   0x2500             MOVS     R5,#+0
   2579            uint32_t tmpreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   2580            
   2581            /* Check the parameters */
   2582            assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
   \   00000008   0xF5B4 0x5F80      CMP      R4,#+4096
   \   0000000C   0xD022             BEQ.N    ??RTC_GetFlagStatus_0
   \   0000000E   0xF5B4 0x6F00      CMP      R4,#+2048
   \   00000012   0xD01F             BEQ.N    ??RTC_GetFlagStatus_0
   \   00000014   0xF5B4 0x6F80      CMP      R4,#+1024
   \   00000018   0xD01C             BEQ.N    ??RTC_GetFlagStatus_0
   \   0000001A   0xF5B4 0x7F00      CMP      R4,#+512
   \   0000001E   0xD019             BEQ.N    ??RTC_GetFlagStatus_0
   \   00000020   0xF5B4 0x7F80      CMP      R4,#+256
   \   00000024   0xD016             BEQ.N    ??RTC_GetFlagStatus_0
   \   00000026   0x2C40             CMP      R4,#+64
   \   00000028   0xD014             BEQ.N    ??RTC_GetFlagStatus_0
   \   0000002A   0x2C20             CMP      R4,#+32
   \   0000002C   0xD012             BEQ.N    ??RTC_GetFlagStatus_0
   \   0000002E   0x2C04             CMP      R4,#+4
   \   00000030   0xD010             BEQ.N    ??RTC_GetFlagStatus_0
   \   00000032   0x2C02             CMP      R4,#+2
   \   00000034   0xD00E             BEQ.N    ??RTC_GetFlagStatus_0
   \   00000036   0x2C01             CMP      R4,#+1
   \   00000038   0xD00C             BEQ.N    ??RTC_GetFlagStatus_0
   \   0000003A   0xF5B4 0x5F00      CMP      R4,#+8192
   \   0000003E   0xD009             BEQ.N    ??RTC_GetFlagStatus_0
   \   00000040   0xF5B4 0x3F80      CMP      R4,#+65536
   \   00000044   0xD006             BEQ.N    ??RTC_GetFlagStatus_0
   \   00000046   0x2C08             CMP      R4,#+8
   \   00000048   0xD004             BEQ.N    ??RTC_GetFlagStatus_0
   \   0000004A   0xF640 0x2116      MOVW     R1,#+2582
   \   0000004E   0x....             LDR.N    R0,??DataTable47
   \   00000050   0x.... 0x....      BL       assert_failed
   2583            
   2584            /* Get all the flags */
   2585            tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
   \                     ??RTC_GetFlagStatus_0: (+1)
   \   00000054   0x....             LDR.N    R0,??DataTable50_3  ;; 0x4000280c
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0xF643 0x7177      MOVW     R1,#+16247
   \   0000005C   0x4008             ANDS     R0,R1,R0
   \   0000005E   0x0006             MOVS     R6,R0
   2586            
   2587            /* Return the status of the flag */
   2588            if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
   \   00000060   0x4226             TST      R6,R4
   \   00000062   0xD002             BEQ.N    ??RTC_GetFlagStatus_1
   2589            {
   2590              bitstatus = SET;
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0x0005             MOVS     R5,R0
   \   00000068   0xE001             B.N      ??RTC_GetFlagStatus_2
   2591            }
   2592            else
   2593            {
   2594              bitstatus = RESET;
   \                     ??RTC_GetFlagStatus_1: (+1)
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x0005             MOVS     R5,R0
   2595            }
   2596            return bitstatus;
   \                     ??RTC_GetFlagStatus_2: (+1)
   \   0000006E   0x0028             MOVS     R0,R5
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0xBD70             POP      {R4-R6,PC}       ;; return
   2597          }
   2598          
   2599          /**
   2600            * @brief  Clears the RTC's pending flags.
   2601            * @param  RTC_FLAG: specifies the RTC flag to clear.
   2602            *          This parameter can be any combination of the following values:
   2603            *            @arg RTC_FLAG_TAMP1F: Tamper 1 event flag
   2604            *            @arg RTC_FLAG_TSOVF: Time Stamp Overflow flag 
   2605            *            @arg RTC_FLAG_TSF: Time Stamp event flag
   2606            *            @arg RTC_FLAG_WUTF: WakeUp Timer flag
   2607            *            @arg RTC_FLAG_ALRBF: Alarm B flag
   2608            *            @arg RTC_FLAG_ALRAF: Alarm A flag
   2609            *            @arg RTC_FLAG_RSF: Registers Synchronized flag
   2610            * @retval None
   2611            */

   \                                 In section .text, align 2, keep-with-next
   2612          void RTC_ClearFlag(uint32_t RTC_FLAG)
   2613          {
   \                     RTC_ClearFlag: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2614            /* Check the parameters */
   2615            assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD002             BEQ.N    ??RTC_ClearFlag_0
   \   00000008   0x....             LDR.N    R0,??DataTable50_14  ;; 0xffff00df
   \   0000000A   0x4204             TST      R4,R0
   \   0000000C   0xD004             BEQ.N    ??RTC_ClearFlag_1
   \                     ??RTC_ClearFlag_0: (+1)
   \   0000000E   0xF640 0x2137      MOVW     R1,#+2615
   \   00000012   0x....             LDR.N    R0,??DataTable50_15
   \   00000014   0x.... 0x....      BL       assert_failed
   2616          
   2617            /* Clear the Flags in the RTC_ISR register */
   2618            RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));  
   \                     ??RTC_ClearFlag_1: (+1)
   \   00000018   0xB2A0             UXTH     R0,R4            ;; ZeroExt  R0,R4,#+16,#+16
   \   0000001A   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000001E   0x....             LDR.N    R1,??DataTable50_3  ;; 0x4000280c
   \   00000020   0x6809             LDR      R1,[R1, #+0]
   \   00000022   0xF011 0x0180      ANDS     R1,R1,#0x80
   \   00000026   0xEA71 0x0000      ORNS     R0,R1,R0
   \   0000002A   0x....             LDR.N    R1,??DataTable50_3  ;; 0x4000280c
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   2619          }
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
   2620          
   2621          /**
   2622            * @brief  Checks whether the specified RTC interrupt has occurred or not.
   2623            * @param  RTC_IT: specifies the RTC interrupt source to check.
   2624            *          This parameter can be one of the following values:
   2625            *            @arg RTC_IT_TS: Time Stamp interrupt 
   2626            *            @arg RTC_IT_WUT: WakeUp Timer interrupt 
   2627            *            @arg RTC_IT_ALRB: Alarm B interrupt 
   2628            *            @arg RTC_IT_ALRA: Alarm A interrupt 
   2629            *            @arg RTC_IT_TAMP1: Tamper 1 event interrupt 
   2630            * @retval The new state of RTC_IT (SET or RESET).
   2631            */

   \                                 In section .text, align 2, keep-with-next
   2632          ITStatus RTC_GetITStatus(uint32_t RTC_IT)
   2633          {
   \                     RTC_GetITStatus: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2634            ITStatus bitstatus = RESET;
   \   00000004   0x2500             MOVS     R5,#+0
   2635            uint32_t tmpreg = 0, enablestatus = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x2700             MOVS     R7,#+0
   2636           
   2637            /* Check the parameters */
   2638            assert_param(IS_RTC_GET_IT(RTC_IT));
   \   0000000A   0xF5B4 0x4F00      CMP      R4,#+32768
   \   0000000E   0xD010             BEQ.N    ??RTC_GetITStatus_0
   \   00000010   0xF5B4 0x4F80      CMP      R4,#+16384
   \   00000014   0xD00D             BEQ.N    ??RTC_GetITStatus_0
   \   00000016   0xF5B4 0x5F00      CMP      R4,#+8192
   \   0000001A   0xD00A             BEQ.N    ??RTC_GetITStatus_0
   \   0000001C   0xF5B4 0x5F80      CMP      R4,#+4096
   \   00000020   0xD007             BEQ.N    ??RTC_GetITStatus_0
   \   00000022   0xF5B4 0x3F00      CMP      R4,#+131072
   \   00000026   0xD004             BEQ.N    ??RTC_GetITStatus_0
   \   00000028   0xF640 0x214E      MOVW     R1,#+2638
   \   0000002C   0x....             LDR.N    R0,??DataTable50_15
   \   0000002E   0x.... 0x....      BL       assert_failed
   2639            
   2640            /* Get the TAMPER Interrupt enable bit and pending bit */
   2641            tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
   \                     ??RTC_GetITStatus_0: (+1)
   \   00000032   0x....             LDR.N    R0,??DataTable50_10  ;; 0x40002840
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0xF010 0x0004      ANDS     R0,R0,#0x4
   \   0000003A   0x0006             MOVS     R6,R0
   2642           
   2643            /* Get the Interrupt enable Status */
   2644            enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & (RTC_IT >> 15)));
   \   0000003C   0x....             LDR.N    R0,??DataTable50_1  ;; 0x40002808
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x4020             ANDS     R0,R4,R0
   \   00000042   0xEA16 0x31D4      ANDS     R1,R6,R4, LSR #+15
   \   00000046   0x4308             ORRS     R0,R1,R0
   \   00000048   0x0007             MOVS     R7,R0
   2645            
   2646            /* Get the Interrupt pending bit */
   2647            tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
   \   0000004A   0x....             LDR.N    R0,??DataTable50_3  ;; 0x4000280c
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0xEA10 0x1014      ANDS     R0,R0,R4, LSR #+4
   \   00000052   0x0006             MOVS     R6,R0
   2648            
   2649            /* Get the status of the Interrupt */
   2650            if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
   \   00000054   0x2F00             CMP      R7,#+0
   \   00000056   0xD004             BEQ.N    ??RTC_GetITStatus_1
   \   00000058   0x0430             LSLS     R0,R6,#+16
   \   0000005A   0xD002             BEQ.N    ??RTC_GetITStatus_1
   2651            {
   2652              bitstatus = SET;
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0x0005             MOVS     R5,R0
   \   00000060   0xE001             B.N      ??RTC_GetITStatus_2
   2653            }
   2654            else
   2655            {
   2656              bitstatus = RESET;
   \                     ??RTC_GetITStatus_1: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x0005             MOVS     R5,R0
   2657            }
   2658            return bitstatus;
   \                     ??RTC_GetITStatus_2: (+1)
   \   00000066   0x0028             MOVS     R0,R5
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2659          }
   2660          
   2661          /**
   2662            * @brief  Clears the RTC's interrupt pending bits.
   2663            * @param  RTC_IT: specifies the RTC interrupt pending bit to clear.
   2664            *          This parameter can be any combination of the following values:
   2665            *            @arg RTC_IT_TS: Time Stamp interrupt 
   2666            *            @arg RTC_IT_WUT: WakeUp Timer interrupt 
   2667            *            @arg RTC_IT_ALRB: Alarm B interrupt 
   2668            *            @arg RTC_IT_ALRA: Alarm A interrupt 
   2669            *            @arg RTC_IT_TAMP1: Tamper 1 event interrupt 
   2670            * @retval None
   2671            */

   \                                 In section .text, align 2, keep-with-next
   2672          void RTC_ClearITPendingBit(uint32_t RTC_IT)
   2673          {
   \                     RTC_ClearITPendingBit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2674            uint32_t tmpreg = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   2675          
   2676            /* Check the parameters */
   2677            assert_param(IS_RTC_CLEAR_IT(RTC_IT));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD003             BEQ.N    ??RTC_ClearITPendingBit_0
   \   0000000A   0xF434 0x303C      BICS     R0,R4,#0x2F000
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD004             BEQ.N    ??RTC_ClearITPendingBit_1
   \                     ??RTC_ClearITPendingBit_0: (+1)
   \   00000012   0xF640 0x2175      MOVW     R1,#+2677
   \   00000016   0x....             LDR.N    R0,??DataTable50_15
   \   00000018   0x.... 0x....      BL       assert_failed
   2678          
   2679            /* Get the RTC_ISR Interrupt pending bits mask */
   2680            tmpreg = (uint32_t)(RTC_IT >> 4);
   \                     ??RTC_ClearITPendingBit_1: (+1)
   \   0000001C   0x0920             LSRS     R0,R4,#+4
   \   0000001E   0x0005             MOVS     R5,R0
   2681          
   2682            /* Clear the interrupt pending bits in the RTC_ISR register */
   2683            RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
   \   00000020   0xB2A8             UXTH     R0,R5            ;; ZeroExt  R0,R5,#+16,#+16
   \   00000022   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000026   0x....             LDR.N    R1,??DataTable50_3  ;; 0x4000280c
   \   00000028   0x6809             LDR      R1,[R1, #+0]
   \   0000002A   0xF011 0x0180      ANDS     R1,R1,#0x80
   \   0000002E   0xEA71 0x0000      ORNS     R0,R1,R0
   \   00000032   0x....             LDR.N    R1,??DataTable50_3  ;; 0x4000280c
   \   00000034   0x6008             STR      R0,[R1, #+0]
   2684          }
   \   00000036   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2685          
   2686          /**
   2687            * @}
   2688            */
   2689          
   2690          /**
   2691            * @brief  Converts a 2 digit decimal to BCD format.
   2692            * @param  Value: Byte to be converted.
   2693            * @retval Converted byte
   2694            */

   \                                 In section .text, align 2, keep-with-next
   2695          static uint8_t RTC_ByteToBcd2(uint8_t Value)
   2696          {
   2697            uint8_t bcdhigh = 0;
   \                     RTC_ByteToBcd2: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   2698            
   2699            while (Value >= 10)
   \                     ??RTC_ByteToBcd2_0: (+1)
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x280A             CMP      R0,#+10
   \   00000006   0xDB02             BLT.N    ??RTC_ByteToBcd2_1
   2700            {
   2701              bcdhigh++;
   \   00000008   0x1C49             ADDS     R1,R1,#+1
   2702              Value -= 10;
   \   0000000A   0x380A             SUBS     R0,R0,#+10
   \   0000000C   0xE7F9             B.N      ??RTC_ByteToBcd2_0
   2703            }
   2704            
   2705            return  ((uint8_t)(bcdhigh << 4) | Value);
   \                     ??RTC_ByteToBcd2_1: (+1)
   \   0000000E   0xEA50 0x1001      ORRS     R0,R0,R1, LSL #+4
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x4770             BX       LR               ;; return
   2706          }
   2707          
   2708          /**
   2709            * @brief  Convert from 2 digit BCD to Binary.
   2710            * @param  Value: BCD value to be converted.
   2711            * @retval Converted word
   2712            */

   \                                 In section .text, align 2, keep-with-next
   2713          static uint8_t RTC_Bcd2ToByte(uint8_t Value)
   2714          {
   2715            uint8_t tmp = 0;
   \                     RTC_Bcd2ToByte: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   2716            tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
   \   00000002   0x0001             MOVS     R1,R0
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x0909             LSRS     R1,R1,#+4
   \   00000008   0x230A             MOVS     R3,#+10
   \   0000000A   0xFB11 0xF103      SMULBB   R1,R1,R3
   \   0000000E   0x000A             MOVS     R2,R1
   2717            return (tmp + (Value & (uint8_t)0x0F));
   \   00000010   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000014   0x1880             ADDS     R0,R0,R2
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x4770             BX       LR               ;; return
   2718          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x40002800         DC32     0x40002800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x40002804         DC32     0x40002804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x40002808         DC32     0x40002808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x40002814         DC32     0x40002814

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0x007F00FF         DC32     0x7f00ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0x40002810         DC32     0x40002810

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   0x40002818         DC32     0x40002818

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \   00000000   0x4000281C         DC32     0x4000281c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x40002820         DC32     0x40002820

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x40002840         DC32     0x40002840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x40002824         DC32     0x40002824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x4000280C         DC32     0x4000280c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x40002824         DC32     0x40002824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x4000280C         DC32     0x4000280c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0x007F7F7F         DC32     0x7f7f7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29:
   \   00000000   0x40002828         DC32     0x40002828

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32:
   \   00000000   0x00FFFF3F         DC32     0xffff3f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46:
   \   00000000   0x40002844         DC32     0x40002844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_1:
   \   00000000   0x40002848         DC32     0x40002848

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_1:
   \   00000000   0x40002808         DC32     0x40002808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48:
   \   00000000   0x40002814         DC32     0x40002814

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50:
   \   00000000   0x40002824         DC32     0x40002824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_1:
   \   00000000   0x40002808         DC32     0x40002808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_2:
   \   00000000   0x40002818         DC32     0x40002818

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_3:
   \   00000000   0x4000280C         DC32     0x4000280c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_4:
   \   00000000   0x4000283C         DC32     0x4000283c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_5:
   \   00000000   0xFFFFF7F7         DC32     0xfffff7f7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_6:
   \   00000000   0x40002830         DC32     0x40002830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_7:
   \   00000000   0x007F7F7F         DC32     0x7f7f7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_8:
   \   00000000   0x40002834         DC32     0x40002834

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_9:
   \   00000000   0x40002838         DC32     0x40002838

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_10:
   \   00000000   0x40002840         DC32     0x40002840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_11:
   \   00000000   0x40002850         DC32     0x40002850

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_12:
   \   00000000   0x4000282C         DC32     0x4000282c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_13:
   \   00000000   0xFFFF0FFB         DC32     0xffff0ffb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_14:
   \   00000000   0xFFFF00DF         DC32     0xffff00df

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_15:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 49H, 41H, 52H, 20H, 57H
   \              0x5C 0x49    
   \              0x41 0x52    
   \              0x20 0x57    
   \   00000008   0x6F 0x72          DC8 6FH, 72H, 6BH, 73H, 70H, 61H, 63H, 65H
   \              0x6B 0x73    
   \              0x70 0x61    
   \              0x63 0x65    
   \   00000010   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 46H, 34H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x46 0x34    
   \   00000018   0x30 0x37          DC8 30H, 37H, 5CH, 53H, 54H, 4DH, 33H, 32H
   \              0x5C 0x53    
   \              0x54 0x4D    
   \              0x33 0x32    
   \   00000020   0x46 0x34          DC8 46H, 34H, 2DH, 44H, 69H, 73H, 63H, 6FH
   \              0x2D 0x44    
   \              0x69 0x73    
   \              0x63 0x6F    
   \   00000028   0x76 0x65          DC8 76H, 65H, 72H, 79H, 5FH, 46H, 57H, 5FH
   \              0x72 0x79    
   \              0x5F 0x46    
   \              0x57 0x5F    
   \   00000030   0x56 0x31          DC8 56H, 31H, 2EH, 31H, 2EH, 30H, 5CH, 4CH
   \              0x2E 0x31    
   \              0x2E 0x30    
   \              0x5C 0x4C    
   \   00000038   0x69 0x62          DC8 69H, 62H, 72H, 61H, 72H, 69H, 65H, 73H
   \              0x72 0x61    
   \              0x72 0x69    
   \              0x65 0x73    
   \   00000040   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 46H, 34H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x46 0x34    
   \   00000048   0x78 0x78          DC8 78H, 78H, 5FH, 53H, 74H, 64H, 50H, 65H
   \              0x5F 0x53    
   \              0x74 0x64    
   \              0x50 0x65    
   \   00000050   0x72 0x69          DC8 72H, 69H, 70H, 68H, 5FH, 44H, 72H, 69H
   \              0x70 0x68    
   \              0x5F 0x44    
   \              0x72 0x69    
   \   00000058   0x76 0x65          DC8 76H, 65H, 72H, 5CH, 73H, 72H, 63H, 5CH
   \              0x72 0x5C    
   \              0x73 0x72    
   \              0x63 0x5C    
   \   00000060   0x73 0x74          DC8 73H, 74H, 6DH, 33H, 32H, 66H, 34H, 78H
   \              0x6D 0x33    
   \              0x32 0x66    
   \              0x34 0x78    
   \   00000068   0x78 0x5F          DC8 78H, 5FH, 72H, 74H, 63H, 2EH, 63H, 0
   \              0x72 0x74    
   \              0x63 0x2E    
   \              0x63 0x00    
   2719          
   2720          /**
   2721            * @}
   2722            */ 
   2723          
   2724          /**
   2725            * @}
   2726            */ 
   2727          
   2728          /**
   2729            * @}
   2730            */ 
   2731          
   2732          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   RTC_AlarmCmd
        24   -> assert_failed
       0   RTC_AlarmStructInit
      24   RTC_AlarmSubSecondConfig
        24   -> assert_failed
       0   RTC_Bcd2ToByte
       8   RTC_BypassShadowCmd
         8   -> assert_failed
       0   RTC_ByteToBcd2
       8   RTC_CalibOutputCmd
         8   -> assert_failed
       8   RTC_CalibOutputConfig
         8   -> assert_failed
       8   RTC_ClearFlag
         8   -> assert_failed
      16   RTC_ClearITPendingBit
        16   -> assert_failed
      16   RTC_CoarseCalibCmd
        16   -> RTC_EnterInitMode
        16   -> RTC_ExitInitMode
        16   -> assert_failed
      16   RTC_CoarseCalibConfig
        16   -> RTC_EnterInitMode
        16   -> RTC_ExitInitMode
        16   -> assert_failed
       0   RTC_DateStructInit
      16   RTC_DayLightSavingConfig
        16   -> assert_failed
      16   RTC_DeInit
        16   -> RTC_EnterInitMode
        16   -> RTC_WaitForSynchro
       4   RTC_EnterInitMode
       0   RTC_ExitInitMode
      24   RTC_GetAlarm
        24   -> RTC_Bcd2ToByte
        24   -> assert_failed
       0   RTC_GetAlarmSubSecond
      16   RTC_GetDate
        16   -> RTC_Bcd2ToByte
        16   -> assert_failed
      16   RTC_GetFlagStatus
        16   -> assert_failed
      24   RTC_GetITStatus
        24   -> assert_failed
       0   RTC_GetStoreOperation
       0   RTC_GetSubSecond
      16   RTC_GetTime
        16   -> RTC_Bcd2ToByte
        16   -> assert_failed
      24   RTC_GetTimeStamp
        24   -> RTC_Bcd2ToByte
        24   -> assert_failed
       0   RTC_GetTimeStampSubSecond
       0   RTC_GetWakeUpCounter
      16   RTC_ITConfig
        16   -> assert_failed
      16   RTC_Init
        16   -> RTC_EnterInitMode
        16   -> RTC_ExitInitMode
        16   -> assert_failed
      16   RTC_OutputConfig
        16   -> assert_failed
       8   RTC_OutputTypeConfig
         8   -> assert_failed
      16   RTC_ReadBackupRegister
        16   -> assert_failed
      16   RTC_RefClockCmd
        16   -> RTC_EnterInitMode
        16   -> RTC_ExitInitMode
        16   -> assert_failed
      32   RTC_SetAlarm
        32   -> RTC_Bcd2ToByte
        32   -> RTC_ByteToBcd2
        32   -> assert_failed
      32   RTC_SetDate
        32   -> RTC_Bcd2ToByte
        32   -> RTC_ByteToBcd2
        32   -> RTC_EnterInitMode
        32   -> RTC_ExitInitMode
        32   -> RTC_WaitForSynchro
        32   -> assert_failed
      32   RTC_SetTime
        32   -> RTC_Bcd2ToByte
        32   -> RTC_ByteToBcd2
        32   -> RTC_EnterInitMode
        32   -> RTC_ExitInitMode
        32   -> RTC_WaitForSynchro
        32   -> assert_failed
       8   RTC_SetWakeUpCounter
         8   -> assert_failed
      24   RTC_SmoothCalibConfig
        24   -> assert_failed
       0   RTC_StructInit
      24   RTC_SynchroShiftConfig
        24   -> RTC_WaitForSynchro
        24   -> assert_failed
      16   RTC_TamperCmd
        16   -> assert_failed
       8   RTC_TamperFilterConfig
         8   -> assert_failed
       8   RTC_TamperPinSelection
         8   -> assert_failed
       8   RTC_TamperPinsPrechargeDuration
         8   -> assert_failed
       8   RTC_TamperPullUpCmd
         8   -> assert_failed
       8   RTC_TamperSamplingFreqConfig
         8   -> assert_failed
      16   RTC_TamperTriggerConfig
        16   -> assert_failed
      16   RTC_TimeStampCmd
        16   -> assert_failed
       8   RTC_TimeStampOnTamperDetectionCmd
         8   -> assert_failed
       8   RTC_TimeStampPinSelection
         8   -> assert_failed
       0   RTC_TimeStructInit
       4   RTC_WaitForSynchro
       8   RTC_WakeUpClockConfig
         8   -> assert_failed
      24   RTC_WakeUpCmd
        24   -> assert_failed
      16   RTC_WriteBackupRegister
        16   -> assert_failed
       8   RTC_WriteProtectionCmd
         8   -> assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable18
       4  ??DataTable20
       4  ??DataTable21
       4  ??DataTable28
       4  ??DataTable29
       4  ??DataTable32
       4  ??DataTable46
       4  ??DataTable46_1
       4  ??DataTable47
       4  ??DataTable47_1
       4  ??DataTable48
       4  ??DataTable50
       4  ??DataTable50_1
       4  ??DataTable50_10
       4  ??DataTable50_11
       4  ??DataTable50_12
       4  ??DataTable50_13
       4  ??DataTable50_14
       4  ??DataTable50_15
       4  ??DataTable50_2
       4  ??DataTable50_3
       4  ??DataTable50_4
       4  ??DataTable50_5
       4  ??DataTable50_6
       4  ??DataTable50_7
       4  ??DataTable50_8
       4  ??DataTable50_9
     112  ?_0
     156  RTC_AlarmCmd
      30  RTC_AlarmStructInit
     198  RTC_AlarmSubSecondConfig
      26  RTC_Bcd2ToByte
      94  RTC_BypassShadowCmd
      22  RTC_ByteToBcd2
      94  RTC_CalibOutputCmd
      82  RTC_CalibOutputConfig
      48  RTC_ClearFlag
      56  RTC_ClearITPendingBit
     122  RTC_CoarseCalibCmd
     106  RTC_CoarseCalibConfig
      18  RTC_DateStructInit
     112  RTC_DayLightSavingConfig
     226  RTC_DeInit
      92  RTC_EnterInitMode
      18  RTC_ExitInitMode
     158  RTC_GetAlarm
      38  RTC_GetAlarmSubSecond
      98  RTC_GetDate
     116  RTC_GetFlagStatus
     108  RTC_GetITStatus
      12  RTC_GetStoreOperation
      18  RTC_GetSubSecond
     102  RTC_GetTime
     178  RTC_GetTimeStamp
       8  RTC_GetTimeStampSubSecond
      10  RTC_GetWakeUpCounter
     132  RTC_ITConfig
     178  RTC_Init
     122  RTC_OutputConfig
      48  RTC_OutputTypeConfig
     120  RTC_ReadBackupRegister
     122  RTC_RefClockCmd
     686  RTC_SetAlarm
     414  RTC_SetDate
     448  RTC_SetTime
      48  RTC_SetWakeUpCounter
     180  RTC_SmoothCalibConfig
      14  RTC_StructInit
     150  RTC_SynchroShiftConfig
      84  RTC_TamperCmd
      70  RTC_TamperFilterConfig
      48  RTC_TamperPinSelection
      70  RTC_TamperPinsPrechargeDuration
      70  RTC_TamperPullUpCmd
      94  RTC_TamperSamplingFreqConfig
      90  RTC_TamperTriggerConfig
     114  RTC_TimeStampCmd
      70  RTC_TimeStampOnTamperDetectionCmd
      48  RTC_TimeStampPinSelection
      18  RTC_TimeStructInit
     106  RTC_WaitForSynchro
      90  RTC_WakeUpClockConfig
     158  RTC_WakeUpCmd
     120  RTC_WriteBackupRegister
      62  RTC_WriteProtectionCmd

 
   112 bytes in section .rodata
 6 476 bytes in section .text
 
 6 476 bytes of CODE  memory
   112 bytes of CONST memory

Errors: none
Warnings: none
