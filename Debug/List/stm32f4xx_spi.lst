###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       06/May/2016  23:31:35
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\IAR
#        Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_spi.c
#    Command line =  
#        "D:\IAR
#        Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_spi.c"
#        -D USE_STDPERIPH_DRIVER -D STM32F4XX -D USE_FULL_ASSERT -lCN "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\List" -o "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\Obj" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\Include\" -I
#        "D:\IAR Workspace\STM32F407\VCP_ESP\..\Utilities\STM32F4-Discovery\"
#        -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\ST\STM32F4xx\Include\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_conf\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\cdc\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\otg\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\core\" -On --use_c++_inline -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    List file    =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\Debug\List\stm32f4xx_spi.lst
#    Object file  =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\Debug\Obj\stm32f4xx_spi.o
#
###############################################################################

D:\IAR Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_spi.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_spi.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    30-September-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Serial peripheral interface (SPI):
      9            *           - Initialization and Configuration
     10            *           - Data transfers functions
     11            *           - Hardware CRC Calculation
     12            *           - DMA transfers management
     13            *           - Interrupts and flags management 
     14            *           
     15            *  @verbatim
     16            *          
     17            *                    
     18            *          ===================================================================
     19            *                                 How to use this driver
     20            *          ===================================================================
     21            *    
     22            *          1. Enable peripheral clock using the following functions 
     23            *             RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE) for SPI1
     24            *             RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE) for SPI2
     25            *             RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE) for SPI3.
     26            *
     27            *          2. Enable SCK, MOSI, MISO and NSS GPIO clocks using RCC_AHB1PeriphClockCmd()
     28            *             function.
     29            *             In I2S mode, if an external clock source is used then the I2S CKIN pin GPIO
     30            *             clock should also be enabled.
     31            *
     32            *          3. Peripherals alternate function: 
     33            *                 - Connect the pin to the desired peripherals' Alternate 
     34            *                   Function (AF) using GPIO_PinAFConfig() function
     35            *                 - Configure the desired pin in alternate function by:
     36            *                   GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     37            *                 - Select the type, pull-up/pull-down and output speed via 
     38            *                   GPIO_PuPd, GPIO_OType and GPIO_Speed members
     39            *                 - Call GPIO_Init() function
     40            *              In I2S mode, if an external clock source is used then the I2S CKIN pin
     41            *              should be also configured in Alternate function Push-pull pull-up mode. 
     42            *        
     43            *          4. Program the Polarity, Phase, First Data, Baud Rate Prescaler, Slave 
     44            *             Management, Peripheral Mode and CRC Polynomial values using the SPI_Init()
     45            *             function.
     46            *             In I2S mode, program the Mode, Standard, Data Format, MCLK Output, Audio 
     47            *             frequency and Polarity using I2S_Init() function.
     48            *             For I2S mode, make sure that either:
     49            *              - I2S PLL is configured using the functions RCC_I2SCLKConfig(RCC_I2S2CLKSource_PLLI2S), 
     50            *                RCC_PLLI2SCmd(ENABLE) and RCC_GetFlagStatus(RCC_FLAG_PLLI2SRDY).
     51            *              or 
     52            *              - External clock source is configured using the function 
     53            *                RCC_I2SCLKConfig(RCC_I2S2CLKSource_Ext) and after setting correctly the define constant
     54            *                I2S_EXTERNAL_CLOCK_VAL in the stm32f4xx_conf.h file. 
     55            *
     56            *          5. Enable the NVIC and the corresponding interrupt using the function 
     57            *             SPI_ITConfig() if you need to use interrupt mode. 
     58            *
     59            *          6. When using the DMA mode 
     60            *                   - Configure the DMA using DMA_Init() function
     61            *                   - Active the needed channel Request using SPI_I2S_DMACmd() function
     62            * 
     63            *          7. Enable the SPI using the SPI_Cmd() function or enable the I2S using
     64            *             I2S_Cmd().
     65            * 
     66            *          8. Enable the DMA using the DMA_Cmd() function when using DMA mode. 
     67            *
     68            *          9. Optionally, you can enable/configure the following parameters without
     69            *             re-initialization (i.e there is no need to call again SPI_Init() function):
     70            *              - When bidirectional mode (SPI_Direction_1Line_Rx or SPI_Direction_1Line_Tx)
     71            *                is programmed as Data direction parameter using the SPI_Init() function
     72            *                it can be possible to switch between SPI_Direction_Tx or SPI_Direction_Rx
     73            *                using the SPI_BiDirectionalLineConfig() function.
     74            *              - When SPI_NSS_Soft is selected as Slave Select Management parameter 
     75            *                using the SPI_Init() function it can be possible to manage the 
     76            *                NSS internal signal using the SPI_NSSInternalSoftwareConfig() function.
     77            *              - Reconfigure the data size using the SPI_DataSizeConfig() function  
     78            *              - Enable or disable the SS output using the SPI_SSOutputCmd() function  
     79            *          
     80            *          10. To use the CRC Hardware calculation feature refer to the Peripheral 
     81            *              CRC hardware Calculation subsection.
     82            *   
     83            *
     84            *          It is possible to use SPI in I2S full duplex mode, in this case, each SPI 
     85            *          peripheral is able to manage sending and receiving data simultaneously
     86            *          using two data lines. Each SPI peripheral has an extended block called I2Sxext
     87            *          (ie. I2S2ext for SPI2 and I2S3ext for SPI3).
     88            *          The extension block is not a full SPI IP, it is used only as I2S slave to
     89            *          implement full duplex mode. The extension block uses the same clock sources
     90            *          as its master.          
     91            *          To configure I2S full duplex you have to:
     92            *            
     93            *          1. Configure SPIx in I2S mode (I2S_Init() function) as described above. 
     94            *           
     95            *          2. Call the I2S_FullDuplexConfig() function using the same strucutre passed to  
     96            *             I2S_Init() function.
     97            *            
     98            *          3. Call I2S_Cmd() for SPIx then for its extended block.
     99            *          
    100            *          4. To configure interrupts or DMA requests and to get/clear flag status, 
    101            *             use I2Sxext instance for the extension block.
    102            *             
    103            *          Functions that can be called with I2Sxext instances are:
    104            *          I2S_Cmd(), I2S_FullDuplexConfig(), SPI_I2S_ReceiveData(), SPI_I2S_SendData(), 
    105            *          SPI_I2S_DMACmd(), SPI_I2S_ITConfig(), SPI_I2S_GetFlagStatus(), SPI_I2S_ClearFlag(),
    106            *          SPI_I2S_GetITStatus() and SPI_I2S_ClearITPendingBit().
    107            *                 
    108            *          Example: To use SPI3 in Full duplex mode (SPI3 is Master Tx, I2S3ext is Slave Rx):
    109            *            
    110            *          RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI3, ENABLE);   
    111            *          I2S_StructInit(&I2SInitStruct);
    112            *          I2SInitStruct.Mode = I2S_Mode_MasterTx;     
    113            *          I2S_Init(SPI3, &I2SInitStruct);
    114            *          I2S_FullDuplexConfig(SPI3ext, &I2SInitStruct)
    115            *          I2S_Cmd(SPI3, ENABLE);
    116            *          I2S_Cmd(SPI3ext, ENABLE);
    117            *          ...
    118            *          while (SPI_I2S_GetFlagStatus(SPI2, SPI_FLAG_TXE) == RESET)
    119            *          {}
    120            *          SPI_I2S_SendData(SPI3, txdata[i]);
    121            *          ...  
    122            *          while (SPI_I2S_GetFlagStatus(I2S3ext, SPI_FLAG_RXNE) == RESET)
    123            *          {}
    124            *          rxdata[i] = SPI_I2S_ReceiveData(I2S3ext);
    125            *          ...          
    126            *              
    127            *     
    128            * @note    In I2S mode: if an external clock is used as source clock for the I2S,  
    129            *          then the define I2S_EXTERNAL_CLOCK_VAL in file stm32f4xx_conf.h should 
    130            *          be enabled and set to the value of the source clock frequency (in Hz).
    131            * 
    132            * @note    In SPI mode: To use the SPI TI mode, call the function SPI_TIModeCmd() 
    133            *          just after calling the function SPI_Init().
    134            *
    135            *  @endverbatim  
    136            *                                  
    137            ******************************************************************************
    138            * @attention
    139            *
    140            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
    141            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
    142            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
    143            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
    144            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
    145            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
    146            *
    147            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
    148            ******************************************************************************  
    149            */ 
    150          
    151          /* Includes ------------------------------------------------------------------*/
    152          #include "stm32f4xx_spi.h"
    153          #include "stm32f4xx_rcc.h"
    154          
    155          /** @addtogroup STM32F4xx_StdPeriph_Driver
    156            * @{
    157            */
    158          
    159          /** @defgroup SPI 
    160            * @brief SPI driver modules
    161            * @{
    162            */ 
    163          
    164          /* Private typedef -----------------------------------------------------------*/
    165          /* Private define ------------------------------------------------------------*/
    166          
    167          /* SPI registers Masks */
    168          #define CR1_CLEAR_MASK            ((uint16_t)0x3040)
    169          #define I2SCFGR_CLEAR_MASK        ((uint16_t)0xF040)
    170          
    171          /* RCC PLLs masks */
    172          #define PLLCFGR_PPLR_MASK         ((uint32_t)0x70000000)
    173          #define PLLCFGR_PPLN_MASK         ((uint32_t)0x00007FC0)
    174          
    175          #define SPI_CR2_FRF               ((uint16_t)0x0010)
    176          #define SPI_SR_TIFRFE             ((uint16_t)0x0100)
    177          
    178          /* Private macro -------------------------------------------------------------*/
    179          /* Private variables ---------------------------------------------------------*/
    180          /* Private function prototypes -----------------------------------------------*/
    181          /* Private functions ---------------------------------------------------------*/
    182          
    183          /** @defgroup SPI_Private_Functions
    184            * @{
    185            */
    186          
    187          /** @defgroup SPI_Group1 Initialization and Configuration functions
    188           *  @brief   Initialization and Configuration functions 
    189           *
    190          @verbatim   
    191           ===============================================================================
    192                            Initialization and Configuration functions
    193           ===============================================================================  
    194          
    195            This section provides a set of functions allowing to initialize the SPI Direction,
    196            SPI Mode, SPI Data Size, SPI Polarity, SPI Phase, SPI NSS Management, SPI Baud
    197            Rate Prescaler, SPI First Bit and SPI CRC Polynomial.
    198            
    199            The SPI_Init() function follows the SPI configuration procedures for Master mode
    200            and Slave mode (details for these procedures are available in reference manual
    201            (RM0090)).
    202            
    203          @endverbatim
    204            * @{
    205            */
    206          
    207          /**
    208            * @brief  Deinitialize the SPIx peripheral registers to their default reset values.
    209            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
    210            *         in SPI mode or 2 or 3 in I2S mode.   
    211            *         
    212            * @note   The extended I2S blocks (ie. I2S2ext and I2S3ext blocks) are deinitialized
    213            *         when the relative I2S peripheral is deinitialized (the extended block's clock
    214            *         is managed by the I2S peripheral clock).
    215            *             
    216            * @retval None
    217            */

   \                                 In section .text, align 2, keep-with-next
    218          void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
    219          {
   \                     SPI_I2S_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    220            /* Check the parameters */
    221            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40013000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00C             BEQ.N    ??SPI_I2S_DeInit_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable18_1  ;; 0x40003800
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD008             BEQ.N    ??SPI_I2S_DeInit_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable22  ;; 0x40003c00
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD004             BEQ.N    ??SPI_I2S_DeInit_0
   \   0000001C   0x21DD             MOVS     R1,#+221
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000022   0x.... 0x....      BL       assert_failed
    222          
    223            if (SPIx == SPI1)
   \                     ??SPI_I2S_DeInit_0: (+1)
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40013000
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD10A             BNE.N    ??SPI_I2S_DeInit_1
    224            {
    225              /* Enable SPI1 reset state */
    226              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
   \   0000002E   0x2101             MOVS     R1,#+1
   \   00000030   0xF44F 0x5080      MOV      R0,#+4096
   \   00000034   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    227              /* Release SPI1 from reset state */
    228              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0xF44F 0x5080      MOV      R0,#+4096
   \   0000003E   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
   \   00000042   0xE01C             B.N      ??SPI_I2S_DeInit_2
    229            }
    230            else if (SPIx == SPI2)
   \                     ??SPI_I2S_DeInit_1: (+1)
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable18_1  ;; 0x40003800
   \   00000048   0x4284             CMP      R4,R0
   \   0000004A   0xD10A             BNE.N    ??SPI_I2S_DeInit_3
    231            {
    232              /* Enable SPI2 reset state */
    233              RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
   \   0000004C   0x2101             MOVS     R1,#+1
   \   0000004E   0xF44F 0x4080      MOV      R0,#+16384
   \   00000052   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    234              /* Release SPI2 from reset state */
    235              RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0xF44F 0x4080      MOV      R0,#+16384
   \   0000005C   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \   00000060   0xE00D             B.N      ??SPI_I2S_DeInit_2
    236              }
    237            else
    238            {
    239              if (SPIx == SPI3)
   \                     ??SPI_I2S_DeInit_3: (+1)
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable22  ;; 0x40003c00
   \   00000066   0x4284             CMP      R4,R0
   \   00000068   0xD109             BNE.N    ??SPI_I2S_DeInit_2
    240              {
    241                /* Enable SPI3 reset state */
    242                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
   \   0000006A   0x2101             MOVS     R1,#+1
   \   0000006C   0xF44F 0x4000      MOV      R0,#+32768
   \   00000070   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    243                /* Release SPI3 from reset state */
    244                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
   \   00000074   0x2100             MOVS     R1,#+0
   \   00000076   0xF44F 0x4000      MOV      R0,#+32768
   \   0000007A   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    245              }
    246            }
    247          }
   \                     ??SPI_I2S_DeInit_2: (+1)
   \   0000007E   0xBD10             POP      {R4,PC}          ;; return
    248          
    249          /**
    250            * @brief  Initializes the SPIx peripheral according to the specified 
    251            *         parameters in the SPI_InitStruct.
    252            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    253            * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
    254            *         contains the configuration information for the specified SPI peripheral.
    255            * @retval None
    256            */

   \                                 In section .text, align 2, keep-with-next
    257          void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
    258          {
   \                     SPI_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    259            uint16_t tmpreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    260            
    261            /* check the parameters */
    262            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40013000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD00D             BEQ.N    ??SPI_Init_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable18_1  ;; 0x40003800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD009             BEQ.N    ??SPI_Init_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40003c00
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD005             BEQ.N    ??SPI_Init_0
   \   00000020   0xF44F 0x7183      MOV      R1,#+262
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000028   0x.... 0x....      BL       assert_failed
    263            
    264            /* Check the SPI parameters */
    265            assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
   \                     ??SPI_Init_0: (+1)
   \   0000002C   0x8828             LDRH     R0,[R5, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD011             BEQ.N    ??SPI_Init_1
   \   00000032   0x8828             LDRH     R0,[R5, #+0]
   \   00000034   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000038   0xD00D             BEQ.N    ??SPI_Init_1
   \   0000003A   0x8828             LDRH     R0,[R5, #+0]
   \   0000003C   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000040   0xD009             BEQ.N    ??SPI_Init_1
   \   00000042   0x8828             LDRH     R0,[R5, #+0]
   \   00000044   0xF5B0 0x4F40      CMP      R0,#+49152
   \   00000048   0xD005             BEQ.N    ??SPI_Init_1
   \   0000004A   0xF240 0x1109      MOVW     R1,#+265
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000052   0x.... 0x....      BL       assert_failed
    266            assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
   \                     ??SPI_Init_1: (+1)
   \   00000056   0x8868             LDRH     R0,[R5, #+2]
   \   00000058   0xF5B0 0x7F82      CMP      R0,#+260
   \   0000005C   0xD008             BEQ.N    ??SPI_Init_2
   \   0000005E   0x8868             LDRH     R0,[R5, #+2]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD005             BEQ.N    ??SPI_Init_2
   \   00000064   0xF44F 0x7185      MOV      R1,#+266
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000006C   0x.... 0x....      BL       assert_failed
    267            assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));
   \                     ??SPI_Init_2: (+1)
   \   00000070   0x88A8             LDRH     R0,[R5, #+4]
   \   00000072   0xF5B0 0x6F00      CMP      R0,#+2048
   \   00000076   0xD008             BEQ.N    ??SPI_Init_3
   \   00000078   0x88A8             LDRH     R0,[R5, #+4]
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD005             BEQ.N    ??SPI_Init_3
   \   0000007E   0xF240 0x110B      MOVW     R1,#+267
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000086   0x.... 0x....      BL       assert_failed
    268            assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
   \                     ??SPI_Init_3: (+1)
   \   0000008A   0x88E8             LDRH     R0,[R5, #+6]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD008             BEQ.N    ??SPI_Init_4
   \   00000090   0x88E8             LDRH     R0,[R5, #+6]
   \   00000092   0x2802             CMP      R0,#+2
   \   00000094   0xD005             BEQ.N    ??SPI_Init_4
   \   00000096   0xF44F 0x7186      MOV      R1,#+268
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000009E   0x.... 0x....      BL       assert_failed
    269            assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
   \                     ??SPI_Init_4: (+1)
   \   000000A2   0x8928             LDRH     R0,[R5, #+8]
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD008             BEQ.N    ??SPI_Init_5
   \   000000A8   0x8928             LDRH     R0,[R5, #+8]
   \   000000AA   0x2801             CMP      R0,#+1
   \   000000AC   0xD005             BEQ.N    ??SPI_Init_5
   \   000000AE   0xF240 0x110D      MOVW     R1,#+269
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   000000B6   0x.... 0x....      BL       assert_failed
    270            assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
   \                     ??SPI_Init_5: (+1)
   \   000000BA   0x8968             LDRH     R0,[R5, #+10]
   \   000000BC   0xF5B0 0x7F00      CMP      R0,#+512
   \   000000C0   0xD008             BEQ.N    ??SPI_Init_6
   \   000000C2   0x8968             LDRH     R0,[R5, #+10]
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD005             BEQ.N    ??SPI_Init_6
   \   000000C8   0xF44F 0x7187      MOV      R1,#+270
   \   000000CC   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   000000D0   0x.... 0x....      BL       assert_failed
    271            assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
   \                     ??SPI_Init_6: (+1)
   \   000000D4   0x89A8             LDRH     R0,[R5, #+12]
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD01A             BEQ.N    ??SPI_Init_7
   \   000000DA   0x89A8             LDRH     R0,[R5, #+12]
   \   000000DC   0x2808             CMP      R0,#+8
   \   000000DE   0xD017             BEQ.N    ??SPI_Init_7
   \   000000E0   0x89A8             LDRH     R0,[R5, #+12]
   \   000000E2   0x2810             CMP      R0,#+16
   \   000000E4   0xD014             BEQ.N    ??SPI_Init_7
   \   000000E6   0x89A8             LDRH     R0,[R5, #+12]
   \   000000E8   0x2818             CMP      R0,#+24
   \   000000EA   0xD011             BEQ.N    ??SPI_Init_7
   \   000000EC   0x89A8             LDRH     R0,[R5, #+12]
   \   000000EE   0x2820             CMP      R0,#+32
   \   000000F0   0xD00E             BEQ.N    ??SPI_Init_7
   \   000000F2   0x89A8             LDRH     R0,[R5, #+12]
   \   000000F4   0x2828             CMP      R0,#+40
   \   000000F6   0xD00B             BEQ.N    ??SPI_Init_7
   \   000000F8   0x89A8             LDRH     R0,[R5, #+12]
   \   000000FA   0x2830             CMP      R0,#+48
   \   000000FC   0xD008             BEQ.N    ??SPI_Init_7
   \   000000FE   0x89A8             LDRH     R0,[R5, #+12]
   \   00000100   0x2838             CMP      R0,#+56
   \   00000102   0xD005             BEQ.N    ??SPI_Init_7
   \   00000104   0xF240 0x110F      MOVW     R1,#+271
   \   00000108   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000010C   0x.... 0x....      BL       assert_failed
    272            assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
   \                     ??SPI_Init_7: (+1)
   \   00000110   0x89E8             LDRH     R0,[R5, #+14]
   \   00000112   0x2800             CMP      R0,#+0
   \   00000114   0xD008             BEQ.N    ??SPI_Init_8
   \   00000116   0x89E8             LDRH     R0,[R5, #+14]
   \   00000118   0x2880             CMP      R0,#+128
   \   0000011A   0xD005             BEQ.N    ??SPI_Init_8
   \   0000011C   0xF44F 0x7188      MOV      R1,#+272
   \   00000120   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000124   0x.... 0x....      BL       assert_failed
    273            assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
   \                     ??SPI_Init_8: (+1)
   \   00000128   0x8A28             LDRH     R0,[R5, #+16]
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD105             BNE.N    ??SPI_Init_9
   \   0000012E   0xF240 0x1111      MOVW     R1,#+273
   \   00000132   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000136   0x.... 0x....      BL       assert_failed
    274          
    275          /*---------------------------- SPIx CR1 Configuration ------------------------*/
    276            /* Get the SPIx CR1 value */
    277            tmpreg = SPIx->CR1;
   \                     ??SPI_Init_9: (+1)
   \   0000013A   0x8820             LDRH     R0,[R4, #+0]
   \   0000013C   0x0006             MOVS     R6,R0
    278            /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
    279            tmpreg &= CR1_CLEAR_MASK;
   \   0000013E   0xF416 0x5641      ANDS     R6,R6,#0x3040
    280            /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
    281               master/salve mode, CPOL and CPHA */
    282            /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
    283            /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    284            /* Set LSBFirst bit according to SPI_FirstBit value */
    285            /* Set BR bits according to SPI_BaudRatePrescaler value */
    286            /* Set CPOL bit according to SPI_CPOL value */
    287            /* Set CPHA bit according to SPI_CPHA value */
    288            tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
    289                            SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
    290                            SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
    291                            SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
   \   00000142   0x8828             LDRH     R0,[R5, #+0]
   \   00000144   0x8869             LDRH     R1,[R5, #+2]
   \   00000146   0x4308             ORRS     R0,R1,R0
   \   00000148   0x88A9             LDRH     R1,[R5, #+4]
   \   0000014A   0x4308             ORRS     R0,R1,R0
   \   0000014C   0x88E9             LDRH     R1,[R5, #+6]
   \   0000014E   0x4308             ORRS     R0,R1,R0
   \   00000150   0x8929             LDRH     R1,[R5, #+8]
   \   00000152   0x4308             ORRS     R0,R1,R0
   \   00000154   0x8969             LDRH     R1,[R5, #+10]
   \   00000156   0x4308             ORRS     R0,R1,R0
   \   00000158   0x89A9             LDRH     R1,[R5, #+12]
   \   0000015A   0x4308             ORRS     R0,R1,R0
   \   0000015C   0x89E9             LDRH     R1,[R5, #+14]
   \   0000015E   0x4308             ORRS     R0,R1,R0
   \   00000160   0x4306             ORRS     R6,R0,R6
    292            /* Write to SPIx CR1 */
    293            SPIx->CR1 = tmpreg;
   \   00000162   0x8026             STRH     R6,[R4, #+0]
    294          
    295            /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
    296            SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
   \   00000164   0x8BA0             LDRH     R0,[R4, #+28]
   \   00000166   0xF24F 0x71FF      MOVW     R1,#+63487
   \   0000016A   0x4008             ANDS     R0,R1,R0
   \   0000016C   0x83A0             STRH     R0,[R4, #+28]
    297          /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
    298            /* Write to SPIx CRCPOLY */
    299            SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
   \   0000016E   0x8A28             LDRH     R0,[R5, #+16]
   \   00000170   0x8220             STRH     R0,[R4, #+16]
    300          }
   \   00000172   0xBD70             POP      {R4-R6,PC}       ;; return
    301          
    302          /**
    303            * @brief  Initializes the SPIx peripheral according to the specified 
    304            *         parameters in the I2S_InitStruct.
    305            * @param  SPIx: where x can be  2 or 3 to select the SPI peripheral (configured in I2S mode).
    306            * @param  I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
    307            *         contains the configuration information for the specified SPI peripheral
    308            *         configured in I2S mode.
    309            *           
    310            * @note   The function calculates the optimal prescaler needed to obtain the most 
    311            *         accurate audio frequency (depending on the I2S clock source, the PLL values 
    312            *         and the product configuration). But in case the prescaler value is greater 
    313            *         than 511, the default value (0x02) will be configured instead.    
    314            * 
    315            * @note   if an external clock is used as source clock for the I2S, then the define
    316            *         I2S_EXTERNAL_CLOCK_VAL in file stm32f4xx_conf.h should be enabled and set
    317            *         to the value of the the source clock frequency (in Hz).
    318            *  
    319            * @retval None
    320            */

   \                                 In section .text, align 2, keep-with-next
    321          void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
    322          {
   \                     I2S_Init: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    323            uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
   \   00000008   0x2600             MOVS     R6,#+0
   \   0000000A   0x2702             MOVS     R7,#+2
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   \   00000010   0xF05F 0x0901      MOVS     R9,#+1
    324            uint32_t tmp = 0, i2sclk = 0;
   \   00000014   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000018   0xF05F 0x0B00      MOVS     R11,#+0
    325          #ifndef I2S_EXTERNAL_CLOCK_VAL
    326            uint32_t pllm = 0, plln = 0, pllr = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x9002             STR      R0,[SP, #+8]
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x9001             STR      R0,[SP, #+4]
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x9000             STR      R0,[SP, #+0]
    327          #endif /* I2S_EXTERNAL_CLOCK_VAL */
    328            
    329            /* Check the I2S parameters */
    330            assert_param(IS_SPI_23_PERIPH(SPIx));
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable18_1  ;; 0x40003800
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD009             BEQ.N    ??I2S_Init_0
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40003c00
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD005             BEQ.N    ??I2S_Init_0
   \   00000038   0xF44F 0x71A5      MOV      R1,#+330
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000040   0x.... 0x....      BL       assert_failed
    331            assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
   \                     ??I2S_Init_0: (+1)
   \   00000044   0x8828             LDRH     R0,[R5, #+0]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD011             BEQ.N    ??I2S_Init_1
   \   0000004A   0x8828             LDRH     R0,[R5, #+0]
   \   0000004C   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000050   0xD00D             BEQ.N    ??I2S_Init_1
   \   00000052   0x8828             LDRH     R0,[R5, #+0]
   \   00000054   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000058   0xD009             BEQ.N    ??I2S_Init_1
   \   0000005A   0x8828             LDRH     R0,[R5, #+0]
   \   0000005C   0xF5B0 0x7F40      CMP      R0,#+768
   \   00000060   0xD005             BEQ.N    ??I2S_Init_1
   \   00000062   0xF240 0x114B      MOVW     R1,#+331
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000006A   0x.... 0x....      BL       assert_failed
    332            assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
   \                     ??I2S_Init_1: (+1)
   \   0000006E   0x8868             LDRH     R0,[R5, #+2]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD011             BEQ.N    ??I2S_Init_2
   \   00000074   0x8868             LDRH     R0,[R5, #+2]
   \   00000076   0x2810             CMP      R0,#+16
   \   00000078   0xD00E             BEQ.N    ??I2S_Init_2
   \   0000007A   0x8868             LDRH     R0,[R5, #+2]
   \   0000007C   0x2820             CMP      R0,#+32
   \   0000007E   0xD00B             BEQ.N    ??I2S_Init_2
   \   00000080   0x8868             LDRH     R0,[R5, #+2]
   \   00000082   0x2830             CMP      R0,#+48
   \   00000084   0xD008             BEQ.N    ??I2S_Init_2
   \   00000086   0x8868             LDRH     R0,[R5, #+2]
   \   00000088   0x28B0             CMP      R0,#+176
   \   0000008A   0xD005             BEQ.N    ??I2S_Init_2
   \   0000008C   0xF44F 0x71A6      MOV      R1,#+332
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000094   0x.... 0x....      BL       assert_failed
    333            assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
   \                     ??I2S_Init_2: (+1)
   \   00000098   0x88A8             LDRH     R0,[R5, #+4]
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD00E             BEQ.N    ??I2S_Init_3
   \   0000009E   0x88A8             LDRH     R0,[R5, #+4]
   \   000000A0   0x2801             CMP      R0,#+1
   \   000000A2   0xD00B             BEQ.N    ??I2S_Init_3
   \   000000A4   0x88A8             LDRH     R0,[R5, #+4]
   \   000000A6   0x2803             CMP      R0,#+3
   \   000000A8   0xD008             BEQ.N    ??I2S_Init_3
   \   000000AA   0x88A8             LDRH     R0,[R5, #+4]
   \   000000AC   0x2805             CMP      R0,#+5
   \   000000AE   0xD005             BEQ.N    ??I2S_Init_3
   \   000000B0   0xF240 0x114D      MOVW     R1,#+333
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   000000B8   0x.... 0x....      BL       assert_failed
    334            assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));
   \                     ??I2S_Init_3: (+1)
   \   000000BC   0x88E8             LDRH     R0,[R5, #+6]
   \   000000BE   0xF5B0 0x7F00      CMP      R0,#+512
   \   000000C2   0xD008             BEQ.N    ??I2S_Init_4
   \   000000C4   0x88E8             LDRH     R0,[R5, #+6]
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD005             BEQ.N    ??I2S_Init_4
   \   000000CA   0xF44F 0x71A7      MOV      R1,#+334
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   000000D2   0x.... 0x....      BL       assert_failed
    335            assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
   \                     ??I2S_Init_4: (+1)
   \   000000D6   0x68A8             LDR      R0,[R5, #+8]
   \   000000D8   0xF5B0 0x5FFA      CMP      R0,#+8000
   \   000000DC   0xD304             BCC.N    ??I2S_Init_5
   \   000000DE   0x68A8             LDR      R0,[R5, #+8]
   \   000000E0   0x.... 0x....      LDR.W    R1,??DataTable22_1  ;; 0x2ee01
   \   000000E4   0x4288             CMP      R0,R1
   \   000000E6   0xD308             BCC.N    ??I2S_Init_6
   \                     ??I2S_Init_5: (+1)
   \   000000E8   0x68A8             LDR      R0,[R5, #+8]
   \   000000EA   0x2802             CMP      R0,#+2
   \   000000EC   0xD005             BEQ.N    ??I2S_Init_6
   \   000000EE   0xF240 0x114F      MOVW     R1,#+335
   \   000000F2   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   000000F6   0x.... 0x....      BL       assert_failed
    336            assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
   \                     ??I2S_Init_6: (+1)
   \   000000FA   0x89A8             LDRH     R0,[R5, #+12]
   \   000000FC   0x2800             CMP      R0,#+0
   \   000000FE   0xD008             BEQ.N    ??I2S_Init_7
   \   00000100   0x89A8             LDRH     R0,[R5, #+12]
   \   00000102   0x2808             CMP      R0,#+8
   \   00000104   0xD005             BEQ.N    ??I2S_Init_7
   \   00000106   0xF44F 0x71A8      MOV      R1,#+336
   \   0000010A   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000010E   0x.... 0x....      BL       assert_failed
    337          
    338          /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
    339            /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    340            SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
   \                     ??I2S_Init_7: (+1)
   \   00000112   0x8BA0             LDRH     R0,[R4, #+28]
   \   00000114   0xF24F 0x0140      MOVW     R1,#+61504
   \   00000118   0x4008             ANDS     R0,R1,R0
   \   0000011A   0x83A0             STRH     R0,[R4, #+28]
    341            SPIx->I2SPR = 0x0002;
   \   0000011C   0x2002             MOVS     R0,#+2
   \   0000011E   0x8420             STRH     R0,[R4, #+32]
    342            
    343            /* Get the I2SCFGR register value */
    344            tmpreg = SPIx->I2SCFGR;
   \   00000120   0x8BA0             LDRH     R0,[R4, #+28]
   \   00000122   0x0006             MOVS     R6,R0
    345            
    346            /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
    347            if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
   \   00000124   0x68A8             LDR      R0,[R5, #+8]
   \   00000126   0x2802             CMP      R0,#+2
   \   00000128   0xD104             BNE.N    ??I2S_Init_8
    348            {
    349              i2sodd = (uint16_t)0;
   \   0000012A   0x2000             MOVS     R0,#+0
   \   0000012C   0x4680             MOV      R8,R0
    350              i2sdiv = (uint16_t)2;   
   \   0000012E   0x2002             MOVS     R0,#+2
   \   00000130   0x0007             MOVS     R7,R0
   \   00000132   0xE05C             B.N      ??I2S_Init_9
    351            }
    352            /* If the requested audio frequency is not the default, compute the prescaler */
    353            else
    354            {
    355              /* Check the frame length (For the Prescaler computing) *******************/
    356              if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
   \                     ??I2S_Init_8: (+1)
   \   00000134   0x88A8             LDRH     R0,[R5, #+4]
   \   00000136   0x2800             CMP      R0,#+0
   \   00000138   0xD102             BNE.N    ??I2S_Init_10
    357              {
    358                /* Packet length is 16 bits */
    359                packetlength = 1;
   \   0000013A   0x2001             MOVS     R0,#+1
   \   0000013C   0x4681             MOV      R9,R0
   \   0000013E   0xE001             B.N      ??I2S_Init_11
    360              }
    361              else
    362              {
    363                /* Packet length is 32 bits */
    364                packetlength = 2;
   \                     ??I2S_Init_10: (+1)
   \   00000140   0x2002             MOVS     R0,#+2
   \   00000142   0x4681             MOV      R9,R0
    365              }
    366          
    367              /* Get I2S source Clock frequency  ****************************************/
    368                
    369              /* If an external I2S clock has to be used, this define should be set  
    370                 in the project configuration or in the stm32f4xx_conf.h file */
    371            #ifdef I2S_EXTERNAL_CLOCK_VAL     
    372              /* Set external clock as I2S clock source */
    373              if ((RCC->CFGR & RCC_CFGR_I2SSRC) == 0)
    374              {
    375                RCC->CFGR |= (uint32_t)RCC_CFGR_I2SSRC;
    376              }
    377              
    378              /* Set the I2S clock to the external clock  value */
    379              i2sclk = I2S_EXTERNAL_CLOCK_VAL;
    380          
    381            #else /* There is no define for External I2S clock source */
    382              /* Set PLLI2S as I2S clock source */
    383              if ((RCC->CFGR & RCC_CFGR_I2SSRC) != 0)
   \                     ??I2S_Init_11: (+1)
   \   00000144   0x.... 0x....      LDR.W    R0,??DataTable22_2  ;; 0x40023808
   \   00000148   0x6800             LDR      R0,[R0, #+0]
   \   0000014A   0x0200             LSLS     R0,R0,#+8
   \   0000014C   0xD507             BPL.N    ??I2S_Init_12
    384              {
    385                RCC->CFGR &= ~(uint32_t)RCC_CFGR_I2SSRC;
   \   0000014E   0x.... 0x....      LDR.W    R0,??DataTable22_2  ;; 0x40023808
   \   00000152   0x6800             LDR      R0,[R0, #+0]
   \   00000154   0xF430 0x0000      BICS     R0,R0,#0x800000
   \   00000158   0x.... 0x....      LDR.W    R1,??DataTable22_2  ;; 0x40023808
   \   0000015C   0x6008             STR      R0,[R1, #+0]
    386              }    
    387              
    388              /* Get the PLLI2SN value */
    389              plln = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6) & \
    390                                (RCC_PLLI2SCFGR_PLLI2SN >> 6));
   \                     ??I2S_Init_12: (+1)
   \   0000015E   0x.... 0x....      LDR.W    R0,??DataTable22_3  ;; 0x40023884
   \   00000162   0x6800             LDR      R0,[R0, #+0]
   \   00000164   0xF3C0 0x1088      UBFX     R0,R0,#+6,#+9
   \   00000168   0x9001             STR      R0,[SP, #+4]
    391              
    392              /* Get the PLLI2SR value */
    393              pllr = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28) & \
    394                                (RCC_PLLI2SCFGR_PLLI2SR >> 28));
   \   0000016A   0x.... 0x....      LDR.W    R0,??DataTable22_3  ;; 0x40023884
   \   0000016E   0x6800             LDR      R0,[R0, #+0]
   \   00000170   0xF3C0 0x7002      UBFX     R0,R0,#+28,#+3
   \   00000174   0x9000             STR      R0,[SP, #+0]
    395              
    396              /* Get the PLLM value */
    397              pllm = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);      
   \   00000176   0x.... 0x....      LDR.W    R0,??DataTable22_4  ;; 0x40023804
   \   0000017A   0x6800             LDR      R0,[R0, #+0]
   \   0000017C   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   00000180   0x9002             STR      R0,[SP, #+8]
    398              
    399              /* Get the I2S source clock value */
    400              i2sclk = (uint32_t)(((HSE_VALUE / pllm) * plln) / pllr);
   \   00000182   0x.... 0x....      LDR.W    R0,??DataTable22_5  ;; 0x7a1200
   \   00000186   0x9902             LDR      R1,[SP, #+8]
   \   00000188   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000018C   0x9901             LDR      R1,[SP, #+4]
   \   0000018E   0x4348             MULS     R0,R1,R0
   \   00000190   0x9900             LDR      R1,[SP, #+0]
   \   00000192   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000196   0x4683             MOV      R11,R0
    401            #endif /* I2S_EXTERNAL_CLOCK_VAL */
    402              
    403              /* Compute the Real divider depending on the MCLK output state, with a floating point */
    404              if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
   \   00000198   0x88E8             LDRH     R0,[R5, #+6]
   \   0000019A   0xF5B0 0x7F00      CMP      R0,#+512
   \   0000019E   0xD10A             BNE.N    ??I2S_Init_13
    405              {
    406                /* MCLK output is enabled */
    407                tmp = (uint16_t)(((((i2sclk / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
   \   000001A0   0xEA5F 0x201B      LSRS     R0,R11,#+8
   \   000001A4   0x210A             MOVS     R1,#+10
   \   000001A6   0x4348             MULS     R0,R1,R0
   \   000001A8   0x68A9             LDR      R1,[R5, #+8]
   \   000001AA   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000001AE   0x1D40             ADDS     R0,R0,#+5
   \   000001B0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001B2   0x4682             MOV      R10,R0
   \   000001B4   0xE00D             B.N      ??I2S_Init_14
    408              }
    409              else
    410              {
    411                /* MCLK output is disabled */
    412                tmp = (uint16_t)(((((i2sclk / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
   \                     ??I2S_Init_13: (+1)
   \   000001B6   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000001BA   0xEA5F 0x1049      LSLS     R0,R9,#+5
   \   000001BE   0xFBBB 0xF0F0      UDIV     R0,R11,R0
   \   000001C2   0x210A             MOVS     R1,#+10
   \   000001C4   0x4348             MULS     R0,R1,R0
   \   000001C6   0x68A9             LDR      R1,[R5, #+8]
   \   000001C8   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000001CC   0x1D40             ADDS     R0,R0,#+5
   \   000001CE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001D0   0x4682             MOV      R10,R0
    413              }
    414              
    415              /* Remove the flatting point */
    416              tmp = tmp / 10;  
   \                     ??I2S_Init_14: (+1)
   \   000001D2   0x200A             MOVS     R0,#+10
   \   000001D4   0xFBBA 0xFAF0      UDIV     R10,R10,R0
    417                
    418              /* Check the parity of the divider */
    419              i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
   \   000001D8   0xF01A 0x0001      ANDS     R0,R10,#0x1
   \   000001DC   0x4680             MOV      R8,R0
    420             
    421              /* Compute the i2sdiv prescaler */
    422              i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
   \   000001DE   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000001E2   0xEBBA 0x0008      SUBS     R0,R10,R8
   \   000001E6   0x0840             LSRS     R0,R0,#+1
   \   000001E8   0x0007             MOVS     R7,R0
    423             
    424              /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    425              i2sodd = (uint16_t) (i2sodd << 8);
   \   000001EA   0xEA5F 0x2808      LSLS     R8,R8,#+8
    426            }
    427          
    428            /* Test if the divider is 1 or 0 or greater than 0xFF */
    429            if ((i2sdiv < 2) || (i2sdiv > 0xFF))
   \                     ??I2S_Init_9: (+1)
   \   000001EE   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000001F0   0x2F02             CMP      R7,#+2
   \   000001F2   0xDB02             BLT.N    ??I2S_Init_15
   \   000001F4   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000001F6   0x2FFF             CMP      R7,#+255
   \   000001F8   0xDD03             BLE.N    ??I2S_Init_16
    430            {
    431              /* Set the default values */
    432              i2sdiv = 2;
   \                     ??I2S_Init_15: (+1)
   \   000001FA   0x2002             MOVS     R0,#+2
   \   000001FC   0x0007             MOVS     R7,R0
    433              i2sodd = 0;
   \   000001FE   0x2000             MOVS     R0,#+0
   \   00000200   0x4680             MOV      R8,R0
    434            }
    435          
    436            /* Write to SPIx I2SPR register the computed value */
    437            SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
   \                     ??I2S_Init_16: (+1)
   \   00000202   0x88E8             LDRH     R0,[R5, #+6]
   \   00000204   0xEA50 0x0008      ORRS     R0,R0,R8
   \   00000208   0x4338             ORRS     R0,R0,R7
   \   0000020A   0x8420             STRH     R0,[R4, #+32]
    438           
    439            /* Configure the I2S with the SPI_InitStruct values */
    440            tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
    441                            (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
    442                            (uint16_t)I2S_InitStruct->I2S_CPOL))));
   \   0000020C   0x8828             LDRH     R0,[R5, #+0]
   \   0000020E   0x8869             LDRH     R1,[R5, #+2]
   \   00000210   0x88AA             LDRH     R2,[R5, #+4]
   \   00000212   0x89AB             LDRH     R3,[R5, #+12]
   \   00000214   0x431A             ORRS     R2,R3,R2
   \   00000216   0x4311             ORRS     R1,R2,R1
   \   00000218   0x4308             ORRS     R0,R1,R0
   \   0000021A   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   0000021E   0x4306             ORRS     R6,R0,R6
    443           
    444            /* Write to SPIx I2SCFGR */  
    445            SPIx->I2SCFGR = tmpreg;
   \   00000220   0x83A6             STRH     R6,[R4, #+28]
    446          }
   \   00000222   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
    447          
    448          /**
    449            * @brief  Fills each SPI_InitStruct member with its default value.
    450            * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure which will be initialized.
    451            * @retval None
    452            */

   \                                 In section .text, align 2, keep-with-next
    453          void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
    454          {
    455          /*--------------- Reset SPI init structure parameters values -----------------*/
    456            /* Initialize the SPI_Direction member */
    457            SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
   \                     SPI_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    458            /* initialize the SPI_Mode member */
    459            SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x8041             STRH     R1,[R0, #+2]
    460            /* initialize the SPI_DataSize member */
    461            SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x8081             STRH     R1,[R0, #+4]
    462            /* Initialize the SPI_CPOL member */
    463            SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x80C1             STRH     R1,[R0, #+6]
    464            /* Initialize the SPI_CPHA member */
    465            SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x8101             STRH     R1,[R0, #+8]
    466            /* Initialize the SPI_NSS member */
    467            SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x8141             STRH     R1,[R0, #+10]
    468            /* Initialize the SPI_BaudRatePrescaler member */
    469            SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x8181             STRH     R1,[R0, #+12]
    470            /* Initialize the SPI_FirstBit member */
    471            SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x81C1             STRH     R1,[R0, #+14]
    472            /* Initialize the SPI_CRCPolynomial member */
    473            SPI_InitStruct->SPI_CRCPolynomial = 7;
   \   00000020   0x2107             MOVS     R1,#+7
   \   00000022   0x8201             STRH     R1,[R0, #+16]
    474          }
   \   00000024   0x4770             BX       LR               ;; return
    475          
    476          /**
    477            * @brief  Fills each I2S_InitStruct member with its default value.
    478            * @param  I2S_InitStruct: pointer to a I2S_InitTypeDef structure which will be initialized.
    479            * @retval None
    480            */

   \                                 In section .text, align 2, keep-with-next
    481          void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
    482          {
    483          /*--------------- Reset I2S init structure parameters values -----------------*/
    484            /* Initialize the I2S_Mode member */
    485            I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
   \                     I2S_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    486            
    487            /* Initialize the I2S_Standard member */
    488            I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x8041             STRH     R1,[R0, #+2]
    489            
    490            /* Initialize the I2S_DataFormat member */
    491            I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x8081             STRH     R1,[R0, #+4]
    492            
    493            /* Initialize the I2S_MCLKOutput member */
    494            I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x80C1             STRH     R1,[R0, #+6]
    495            
    496            /* Initialize the I2S_AudioFreq member */
    497            I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
   \   00000010   0x2102             MOVS     R1,#+2
   \   00000012   0x6081             STR      R1,[R0, #+8]
    498            
    499            /* Initialize the I2S_CPOL member */
    500            I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x8181             STRH     R1,[R0, #+12]
    501          }
   \   00000018   0x4770             BX       LR               ;; return
    502          
    503          /**
    504            * @brief  Enables or disables the specified SPI peripheral.
    505            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    506            * @param  NewState: new state of the SPIx peripheral. 
    507            *          This parameter can be: ENABLE or DISABLE.
    508            * @retval None
    509            */

   \                                 In section .text, align 2, keep-with-next
    510          void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    511          {
   \                     SPI_Cmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    512            /* Check the parameters */
    513            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??SPI_Cmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_1  ;; 0x40003800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??SPI_Cmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40003c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??SPI_Cmd_0
   \   0000001E   0xF240 0x2101      MOVW     R1,#+513
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000026   0x.... 0x....      BL       assert_failed
    514            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??SPI_Cmd_0: (+1)
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD008             BEQ.N    ??SPI_Cmd_1
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D01             CMP      R5,#+1
   \   00000034   0xD005             BEQ.N    ??SPI_Cmd_1
   \   00000036   0xF240 0x2102      MOVW     R1,#+514
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000003E   0x.... 0x....      BL       assert_failed
    515            if (NewState != DISABLE)
   \                     ??SPI_Cmd_1: (+1)
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD004             BEQ.N    ??SPI_Cmd_2
    516            {
    517              /* Enable the selected SPI peripheral */
    518              SPIx->CR1 |= SPI_CR1_SPE;
   \   00000048   0x8820             LDRH     R0,[R4, #+0]
   \   0000004A   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000004E   0x8020             STRH     R0,[R4, #+0]
   \   00000050   0xE004             B.N      ??SPI_Cmd_3
    519            }
    520            else
    521            {
    522              /* Disable the selected SPI peripheral */
    523              SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
   \                     ??SPI_Cmd_2: (+1)
   \   00000052   0x8820             LDRH     R0,[R4, #+0]
   \   00000054   0xF64F 0x71BF      MOVW     R1,#+65471
   \   00000058   0x4008             ANDS     R0,R1,R0
   \   0000005A   0x8020             STRH     R0,[R4, #+0]
    524            }
    525          }
   \                     ??SPI_Cmd_3: (+1)
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    526          
    527          /**
    528            * @brief  Enables or disables the specified SPI peripheral (in I2S mode).
    529            * @param  SPIx: where x can be 2 or 3 to select the SPI peripheral (or I2Sxext 
    530            *         for full duplex mode).
    531            * @param  NewState: new state of the SPIx peripheral. 
    532            *         This parameter can be: ENABLE or DISABLE.
    533            * @retval None
    534            */

   \                                 In section .text, align 2, keep-with-next
    535          void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    536          {
   \                     I2S_Cmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    537            /* Check the parameters */
    538            assert_param(IS_SPI_23_PERIPH_EXT(SPIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18_1  ;; 0x40003800
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD010             BEQ.N    ??I2S_Cmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40003c00
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD00C             BEQ.N    ??I2S_Cmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable22_6  ;; 0x40003400
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD008             BEQ.N    ??I2S_Cmd_0
   \   0000001E   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   00000022   0xD005             BEQ.N    ??I2S_Cmd_0
   \   00000024   0xF240 0x211A      MOVW     R1,#+538
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000002C   0x.... 0x....      BL       assert_failed
    539            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2S_Cmd_0: (+1)
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD008             BEQ.N    ??I2S_Cmd_1
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x2D01             CMP      R5,#+1
   \   0000003A   0xD005             BEQ.N    ??I2S_Cmd_1
   \   0000003C   0xF240 0x211B      MOVW     R1,#+539
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000044   0x.... 0x....      BL       assert_failed
    540            
    541            if (NewState != DISABLE)
   \                     ??I2S_Cmd_1: (+1)
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x2D00             CMP      R5,#+0
   \   0000004C   0xD004             BEQ.N    ??I2S_Cmd_2
    542            {
    543              /* Enable the selected SPI peripheral (in I2S mode) */
    544              SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
   \   0000004E   0x8BA0             LDRH     R0,[R4, #+28]
   \   00000050   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000054   0x83A0             STRH     R0,[R4, #+28]
   \   00000056   0xE004             B.N      ??I2S_Cmd_3
    545            }
    546            else
    547            {
    548              /* Disable the selected SPI peripheral in I2S mode */
    549              SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
   \                     ??I2S_Cmd_2: (+1)
   \   00000058   0x8BA0             LDRH     R0,[R4, #+28]
   \   0000005A   0xF64F 0x31FF      MOVW     R1,#+64511
   \   0000005E   0x4008             ANDS     R0,R1,R0
   \   00000060   0x83A0             STRH     R0,[R4, #+28]
    550            }
    551          }
   \                     ??I2S_Cmd_3: (+1)
   \   00000062   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    552          
    553          /**
    554            * @brief  Configures the data size for the selected SPI.
    555            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    556            * @param  SPI_DataSize: specifies the SPI data size.
    557            *          This parameter can be one of the following values:
    558            *            @arg SPI_DataSize_16b: Set data frame format to 16bit
    559            *            @arg SPI_DataSize_8b: Set data frame format to 8bit
    560            * @retval None
    561            */

   \                                 In section .text, align 2, keep-with-next
    562          void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)
    563          {
   \                     SPI_DataSizeConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    564            /* Check the parameters */
    565            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??SPI_DataSizeConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_1  ;; 0x40003800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??SPI_DataSizeConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40003c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??SPI_DataSizeConfig_0
   \   0000001E   0xF240 0x2135      MOVW     R1,#+565
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000026   0x.... 0x....      BL       assert_failed
    566            assert_param(IS_SPI_DATASIZE(SPI_DataSize));
   \                     ??SPI_DataSizeConfig_0: (+1)
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0xF5B5 0x6F00      CMP      R5,#+2048
   \   00000030   0xD008             BEQ.N    ??SPI_DataSizeConfig_1
   \   00000032   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD005             BEQ.N    ??SPI_DataSizeConfig_1
   \   00000038   0xF240 0x2136      MOVW     R1,#+566
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000040   0x.... 0x....      BL       assert_failed
    567            /* Clear DFF bit */
    568            SPIx->CR1 &= (uint16_t)~SPI_DataSize_16b;
   \                     ??SPI_DataSizeConfig_1: (+1)
   \   00000044   0x8820             LDRH     R0,[R4, #+0]
   \   00000046   0xF24F 0x71FF      MOVW     R1,#+63487
   \   0000004A   0x4008             ANDS     R0,R1,R0
   \   0000004C   0x8020             STRH     R0,[R4, #+0]
    569            /* Set new DFF bit value */
    570            SPIx->CR1 |= SPI_DataSize;
   \   0000004E   0x8820             LDRH     R0,[R4, #+0]
   \   00000050   0x4328             ORRS     R0,R5,R0
   \   00000052   0x8020             STRH     R0,[R4, #+0]
    571          }
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    572          
    573          /**
    574            * @brief  Selects the data transfer direction in bidirectional mode for the specified SPI.
    575            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    576            * @param  SPI_Direction: specifies the data transfer direction in bidirectional mode. 
    577            *          This parameter can be one of the following values:
    578            *            @arg SPI_Direction_Tx: Selects Tx transmission direction
    579            *            @arg SPI_Direction_Rx: Selects Rx receive direction
    580            * @retval None
    581            */

   \                                 In section .text, align 2, keep-with-next
    582          void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
    583          {
   \                     SPI_BiDirectionalLineConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    584            /* Check the parameters */
    585            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??SPI_BiDirectionalLineConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_1  ;; 0x40003800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??SPI_BiDirectionalLineConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40003c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??SPI_BiDirectionalLineConfig_0
   \   0000001E   0xF240 0x2149      MOVW     R1,#+585
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000026   0x.... 0x....      BL       assert_failed
    586            assert_param(IS_SPI_DIRECTION(SPI_Direction));
   \                     ??SPI_BiDirectionalLineConfig_0: (+1)
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0xF64B 0x70FF      MOVW     R0,#+49151
   \   00000030   0x4285             CMP      R5,R0
   \   00000032   0xD009             BEQ.N    ??SPI_BiDirectionalLineConfig_1
   \   00000034   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000036   0xF5B5 0x4F80      CMP      R5,#+16384
   \   0000003A   0xD005             BEQ.N    ??SPI_BiDirectionalLineConfig_1
   \   0000003C   0xF240 0x214A      MOVW     R1,#+586
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000044   0x.... 0x....      BL       assert_failed
    587            if (SPI_Direction == SPI_Direction_Tx)
   \                     ??SPI_BiDirectionalLineConfig_1: (+1)
   \   00000048   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004A   0xF5B5 0x4F80      CMP      R5,#+16384
   \   0000004E   0xD104             BNE.N    ??SPI_BiDirectionalLineConfig_2
    588            {
    589              /* Set the Tx only mode */
    590              SPIx->CR1 |= SPI_Direction_Tx;
   \   00000050   0x8820             LDRH     R0,[R4, #+0]
   \   00000052   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   00000056   0x8020             STRH     R0,[R4, #+0]
   \   00000058   0xE004             B.N      ??SPI_BiDirectionalLineConfig_3
    591            }
    592            else
    593            {
    594              /* Set the Rx only mode */
    595              SPIx->CR1 &= SPI_Direction_Rx;
   \                     ??SPI_BiDirectionalLineConfig_2: (+1)
   \   0000005A   0x8820             LDRH     R0,[R4, #+0]
   \   0000005C   0xF64B 0x71FF      MOVW     R1,#+49151
   \   00000060   0x4008             ANDS     R0,R1,R0
   \   00000062   0x8020             STRH     R0,[R4, #+0]
    596            }
    597          }
   \                     ??SPI_BiDirectionalLineConfig_3: (+1)
   \   00000064   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    598          
    599          /**
    600            * @brief  Configures internally by software the NSS pin for the selected SPI.
    601            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    602            * @param  SPI_NSSInternalSoft: specifies the SPI NSS internal state.
    603            *          This parameter can be one of the following values:
    604            *            @arg SPI_NSSInternalSoft_Set: Set NSS pin internally
    605            *            @arg SPI_NSSInternalSoft_Reset: Reset NSS pin internally
    606            * @retval None
    607            */

   \                                 In section .text, align 2, keep-with-next
    608          void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
    609          {
   \                     SPI_NSSInternalSoftwareConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    610            /* Check the parameters */
    611            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??SPI_NSSInternalSoftwareConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_1  ;; 0x40003800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??SPI_NSSInternalSoftwareConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40003c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??SPI_NSSInternalSoftwareConfig_0
   \   0000001E   0xF240 0x2163      MOVW     R1,#+611
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000026   0x.... 0x....      BL       assert_failed
    612            assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
   \                     ??SPI_NSSInternalSoftwareConfig_0: (+1)
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000030   0xD00A             BEQ.N    ??SPI_NSSInternalSoftwareConfig_1
   \   00000032   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000034   0xF64F 0x60FF      MOVW     R0,#+65279
   \   00000038   0x4285             CMP      R5,R0
   \   0000003A   0xD005             BEQ.N    ??SPI_NSSInternalSoftwareConfig_1
   \   0000003C   0xF44F 0x7119      MOV      R1,#+612
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000044   0x.... 0x....      BL       assert_failed
    613            if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
   \                     ??SPI_NSSInternalSoftwareConfig_1: (+1)
   \   00000048   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004A   0xF64F 0x60FF      MOVW     R0,#+65279
   \   0000004E   0x4285             CMP      R5,R0
   \   00000050   0xD004             BEQ.N    ??SPI_NSSInternalSoftwareConfig_2
    614            {
    615              /* Set NSS pin internally by software */
    616              SPIx->CR1 |= SPI_NSSInternalSoft_Set;
   \   00000052   0x8820             LDRH     R0,[R4, #+0]
   \   00000054   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000058   0x8020             STRH     R0,[R4, #+0]
   \   0000005A   0xE004             B.N      ??SPI_NSSInternalSoftwareConfig_3
    617            }
    618            else
    619            {
    620              /* Reset NSS pin internally by software */
    621              SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
   \                     ??SPI_NSSInternalSoftwareConfig_2: (+1)
   \   0000005C   0x8820             LDRH     R0,[R4, #+0]
   \   0000005E   0xF64F 0x61FF      MOVW     R1,#+65279
   \   00000062   0x4008             ANDS     R0,R1,R0
   \   00000064   0x8020             STRH     R0,[R4, #+0]
    622            }
    623          }
   \                     ??SPI_NSSInternalSoftwareConfig_3: (+1)
   \   00000066   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    624          
    625          /**
    626            * @brief  Enables or disables the SS output for the selected SPI.
    627            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    628            * @param  NewState: new state of the SPIx SS output. 
    629            *          This parameter can be: ENABLE or DISABLE.
    630            * @retval None
    631            */

   \                                 In section .text, align 2, keep-with-next
    632          void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    633          {
   \                     SPI_SSOutputCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    634            /* Check the parameters */
    635            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??SPI_SSOutputCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_1  ;; 0x40003800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??SPI_SSOutputCmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40003c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??SPI_SSOutputCmd_0
   \   0000001E   0xF240 0x217B      MOVW     R1,#+635
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000026   0x.... 0x....      BL       assert_failed
    636            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??SPI_SSOutputCmd_0: (+1)
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD008             BEQ.N    ??SPI_SSOutputCmd_1
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D01             CMP      R5,#+1
   \   00000034   0xD005             BEQ.N    ??SPI_SSOutputCmd_1
   \   00000036   0xF44F 0x711F      MOV      R1,#+636
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000003E   0x.... 0x....      BL       assert_failed
    637            if (NewState != DISABLE)
   \                     ??SPI_SSOutputCmd_1: (+1)
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD004             BEQ.N    ??SPI_SSOutputCmd_2
    638            {
    639              /* Enable the selected SPI SS output */
    640              SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
   \   00000048   0x88A0             LDRH     R0,[R4, #+4]
   \   0000004A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000004E   0x80A0             STRH     R0,[R4, #+4]
   \   00000050   0xE004             B.N      ??SPI_SSOutputCmd_3
    641            }
    642            else
    643            {
    644              /* Disable the selected SPI SS output */
    645              SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
   \                     ??SPI_SSOutputCmd_2: (+1)
   \   00000052   0x88A0             LDRH     R0,[R4, #+4]
   \   00000054   0xF64F 0x71FB      MOVW     R1,#+65531
   \   00000058   0x4008             ANDS     R0,R1,R0
   \   0000005A   0x80A0             STRH     R0,[R4, #+4]
    646            }
    647          }
   \                     ??SPI_SSOutputCmd_3: (+1)
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    648          
    649          /**
    650            * @brief  Enables or disables the SPIx/I2Sx DMA interface.
    651            *   
    652            * @note   This function can be called only after the SPI_Init() function has 
    653            *         been called. 
    654            * @note   When TI mode is selected, the control bits SSM, SSI, CPOL and CPHA 
    655            *         are not taken into consideration and are configured by hardware
    656            *         respectively to the TI mode requirements.  
    657            * 
    658            * @param  SPIx: where x can be 1, 2 or 3 
    659            * @param  NewState: new state of the selected SPI TI communication mode.
    660            *          This parameter can be: ENABLE or DISABLE.
    661            * @retval None
    662            */

   \                                 In section .text, align 2, keep-with-next
    663          void SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    664          {
   \                     SPI_TIModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    665            /* Check the parameters */
    666            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??SPI_TIModeCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_1  ;; 0x40003800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??SPI_TIModeCmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40003c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??SPI_TIModeCmd_0
   \   0000001E   0xF240 0x219A      MOVW     R1,#+666
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000026   0x.... 0x....      BL       assert_failed
    667            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??SPI_TIModeCmd_0: (+1)
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD008             BEQ.N    ??SPI_TIModeCmd_1
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D01             CMP      R5,#+1
   \   00000034   0xD005             BEQ.N    ??SPI_TIModeCmd_1
   \   00000036   0xF240 0x219B      MOVW     R1,#+667
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000003E   0x.... 0x....      BL       assert_failed
    668          
    669            if (NewState != DISABLE)
   \                     ??SPI_TIModeCmd_1: (+1)
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD004             BEQ.N    ??SPI_TIModeCmd_2
    670            {
    671              /* Enable the TI mode for the selected SPI peripheral */
    672              SPIx->CR2 |= SPI_CR2_FRF;
   \   00000048   0x88A0             LDRH     R0,[R4, #+4]
   \   0000004A   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000004E   0x80A0             STRH     R0,[R4, #+4]
   \   00000050   0xE004             B.N      ??SPI_TIModeCmd_3
    673            }
    674            else
    675            {
    676              /* Disable the TI mode for the selected SPI peripheral */
    677              SPIx->CR2 &= (uint16_t)~SPI_CR2_FRF;
   \                     ??SPI_TIModeCmd_2: (+1)
   \   00000052   0x88A0             LDRH     R0,[R4, #+4]
   \   00000054   0xF64F 0x71EF      MOVW     R1,#+65519
   \   00000058   0x4008             ANDS     R0,R1,R0
   \   0000005A   0x80A0             STRH     R0,[R4, #+4]
    678            }
    679          }
   \                     ??SPI_TIModeCmd_3: (+1)
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    680          
    681          /**
    682            * @brief  Configures the full duplex mode for the I2Sx peripheral using its
    683            *         extension I2Sxext according to the specified parameters in the 
    684            *         I2S_InitStruct.
    685            * @param  I2Sxext: where x can be  2 or 3 to select the I2S peripheral extension block.
    686            * @param  I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
    687            *         contains the configuration information for the specified I2S peripheral
    688            *         extension.
    689            * 
    690            * @note   The structure pointed by I2S_InitStruct parameter should be the same
    691            *         used for the master I2S peripheral. In this case, if the master is 
    692            *         configured as transmitter, the slave will be receiver and vice versa.
    693            *         Or you can force a different mode by modifying the field I2S_Mode to the
    694            *         value I2S_SlaveRx or I2S_SlaveTx indepedently of the master configuration.    
    695            *         
    696            * @note   The I2S full duplex extension can be configured in slave mode only.    
    697            *  
    698            * @retval None
    699            */

   \                                 In section .text, align 2, keep-with-next
    700          void I2S_FullDuplexConfig(SPI_TypeDef* I2Sxext, I2S_InitTypeDef* I2S_InitStruct)
    701          {
   \                     I2S_FullDuplexConfig: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    702            uint16_t tmpreg = 0, tmp = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x2700             MOVS     R7,#+0
    703            
    704            /* Check the I2S parameters */
    705            assert_param(IS_I2S_EXT_PERIPH(I2Sxext));
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable22_6  ;; 0x40003400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD008             BEQ.N    ??I2S_FullDuplexConfig_0
   \   00000012   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   00000016   0xD005             BEQ.N    ??I2S_FullDuplexConfig_0
   \   00000018   0xF240 0x21C1      MOVW     R1,#+705
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000020   0x.... 0x....      BL       assert_failed
    706            assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
   \                     ??I2S_FullDuplexConfig_0: (+1)
   \   00000024   0x8828             LDRH     R0,[R5, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD011             BEQ.N    ??I2S_FullDuplexConfig_1
   \   0000002A   0x8828             LDRH     R0,[R5, #+0]
   \   0000002C   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000030   0xD00D             BEQ.N    ??I2S_FullDuplexConfig_1
   \   00000032   0x8828             LDRH     R0,[R5, #+0]
   \   00000034   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000038   0xD009             BEQ.N    ??I2S_FullDuplexConfig_1
   \   0000003A   0x8828             LDRH     R0,[R5, #+0]
   \   0000003C   0xF5B0 0x7F40      CMP      R0,#+768
   \   00000040   0xD005             BEQ.N    ??I2S_FullDuplexConfig_1
   \   00000042   0xF240 0x21C2      MOVW     R1,#+706
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000004A   0x.... 0x....      BL       assert_failed
    707            assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
   \                     ??I2S_FullDuplexConfig_1: (+1)
   \   0000004E   0x8868             LDRH     R0,[R5, #+2]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD010             BEQ.N    ??I2S_FullDuplexConfig_2
   \   00000054   0x8868             LDRH     R0,[R5, #+2]
   \   00000056   0x2810             CMP      R0,#+16
   \   00000058   0xD00D             BEQ.N    ??I2S_FullDuplexConfig_2
   \   0000005A   0x8868             LDRH     R0,[R5, #+2]
   \   0000005C   0x2820             CMP      R0,#+32
   \   0000005E   0xD00A             BEQ.N    ??I2S_FullDuplexConfig_2
   \   00000060   0x8868             LDRH     R0,[R5, #+2]
   \   00000062   0x2830             CMP      R0,#+48
   \   00000064   0xD007             BEQ.N    ??I2S_FullDuplexConfig_2
   \   00000066   0x8868             LDRH     R0,[R5, #+2]
   \   00000068   0x28B0             CMP      R0,#+176
   \   0000006A   0xD004             BEQ.N    ??I2S_FullDuplexConfig_2
   \   0000006C   0xF240 0x21C3      MOVW     R1,#+707
   \   00000070   0x....             LDR.N    R0,??DataTable18_2
   \   00000072   0x.... 0x....      BL       assert_failed
    708            assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
   \                     ??I2S_FullDuplexConfig_2: (+1)
   \   00000076   0x88A8             LDRH     R0,[R5, #+4]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD00D             BEQ.N    ??I2S_FullDuplexConfig_3
   \   0000007C   0x88A8             LDRH     R0,[R5, #+4]
   \   0000007E   0x2801             CMP      R0,#+1
   \   00000080   0xD00A             BEQ.N    ??I2S_FullDuplexConfig_3
   \   00000082   0x88A8             LDRH     R0,[R5, #+4]
   \   00000084   0x2803             CMP      R0,#+3
   \   00000086   0xD007             BEQ.N    ??I2S_FullDuplexConfig_3
   \   00000088   0x88A8             LDRH     R0,[R5, #+4]
   \   0000008A   0x2805             CMP      R0,#+5
   \   0000008C   0xD004             BEQ.N    ??I2S_FullDuplexConfig_3
   \   0000008E   0xF44F 0x7131      MOV      R1,#+708
   \   00000092   0x....             LDR.N    R0,??DataTable18_2
   \   00000094   0x.... 0x....      BL       assert_failed
    709            assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
   \                     ??I2S_FullDuplexConfig_3: (+1)
   \   00000098   0x89A8             LDRH     R0,[R5, #+12]
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD007             BEQ.N    ??I2S_FullDuplexConfig_4
   \   0000009E   0x89A8             LDRH     R0,[R5, #+12]
   \   000000A0   0x2808             CMP      R0,#+8
   \   000000A2   0xD004             BEQ.N    ??I2S_FullDuplexConfig_4
   \   000000A4   0xF240 0x21C5      MOVW     R1,#+709
   \   000000A8   0x....             LDR.N    R0,??DataTable18_2
   \   000000AA   0x.... 0x....      BL       assert_failed
    710          
    711          /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
    712            /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    713            I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
   \                     ??I2S_FullDuplexConfig_4: (+1)
   \   000000AE   0x8BA0             LDRH     R0,[R4, #+28]
   \   000000B0   0xF24F 0x0140      MOVW     R1,#+61504
   \   000000B4   0x4008             ANDS     R0,R1,R0
   \   000000B6   0x83A0             STRH     R0,[R4, #+28]
    714            I2Sxext->I2SPR = 0x0002;
   \   000000B8   0x2002             MOVS     R0,#+2
   \   000000BA   0x8420             STRH     R0,[R4, #+32]
    715            
    716            /* Get the I2SCFGR register value */
    717            tmpreg = I2Sxext->I2SCFGR;
   \   000000BC   0x8BA0             LDRH     R0,[R4, #+28]
   \   000000BE   0x0006             MOVS     R6,R0
    718            
    719            /* Get the mode to be configured for the extended I2S */
    720            if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
   \   000000C0   0x8828             LDRH     R0,[R5, #+0]
   \   000000C2   0xF5B0 0x7F00      CMP      R0,#+512
   \   000000C6   0xD002             BEQ.N    ??I2S_FullDuplexConfig_5
   \   000000C8   0x8828             LDRH     R0,[R5, #+0]
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD103             BNE.N    ??I2S_FullDuplexConfig_6
    721            {
    722              tmp = I2S_Mode_SlaveRx;
   \                     ??I2S_FullDuplexConfig_5: (+1)
   \   000000CE   0xF44F 0x7080      MOV      R0,#+256
   \   000000D2   0x0007             MOVS     R7,R0
   \   000000D4   0xE009             B.N      ??I2S_FullDuplexConfig_7
    723            }
    724            else
    725            {
    726              if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterRx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveRx))
   \                     ??I2S_FullDuplexConfig_6: (+1)
   \   000000D6   0x8828             LDRH     R0,[R5, #+0]
   \   000000D8   0xF5B0 0x7F40      CMP      R0,#+768
   \   000000DC   0xD003             BEQ.N    ??I2S_FullDuplexConfig_8
   \   000000DE   0x8828             LDRH     R0,[R5, #+0]
   \   000000E0   0xF5B0 0x7F80      CMP      R0,#+256
   \   000000E4   0xD101             BNE.N    ??I2S_FullDuplexConfig_7
    727              {
    728                tmp = I2S_Mode_SlaveTx;
   \                     ??I2S_FullDuplexConfig_8: (+1)
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0x0007             MOVS     R7,R0
    729              }
    730            }
    731          
    732           
    733            /* Configure the I2S with the SPI_InitStruct values */
    734            tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
    735                            (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
    736                            (uint16_t)I2S_InitStruct->I2S_CPOL))));
   \                     ??I2S_FullDuplexConfig_7: (+1)
   \   000000EA   0x8868             LDRH     R0,[R5, #+2]
   \   000000EC   0x88A9             LDRH     R1,[R5, #+4]
   \   000000EE   0x89AA             LDRH     R2,[R5, #+12]
   \   000000F0   0x4311             ORRS     R1,R2,R1
   \   000000F2   0x4308             ORRS     R0,R1,R0
   \   000000F4   0x4338             ORRS     R0,R0,R7
   \   000000F6   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   000000FA   0x4306             ORRS     R6,R0,R6
    737           
    738            /* Write to SPIx I2SCFGR */  
    739            I2Sxext->I2SCFGR = tmpreg;
   \   000000FC   0x83A6             STRH     R6,[R4, #+28]
    740          }
   \   000000FE   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    741          
    742          /**
    743            * @}
    744            */
    745          
    746          /** @defgroup SPI_Group2 Data transfers functions
    747           *  @brief   Data transfers functions
    748           *
    749          @verbatim   
    750           ===============================================================================
    751                                   Data transfers functions
    752           ===============================================================================  
    753          
    754            This section provides a set of functions allowing to manage the SPI data transfers
    755            
    756            In reception, data are received and then stored into an internal Rx buffer while 
    757            In transmission, data are first stored into an internal Tx buffer before being 
    758            transmitted.
    759          
    760            The read access of the SPI_DR register can be done using the SPI_I2S_ReceiveData()
    761            function and returns the Rx buffered value. Whereas a write access to the SPI_DR 
    762            can be done using SPI_I2S_SendData() function and stores the written data into 
    763            Tx buffer.
    764          
    765          @endverbatim
    766            * @{
    767            */
    768          
    769          /**
    770            * @brief  Returns the most recent received data by the SPIx/I2Sx peripheral. 
    771            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
    772            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
    773            * @retval The value of the received data.
    774            */

   \                                 In section .text, align 2, keep-with-next
    775          uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
    776          {
   \                     SPI_I2S_ReceiveData: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    777            /* Check the parameters */
    778            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   \   00000004   0x....             LDR.N    R0,??DataTable18  ;; 0x40013000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD011             BEQ.N    ??SPI_I2S_ReceiveData_0
   \   0000000A   0x....             LDR.N    R0,??DataTable18_1  ;; 0x40003800
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD00E             BEQ.N    ??SPI_I2S_ReceiveData_0
   \   00000010   0x....             LDR.N    R0,??DataTable19  ;; 0x40003c00
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD00B             BEQ.N    ??SPI_I2S_ReceiveData_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable22_6  ;; 0x40003400
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD007             BEQ.N    ??SPI_I2S_ReceiveData_0
   \   0000001E   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   00000022   0xD004             BEQ.N    ??SPI_I2S_ReceiveData_0
   \   00000024   0xF240 0x310A      MOVW     R1,#+778
   \   00000028   0x....             LDR.N    R0,??DataTable18_2
   \   0000002A   0x.... 0x....      BL       assert_failed
    779            
    780            /* Return the data in the DR register */
    781            return SPIx->DR;
   \                     ??SPI_I2S_ReceiveData_0: (+1)
   \   0000002E   0x89A0             LDRH     R0,[R4, #+12]
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    782          }
    783          
    784          /**
    785            * @brief  Transmits a Data through the SPIx/I2Sx peripheral.
    786            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
    787            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode.     
    788            * @param  Data: Data to be transmitted.
    789            * @retval None
    790            */

   \                                 In section .text, align 2, keep-with-next
    791          void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
    792          {
   \                     SPI_I2S_SendData: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    793            /* Check the parameters */
    794            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   \   00000006   0x....             LDR.N    R0,??DataTable18  ;; 0x40013000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD011             BEQ.N    ??SPI_I2S_SendData_0
   \   0000000C   0x....             LDR.N    R0,??DataTable18_1  ;; 0x40003800
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD00E             BEQ.N    ??SPI_I2S_SendData_0
   \   00000012   0x....             LDR.N    R0,??DataTable19  ;; 0x40003c00
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD00B             BEQ.N    ??SPI_I2S_SendData_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable22_6  ;; 0x40003400
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD007             BEQ.N    ??SPI_I2S_SendData_0
   \   00000020   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   00000024   0xD004             BEQ.N    ??SPI_I2S_SendData_0
   \   00000026   0xF240 0x311A      MOVW     R1,#+794
   \   0000002A   0x....             LDR.N    R0,??DataTable18_2
   \   0000002C   0x.... 0x....      BL       assert_failed
    795            
    796            /* Write in the DR register the data to be sent */
    797            SPIx->DR = Data;
   \                     ??SPI_I2S_SendData_0: (+1)
   \   00000030   0x81A5             STRH     R5,[R4, #+12]
    798          }
   \   00000032   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    799          
    800          /**
    801            * @}
    802            */
    803          
    804          /** @defgroup SPI_Group3 Hardware CRC Calculation functions
    805           *  @brief   Hardware CRC Calculation functions
    806           *
    807          @verbatim   
    808           ===============================================================================
    809                                   Hardware CRC Calculation functions
    810           ===============================================================================  
    811          
    812            This section provides a set of functions allowing to manage the SPI CRC hardware 
    813            calculation
    814          
    815            SPI communication using CRC is possible through the following procedure:
    816               1. Program the Data direction, Polarity, Phase, First Data, Baud Rate Prescaler, 
    817                  Slave Management, Peripheral Mode and CRC Polynomial values using the SPI_Init()
    818                  function.
    819               2. Enable the CRC calculation using the SPI_CalculateCRC() function.
    820               3. Enable the SPI using the SPI_Cmd() function
    821               4. Before writing the last data to the TX buffer, set the CRCNext bit using the 
    822                SPI_TransmitCRC() function to indicate that after transmission of the last 
    823                data, the CRC should be transmitted.
    824               5. After transmitting the last data, the SPI transmits the CRC. The SPI_CR1_CRCNEXT
    825                  bit is reset. The CRC is also received and compared against the SPI_RXCRCR 
    826                  value. 
    827                  If the value does not match, the SPI_FLAG_CRCERR flag is set and an interrupt
    828                  can be generated when the SPI_I2S_IT_ERR interrupt is enabled.
    829          
    830          @note It is advised not to read the calculated CRC values during the communication.
    831          
    832          @note When the SPI is in slave mode, be careful to enable CRC calculation only 
    833                when the clock is stable, that is, when the clock is in the steady state. 
    834                If not, a wrong CRC calculation may be done. In fact, the CRC is sensitive 
    835                to the SCK slave input clock as soon as CRCEN is set, and this, whatever 
    836                the value of the SPE bit.
    837          
    838          @note With high bitrate frequencies, be careful when transmitting the CRC.
    839                As the number of used CPU cycles has to be as low as possible in the CRC 
    840                transfer phase, it is forbidden to call software functions in the CRC 
    841                transmission sequence to avoid errors in the last data and CRC reception. 
    842                In fact, CRCNEXT bit has to be written before the end of the transmission/reception 
    843                of the last data.
    844          
    845          @note For high bit rate frequencies, it is advised to use the DMA mode to avoid the
    846                degradation of the SPI speed performance due to CPU accesses impacting the 
    847                SPI bandwidth.
    848          
    849          @note When the STM32F4xx is configured as slave and the NSS hardware mode is 
    850                used, the NSS pin needs to be kept low between the data phase and the CRC 
    851                phase.
    852          
    853          @note When the SPI is configured in slave mode with the CRC feature enabled, CRC
    854                calculation takes place even if a high level is applied on the NSS pin. 
    855                This may happen for example in case of a multi-slave environment where the 
    856                communication master addresses slaves alternately.
    857          
    858          @note Between a slave de-selection (high level on NSS) and a new slave selection 
    859                (low level on NSS), the CRC value should be cleared on both master and slave
    860                sides in order to resynchronize the master and slave for their respective 
    861                CRC calculation.
    862          
    863          @note To clear the CRC, follow the procedure below:
    864                  1. Disable SPI using the SPI_Cmd() function
    865                  2. Disable the CRC calculation using the SPI_CalculateCRC() function.
    866                  3. Enable the CRC calculation using the SPI_CalculateCRC() function.
    867                  4. Enable SPI using the SPI_Cmd() function.
    868          
    869          @endverbatim
    870            * @{
    871            */
    872          
    873          /**
    874            * @brief  Enables or disables the CRC value calculation of the transferred bytes.
    875            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    876            * @param  NewState: new state of the SPIx CRC value calculation.
    877            *          This parameter can be: ENABLE or DISABLE.
    878            * @retval None
    879            */

   \                                 In section .text, align 2, keep-with-next
    880          void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
    881          {
   \                     SPI_CalculateCRC: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    882            /* Check the parameters */
    883            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000006   0x....             LDR.N    R0,??DataTable18  ;; 0x40013000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00A             BEQ.N    ??SPI_CalculateCRC_0
   \   0000000C   0x....             LDR.N    R0,??DataTable18_1  ;; 0x40003800
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD007             BEQ.N    ??SPI_CalculateCRC_0
   \   00000012   0x....             LDR.N    R0,??DataTable19  ;; 0x40003c00
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD004             BEQ.N    ??SPI_CalculateCRC_0
   \   00000018   0xF240 0x3173      MOVW     R1,#+883
   \   0000001C   0x....             LDR.N    R0,??DataTable18_2
   \   0000001E   0x.... 0x....      BL       assert_failed
    884            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??SPI_CalculateCRC_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD007             BEQ.N    ??SPI_CalculateCRC_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD004             BEQ.N    ??SPI_CalculateCRC_1
   \   0000002E   0xF44F 0x715D      MOV      R1,#+884
   \   00000032   0x....             LDR.N    R0,??DataTable18_2
   \   00000034   0x.... 0x....      BL       assert_failed
    885            if (NewState != DISABLE)
   \                     ??SPI_CalculateCRC_1: (+1)
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD004             BEQ.N    ??SPI_CalculateCRC_2
    886            {
    887              /* Enable the selected SPI CRC calculation */
    888              SPIx->CR1 |= SPI_CR1_CRCEN;
   \   0000003E   0x8820             LDRH     R0,[R4, #+0]
   \   00000040   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000044   0x8020             STRH     R0,[R4, #+0]
   \   00000046   0xE004             B.N      ??SPI_CalculateCRC_3
    889            }
    890            else
    891            {
    892              /* Disable the selected SPI CRC calculation */
    893              SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
   \                     ??SPI_CalculateCRC_2: (+1)
   \   00000048   0x8820             LDRH     R0,[R4, #+0]
   \   0000004A   0xF64D 0x71FF      MOVW     R1,#+57343
   \   0000004E   0x4008             ANDS     R0,R1,R0
   \   00000050   0x8020             STRH     R0,[R4, #+0]
    894            }
    895          }
   \                     ??SPI_CalculateCRC_3: (+1)
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    896          
    897          /**
    898            * @brief  Transmit the SPIx CRC value.
    899            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    900            * @retval None
    901            */

   \                                 In section .text, align 2, keep-with-next
    902          void SPI_TransmitCRC(SPI_TypeDef* SPIx)
    903          {
   \                     SPI_TransmitCRC: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    904            /* Check the parameters */
    905            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000004   0x....             LDR.N    R0,??DataTable18  ;; 0x40013000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD00A             BEQ.N    ??SPI_TransmitCRC_0
   \   0000000A   0x....             LDR.N    R0,??DataTable18_1  ;; 0x40003800
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD007             BEQ.N    ??SPI_TransmitCRC_0
   \   00000010   0x....             LDR.N    R0,??DataTable19  ;; 0x40003c00
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD004             BEQ.N    ??SPI_TransmitCRC_0
   \   00000016   0xF240 0x3189      MOVW     R1,#+905
   \   0000001A   0x....             LDR.N    R0,??DataTable18_2
   \   0000001C   0x.... 0x....      BL       assert_failed
    906            
    907            /* Enable the selected SPI CRC transmission */
    908            SPIx->CR1 |= SPI_CR1_CRCNEXT;
   \                     ??SPI_TransmitCRC_0: (+1)
   \   00000020   0x8820             LDRH     R0,[R4, #+0]
   \   00000022   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000026   0x8020             STRH     R0,[R4, #+0]
    909          }
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    910          
    911          /**
    912            * @brief  Returns the transmit or the receive CRC register value for the specified SPI.
    913            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    914            * @param  SPI_CRC: specifies the CRC register to be read.
    915            *          This parameter can be one of the following values:
    916            *            @arg SPI_CRC_Tx: Selects Tx CRC register
    917            *            @arg SPI_CRC_Rx: Selects Rx CRC register
    918            * @retval The selected CRC register value..
    919            */

   \                                 In section .text, align 2, keep-with-next
    920          uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC)
    921          {
   \                     SPI_GetCRC: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    922            uint16_t crcreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    923            /* Check the parameters */
    924            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000008   0x....             LDR.N    R0,??DataTable18  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00A             BEQ.N    ??SPI_GetCRC_0
   \   0000000E   0x....             LDR.N    R0,??DataTable18_1  ;; 0x40003800
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD007             BEQ.N    ??SPI_GetCRC_0
   \   00000014   0x....             LDR.N    R0,??DataTable19  ;; 0x40003c00
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD004             BEQ.N    ??SPI_GetCRC_0
   \   0000001A   0xF44F 0x7167      MOV      R1,#+924
   \   0000001E   0x....             LDR.N    R0,??DataTable18_2
   \   00000020   0x.... 0x....      BL       assert_failed
    925            assert_param(IS_SPI_CRC(SPI_CRC));
   \                     ??SPI_GetCRC_0: (+1)
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD007             BEQ.N    ??SPI_GetCRC_1
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x2D01             CMP      R5,#+1
   \   0000002E   0xD004             BEQ.N    ??SPI_GetCRC_1
   \   00000030   0xF240 0x319D      MOVW     R1,#+925
   \   00000034   0x....             LDR.N    R0,??DataTable18_2
   \   00000036   0x.... 0x....      BL       assert_failed
    926            if (SPI_CRC != SPI_CRC_Rx)
   \                     ??SPI_GetCRC_1: (+1)
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D01             CMP      R5,#+1
   \   0000003E   0xD002             BEQ.N    ??SPI_GetCRC_2
    927            {
    928              /* Get the Tx CRC register */
    929              crcreg = SPIx->TXCRCR;
   \   00000040   0x8B20             LDRH     R0,[R4, #+24]
   \   00000042   0x0006             MOVS     R6,R0
   \   00000044   0xE001             B.N      ??SPI_GetCRC_3
    930            }
    931            else
    932            {
    933              /* Get the Rx CRC register */
    934              crcreg = SPIx->RXCRCR;
   \                     ??SPI_GetCRC_2: (+1)
   \   00000046   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000048   0x0006             MOVS     R6,R0
    935            }
    936            /* Return the selected CRC register */
    937            return crcreg;
   \                     ??SPI_GetCRC_3: (+1)
   \   0000004A   0x0030             MOVS     R0,R6
   \   0000004C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000004E   0xBD70             POP      {R4-R6,PC}       ;; return
    938          }
    939          
    940          /**
    941            * @brief  Returns the CRC Polynomial register value for the specified SPI.
    942            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    943            * @retval The CRC Polynomial register value.
    944            */

   \                                 In section .text, align 2, keep-with-next
    945          uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
    946          {
   \                     SPI_GetCRCPolynomial: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    947            /* Check the parameters */
    948            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000004   0x....             LDR.N    R0,??DataTable18  ;; 0x40013000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD00A             BEQ.N    ??SPI_GetCRCPolynomial_0
   \   0000000A   0x....             LDR.N    R0,??DataTable18_1  ;; 0x40003800
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD007             BEQ.N    ??SPI_GetCRCPolynomial_0
   \   00000010   0x....             LDR.N    R0,??DataTable19  ;; 0x40003c00
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD004             BEQ.N    ??SPI_GetCRCPolynomial_0
   \   00000016   0xF44F 0x716D      MOV      R1,#+948
   \   0000001A   0x....             LDR.N    R0,??DataTable18_2
   \   0000001C   0x.... 0x....      BL       assert_failed
    949            
    950            /* Return the CRC polynomial register */
    951            return SPIx->CRCPR;
   \                     ??SPI_GetCRCPolynomial_0: (+1)
   \   00000020   0x8A20             LDRH     R0,[R4, #+16]
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    952          }
    953          
    954          /**
    955            * @}
    956            */
    957          
    958          /** @defgroup SPI_Group4 DMA transfers management functions
    959           *  @brief   DMA transfers management functions
    960            *
    961          @verbatim   
    962           ===============================================================================
    963                                   DMA transfers management functions
    964           ===============================================================================  
    965          
    966          @endverbatim
    967            * @{
    968            */
    969          
    970          /**
    971            * @brief  Enables or disables the SPIx/I2Sx DMA interface.
    972            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
    973            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
    974            * @param  SPI_I2S_DMAReq: specifies the SPI DMA transfer request to be enabled or disabled. 
    975            *          This parameter can be any combination of the following values:
    976            *            @arg SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
    977            *            @arg SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
    978            * @param  NewState: new state of the selected SPI DMA transfer request.
    979            *          This parameter can be: ENABLE or DISABLE.
    980            * @retval None
    981            */

   \                                 In section .text, align 2, keep-with-next
    982          void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
    983          {
   \                     SPI_I2S_DMACmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    984            /* Check the parameters */
    985            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   \   00000008   0x....             LDR.N    R0,??DataTable18  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD010             BEQ.N    ??SPI_I2S_DMACmd_0
   \   0000000E   0x....             LDR.N    R0,??DataTable18_1  ;; 0x40003800
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD00D             BEQ.N    ??SPI_I2S_DMACmd_0
   \   00000014   0x....             LDR.N    R0,??DataTable19  ;; 0x40003c00
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD00A             BEQ.N    ??SPI_I2S_DMACmd_0
   \   0000001A   0x....             LDR.N    R0,??DataTable22_6  ;; 0x40003400
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD007             BEQ.N    ??SPI_I2S_DMACmd_0
   \   00000020   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   00000024   0xD004             BEQ.N    ??SPI_I2S_DMACmd_0
   \   00000026   0xF240 0x31D9      MOVW     R1,#+985
   \   0000002A   0x....             LDR.N    R0,??DataTable18_2
   \   0000002C   0x.... 0x....      BL       assert_failed
    986            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??SPI_I2S_DMACmd_0: (+1)
   \   00000030   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000032   0x2E00             CMP      R6,#+0
   \   00000034   0xD007             BEQ.N    ??SPI_I2S_DMACmd_1
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x2E01             CMP      R6,#+1
   \   0000003A   0xD004             BEQ.N    ??SPI_I2S_DMACmd_1
   \   0000003C   0xF240 0x31DA      MOVW     R1,#+986
   \   00000040   0x....             LDR.N    R0,??DataTable18_2
   \   00000042   0x.... 0x....      BL       assert_failed
    987            assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
   \                     ??SPI_I2S_DMACmd_1: (+1)
   \   00000046   0xF64F 0x70FC      MOVW     R0,#+65532
   \   0000004A   0x4205             TST      R5,R0
   \   0000004C   0xD102             BNE.N    ??SPI_I2S_DMACmd_2
   \   0000004E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000050   0x2D00             CMP      R5,#+0
   \   00000052   0xD104             BNE.N    ??SPI_I2S_DMACmd_3
   \                     ??SPI_I2S_DMACmd_2: (+1)
   \   00000054   0xF240 0x31DB      MOVW     R1,#+987
   \   00000058   0x....             LDR.N    R0,??DataTable18_2
   \   0000005A   0x.... 0x....      BL       assert_failed
    988          
    989            if (NewState != DISABLE)
   \                     ??SPI_I2S_DMACmd_3: (+1)
   \   0000005E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000060   0x2E00             CMP      R6,#+0
   \   00000062   0xD003             BEQ.N    ??SPI_I2S_DMACmd_4
    990            {
    991              /* Enable the selected SPI DMA requests */
    992              SPIx->CR2 |= SPI_I2S_DMAReq;
   \   00000064   0x88A0             LDRH     R0,[R4, #+4]
   \   00000066   0x4328             ORRS     R0,R5,R0
   \   00000068   0x80A0             STRH     R0,[R4, #+4]
   \   0000006A   0xE002             B.N      ??SPI_I2S_DMACmd_5
    993            }
    994            else
    995            {
    996              /* Disable the selected SPI DMA requests */
    997              SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
   \                     ??SPI_I2S_DMACmd_4: (+1)
   \   0000006C   0x88A0             LDRH     R0,[R4, #+4]
   \   0000006E   0x43A8             BICS     R0,R0,R5
   \   00000070   0x80A0             STRH     R0,[R4, #+4]
    998            }
    999          }
   \                     ??SPI_I2S_DMACmd_5: (+1)
   \   00000072   0xBD70             POP      {R4-R6,PC}       ;; return
   1000          
   1001          /**
   1002            * @}
   1003            */
   1004          
   1005          /** @defgroup SPI_Group5 Interrupts and flags management functions
   1006           *  @brief   Interrupts and flags management functions
   1007            *
   1008          @verbatim   
   1009           ===============================================================================
   1010                                   Interrupts and flags management functions
   1011           ===============================================================================  
   1012          
   1013            This section provides a set of functions allowing to configure the SPI Interrupts 
   1014            sources and check or clear the flags or pending bits status.
   1015            The user should identify which mode will be used in his application to manage 
   1016            the communication: Polling mode, Interrupt mode or DMA mode. 
   1017              
   1018            Polling Mode
   1019            =============
   1020            In Polling Mode, the SPI/I2S communication can be managed by 9 flags:
   1021               1. SPI_I2S_FLAG_TXE : to indicate the status of the transmit buffer register
   1022               2. SPI_I2S_FLAG_RXNE : to indicate the status of the receive buffer register
   1023               3. SPI_I2S_FLAG_BSY : to indicate the state of the communication layer of the SPI.
   1024               4. SPI_FLAG_CRCERR : to indicate if a CRC Calculation error occur              
   1025               5. SPI_FLAG_MODF : to indicate if a Mode Fault error occur
   1026               6. SPI_I2S_FLAG_OVR : to indicate if an Overrun error occur
   1027               7. I2S_FLAG_TIFRFE: to indicate a Frame Format error occurs.
   1028               8. I2S_FLAG_UDR: to indicate an Underrun error occurs.
   1029               9. I2S_FLAG_CHSIDE: to indicate Channel Side.
   1030          
   1031          @note Do not use the BSY flag to handle each data transmission or reception.  It is
   1032                better to use the TXE and RXNE flags instead.
   1033          
   1034            In this Mode it is advised to use the following functions:
   1035               - FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
   1036               - void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
   1037          
   1038            Interrupt Mode
   1039            ===============
   1040            In Interrupt Mode, the SPI communication can be managed by 3 interrupt sources
   1041            and 7 pending bits: 
   1042            Pending Bits:
   1043            ------------- 
   1044               1. SPI_I2S_IT_TXE : to indicate the status of the transmit buffer register
   1045               2. SPI_I2S_IT_RXNE : to indicate the status of the receive buffer register
   1046               3. SPI_IT_CRCERR : to indicate if a CRC Calculation error occur (available in SPI mode only)            
   1047               4. SPI_IT_MODF : to indicate if a Mode Fault error occur (available in SPI mode only)
   1048               5. SPI_I2S_IT_OVR : to indicate if an Overrun error occur
   1049               6. I2S_IT_UDR : to indicate an Underrun Error occurs (available in I2S mode only).
   1050               7. I2S_FLAG_TIFRFE : to indicate a Frame Format error occurs (available in TI mode only).
   1051          
   1052            Interrupt Source:
   1053            -----------------
   1054               1. SPI_I2S_IT_TXE: specifies the interrupt source for the Tx buffer empty 
   1055                                  interrupt.  
   1056               2. SPI_I2S_IT_RXNE : specifies the interrupt source for the Rx buffer not 
   1057                                    empty interrupt.
   1058               3. SPI_I2S_IT_ERR : specifies the interrupt source for the errors interrupt.
   1059          
   1060            In this Mode it is advised to use the following functions:
   1061               - void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState);
   1062               - ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
   1063               - void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
   1064          
   1065            DMA Mode
   1066            ========
   1067            In DMA Mode, the SPI communication can be managed by 2 DMA Channel requests:
   1068               1. SPI_I2S_DMAReq_Tx: specifies the Tx buffer DMA transfer request
   1069               2. SPI_I2S_DMAReq_Rx: specifies the Rx buffer DMA transfer request
   1070          
   1071            In this Mode it is advised to use the following function:
   1072              - void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState);
   1073          
   1074          @endverbatim
   1075            * @{
   1076            */
   1077          
   1078          /**
   1079            * @brief  Enables or disables the specified SPI/I2S interrupts.
   1080            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
   1081            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
   1082            * @param  SPI_I2S_IT: specifies the SPI interrupt source to be enabled or disabled. 
   1083            *          This parameter can be one of the following values:
   1084            *            @arg SPI_I2S_IT_TXE: Tx buffer empty interrupt mask
   1085            *            @arg SPI_I2S_IT_RXNE: Rx buffer not empty interrupt mask
   1086            *            @arg SPI_I2S_IT_ERR: Error interrupt mask
   1087            * @param  NewState: new state of the specified SPI interrupt.
   1088            *          This parameter can be: ENABLE or DISABLE.
   1089            * @retval None
   1090            */

   \                                 In section .text, align 2, keep-with-next
   1091          void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
   1092          {
   \                     SPI_I2S_ITConfig: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1093            uint16_t itpos = 0, itmask = 0 ;
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1094            
   1095            /* Check the parameters */
   1096            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   \   00000010   0x....             LDR.N    R0,??DataTable18  ;; 0x40013000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD010             BEQ.N    ??SPI_I2S_ITConfig_0
   \   00000016   0x....             LDR.N    R0,??DataTable18_1  ;; 0x40003800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD00D             BEQ.N    ??SPI_I2S_ITConfig_0
   \   0000001C   0x....             LDR.N    R0,??DataTable19  ;; 0x40003c00
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD00A             BEQ.N    ??SPI_I2S_ITConfig_0
   \   00000022   0x....             LDR.N    R0,??DataTable22_6  ;; 0x40003400
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD007             BEQ.N    ??SPI_I2S_ITConfig_0
   \   00000028   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   0000002C   0xD004             BEQ.N    ??SPI_I2S_ITConfig_0
   \   0000002E   0xF44F 0x6189      MOV      R1,#+1096
   \   00000032   0x....             LDR.N    R0,??DataTable18_2
   \   00000034   0x.... 0x....      BL       assert_failed
   1097            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??SPI_I2S_ITConfig_0: (+1)
   \   00000038   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003A   0x2E00             CMP      R6,#+0
   \   0000003C   0xD007             BEQ.N    ??SPI_I2S_ITConfig_1
   \   0000003E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000040   0x2E01             CMP      R6,#+1
   \   00000042   0xD004             BEQ.N    ??SPI_I2S_ITConfig_1
   \   00000044   0xF240 0x4149      MOVW     R1,#+1097
   \   00000048   0x....             LDR.N    R0,??DataTable18_2
   \   0000004A   0x.... 0x....      BL       assert_failed
   1098            assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
   \                     ??SPI_I2S_ITConfig_1: (+1)
   \   0000004E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000050   0x2D71             CMP      R5,#+113
   \   00000052   0xD00A             BEQ.N    ??SPI_I2S_ITConfig_2
   \   00000054   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000056   0x2D60             CMP      R5,#+96
   \   00000058   0xD007             BEQ.N    ??SPI_I2S_ITConfig_2
   \   0000005A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005C   0x2D50             CMP      R5,#+80
   \   0000005E   0xD004             BEQ.N    ??SPI_I2S_ITConfig_2
   \   00000060   0xF240 0x414A      MOVW     R1,#+1098
   \   00000064   0x....             LDR.N    R0,??DataTable18_2
   \   00000066   0x.... 0x....      BL       assert_failed
   1099          
   1100            /* Get the SPI IT index */
   1101            itpos = SPI_I2S_IT >> 4;
   \                     ??SPI_I2S_ITConfig_2: (+1)
   \   0000006A   0x0028             MOVS     R0,R5
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0x0900             LSRS     R0,R0,#+4
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0x0007             MOVS     R7,R0
   1102          
   1103            /* Set the IT mask */
   1104            itmask = (uint16_t)1 << (uint16_t)itpos;
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0x40B8             LSLS     R0,R0,R7
   \   00000078   0x4680             MOV      R8,R0
   1105          
   1106            if (NewState != DISABLE)
   \   0000007A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000007C   0x2E00             CMP      R6,#+0
   \   0000007E   0xD004             BEQ.N    ??SPI_I2S_ITConfig_3
   1107            {
   1108              /* Enable the selected SPI interrupt */
   1109              SPIx->CR2 |= itmask;
   \   00000080   0x88A0             LDRH     R0,[R4, #+4]
   \   00000082   0xEA58 0x0000      ORRS     R0,R8,R0
   \   00000086   0x80A0             STRH     R0,[R4, #+4]
   \   00000088   0xE003             B.N      ??SPI_I2S_ITConfig_4
   1110            }
   1111            else
   1112            {
   1113              /* Disable the selected SPI interrupt */
   1114              SPIx->CR2 &= (uint16_t)~itmask;
   \                     ??SPI_I2S_ITConfig_3: (+1)
   \   0000008A   0x88A0             LDRH     R0,[R4, #+4]
   \   0000008C   0xEA30 0x0008      BICS     R0,R0,R8
   \   00000090   0x80A0             STRH     R0,[R4, #+4]
   1115            }
   1116          }
   \                     ??SPI_I2S_ITConfig_4: (+1)
   \   00000092   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1117          
   1118          /**
   1119            * @brief  Checks whether the specified SPIx/I2Sx flag is set or not.
   1120            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
   1121            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
   1122            * @param  SPI_I2S_FLAG: specifies the SPI flag to check. 
   1123            *          This parameter can be one of the following values:
   1124            *            @arg SPI_I2S_FLAG_TXE: Transmit buffer empty flag.
   1125            *            @arg SPI_I2S_FLAG_RXNE: Receive buffer not empty flag.
   1126            *            @arg SPI_I2S_FLAG_BSY: Busy flag.
   1127            *            @arg SPI_I2S_FLAG_OVR: Overrun flag.
   1128            *            @arg SPI_FLAG_MODF: Mode Fault flag.
   1129            *            @arg SPI_FLAG_CRCERR: CRC Error flag.
   1130            *            @arg SPI_I2S_FLAG_TIFRFE: Format Error.
   1131            *            @arg I2S_FLAG_UDR: Underrun Error flag.
   1132            *            @arg I2S_FLAG_CHSIDE: Channel Side flag.  
   1133            * @retval The new state of SPI_I2S_FLAG (SET or RESET).
   1134            */

   \                                 In section .text, align 2, keep-with-next
   1135          FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
   1136          {
   \                     SPI_I2S_GetFlagStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1137            FlagStatus bitstatus = RESET;
   \   00000006   0x2600             MOVS     R6,#+0
   1138            /* Check the parameters */
   1139            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   \   00000008   0x....             LDR.N    R0,??DataTable22_7  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD010             BEQ.N    ??SPI_I2S_GetFlagStatus_0
   \   0000000E   0x....             LDR.N    R0,??DataTable22_8  ;; 0x40003800
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD00D             BEQ.N    ??SPI_I2S_GetFlagStatus_0
   \   00000014   0x....             LDR.N    R0,??DataTable19  ;; 0x40003c00
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD00A             BEQ.N    ??SPI_I2S_GetFlagStatus_0
   \   0000001A   0x....             LDR.N    R0,??DataTable22_6  ;; 0x40003400
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD007             BEQ.N    ??SPI_I2S_GetFlagStatus_0
   \   00000020   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   00000024   0xD004             BEQ.N    ??SPI_I2S_GetFlagStatus_0
   \   00000026   0xF240 0x4173      MOVW     R1,#+1139
   \   0000002A   0x....             LDR.N    R0,??DataTable22_9
   \   0000002C   0x.... 0x....      BL       assert_failed
   1140            assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
   \                     ??SPI_I2S_GetFlagStatus_0: (+1)
   \   00000030   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000032   0x2D80             CMP      R5,#+128
   \   00000034   0xD01D             BEQ.N    ??SPI_I2S_GetFlagStatus_1
   \   00000036   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000038   0x2D40             CMP      R5,#+64
   \   0000003A   0xD01A             BEQ.N    ??SPI_I2S_GetFlagStatus_1
   \   0000003C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003E   0x2D20             CMP      R5,#+32
   \   00000040   0xD017             BEQ.N    ??SPI_I2S_GetFlagStatus_1
   \   00000042   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   0x2D10             CMP      R5,#+16
   \   00000046   0xD014             BEQ.N    ??SPI_I2S_GetFlagStatus_1
   \   00000048   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004A   0x2D08             CMP      R5,#+8
   \   0000004C   0xD011             BEQ.N    ??SPI_I2S_GetFlagStatus_1
   \   0000004E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000050   0x2D04             CMP      R5,#+4
   \   00000052   0xD00E             BEQ.N    ??SPI_I2S_GetFlagStatus_1
   \   00000054   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000056   0x2D02             CMP      R5,#+2
   \   00000058   0xD00B             BEQ.N    ??SPI_I2S_GetFlagStatus_1
   \   0000005A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005C   0x2D01             CMP      R5,#+1
   \   0000005E   0xD008             BEQ.N    ??SPI_I2S_GetFlagStatus_1
   \   00000060   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000062   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000066   0xD004             BEQ.N    ??SPI_I2S_GetFlagStatus_1
   \   00000068   0xF240 0x4174      MOVW     R1,#+1140
   \   0000006C   0x....             LDR.N    R0,??DataTable22_9
   \   0000006E   0x.... 0x....      BL       assert_failed
   1141            
   1142            /* Check the status of the specified SPI flag */
   1143            if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
   \                     ??SPI_I2S_GetFlagStatus_1: (+1)
   \   00000072   0x8920             LDRH     R0,[R4, #+8]
   \   00000074   0x4228             TST      R0,R5
   \   00000076   0xD002             BEQ.N    ??SPI_I2S_GetFlagStatus_2
   1144            {
   1145              /* SPI_I2S_FLAG is set */
   1146              bitstatus = SET;
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0x0006             MOVS     R6,R0
   \   0000007C   0xE001             B.N      ??SPI_I2S_GetFlagStatus_3
   1147            }
   1148            else
   1149            {
   1150              /* SPI_I2S_FLAG is reset */
   1151              bitstatus = RESET;
   \                     ??SPI_I2S_GetFlagStatus_2: (+1)
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x0006             MOVS     R6,R0
   1152            }
   1153            /* Return the SPI_I2S_FLAG status */
   1154            return  bitstatus;
   \                     ??SPI_I2S_GetFlagStatus_3: (+1)
   \   00000082   0x0030             MOVS     R0,R6
   \   00000084   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000086   0xBD70             POP      {R4-R6,PC}       ;; return
   1155          }
   1156          
   1157          /**
   1158            * @brief  Clears the SPIx CRC Error (CRCERR) flag.
   1159            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
   1160            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
   1161            * @param  SPI_I2S_FLAG: specifies the SPI flag to clear. 
   1162            *          This function clears only CRCERR flag.
   1163            *            @arg SPI_FLAG_CRCERR: CRC Error flag.  
   1164            *  
   1165            * @note   OVR (OverRun error) flag is cleared by software sequence: a read 
   1166            *          operation to SPI_DR register (SPI_I2S_ReceiveData()) followed by a read 
   1167            *          operation to SPI_SR register (SPI_I2S_GetFlagStatus()).
   1168            * @note   UDR (UnderRun error) flag is cleared by a read operation to 
   1169            *          SPI_SR register (SPI_I2S_GetFlagStatus()).   
   1170            * @note   MODF (Mode Fault) flag is cleared by software sequence: a read/write 
   1171            *          operation to SPI_SR register (SPI_I2S_GetFlagStatus()) followed by a 
   1172            *          write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).
   1173            *  
   1174            * @retval None
   1175            */

   \                                 In section .text, align 2, keep-with-next
   1176          void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
   1177          {
   \                     SPI_I2S_ClearFlag: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1178            /* Check the parameters */
   1179            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   \   00000006   0x....             LDR.N    R0,??DataTable22_7  ;; 0x40013000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD010             BEQ.N    ??SPI_I2S_ClearFlag_0
   \   0000000C   0x....             LDR.N    R0,??DataTable22_8  ;; 0x40003800
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD00D             BEQ.N    ??SPI_I2S_ClearFlag_0
   \   00000012   0x....             LDR.N    R0,??DataTable22  ;; 0x40003c00
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD00A             BEQ.N    ??SPI_I2S_ClearFlag_0
   \   00000018   0x....             LDR.N    R0,??DataTable22_6  ;; 0x40003400
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD007             BEQ.N    ??SPI_I2S_ClearFlag_0
   \   0000001E   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   00000022   0xD004             BEQ.N    ??SPI_I2S_ClearFlag_0
   \   00000024   0xF240 0x419B      MOVW     R1,#+1179
   \   00000028   0x....             LDR.N    R0,??DataTable22_9
   \   0000002A   0x.... 0x....      BL       assert_failed
   1180            assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
   \                     ??SPI_I2S_ClearFlag_0: (+1)
   \   0000002E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000030   0x2D10             CMP      R5,#+16
   \   00000032   0xD004             BEQ.N    ??SPI_I2S_ClearFlag_1
   \   00000034   0xF240 0x419C      MOVW     R1,#+1180
   \   00000038   0x....             LDR.N    R0,??DataTable22_9
   \   0000003A   0x.... 0x....      BL       assert_failed
   1181              
   1182            /* Clear the selected SPI CRC Error (CRCERR) flag */
   1183            SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
   \                     ??SPI_I2S_ClearFlag_1: (+1)
   \   0000003E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000040   0x43E8             MVNS     R0,R5
   \   00000042   0x8120             STRH     R0,[R4, #+8]
   1184          }
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1185          
   1186          /**
   1187            * @brief  Checks whether the specified SPIx/I2Sx interrupt has occurred or not.
   1188            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
   1189            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode.  
   1190            * @param  SPI_I2S_IT: specifies the SPI interrupt source to check. 
   1191            *          This parameter can be one of the following values:
   1192            *            @arg SPI_I2S_IT_TXE: Transmit buffer empty interrupt.
   1193            *            @arg SPI_I2S_IT_RXNE: Receive buffer not empty interrupt.
   1194            *            @arg SPI_I2S_IT_OVR: Overrun interrupt.
   1195            *            @arg SPI_IT_MODF: Mode Fault interrupt.
   1196            *            @arg SPI_IT_CRCERR: CRC Error interrupt.
   1197            *            @arg I2S_IT_UDR: Underrun interrupt.  
   1198            *            @arg SPI_I2S_IT_TIFRFE: Format Error interrupt.  
   1199            * @retval The new state of SPI_I2S_IT (SET or RESET).
   1200            */

   \                                 In section .text, align 2, keep-with-next
   1201          ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
   1202          {
   \                     SPI_I2S_GetITStatus: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1203            ITStatus bitstatus = RESET;
   \   00000008   0x2600             MOVS     R6,#+0
   1204            uint16_t itpos = 0, itmask = 0, enablestatus = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
   1205          
   1206            /* Check the parameters */
   1207            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   \   00000014   0x....             LDR.N    R0,??DataTable22_7  ;; 0x40013000
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD010             BEQ.N    ??SPI_I2S_GetITStatus_0
   \   0000001A   0x....             LDR.N    R0,??DataTable22_8  ;; 0x40003800
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD00D             BEQ.N    ??SPI_I2S_GetITStatus_0
   \   00000020   0x....             LDR.N    R0,??DataTable22  ;; 0x40003c00
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD00A             BEQ.N    ??SPI_I2S_GetITStatus_0
   \   00000026   0x....             LDR.N    R0,??DataTable22_6  ;; 0x40003400
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD007             BEQ.N    ??SPI_I2S_GetITStatus_0
   \   0000002C   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   00000030   0xD004             BEQ.N    ??SPI_I2S_GetITStatus_0
   \   00000032   0xF240 0x41B7      MOVW     R1,#+1207
   \   00000036   0x....             LDR.N    R0,??DataTable22_9
   \   00000038   0x.... 0x....      BL       assert_failed
   1208            assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
   \                     ??SPI_I2S_GetITStatus_0: (+1)
   \   0000003C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003E   0x2D60             CMP      R5,#+96
   \   00000040   0xD016             BEQ.N    ??SPI_I2S_GetITStatus_1
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D71             CMP      R5,#+113
   \   00000046   0xD013             BEQ.N    ??SPI_I2S_GetITStatus_1
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x2D54             CMP      R5,#+84
   \   0000004C   0xD010             BEQ.N    ??SPI_I2S_GetITStatus_1
   \   0000004E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000050   0x2D55             CMP      R5,#+85
   \   00000052   0xD00D             BEQ.N    ??SPI_I2S_GetITStatus_1
   \   00000054   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000056   0x2D56             CMP      R5,#+86
   \   00000058   0xD00A             BEQ.N    ??SPI_I2S_GetITStatus_1
   \   0000005A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005C   0x2D53             CMP      R5,#+83
   \   0000005E   0xD007             BEQ.N    ??SPI_I2S_GetITStatus_1
   \   00000060   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000062   0x2D58             CMP      R5,#+88
   \   00000064   0xD004             BEQ.N    ??SPI_I2S_GetITStatus_1
   \   00000066   0xF44F 0x6197      MOV      R1,#+1208
   \   0000006A   0x....             LDR.N    R0,??DataTable22_9
   \   0000006C   0x.... 0x....      BL       assert_failed
   1209          
   1210            /* Get the SPI_I2S_IT index */
   1211            itpos = 0x01 << (SPI_I2S_IT & 0x0F);
   \                     ??SPI_I2S_GetITStatus_1: (+1)
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0xF015 0x010F      ANDS     R1,R5,#0xF
   \   00000076   0x4088             LSLS     R0,R0,R1
   \   00000078   0x0007             MOVS     R7,R0
   1212          
   1213            /* Get the SPI_I2S_IT IT mask */
   1214            itmask = SPI_I2S_IT >> 4;
   \   0000007A   0x0028             MOVS     R0,R5
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007E   0x0900             LSRS     R0,R0,#+4
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000082   0x4680             MOV      R8,R0
   1215          
   1216            /* Set the IT mask */
   1217            itmask = 0x01 << itmask;
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0xFA10 0xF808      LSLS     R8,R0,R8
   1218          
   1219            /* Get the SPI_I2S_IT enable bit status */
   1220            enablestatus = (SPIx->CR2 & itmask) ;
   \   0000008A   0x88A0             LDRH     R0,[R4, #+4]
   \   0000008C   0xEA18 0x0000      ANDS     R0,R8,R0
   \   00000090   0x4681             MOV      R9,R0
   1221          
   1222            /* Check the status of the specified SPI interrupt */
   1223            if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
   \   00000092   0x8920             LDRH     R0,[R4, #+8]
   \   00000094   0x4238             TST      R0,R7
   \   00000096   0xD007             BEQ.N    ??SPI_I2S_GetITStatus_2
   \   00000098   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000009C   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000A0   0xD002             BEQ.N    ??SPI_I2S_GetITStatus_2
   1224            {
   1225              /* SPI_I2S_IT is set */
   1226              bitstatus = SET;
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0x0006             MOVS     R6,R0
   \   000000A6   0xE001             B.N      ??SPI_I2S_GetITStatus_3
   1227            }
   1228            else
   1229            {
   1230              /* SPI_I2S_IT is reset */
   1231              bitstatus = RESET;
   \                     ??SPI_I2S_GetITStatus_2: (+1)
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x0006             MOVS     R6,R0
   1232            }
   1233            /* Return the SPI_I2S_IT status */
   1234            return bitstatus;
   \                     ??SPI_I2S_GetITStatus_3: (+1)
   \   000000AC   0x0030             MOVS     R0,R6
   \   000000AE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B0   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1235          }
   1236          
   1237          /**
   1238            * @brief  Clears the SPIx CRC Error (CRCERR) interrupt pending bit.
   1239            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
   1240            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode.  
   1241            * @param  SPI_I2S_IT: specifies the SPI interrupt pending bit to clear.
   1242            *         This function clears only CRCERR interrupt pending bit.   
   1243            *            @arg SPI_IT_CRCERR: CRC Error interrupt.
   1244            *   
   1245            * @note   OVR (OverRun Error) interrupt pending bit is cleared by software 
   1246            *          sequence: a read operation to SPI_DR register (SPI_I2S_ReceiveData()) 
   1247            *          followed by a read operation to SPI_SR register (SPI_I2S_GetITStatus()).
   1248            * @note   UDR (UnderRun Error) interrupt pending bit is cleared by a read 
   1249            *          operation to SPI_SR register (SPI_I2S_GetITStatus()).   
   1250            * @note   MODF (Mode Fault) interrupt pending bit is cleared by software sequence:
   1251            *          a read/write operation to SPI_SR register (SPI_I2S_GetITStatus()) 
   1252            *          followed by a write operation to SPI_CR1 register (SPI_Cmd() to enable 
   1253            *          the SPI).
   1254            * @retval None
   1255            */

   \                                 In section .text, align 2, keep-with-next
   1256          void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
   1257          {
   \                     SPI_I2S_ClearITPendingBit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1258            uint16_t itpos = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1259            /* Check the parameters */
   1260            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   \   00000008   0x....             LDR.N    R0,??DataTable22_7  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD010             BEQ.N    ??SPI_I2S_ClearITPendingBit_0
   \   0000000E   0x....             LDR.N    R0,??DataTable22_8  ;; 0x40003800
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD00D             BEQ.N    ??SPI_I2S_ClearITPendingBit_0
   \   00000014   0x....             LDR.N    R0,??DataTable22  ;; 0x40003c00
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD00A             BEQ.N    ??SPI_I2S_ClearITPendingBit_0
   \   0000001A   0x....             LDR.N    R0,??DataTable22_6  ;; 0x40003400
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD007             BEQ.N    ??SPI_I2S_ClearITPendingBit_0
   \   00000020   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   00000024   0xD004             BEQ.N    ??SPI_I2S_ClearITPendingBit_0
   \   00000026   0xF240 0x41EC      MOVW     R1,#+1260
   \   0000002A   0x....             LDR.N    R0,??DataTable22_9
   \   0000002C   0x.... 0x....      BL       assert_failed
   1261            assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));
   \                     ??SPI_I2S_ClearITPendingBit_0: (+1)
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D54             CMP      R5,#+84
   \   00000034   0xD004             BEQ.N    ??SPI_I2S_ClearITPendingBit_1
   \   00000036   0xF240 0x41ED      MOVW     R1,#+1261
   \   0000003A   0x....             LDR.N    R0,??DataTable22_9
   \   0000003C   0x.... 0x....      BL       assert_failed
   1262          
   1263            /* Get the SPI_I2S IT index */
   1264            itpos = 0x01 << (SPI_I2S_IT & 0x0F);
   \                     ??SPI_I2S_ClearITPendingBit_1: (+1)
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF015 0x010F      ANDS     R1,R5,#0xF
   \   00000046   0x4088             LSLS     R0,R0,R1
   \   00000048   0x0006             MOVS     R6,R0
   1265          
   1266            /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
   1267            SPIx->SR = (uint16_t)~itpos;
   \   0000004A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000004C   0x43F0             MVNS     R0,R6
   \   0000004E   0x8120             STRH     R0,[R4, #+8]
   1268          }
   \   00000050   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x40013000         DC32     0x40013000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x40003800         DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x40003C00         DC32     0x40003c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0x40003C00         DC32     0x40003c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \   00000000   0x0002EE01         DC32     0x2ee01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \   00000000   0x40023808         DC32     0x40023808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_3:
   \   00000000   0x40023884         DC32     0x40023884

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_4:
   \   00000000   0x40023804         DC32     0x40023804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_5:
   \   00000000   0x007A1200         DC32     0x7a1200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_6:
   \   00000000   0x40003400         DC32     0x40003400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_7:
   \   00000000   0x40013000         DC32     0x40013000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_8:
   \   00000000   0x40003800         DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_9:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 49H, 41H, 52H, 20H, 57H
   \              0x5C 0x49    
   \              0x41 0x52    
   \              0x20 0x57    
   \   00000008   0x6F 0x72          DC8 6FH, 72H, 6BH, 73H, 70H, 61H, 63H, 65H
   \              0x6B 0x73    
   \              0x70 0x61    
   \              0x63 0x65    
   \   00000010   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 46H, 34H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x46 0x34    
   \   00000018   0x30 0x37          DC8 30H, 37H, 5CH, 53H, 54H, 4DH, 33H, 32H
   \              0x5C 0x53    
   \              0x54 0x4D    
   \              0x33 0x32    
   \   00000020   0x46 0x34          DC8 46H, 34H, 2DH, 44H, 69H, 73H, 63H, 6FH
   \              0x2D 0x44    
   \              0x69 0x73    
   \              0x63 0x6F    
   \   00000028   0x76 0x65          DC8 76H, 65H, 72H, 79H, 5FH, 46H, 57H, 5FH
   \              0x72 0x79    
   \              0x5F 0x46    
   \              0x57 0x5F    
   \   00000030   0x56 0x31          DC8 56H, 31H, 2EH, 31H, 2EH, 30H, 5CH, 4CH
   \              0x2E 0x31    
   \              0x2E 0x30    
   \              0x5C 0x4C    
   \   00000038   0x69 0x62          DC8 69H, 62H, 72H, 61H, 72H, 69H, 65H, 73H
   \              0x72 0x61    
   \              0x72 0x69    
   \              0x65 0x73    
   \   00000040   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 46H, 34H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x46 0x34    
   \   00000048   0x78 0x78          DC8 78H, 78H, 5FH, 53H, 74H, 64H, 50H, 65H
   \              0x5F 0x53    
   \              0x74 0x64    
   \              0x50 0x65    
   \   00000050   0x72 0x69          DC8 72H, 69H, 70H, 68H, 5FH, 44H, 72H, 69H
   \              0x70 0x68    
   \              0x5F 0x44    
   \              0x72 0x69    
   \   00000058   0x76 0x65          DC8 76H, 65H, 72H, 5CH, 73H, 72H, 63H, 5CH
   \              0x72 0x5C    
   \              0x73 0x72    
   \              0x63 0x5C    
   \   00000060   0x73 0x74          DC8 73H, 74H, 6DH, 33H, 32H, 66H, 34H, 78H
   \              0x6D 0x33    
   \              0x32 0x66    
   \              0x34 0x78    
   \   00000068   0x78 0x5F          DC8 78H, 5FH, 73H, 70H, 69H, 2EH, 63H, 0
   \              0x73 0x70    
   \              0x69 0x2E    
   \              0x63 0x00    
   1269          
   1270          /**
   1271            * @}
   1272            */
   1273          
   1274          /**
   1275            * @}
   1276            */ 
   1277          
   1278          /**
   1279            * @}
   1280            */ 
   1281          
   1282          /**
   1283            * @}
   1284            */ 
   1285          
   1286          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   I2S_Cmd
        16   -> assert_failed
      24   I2S_FullDuplexConfig
        24   -> assert_failed
      48   I2S_Init
        48   -> assert_failed
       0   I2S_StructInit
      16   SPI_BiDirectionalLineConfig
        16   -> assert_failed
      16   SPI_CalculateCRC
        16   -> assert_failed
      16   SPI_Cmd
        16   -> assert_failed
      16   SPI_DataSizeConfig
        16   -> assert_failed
      16   SPI_GetCRC
        16   -> assert_failed
       8   SPI_GetCRCPolynomial
         8   -> assert_failed
      16   SPI_I2S_ClearFlag
        16   -> assert_failed
      16   SPI_I2S_ClearITPendingBit
        16   -> assert_failed
      16   SPI_I2S_DMACmd
        16   -> assert_failed
       8   SPI_I2S_DeInit
         8   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
         8   -> assert_failed
      16   SPI_I2S_GetFlagStatus
        16   -> assert_failed
      32   SPI_I2S_GetITStatus
        32   -> assert_failed
      24   SPI_I2S_ITConfig
        24   -> assert_failed
       8   SPI_I2S_ReceiveData
         8   -> assert_failed
      16   SPI_I2S_SendData
        16   -> assert_failed
      16   SPI_Init
        16   -> assert_failed
      16   SPI_NSSInternalSoftwareConfig
        16   -> assert_failed
      16   SPI_SSOutputCmd
        16   -> assert_failed
       0   SPI_StructInit
      16   SPI_TIModeCmd
        16   -> assert_failed
       8   SPI_TransmitCRC
         8   -> assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable19
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable22_5
       4  ??DataTable22_6
       4  ??DataTable22_7
       4  ??DataTable22_8
       4  ??DataTable22_9
     112  ?_0
     100  I2S_Cmd
     256  I2S_FullDuplexConfig
     550  I2S_Init
      26  I2S_StructInit
     102  SPI_BiDirectionalLineConfig
      84  SPI_CalculateCRC
      94  SPI_Cmd
      86  SPI_DataSizeConfig
      80  SPI_GetCRC
      36  SPI_GetCRCPolynomial
      70  SPI_I2S_ClearFlag
      82  SPI_I2S_ClearITPendingBit
     116  SPI_I2S_DMACmd
     128  SPI_I2S_DeInit
     136  SPI_I2S_GetFlagStatus
     180  SPI_I2S_GetITStatus
     150  SPI_I2S_ITConfig
      50  SPI_I2S_ReceiveData
      52  SPI_I2S_SendData
     372  SPI_Init
     104  SPI_NSSInternalSoftwareConfig
      94  SPI_SSOutputCmd
      38  SPI_StructInit
      94  SPI_TIModeCmd
      42  SPI_TransmitCRC

 
   112 bytes in section .rodata
 3 178 bytes in section .text
 
 3 178 bytes of CODE  memory
   112 bytes of CONST memory

Errors: none
Warnings: none
