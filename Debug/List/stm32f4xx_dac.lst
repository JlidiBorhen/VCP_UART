###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       06/May/2016  23:31:32
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\IAR
#        Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dac.c
#    Command line =  
#        "D:\IAR
#        Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dac.c"
#        -D USE_STDPERIPH_DRIVER -D STM32F4XX -D USE_FULL_ASSERT -lCN "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\List" -o "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\Obj" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\Include\" -I
#        "D:\IAR Workspace\STM32F407\VCP_ESP\..\Utilities\STM32F4-Discovery\"
#        -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\ST\STM32F4xx\Include\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_conf\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\cdc\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\otg\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\core\" -On --use_c++_inline -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    List file    =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\Debug\List\stm32f4xx_dac.lst
#    Object file  =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\Debug\Obj\stm32f4xx_dac.o
#
###############################################################################

D:\IAR Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dac.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_dac.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    30-September-2011
      7             * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Digital-to-Analog Converter (DAC) peripheral: 
      9            *           - DAC channels configuration: trigger, output buffer, data format
     10            *           - DMA management      
     11            *           - Interrupts and flags management
     12            *
     13            *  @verbatim
     14            *    
     15            *          ===================================================================
     16            *                             DAC Peripheral features
     17            *          ===================================================================
     18            *          
     19            *          DAC Channels
     20            *          =============  
     21            *          The device integrates two 12-bit Digital Analog Converters that can 
     22            *          be used independently or simultaneously (dual mode):
     23            *            1- DAC channel1 with DAC_OUT1 (PA4) as output
     24            *            1- DAC channel2 with DAC_OUT2 (PA5) as output
     25            *
     26            *          DAC Triggers
     27            *          =============
     28            *          Digital to Analog conversion can be non-triggered using DAC_Trigger_None
     29            *          and DAC_OUT1/DAC_OUT2 is available once writing to DHRx register 
     30            *          using DAC_SetChannel1Data() / DAC_SetChannel2Data() functions.
     31            *   
     32            *         Digital to Analog conversion can be triggered by:
     33            *             1- External event: EXTI Line 9 (any GPIOx_Pin9) using DAC_Trigger_Ext_IT9.
     34            *                The used pin (GPIOx_Pin9) must be configured in input mode.
     35            *
     36            *             2- Timers TRGO: TIM2, TIM4, TIM5, TIM6, TIM7 and TIM8 
     37            *                (DAC_Trigger_T2_TRGO, DAC_Trigger_T4_TRGO...)
     38            *                The timer TRGO event should be selected using TIM_SelectOutputTrigger()
     39            *
     40            *             3- Software using DAC_Trigger_Software
     41            *
     42            *          DAC Buffer mode feature
     43            *          ========================  
     44            *          Each DAC channel integrates an output buffer that can be used to 
     45            *          reduce the output impedance, and to drive external loads directly
     46            *          without having to add an external operational amplifier.
     47            *          To enable, the output buffer use  
     48            *              DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Enable;
     49            *          
     50            *          Refer to the device datasheet for more details about output 
     51            *          impedance value with and without output buffer.
     52            *          
     53            *          DAC wave generation feature
     54            *          =============================      
     55            *          Both DAC channels can be used to generate
     56            *             1- Noise wave using DAC_WaveGeneration_Noise
     57            *             2- Triangle wave using DAC_WaveGeneration_Triangle
     58            *        
     59            *          Wave generation can be disabled using DAC_WaveGeneration_None
     60            *
     61            *          DAC data format
     62            *          ================   
     63            *          The DAC data format can be:
     64            *             1- 8-bit right alignment using DAC_Align_8b_R
     65            *             2- 12-bit left alignment using DAC_Align_12b_L
     66            *             3- 12-bit right alignment using DAC_Align_12b_R
     67            *
     68            *          DAC data value to voltage correspondence  
     69            *          ========================================  
     70            *          The analog output voltage on each DAC channel pin is determined
     71            *          by the following equation: 
     72            *          DAC_OUTx = VREF+ * DOR / 4095
     73            *          with  DOR is the Data Output Register
     74            *                VEF+ is the input voltage reference (refer to the device datasheet)
     75            *          e.g. To set DAC_OUT1 to 0.7V, use
     76            *            DAC_SetChannel1Data(DAC_Align_12b_R, 868);
     77            *          Assuming that VREF+ = 3.3V, DAC_OUT1 = (3.3 * 868) / 4095 = 0.7V
     78            *
     79            *          DMA requests 
     80            *          =============    
     81            *          A DMA1 request can be generated when an external trigger (but not
     82            *          a software trigger) occurs if DMA1 requests are enabled using
     83            *          DAC_DMACmd()
     84            *          DMA1 requests are mapped as following:
     85            *             1- DAC channel1 : mapped on DMA1 Stream5 channel7 which must be 
     86            *                               already configured
     87            *             2- DAC channel2 : mapped on DMA1 Stream6 channel7 which must be 
     88            *                               already configured
     89            *
     90            *          ===================================================================      
     91            *                              How to use this driver 
     92            *          ===================================================================          
     93            *            - DAC APB clock must be enabled to get write access to DAC
     94            *              registers using
     95            *              RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE)
     96            *            - Configure DAC_OUTx (DAC_OUT1: PA4, DAC_OUT2: PA5) in analog mode.
     97            *            - Configure the DAC channel using DAC_Init() function
     98            *            - Enable the DAC channel using DAC_Cmd() function
     99            * 
    100            *  @endverbatim
    101            *    
    102            ******************************************************************************
    103            * @attention
    104            *
    105            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
    106            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
    107            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
    108            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
    109            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
    110            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
    111            *
    112            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
    113            ******************************************************************************  
    114            */ 
    115          
    116          
    117          /* Includes ------------------------------------------------------------------*/
    118          #include "stm32f4xx_dac.h"
    119          #include "stm32f4xx_rcc.h"
    120          
    121          /** @addtogroup STM32F4xx_StdPeriph_Driver
    122            * @{
    123            */
    124          
    125          /** @defgroup DAC 
    126            * @brief DAC driver modules
    127            * @{
    128            */ 
    129          
    130          /* Private typedef -----------------------------------------------------------*/
    131          /* Private define ------------------------------------------------------------*/
    132          
    133          /* CR register Mask */
    134          #define CR_CLEAR_MASK              ((uint32_t)0x00000FFE)
    135          
    136          /* DAC Dual Channels SWTRIG masks */
    137          #define DUAL_SWTRIG_SET            ((uint32_t)0x00000003)
    138          #define DUAL_SWTRIG_RESET          ((uint32_t)0xFFFFFFFC)
    139          
    140          /* DHR registers offsets */
    141          #define DHR12R1_OFFSET             ((uint32_t)0x00000008)
    142          #define DHR12R2_OFFSET             ((uint32_t)0x00000014)
    143          #define DHR12RD_OFFSET             ((uint32_t)0x00000020)
    144          
    145          /* DOR register offset */
    146          #define DOR_OFFSET                 ((uint32_t)0x0000002C)
    147          
    148          /* Private macro -------------------------------------------------------------*/
    149          /* Private variables ---------------------------------------------------------*/
    150          /* Private function prototypes -----------------------------------------------*/
    151          /* Private functions ---------------------------------------------------------*/
    152          
    153          /** @defgroup DAC_Private_Functions
    154            * @{
    155            */
    156          
    157          /** @defgroup DAC_Group1 DAC channels configuration
    158           *  @brief   DAC channels configuration: trigger, output buffer, data format 
    159           *
    160          @verbatim   
    161           ===============================================================================
    162                    DAC channels configuration: trigger, output buffer, data format
    163           ===============================================================================  
    164          
    165          @endverbatim
    166            * @{
    167            */
    168          
    169          /**
    170            * @brief  Deinitializes the DAC peripheral registers to their default reset values.
    171            * @param  None
    172            * @retval None
    173            */

   \                                 In section .text, align 2, keep-with-next
    174          void DAC_DeInit(void)
    175          {
   \                     DAC_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    176            /* Enable DAC reset state */
    177            RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0xF05F 0x5000      MOVS     R0,#+536870912
   \   00000008   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    178            /* Release DAC from reset state */
    179            RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xF05F 0x5000      MOVS     R0,#+536870912
   \   00000012   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    180          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    181          
    182          /**
    183            * @brief  Initializes the DAC peripheral according to the specified parameters
    184            *         in the DAC_InitStruct.
    185            * @param  DAC_Channel: the selected DAC channel. 
    186            *          This parameter can be one of the following values:
    187            *            @arg DAC_Channel_1: DAC Channel1 selected
    188            *            @arg DAC_Channel_2: DAC Channel2 selected
    189            * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure that contains
    190            *         the configuration information for the  specified DAC channel.
    191            * @retval None
    192            */

   \                                 In section .text, align 2, keep-with-next
    193          void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
    194          {
   \                     DAC_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    195            uint32_t tmpreg1 = 0, tmpreg2 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x2700             MOVS     R7,#+0
    196          
    197            /* Check the DAC parameters */
    198            assert_param(IS_DAC_TRIGGER(DAC_InitStruct->DAC_Trigger));
   \   0000000A   0x6828             LDR      R0,[R5, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD01C             BEQ.N    ??DAC_Init_0
   \   00000010   0x6828             LDR      R0,[R5, #+0]
   \   00000012   0x2804             CMP      R0,#+4
   \   00000014   0xD019             BEQ.N    ??DAC_Init_0
   \   00000016   0x6828             LDR      R0,[R5, #+0]
   \   00000018   0x280C             CMP      R0,#+12
   \   0000001A   0xD016             BEQ.N    ??DAC_Init_0
   \   0000001C   0x6828             LDR      R0,[R5, #+0]
   \   0000001E   0x2814             CMP      R0,#+20
   \   00000020   0xD013             BEQ.N    ??DAC_Init_0
   \   00000022   0x6828             LDR      R0,[R5, #+0]
   \   00000024   0x281C             CMP      R0,#+28
   \   00000026   0xD010             BEQ.N    ??DAC_Init_0
   \   00000028   0x6828             LDR      R0,[R5, #+0]
   \   0000002A   0x2824             CMP      R0,#+36
   \   0000002C   0xD00D             BEQ.N    ??DAC_Init_0
   \   0000002E   0x6828             LDR      R0,[R5, #+0]
   \   00000030   0x282C             CMP      R0,#+44
   \   00000032   0xD00A             BEQ.N    ??DAC_Init_0
   \   00000034   0x6828             LDR      R0,[R5, #+0]
   \   00000036   0x2834             CMP      R0,#+52
   \   00000038   0xD007             BEQ.N    ??DAC_Init_0
   \   0000003A   0x6828             LDR      R0,[R5, #+0]
   \   0000003C   0x283C             CMP      R0,#+60
   \   0000003E   0xD004             BEQ.N    ??DAC_Init_0
   \   00000040   0x21C6             MOVS     R1,#+198
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000046   0x.... 0x....      BL       assert_failed
    199            assert_param(IS_DAC_GENERATE_WAVE(DAC_InitStruct->DAC_WaveGeneration));
   \                     ??DAC_Init_0: (+1)
   \   0000004A   0x6868             LDR      R0,[R5, #+4]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD00A             BEQ.N    ??DAC_Init_1
   \   00000050   0x6868             LDR      R0,[R5, #+4]
   \   00000052   0x2840             CMP      R0,#+64
   \   00000054   0xD007             BEQ.N    ??DAC_Init_1
   \   00000056   0x6868             LDR      R0,[R5, #+4]
   \   00000058   0x2880             CMP      R0,#+128
   \   0000005A   0xD004             BEQ.N    ??DAC_Init_1
   \   0000005C   0x21C7             MOVS     R1,#+199
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000062   0x.... 0x....      BL       assert_failed
    200            assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude));
   \                     ??DAC_Init_1: (+1)
   \   00000066   0x68A8             LDR      R0,[R5, #+8]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD05F             BEQ.N    ??DAC_Init_2
   \   0000006C   0x68A8             LDR      R0,[R5, #+8]
   \   0000006E   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000072   0xD05B             BEQ.N    ??DAC_Init_2
   \   00000074   0x68A8             LDR      R0,[R5, #+8]
   \   00000076   0xF5B0 0x7F00      CMP      R0,#+512
   \   0000007A   0xD057             BEQ.N    ??DAC_Init_2
   \   0000007C   0x68A8             LDR      R0,[R5, #+8]
   \   0000007E   0xF5B0 0x7F40      CMP      R0,#+768
   \   00000082   0xD053             BEQ.N    ??DAC_Init_2
   \   00000084   0x68A8             LDR      R0,[R5, #+8]
   \   00000086   0xF5B0 0x6F80      CMP      R0,#+1024
   \   0000008A   0xD04F             BEQ.N    ??DAC_Init_2
   \   0000008C   0x68A8             LDR      R0,[R5, #+8]
   \   0000008E   0xF5B0 0x6FA0      CMP      R0,#+1280
   \   00000092   0xD04B             BEQ.N    ??DAC_Init_2
   \   00000094   0x68A8             LDR      R0,[R5, #+8]
   \   00000096   0xF5B0 0x6FC0      CMP      R0,#+1536
   \   0000009A   0xD047             BEQ.N    ??DAC_Init_2
   \   0000009C   0x68A8             LDR      R0,[R5, #+8]
   \   0000009E   0xF5B0 0x6FE0      CMP      R0,#+1792
   \   000000A2   0xD043             BEQ.N    ??DAC_Init_2
   \   000000A4   0x68A8             LDR      R0,[R5, #+8]
   \   000000A6   0xF5B0 0x6F00      CMP      R0,#+2048
   \   000000AA   0xD03F             BEQ.N    ??DAC_Init_2
   \   000000AC   0x68A8             LDR      R0,[R5, #+8]
   \   000000AE   0xF5B0 0x6F10      CMP      R0,#+2304
   \   000000B2   0xD03B             BEQ.N    ??DAC_Init_2
   \   000000B4   0x68A8             LDR      R0,[R5, #+8]
   \   000000B6   0xF5B0 0x6F20      CMP      R0,#+2560
   \   000000BA   0xD037             BEQ.N    ??DAC_Init_2
   \   000000BC   0x68A8             LDR      R0,[R5, #+8]
   \   000000BE   0xF5B0 0x6F30      CMP      R0,#+2816
   \   000000C2   0xD033             BEQ.N    ??DAC_Init_2
   \   000000C4   0x68A8             LDR      R0,[R5, #+8]
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD030             BEQ.N    ??DAC_Init_2
   \   000000CA   0x68A8             LDR      R0,[R5, #+8]
   \   000000CC   0xF5B0 0x7F80      CMP      R0,#+256
   \   000000D0   0xD02C             BEQ.N    ??DAC_Init_2
   \   000000D2   0x68A8             LDR      R0,[R5, #+8]
   \   000000D4   0xF5B0 0x7F00      CMP      R0,#+512
   \   000000D8   0xD028             BEQ.N    ??DAC_Init_2
   \   000000DA   0x68A8             LDR      R0,[R5, #+8]
   \   000000DC   0xF5B0 0x7F40      CMP      R0,#+768
   \   000000E0   0xD024             BEQ.N    ??DAC_Init_2
   \   000000E2   0x68A8             LDR      R0,[R5, #+8]
   \   000000E4   0xF5B0 0x6F80      CMP      R0,#+1024
   \   000000E8   0xD020             BEQ.N    ??DAC_Init_2
   \   000000EA   0x68A8             LDR      R0,[R5, #+8]
   \   000000EC   0xF5B0 0x6FA0      CMP      R0,#+1280
   \   000000F0   0xD01C             BEQ.N    ??DAC_Init_2
   \   000000F2   0x68A8             LDR      R0,[R5, #+8]
   \   000000F4   0xF5B0 0x6FC0      CMP      R0,#+1536
   \   000000F8   0xD018             BEQ.N    ??DAC_Init_2
   \   000000FA   0x68A8             LDR      R0,[R5, #+8]
   \   000000FC   0xF5B0 0x6FE0      CMP      R0,#+1792
   \   00000100   0xD014             BEQ.N    ??DAC_Init_2
   \   00000102   0x68A8             LDR      R0,[R5, #+8]
   \   00000104   0xF5B0 0x6F00      CMP      R0,#+2048
   \   00000108   0xD010             BEQ.N    ??DAC_Init_2
   \   0000010A   0x68A8             LDR      R0,[R5, #+8]
   \   0000010C   0xF5B0 0x6F10      CMP      R0,#+2304
   \   00000110   0xD00C             BEQ.N    ??DAC_Init_2
   \   00000112   0x68A8             LDR      R0,[R5, #+8]
   \   00000114   0xF5B0 0x6F20      CMP      R0,#+2560
   \   00000118   0xD008             BEQ.N    ??DAC_Init_2
   \   0000011A   0x68A8             LDR      R0,[R5, #+8]
   \   0000011C   0xF5B0 0x6F30      CMP      R0,#+2816
   \   00000120   0xD004             BEQ.N    ??DAC_Init_2
   \   00000122   0x21C8             MOVS     R1,#+200
   \   00000124   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000128   0x.... 0x....      BL       assert_failed
    201            assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));
   \                     ??DAC_Init_2: (+1)
   \   0000012C   0x68E8             LDR      R0,[R5, #+12]
   \   0000012E   0x2800             CMP      R0,#+0
   \   00000130   0xD007             BEQ.N    ??DAC_Init_3
   \   00000132   0x68E8             LDR      R0,[R5, #+12]
   \   00000134   0x2802             CMP      R0,#+2
   \   00000136   0xD004             BEQ.N    ??DAC_Init_3
   \   00000138   0x21C9             MOVS     R1,#+201
   \   0000013A   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000013E   0x.... 0x....      BL       assert_failed
    202          
    203          /*---------------------------- DAC CR Configuration --------------------------*/
    204            /* Get the DAC CR value */
    205            tmpreg1 = DAC->CR;
   \                     ??DAC_Init_3: (+1)
   \   00000142   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40007400
   \   00000146   0x6800             LDR      R0,[R0, #+0]
   \   00000148   0x0006             MOVS     R6,R0
    206            /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
    207            tmpreg1 &= ~(CR_CLEAR_MASK << DAC_Channel);
   \   0000014A   0xF640 0x70FE      MOVW     R0,#+4094
   \   0000014E   0x40A0             LSLS     R0,R0,R4
   \   00000150   0x4386             BICS     R6,R6,R0
    208            /* Configure for the selected DAC channel: buffer output, trigger, 
    209               wave generation, mask/amplitude for wave generation */
    210            /* Set TSELx and TENx bits according to DAC_Trigger value */
    211            /* Set WAVEx bits according to DAC_WaveGeneration value */
    212            /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
    213            /* Set BOFFx bit according to DAC_OutputBuffer value */   
    214            tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
    215                       DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | \
    216                       DAC_InitStruct->DAC_OutputBuffer);
   \   00000152   0x6828             LDR      R0,[R5, #+0]
   \   00000154   0x6869             LDR      R1,[R5, #+4]
   \   00000156   0x4308             ORRS     R0,R1,R0
   \   00000158   0x68A9             LDR      R1,[R5, #+8]
   \   0000015A   0x4308             ORRS     R0,R1,R0
   \   0000015C   0x68E9             LDR      R1,[R5, #+12]
   \   0000015E   0x4308             ORRS     R0,R1,R0
   \   00000160   0x0007             MOVS     R7,R0
    217            /* Calculate CR register value depending on DAC_Channel */
    218            tmpreg1 |= tmpreg2 << DAC_Channel;
   \   00000162   0xFA17 0xF004      LSLS     R0,R7,R4
   \   00000166   0x4306             ORRS     R6,R0,R6
    219            /* Write to DAC CR */
    220            DAC->CR = tmpreg1;
   \   00000168   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40007400
   \   0000016C   0x6006             STR      R6,[R0, #+0]
    221          }
   \   0000016E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    222          
    223          /**
    224            * @brief  Fills each DAC_InitStruct member with its default value.
    225            * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure which will 
    226            *         be initialized.
    227            * @retval None
    228            */

   \                                 In section .text, align 2, keep-with-next
    229          void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
    230          {
    231          /*--------------- Reset DAC init structure parameters values -----------------*/
    232            /* Initialize the DAC_Trigger member */
    233            DAC_InitStruct->DAC_Trigger = DAC_Trigger_None;
   \                     DAC_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    234            /* Initialize the DAC_WaveGeneration member */
    235            DAC_InitStruct->DAC_WaveGeneration = DAC_WaveGeneration_None;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6041             STR      R1,[R0, #+4]
    236            /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
    237            DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6081             STR      R1,[R0, #+8]
    238            /* Initialize the DAC_OutputBuffer member */
    239            DAC_InitStruct->DAC_OutputBuffer = DAC_OutputBuffer_Enable;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
    240          }
   \   00000010   0x4770             BX       LR               ;; return
    241          
    242          /**
    243            * @brief  Enables or disables the specified DAC channel.
    244            * @param  DAC_Channel: The selected DAC channel. 
    245            *          This parameter can be one of the following values:
    246            *            @arg DAC_Channel_1: DAC Channel1 selected
    247            *            @arg DAC_Channel_2: DAC Channel2 selected
    248            * @param  NewState: new state of the DAC channel. 
    249            *          This parameter can be: ENABLE or DISABLE.
    250            * @note   When the DAC channel is enabled the trigger source can no more be modified.
    251            * @retval None
    252            */

   \                                 In section .text, align 2, keep-with-next
    253          void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState)
    254          {
   \                     DAC_Cmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    255            /* Check the parameters */
    256            assert_param(IS_DAC_CHANNEL(DAC_Channel));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??DAC_Cmd_0
   \   0000000A   0x2C10             CMP      R4,#+16
   \   0000000C   0xD005             BEQ.N    ??DAC_Cmd_0
   \   0000000E   0xF44F 0x7180      MOV      R1,#+256
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000016   0x.... 0x....      BL       assert_failed
    257            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??DAC_Cmd_0: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD008             BEQ.N    ??DAC_Cmd_1
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD005             BEQ.N    ??DAC_Cmd_1
   \   00000026   0xF240 0x1101      MOVW     R1,#+257
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000002E   0x.... 0x....      BL       assert_failed
    258          
    259            if (NewState != DISABLE)
   \                     ??DAC_Cmd_1: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD009             BEQ.N    ??DAC_Cmd_2
    260            {
    261              /* Enable the selected DAC channel */
    262              DAC->CR |= (DAC_CR_EN1 << DAC_Channel);
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40007400
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0x40A1             LSLS     R1,R1,R4
   \   00000042   0x4308             ORRS     R0,R1,R0
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable14_1  ;; 0x40007400
   \   00000048   0x6008             STR      R0,[R1, #+0]
   \   0000004A   0xE008             B.N      ??DAC_Cmd_3
    263            }
    264            else
    265            {
    266              /* Disable the selected DAC channel */
    267              DAC->CR &= (~(DAC_CR_EN1 << DAC_Channel));
   \                     ??DAC_Cmd_2: (+1)
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40007400
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0x40A1             LSLS     R1,R1,R4
   \   00000056   0x4388             BICS     R0,R0,R1
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable14_1  ;; 0x40007400
   \   0000005C   0x6008             STR      R0,[R1, #+0]
    268            }
    269          }
   \                     ??DAC_Cmd_3: (+1)
   \   0000005E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    270          
    271          /**
    272            * @brief  Enables or disables the selected DAC channel software trigger.
    273            * @param  DAC_Channel: The selected DAC channel. 
    274            *          This parameter can be one of the following values:
    275            *            @arg DAC_Channel_1: DAC Channel1 selected
    276            *            @arg DAC_Channel_2: DAC Channel2 selected
    277            * @param  NewState: new state of the selected DAC channel software trigger.
    278            *          This parameter can be: ENABLE or DISABLE.
    279            * @retval None
    280            */

   \                                 In section .text, align 2, keep-with-next
    281          void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState)
    282          {
   \                     DAC_SoftwareTriggerCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    283            /* Check the parameters */
    284            assert_param(IS_DAC_CHANNEL(DAC_Channel));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??DAC_SoftwareTriggerCmd_0
   \   0000000A   0x2C10             CMP      R4,#+16
   \   0000000C   0xD005             BEQ.N    ??DAC_SoftwareTriggerCmd_0
   \   0000000E   0xF44F 0x718E      MOV      R1,#+284
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000016   0x.... 0x....      BL       assert_failed
    285            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??DAC_SoftwareTriggerCmd_0: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD008             BEQ.N    ??DAC_SoftwareTriggerCmd_1
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD005             BEQ.N    ??DAC_SoftwareTriggerCmd_1
   \   00000026   0xF240 0x111D      MOVW     R1,#+285
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000002E   0x.... 0x....      BL       assert_failed
    286          
    287            if (NewState != DISABLE)
   \                     ??DAC_SoftwareTriggerCmd_1: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD00A             BEQ.N    ??DAC_SoftwareTriggerCmd_2
    288            {
    289              /* Enable software trigger for the selected DAC channel */
    290              DAC->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4);
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable14_2  ;; 0x40007404
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0x0922             LSRS     R2,R4,#+4
   \   00000042   0x4091             LSLS     R1,R1,R2
   \   00000044   0x4308             ORRS     R0,R1,R0
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable14_2  ;; 0x40007404
   \   0000004A   0x6008             STR      R0,[R1, #+0]
   \   0000004C   0xE009             B.N      ??DAC_SoftwareTriggerCmd_3
    291            }
    292            else
    293            {
    294              /* Disable software trigger for the selected DAC channel */
    295              DAC->SWTRIGR &= ~((uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4));
   \                     ??DAC_SoftwareTriggerCmd_2: (+1)
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable14_2  ;; 0x40007404
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x2101             MOVS     R1,#+1
   \   00000056   0x0922             LSRS     R2,R4,#+4
   \   00000058   0x4091             LSLS     R1,R1,R2
   \   0000005A   0x4388             BICS     R0,R0,R1
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable14_2  ;; 0x40007404
   \   00000060   0x6008             STR      R0,[R1, #+0]
    296            }
    297          }
   \                     ??DAC_SoftwareTriggerCmd_3: (+1)
   \   00000062   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    298          
    299          /**
    300            * @brief  Enables or disables simultaneously the two DAC channels software triggers.
    301            * @param  NewState: new state of the DAC channels software triggers.
    302            *          This parameter can be: ENABLE or DISABLE.
    303            * @retval None
    304            */

   \                                 In section .text, align 2, keep-with-next
    305          void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
    306          {
   \                     DAC_DualSoftwareTriggerCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    307            /* Check the parameters */
    308            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??DAC_DualSoftwareTriggerCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??DAC_DualSoftwareTriggerCmd_0
   \   00000010   0xF44F 0x719A      MOV      R1,#+308
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000018   0x.... 0x....      BL       assert_failed
    309          
    310            if (NewState != DISABLE)
   \                     ??DAC_DualSoftwareTriggerCmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD008             BEQ.N    ??DAC_DualSoftwareTriggerCmd_1
    311            {
    312              /* Enable software trigger for both DAC channels */
    313              DAC->SWTRIGR |= DUAL_SWTRIG_SET;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable14_2  ;; 0x40007404
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xF050 0x0003      ORRS     R0,R0,#0x3
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable14_2  ;; 0x40007404
   \   00000030   0x6008             STR      R0,[R1, #+0]
   \   00000032   0xE007             B.N      ??DAC_DualSoftwareTriggerCmd_2
    314            }
    315            else
    316            {
    317              /* Disable software trigger for both DAC channels */
    318              DAC->SWTRIGR &= DUAL_SWTRIG_RESET;
   \                     ??DAC_DualSoftwareTriggerCmd_1: (+1)
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable14_2  ;; 0x40007404
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x0880             LSRS     R0,R0,#+2
   \   0000003C   0x0080             LSLS     R0,R0,#+2
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable14_2  ;; 0x40007404
   \   00000042   0x6008             STR      R0,[R1, #+0]
    319            }
    320          }
   \                     ??DAC_DualSoftwareTriggerCmd_2: (+1)
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
    321          
    322          /**
    323            * @brief  Enables or disables the selected DAC channel wave generation.
    324            * @param  DAC_Channel: The selected DAC channel. 
    325            *          This parameter can be one of the following values:
    326            *            @arg DAC_Channel_1: DAC Channel1 selected
    327            *            @arg DAC_Channel_2: DAC Channel2 selected
    328            * @param  DAC_Wave: specifies the wave type to enable or disable.
    329            *          This parameter can be one of the following values:
    330            *            @arg DAC_Wave_Noise: noise wave generation
    331            *            @arg DAC_Wave_Triangle: triangle wave generation
    332            * @param  NewState: new state of the selected DAC channel wave generation.
    333            *          This parameter can be: ENABLE or DISABLE.  
    334            * @retval None
    335            */

   \                                 In section .text, align 2, keep-with-next
    336          void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState)
    337          {
   \                     DAC_WaveGenerationCmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    338            /* Check the parameters */
    339            assert_param(IS_DAC_CHANNEL(DAC_Channel));
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD007             BEQ.N    ??DAC_WaveGenerationCmd_0
   \   0000000C   0x2C10             CMP      R4,#+16
   \   0000000E   0xD005             BEQ.N    ??DAC_WaveGenerationCmd_0
   \   00000010   0xF240 0x1153      MOVW     R1,#+339
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000018   0x.... 0x....      BL       assert_failed
    340            assert_param(IS_DAC_WAVE(DAC_Wave)); 
   \                     ??DAC_WaveGenerationCmd_0: (+1)
   \   0000001C   0x2D40             CMP      R5,#+64
   \   0000001E   0xD007             BEQ.N    ??DAC_WaveGenerationCmd_1
   \   00000020   0x2D80             CMP      R5,#+128
   \   00000022   0xD005             BEQ.N    ??DAC_WaveGenerationCmd_1
   \   00000024   0xF44F 0x71AA      MOV      R1,#+340
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000002C   0x.... 0x....      BL       assert_failed
    341            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??DAC_WaveGenerationCmd_1: (+1)
   \   00000030   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000032   0x2E00             CMP      R6,#+0
   \   00000034   0xD008             BEQ.N    ??DAC_WaveGenerationCmd_2
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x2E01             CMP      R6,#+1
   \   0000003A   0xD005             BEQ.N    ??DAC_WaveGenerationCmd_2
   \   0000003C   0xF240 0x1155      MOVW     R1,#+341
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000044   0x.... 0x....      BL       assert_failed
    342          
    343            if (NewState != DISABLE)
   \                     ??DAC_WaveGenerationCmd_2: (+1)
   \   00000048   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004A   0x2E00             CMP      R6,#+0
   \   0000004C   0xD007             BEQ.N    ??DAC_WaveGenerationCmd_3
    344            {
    345              /* Enable the selected wave generation for the selected DAC channel */
    346              DAC->CR |= DAC_Wave << DAC_Channel;
   \   0000004E   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40007400
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xFA15 0xF104      LSLS     R1,R5,R4
   \   00000056   0x4308             ORRS     R0,R1,R0
   \   00000058   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40007400
   \   0000005A   0x6008             STR      R0,[R1, #+0]
   \   0000005C   0xE006             B.N      ??DAC_WaveGenerationCmd_4
    347            }
    348            else
    349            {
    350              /* Disable the selected wave generation for the selected DAC channel */
    351              DAC->CR &= ~(DAC_Wave << DAC_Channel);
   \                     ??DAC_WaveGenerationCmd_3: (+1)
   \   0000005E   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40007400
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0xFA15 0xF104      LSLS     R1,R5,R4
   \   00000066   0x4388             BICS     R0,R0,R1
   \   00000068   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40007400
   \   0000006A   0x6008             STR      R0,[R1, #+0]
    352            }
    353          }
   \                     ??DAC_WaveGenerationCmd_4: (+1)
   \   0000006C   0xBD70             POP      {R4-R6,PC}       ;; return
    354          
    355          /**
    356            * @brief  Set the specified data holding register value for DAC channel1.
    357            * @param  DAC_Align: Specifies the data alignment for DAC channel1.
    358            *          This parameter can be one of the following values:
    359            *            @arg DAC_Align_8b_R: 8bit right data alignment selected
    360            *            @arg DAC_Align_12b_L: 12bit left data alignment selected
    361            *            @arg DAC_Align_12b_R: 12bit right data alignment selected
    362            * @param  Data: Data to be loaded in the selected data holding register.
    363            * @retval None
    364            */

   \                                 In section .text, align 2, keep-with-next
    365          void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data)
    366          {  
   \                     DAC_SetChannel1Data: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    367            __IO uint32_t tmp = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
    368            
    369            /* Check the parameters */
    370            assert_param(IS_DAC_ALIGN(DAC_Align));
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD008             BEQ.N    ??DAC_SetChannel1Data_0
   \   0000000E   0x2C04             CMP      R4,#+4
   \   00000010   0xD006             BEQ.N    ??DAC_SetChannel1Data_0
   \   00000012   0x2C08             CMP      R4,#+8
   \   00000014   0xD004             BEQ.N    ??DAC_SetChannel1Data_0
   \   00000016   0xF44F 0x71B9      MOV      R1,#+370
   \   0000001A   0x....             LDR.N    R0,??DataTable14
   \   0000001C   0x.... 0x....      BL       assert_failed
    371            assert_param(IS_DAC_DATA(Data));
   \                     ??DAC_SetChannel1Data_0: (+1)
   \   00000020   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000022   0xF64F 0x70F1      MOVW     R0,#+65521
   \   00000026   0x4285             CMP      R5,R0
   \   00000028   0xDB04             BLT.N    ??DAC_SetChannel1Data_1
   \   0000002A   0xF240 0x1173      MOVW     R1,#+371
   \   0000002E   0x....             LDR.N    R0,??DataTable14
   \   00000030   0x.... 0x....      BL       assert_failed
    372            
    373            tmp = (uint32_t)DAC_BASE; 
   \                     ??DAC_SetChannel1Data_1: (+1)
   \   00000034   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40007400
   \   00000036   0x9000             STR      R0,[SP, #+0]
    374            tmp += DHR12R1_OFFSET + DAC_Align;
   \   00000038   0x9800             LDR      R0,[SP, #+0]
   \   0000003A   0xF114 0x0108      ADDS     R1,R4,#+8
   \   0000003E   0x1808             ADDS     R0,R1,R0
   \   00000040   0x9000             STR      R0,[SP, #+0]
    375          
    376            /* Set the DAC channel1 selected data holding register */
    377            *(__IO uint32_t *) tmp = Data;
   \   00000042   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   0x9800             LDR      R0,[SP, #+0]
   \   00000046   0x6005             STR      R5,[R0, #+0]
    378          }
   \   00000048   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    379          
    380          /**
    381            * @brief  Set the specified data holding register value for DAC channel2.
    382            * @param  DAC_Align: Specifies the data alignment for DAC channel2.
    383            *          This parameter can be one of the following values:
    384            *            @arg DAC_Align_8b_R: 8bit right data alignment selected
    385            *            @arg DAC_Align_12b_L: 12bit left data alignment selected
    386            *            @arg DAC_Align_12b_R: 12bit right data alignment selected
    387            * @param  Data: Data to be loaded in the selected data holding register.
    388            * @retval None
    389            */

   \                                 In section .text, align 2, keep-with-next
    390          void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data)
    391          {
   \                     DAC_SetChannel2Data: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    392            __IO uint32_t tmp = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
    393          
    394            /* Check the parameters */
    395            assert_param(IS_DAC_ALIGN(DAC_Align));
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD008             BEQ.N    ??DAC_SetChannel2Data_0
   \   0000000E   0x2C04             CMP      R4,#+4
   \   00000010   0xD006             BEQ.N    ??DAC_SetChannel2Data_0
   \   00000012   0x2C08             CMP      R4,#+8
   \   00000014   0xD004             BEQ.N    ??DAC_SetChannel2Data_0
   \   00000016   0xF240 0x118B      MOVW     R1,#+395
   \   0000001A   0x....             LDR.N    R0,??DataTable14
   \   0000001C   0x.... 0x....      BL       assert_failed
    396            assert_param(IS_DAC_DATA(Data));
   \                     ??DAC_SetChannel2Data_0: (+1)
   \   00000020   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000022   0xF64F 0x70F1      MOVW     R0,#+65521
   \   00000026   0x4285             CMP      R5,R0
   \   00000028   0xDB04             BLT.N    ??DAC_SetChannel2Data_1
   \   0000002A   0xF44F 0x71C6      MOV      R1,#+396
   \   0000002E   0x....             LDR.N    R0,??DataTable14
   \   00000030   0x.... 0x....      BL       assert_failed
    397            
    398            tmp = (uint32_t)DAC_BASE;
   \                     ??DAC_SetChannel2Data_1: (+1)
   \   00000034   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40007400
   \   00000036   0x9000             STR      R0,[SP, #+0]
    399            tmp += DHR12R2_OFFSET + DAC_Align;
   \   00000038   0x9800             LDR      R0,[SP, #+0]
   \   0000003A   0xF114 0x0114      ADDS     R1,R4,#+20
   \   0000003E   0x1808             ADDS     R0,R1,R0
   \   00000040   0x9000             STR      R0,[SP, #+0]
    400          
    401            /* Set the DAC channel2 selected data holding register */
    402            *(__IO uint32_t *)tmp = Data;
   \   00000042   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   0x9800             LDR      R0,[SP, #+0]
   \   00000046   0x6005             STR      R5,[R0, #+0]
    403          }
   \   00000048   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    404          
    405          /**
    406            * @brief  Set the specified data holding register value for dual channel DAC.
    407            * @param  DAC_Align: Specifies the data alignment for dual channel DAC.
    408            *          This parameter can be one of the following values:
    409            *            @arg DAC_Align_8b_R: 8bit right data alignment selected
    410            *            @arg DAC_Align_12b_L: 12bit left data alignment selected
    411            *            @arg DAC_Align_12b_R: 12bit right data alignment selected
    412            * @param  Data2: Data for DAC Channel2 to be loaded in the selected data holding register.
    413            * @param  Data1: Data for DAC Channel1 to be loaded in the selected data  holding register.
    414            * @note   In dual mode, a unique register access is required to write in both
    415            *          DAC channels at the same time.
    416            * @retval None
    417            */

   \                                 In section .text, align 2, keep-with-next
    418          void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1)
    419          {
   \                     DAC_SetDualChannelData: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    420            uint32_t data = 0, tmp = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
    421            
    422            /* Check the parameters */
    423            assert_param(IS_DAC_ALIGN(DAC_Align));
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD008             BEQ.N    ??DAC_SetDualChannelData_0
   \   00000014   0x2C04             CMP      R4,#+4
   \   00000016   0xD006             BEQ.N    ??DAC_SetDualChannelData_0
   \   00000018   0x2C08             CMP      R4,#+8
   \   0000001A   0xD004             BEQ.N    ??DAC_SetDualChannelData_0
   \   0000001C   0xF240 0x11A7      MOVW     R1,#+423
   \   00000020   0x....             LDR.N    R0,??DataTable14
   \   00000022   0x.... 0x....      BL       assert_failed
    424            assert_param(IS_DAC_DATA(Data1));
   \                     ??DAC_SetDualChannelData_0: (+1)
   \   00000026   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000028   0xF64F 0x70F1      MOVW     R0,#+65521
   \   0000002C   0x4286             CMP      R6,R0
   \   0000002E   0xDB04             BLT.N    ??DAC_SetDualChannelData_1
   \   00000030   0xF44F 0x71D4      MOV      R1,#+424
   \   00000034   0x....             LDR.N    R0,??DataTable14
   \   00000036   0x.... 0x....      BL       assert_failed
    425            assert_param(IS_DAC_DATA(Data2));
   \                     ??DAC_SetDualChannelData_1: (+1)
   \   0000003A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003C   0xF64F 0x70F1      MOVW     R0,#+65521
   \   00000040   0x4285             CMP      R5,R0
   \   00000042   0xDB04             BLT.N    ??DAC_SetDualChannelData_2
   \   00000044   0xF240 0x11A9      MOVW     R1,#+425
   \   00000048   0x....             LDR.N    R0,??DataTable14
   \   0000004A   0x.... 0x....      BL       assert_failed
    426            
    427            /* Calculate and set dual DAC data holding register value */
    428            if (DAC_Align == DAC_Align_8b_R)
   \                     ??DAC_SetDualChannelData_2: (+1)
   \   0000004E   0x2C08             CMP      R4,#+8
   \   00000050   0xD105             BNE.N    ??DAC_SetDualChannelData_3
    429            {
    430              data = ((uint32_t)Data2 << 8) | Data1; 
   \   00000052   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000054   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000056   0xEA56 0x2005      ORRS     R0,R6,R5, LSL #+8
   \   0000005A   0x0007             MOVS     R7,R0
   \   0000005C   0xE004             B.N      ??DAC_SetDualChannelData_4
    431            }
    432            else
    433            {
    434              data = ((uint32_t)Data2 << 16) | Data1;
   \                     ??DAC_SetDualChannelData_3: (+1)
   \   0000005E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000060   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000062   0xEA56 0x4005      ORRS     R0,R6,R5, LSL #+16
   \   00000066   0x0007             MOVS     R7,R0
    435            }
    436            
    437            tmp = (uint32_t)DAC_BASE;
   \                     ??DAC_SetDualChannelData_4: (+1)
   \   00000068   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40007400
   \   0000006A   0x4680             MOV      R8,R0
    438            tmp += DHR12RD_OFFSET + DAC_Align;
   \   0000006C   0xF114 0x0020      ADDS     R0,R4,#+32
   \   00000070   0xEB10 0x0808      ADDS     R8,R0,R8
    439          
    440            /* Set the dual DAC selected data holding register */
    441            *(__IO uint32_t *)tmp = data;
   \   00000074   0xF8C8 0x7000      STR      R7,[R8, #+0]
    442          }
   \   00000078   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    443          
    444          /**
    445            * @brief  Returns the last data output value of the selected DAC channel.
    446            * @param  DAC_Channel: The selected DAC channel. 
    447            *          This parameter can be one of the following values:
    448            *            @arg DAC_Channel_1: DAC Channel1 selected
    449            *            @arg DAC_Channel_2: DAC Channel2 selected
    450            * @retval The selected DAC channel data output value.
    451            */

   \                                 In section .text, align 2, keep-with-next
    452          uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel)
    453          {
   \                     DAC_GetDataOutputValue: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    454            __IO uint32_t tmp = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
    455            
    456            /* Check the parameters */
    457            assert_param(IS_DAC_CHANNEL(DAC_Channel));
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD006             BEQ.N    ??DAC_GetDataOutputValue_0
   \   0000000E   0x2C10             CMP      R4,#+16
   \   00000010   0xD004             BEQ.N    ??DAC_GetDataOutputValue_0
   \   00000012   0xF240 0x11C9      MOVW     R1,#+457
   \   00000016   0x....             LDR.N    R0,??DataTable14
   \   00000018   0x.... 0x....      BL       assert_failed
    458            
    459            tmp = (uint32_t) DAC_BASE ;
   \                     ??DAC_GetDataOutputValue_0: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40007400
   \   0000001E   0x9000             STR      R0,[SP, #+0]
    460            tmp += DOR_OFFSET + ((uint32_t)DAC_Channel >> 2);
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0x08A1             LSRS     R1,R4,#+2
   \   00000024   0x312C             ADDS     R1,R1,#+44
   \   00000026   0x1808             ADDS     R0,R1,R0
   \   00000028   0x9000             STR      R0,[SP, #+0]
    461            
    462            /* Returns the DAC channel data output register value */
    463            return (uint16_t) (*(__IO uint32_t*) tmp);
   \   0000002A   0x9800             LDR      R0,[SP, #+0]
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000030   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    464          }
    465          /**
    466            * @}
    467            */
    468          
    469          /** @defgroup DAC_Group2 DMA management functions
    470           *  @brief   DMA management functions
    471           *
    472          @verbatim   
    473           ===============================================================================
    474                                    DMA management functions
    475           ===============================================================================  
    476          
    477          @endverbatim
    478            * @{
    479            */
    480          
    481          /**
    482            * @brief  Enables or disables the specified DAC channel DMA request.
    483            * @note   When enabled DMA1 is generated when an external trigger (EXTI Line9,
    484            *         TIM2, TIM4, TIM5, TIM6, TIM7 or TIM8  but not a software trigger) occurs.
    485            * @param  DAC_Channel: The selected DAC channel. 
    486            *          This parameter can be one of the following values:
    487            *            @arg DAC_Channel_1: DAC Channel1 selected
    488            *            @arg DAC_Channel_2: DAC Channel2 selected
    489            * @param  NewState: new state of the selected DAC channel DMA request.
    490            *          This parameter can be: ENABLE or DISABLE.
    491            * @note   The DAC channel1 is mapped on DMA1 Stream 5 channel7 which must be
    492            *          already configured.
    493            * @note   The DAC channel2 is mapped on DMA1 Stream 6 channel7 which must be
    494            *          already configured.    
    495            * @retval None
    496            */

   \                                 In section .text, align 2, keep-with-next
    497          void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState)
    498          {
   \                     DAC_DMACmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    499            /* Check the parameters */
    500            assert_param(IS_DAC_CHANNEL(DAC_Channel));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD006             BEQ.N    ??DAC_DMACmd_0
   \   0000000A   0x2C10             CMP      R4,#+16
   \   0000000C   0xD004             BEQ.N    ??DAC_DMACmd_0
   \   0000000E   0xF44F 0x71FA      MOV      R1,#+500
   \   00000012   0x....             LDR.N    R0,??DataTable14
   \   00000014   0x.... 0x....      BL       assert_failed
    501            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??DAC_DMACmd_0: (+1)
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD007             BEQ.N    ??DAC_DMACmd_1
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD004             BEQ.N    ??DAC_DMACmd_1
   \   00000024   0xF240 0x11F5      MOVW     R1,#+501
   \   00000028   0x....             LDR.N    R0,??DataTable14
   \   0000002A   0x.... 0x....      BL       assert_failed
    502          
    503            if (NewState != DISABLE)
   \                     ??DAC_DMACmd_1: (+1)
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD008             BEQ.N    ??DAC_DMACmd_2
    504            {
    505              /* Enable the selected DAC channel DMA request */
    506              DAC->CR |= (DAC_CR_DMAEN1 << DAC_Channel);
   \   00000034   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40007400
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF44F 0x5180      MOV      R1,#+4096
   \   0000003C   0x40A1             LSLS     R1,R1,R4
   \   0000003E   0x4308             ORRS     R0,R1,R0
   \   00000040   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40007400
   \   00000042   0x6008             STR      R0,[R1, #+0]
   \   00000044   0xE007             B.N      ??DAC_DMACmd_3
    507            }
    508            else
    509            {
    510              /* Disable the selected DAC channel DMA request */
    511              DAC->CR &= (~(DAC_CR_DMAEN1 << DAC_Channel));
   \                     ??DAC_DMACmd_2: (+1)
   \   00000046   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40007400
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF44F 0x5180      MOV      R1,#+4096
   \   0000004E   0x40A1             LSLS     R1,R1,R4
   \   00000050   0x4388             BICS     R0,R0,R1
   \   00000052   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40007400
   \   00000054   0x6008             STR      R0,[R1, #+0]
    512            }
    513          }
   \                     ??DAC_DMACmd_3: (+1)
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    514          /**
    515            * @}
    516            */
    517          
    518          /** @defgroup DAC_Group3 Interrupts and flags management functions
    519           *  @brief   Interrupts and flags management functions
    520           *
    521          @verbatim   
    522           ===============================================================================
    523                             Interrupts and flags management functions
    524           ===============================================================================  
    525          
    526          @endverbatim
    527            * @{
    528            */
    529          
    530          /**
    531            * @brief  Enables or disables the specified DAC interrupts.
    532            * @param  DAC_Channel: The selected DAC channel. 
    533            *          This parameter can be one of the following values:
    534            *            @arg DAC_Channel_1: DAC Channel1 selected
    535            *            @arg DAC_Channel_2: DAC Channel2 selected
    536            * @param  DAC_IT: specifies the DAC interrupt sources to be enabled or disabled. 
    537            *          This parameter can be the following values:
    538            *            @arg DAC_IT_DMAUDR: DMA underrun interrupt mask
    539            * @note   The DMA underrun occurs when a second external trigger arrives before the 
    540            *         acknowledgement for the first external trigger is received (first request).
    541            * @param  NewState: new state of the specified DAC interrupts.
    542            *          This parameter can be: ENABLE or DISABLE.
    543            * @retval None
    544            */ 

   \                                 In section .text, align 2, keep-with-next
    545          void DAC_ITConfig(uint32_t DAC_Channel, uint32_t DAC_IT, FunctionalState NewState)  
    546          {
   \                     DAC_ITConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    547            /* Check the parameters */
    548            assert_param(IS_DAC_CHANNEL(DAC_Channel));
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD006             BEQ.N    ??DAC_ITConfig_0
   \   0000000C   0x2C10             CMP      R4,#+16
   \   0000000E   0xD004             BEQ.N    ??DAC_ITConfig_0
   \   00000010   0xF44F 0x7109      MOV      R1,#+548
   \   00000014   0x....             LDR.N    R0,??DataTable14
   \   00000016   0x.... 0x....      BL       assert_failed
    549            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??DAC_ITConfig_0: (+1)
   \   0000001A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xD007             BEQ.N    ??DAC_ITConfig_1
   \   00000020   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000022   0x2E01             CMP      R6,#+1
   \   00000024   0xD004             BEQ.N    ??DAC_ITConfig_1
   \   00000026   0xF240 0x2125      MOVW     R1,#+549
   \   0000002A   0x....             LDR.N    R0,??DataTable14
   \   0000002C   0x.... 0x....      BL       assert_failed
    550            assert_param(IS_DAC_IT(DAC_IT)); 
   \                     ??DAC_ITConfig_1: (+1)
   \   00000030   0xF5B5 0x5F00      CMP      R5,#+8192
   \   00000034   0xD004             BEQ.N    ??DAC_ITConfig_2
   \   00000036   0xF240 0x2126      MOVW     R1,#+550
   \   0000003A   0x....             LDR.N    R0,??DataTable14
   \   0000003C   0x.... 0x....      BL       assert_failed
    551          
    552            if (NewState != DISABLE)
   \                     ??DAC_ITConfig_2: (+1)
   \   00000040   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000042   0x2E00             CMP      R6,#+0
   \   00000044   0xD007             BEQ.N    ??DAC_ITConfig_3
    553            {
    554              /* Enable the selected DAC interrupts */
    555              DAC->CR |=  (DAC_IT << DAC_Channel);
   \   00000046   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40007400
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xFA15 0xF104      LSLS     R1,R5,R4
   \   0000004E   0x4308             ORRS     R0,R1,R0
   \   00000050   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40007400
   \   00000052   0x6008             STR      R0,[R1, #+0]
   \   00000054   0xE006             B.N      ??DAC_ITConfig_4
    556            }
    557            else
    558            {
    559              /* Disable the selected DAC interrupts */
    560              DAC->CR &= (~(uint32_t)(DAC_IT << DAC_Channel));
   \                     ??DAC_ITConfig_3: (+1)
   \   00000056   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40007400
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xFA15 0xF104      LSLS     R1,R5,R4
   \   0000005E   0x4388             BICS     R0,R0,R1
   \   00000060   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40007400
   \   00000062   0x6008             STR      R0,[R1, #+0]
    561            }
    562          }
   \                     ??DAC_ITConfig_4: (+1)
   \   00000064   0xBD70             POP      {R4-R6,PC}       ;; return
    563          
    564          /**
    565            * @brief  Checks whether the specified DAC flag is set or not.
    566            * @param  DAC_Channel: The selected DAC channel. 
    567            *          This parameter can be one of the following values:
    568            *            @arg DAC_Channel_1: DAC Channel1 selected
    569            *            @arg DAC_Channel_2: DAC Channel2 selected
    570            * @param  DAC_FLAG: specifies the flag to check. 
    571            *          This parameter can be only of the following value:
    572            *            @arg DAC_FLAG_DMAUDR: DMA underrun flag
    573            * @note   The DMA underrun occurs when a second external trigger arrives before the 
    574            *         acknowledgement for the first external trigger is received (first request).
    575            * @retval The new state of DAC_FLAG (SET or RESET).
    576            */

   \                                 In section .text, align 2, keep-with-next
    577          FlagStatus DAC_GetFlagStatus(uint32_t DAC_Channel, uint32_t DAC_FLAG)
    578          {
   \                     DAC_GetFlagStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    579            FlagStatus bitstatus = RESET;
   \   00000006   0x2600             MOVS     R6,#+0
    580            /* Check the parameters */
    581            assert_param(IS_DAC_CHANNEL(DAC_Channel));
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD006             BEQ.N    ??DAC_GetFlagStatus_0
   \   0000000C   0x2C10             CMP      R4,#+16
   \   0000000E   0xD004             BEQ.N    ??DAC_GetFlagStatus_0
   \   00000010   0xF240 0x2145      MOVW     R1,#+581
   \   00000014   0x....             LDR.N    R0,??DataTable14
   \   00000016   0x.... 0x....      BL       assert_failed
    582            assert_param(IS_DAC_FLAG(DAC_FLAG));
   \                     ??DAC_GetFlagStatus_0: (+1)
   \   0000001A   0xF5B5 0x5F00      CMP      R5,#+8192
   \   0000001E   0xD004             BEQ.N    ??DAC_GetFlagStatus_1
   \   00000020   0xF240 0x2146      MOVW     R1,#+582
   \   00000024   0x....             LDR.N    R0,??DataTable14
   \   00000026   0x.... 0x....      BL       assert_failed
    583          
    584            /* Check the status of the specified DAC flag */
    585            if ((DAC->SR & (DAC_FLAG << DAC_Channel)) != (uint8_t)RESET)
   \                     ??DAC_GetFlagStatus_1: (+1)
   \   0000002A   0x....             LDR.N    R0,??DataTable14_3  ;; 0x40007434
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0xFA15 0xF104      LSLS     R1,R5,R4
   \   00000032   0x4208             TST      R0,R1
   \   00000034   0xD002             BEQ.N    ??DAC_GetFlagStatus_2
    586            {
    587              /* DAC_FLAG is set */
    588              bitstatus = SET;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x0006             MOVS     R6,R0
   \   0000003A   0xE001             B.N      ??DAC_GetFlagStatus_3
    589            }
    590            else
    591            {
    592              /* DAC_FLAG is reset */
    593              bitstatus = RESET;
   \                     ??DAC_GetFlagStatus_2: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x0006             MOVS     R6,R0
    594            }
    595            /* Return the DAC_FLAG status */
    596            return  bitstatus;
   \                     ??DAC_GetFlagStatus_3: (+1)
   \   00000040   0x0030             MOVS     R0,R6
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0xBD70             POP      {R4-R6,PC}       ;; return
    597          }
    598          
    599          /**
    600            * @brief  Clears the DAC channel's pending flags.
    601            * @param  DAC_Channel: The selected DAC channel. 
    602            *          This parameter can be one of the following values:
    603            *            @arg DAC_Channel_1: DAC Channel1 selected
    604            *            @arg DAC_Channel_2: DAC Channel2 selected
    605            * @param  DAC_FLAG: specifies the flag to clear. 
    606            *          This parameter can be of the following value:
    607            *            @arg DAC_FLAG_DMAUDR: DMA underrun flag 
    608            * @note   The DMA underrun occurs when a second external trigger arrives before the 
    609            *         acknowledgement for the first external trigger is received (first request).                           
    610            * @retval None
    611            */

   \                                 In section .text, align 2, keep-with-next
    612          void DAC_ClearFlag(uint32_t DAC_Channel, uint32_t DAC_FLAG)
    613          {
   \                     DAC_ClearFlag: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    614            /* Check the parameters */
    615            assert_param(IS_DAC_CHANNEL(DAC_Channel));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD006             BEQ.N    ??DAC_ClearFlag_0
   \   0000000A   0x2C10             CMP      R4,#+16
   \   0000000C   0xD004             BEQ.N    ??DAC_ClearFlag_0
   \   0000000E   0xF240 0x2167      MOVW     R1,#+615
   \   00000012   0x....             LDR.N    R0,??DataTable14
   \   00000014   0x.... 0x....      BL       assert_failed
    616            assert_param(IS_DAC_FLAG(DAC_FLAG));
   \                     ??DAC_ClearFlag_0: (+1)
   \   00000018   0xF5B5 0x5F00      CMP      R5,#+8192
   \   0000001C   0xD004             BEQ.N    ??DAC_ClearFlag_1
   \   0000001E   0xF44F 0x711A      MOV      R1,#+616
   \   00000022   0x....             LDR.N    R0,??DataTable14
   \   00000024   0x.... 0x....      BL       assert_failed
    617          
    618            /* Clear the selected DAC flags */
    619            DAC->SR = (DAC_FLAG << DAC_Channel);
   \                     ??DAC_ClearFlag_1: (+1)
   \   00000028   0xFA15 0xF004      LSLS     R0,R5,R4
   \   0000002C   0x....             LDR.N    R1,??DataTable14_3  ;; 0x40007434
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    620          }
   \   00000030   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    621          
    622          /**
    623            * @brief  Checks whether the specified DAC interrupt has occurred or not.
    624            * @param  DAC_Channel: The selected DAC channel. 
    625            *          This parameter can be one of the following values:
    626            *            @arg DAC_Channel_1: DAC Channel1 selected
    627            *            @arg DAC_Channel_2: DAC Channel2 selected
    628            * @param  DAC_IT: specifies the DAC interrupt source to check. 
    629            *          This parameter can be the following values:
    630            *            @arg DAC_IT_DMAUDR: DMA underrun interrupt mask
    631            * @note   The DMA underrun occurs when a second external trigger arrives before the 
    632            *         acknowledgement for the first external trigger is received (first request).
    633            * @retval The new state of DAC_IT (SET or RESET).
    634            */

   \                                 In section .text, align 2, keep-with-next
    635          ITStatus DAC_GetITStatus(uint32_t DAC_Channel, uint32_t DAC_IT)
    636          {
   \                     DAC_GetITStatus: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    637            ITStatus bitstatus = RESET;
   \   00000006   0x2600             MOVS     R6,#+0
    638            uint32_t enablestatus = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    639            
    640            /* Check the parameters */
    641            assert_param(IS_DAC_CHANNEL(DAC_Channel));
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD006             BEQ.N    ??DAC_GetITStatus_0
   \   0000000E   0x2C10             CMP      R4,#+16
   \   00000010   0xD004             BEQ.N    ??DAC_GetITStatus_0
   \   00000012   0xF240 0x2181      MOVW     R1,#+641
   \   00000016   0x....             LDR.N    R0,??DataTable14
   \   00000018   0x.... 0x....      BL       assert_failed
    642            assert_param(IS_DAC_IT(DAC_IT));
   \                     ??DAC_GetITStatus_0: (+1)
   \   0000001C   0xF5B5 0x5F00      CMP      R5,#+8192
   \   00000020   0xD004             BEQ.N    ??DAC_GetITStatus_1
   \   00000022   0xF240 0x2182      MOVW     R1,#+642
   \   00000026   0x....             LDR.N    R0,??DataTable14
   \   00000028   0x.... 0x....      BL       assert_failed
    643          
    644            /* Get the DAC_IT enable bit status */
    645            enablestatus = (DAC->CR & (DAC_IT << DAC_Channel)) ;
   \                     ??DAC_GetITStatus_1: (+1)
   \   0000002C   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40007400
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xFA15 0xF104      LSLS     R1,R5,R4
   \   00000034   0x4008             ANDS     R0,R1,R0
   \   00000036   0x0007             MOVS     R7,R0
    646            
    647            /* Check the status of the specified DAC interrupt */
    648            if (((DAC->SR & (DAC_IT << DAC_Channel)) != (uint32_t)RESET) && enablestatus)
   \   00000038   0x....             LDR.N    R0,??DataTable14_3  ;; 0x40007434
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xFA15 0xF104      LSLS     R1,R5,R4
   \   00000040   0x4208             TST      R0,R1
   \   00000042   0xD004             BEQ.N    ??DAC_GetITStatus_2
   \   00000044   0x2F00             CMP      R7,#+0
   \   00000046   0xD002             BEQ.N    ??DAC_GetITStatus_2
    649            {
    650              /* DAC_IT is set */
    651              bitstatus = SET;
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0x0006             MOVS     R6,R0
   \   0000004C   0xE001             B.N      ??DAC_GetITStatus_3
    652            }
    653            else
    654            {
    655              /* DAC_IT is reset */
    656              bitstatus = RESET;
   \                     ??DAC_GetITStatus_2: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x0006             MOVS     R6,R0
    657            }
    658            /* Return the DAC_IT status */
    659            return  bitstatus;
   \                     ??DAC_GetITStatus_3: (+1)
   \   00000052   0x0030             MOVS     R0,R6
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    660          }
    661          
    662          /**
    663            * @brief  Clears the DAC channel's interrupt pending bits.
    664            * @param  DAC_Channel: The selected DAC channel. 
    665            *          This parameter can be one of the following values:
    666            *            @arg DAC_Channel_1: DAC Channel1 selected
    667            *            @arg DAC_Channel_2: DAC Channel2 selected
    668            * @param  DAC_IT: specifies the DAC interrupt pending bit to clear.
    669            *          This parameter can be the following values:
    670            *            @arg DAC_IT_DMAUDR: DMA underrun interrupt mask                         
    671            * @note   The DMA underrun occurs when a second external trigger arrives before the 
    672            *         acknowledgement for the first external trigger is received (first request).                           
    673            * @retval None
    674            */

   \                                 In section .text, align 2, keep-with-next
    675          void DAC_ClearITPendingBit(uint32_t DAC_Channel, uint32_t DAC_IT)
    676          {
   \                     DAC_ClearITPendingBit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    677            /* Check the parameters */
    678            assert_param(IS_DAC_CHANNEL(DAC_Channel));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD006             BEQ.N    ??DAC_ClearITPendingBit_0
   \   0000000A   0x2C10             CMP      R4,#+16
   \   0000000C   0xD004             BEQ.N    ??DAC_ClearITPendingBit_0
   \   0000000E   0xF240 0x21A6      MOVW     R1,#+678
   \   00000012   0x....             LDR.N    R0,??DataTable14
   \   00000014   0x.... 0x....      BL       assert_failed
    679            assert_param(IS_DAC_IT(DAC_IT)); 
   \                     ??DAC_ClearITPendingBit_0: (+1)
   \   00000018   0xF5B5 0x5F00      CMP      R5,#+8192
   \   0000001C   0xD004             BEQ.N    ??DAC_ClearITPendingBit_1
   \   0000001E   0xF240 0x21A7      MOVW     R1,#+679
   \   00000022   0x....             LDR.N    R0,??DataTable14
   \   00000024   0x.... 0x....      BL       assert_failed
    680          
    681            /* Clear the selected DAC interrupt pending bits */
    682            DAC->SR = (DAC_IT << DAC_Channel);
   \                     ??DAC_ClearITPendingBit_1: (+1)
   \   00000028   0xFA15 0xF004      LSLS     R0,R5,R4
   \   0000002C   0x....             LDR.N    R1,??DataTable14_3  ;; 0x40007434
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    683          }
   \   00000030   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x40007400         DC32     0x40007400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x40007404         DC32     0x40007404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x40007434         DC32     0x40007434

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 49H, 41H, 52H, 20H, 57H
   \              0x5C 0x49    
   \              0x41 0x52    
   \              0x20 0x57    
   \   00000008   0x6F 0x72          DC8 6FH, 72H, 6BH, 73H, 70H, 61H, 63H, 65H
   \              0x6B 0x73    
   \              0x70 0x61    
   \              0x63 0x65    
   \   00000010   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 46H, 34H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x46 0x34    
   \   00000018   0x30 0x37          DC8 30H, 37H, 5CH, 53H, 54H, 4DH, 33H, 32H
   \              0x5C 0x53    
   \              0x54 0x4D    
   \              0x33 0x32    
   \   00000020   0x46 0x34          DC8 46H, 34H, 2DH, 44H, 69H, 73H, 63H, 6FH
   \              0x2D 0x44    
   \              0x69 0x73    
   \              0x63 0x6F    
   \   00000028   0x76 0x65          DC8 76H, 65H, 72H, 79H, 5FH, 46H, 57H, 5FH
   \              0x72 0x79    
   \              0x5F 0x46    
   \              0x57 0x5F    
   \   00000030   0x56 0x31          DC8 56H, 31H, 2EH, 31H, 2EH, 30H, 5CH, 4CH
   \              0x2E 0x31    
   \              0x2E 0x30    
   \              0x5C 0x4C    
   \   00000038   0x69 0x62          DC8 69H, 62H, 72H, 61H, 72H, 69H, 65H, 73H
   \              0x72 0x61    
   \              0x72 0x69    
   \              0x65 0x73    
   \   00000040   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 46H, 34H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x46 0x34    
   \   00000048   0x78 0x78          DC8 78H, 78H, 5FH, 53H, 74H, 64H, 50H, 65H
   \              0x5F 0x53    
   \              0x74 0x64    
   \              0x50 0x65    
   \   00000050   0x72 0x69          DC8 72H, 69H, 70H, 68H, 5FH, 44H, 72H, 69H
   \              0x70 0x68    
   \              0x5F 0x44    
   \              0x72 0x69    
   \   00000058   0x76 0x65          DC8 76H, 65H, 72H, 5CH, 73H, 72H, 63H, 5CH
   \              0x72 0x5C    
   \              0x73 0x72    
   \              0x63 0x5C    
   \   00000060   0x73 0x74          DC8 73H, 74H, 6DH, 33H, 32H, 66H, 34H, 78H
   \              0x6D 0x33    
   \              0x32 0x66    
   \              0x34 0x78    
   \   00000068   0x78 0x5F          DC8 78H, 5FH, 64H, 61H, 63H, 2EH, 63H, 0
   \              0x64 0x61    
   \              0x63 0x2E    
   \              0x63 0x00    
    684          
    685          /**
    686            * @}
    687            */
    688          
    689          /**
    690            * @}
    691            */
    692          
    693          /**
    694            * @}
    695            */
    696          
    697          /**
    698            * @}
    699            */
    700          
    701          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   DAC_ClearFlag
        16   -> assert_failed
      16   DAC_ClearITPendingBit
        16   -> assert_failed
      16   DAC_Cmd
        16   -> assert_failed
      16   DAC_DMACmd
        16   -> assert_failed
       8   DAC_DeInit
         8   -> RCC_APB1PeriphResetCmd
       8   DAC_DualSoftwareTriggerCmd
         8   -> assert_failed
      16   DAC_GetDataOutputValue
        16   -> assert_failed
      16   DAC_GetFlagStatus
        16   -> assert_failed
      24   DAC_GetITStatus
        24   -> assert_failed
      16   DAC_ITConfig
        16   -> assert_failed
      24   DAC_Init
        24   -> assert_failed
      16   DAC_SetChannel1Data
        16   -> assert_failed
      16   DAC_SetChannel2Data
        16   -> assert_failed
      24   DAC_SetDualChannelData
        24   -> assert_failed
      16   DAC_SoftwareTriggerCmd
        16   -> assert_failed
       0   DAC_StructInit
      16   DAC_WaveGenerationCmd
        16   -> assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
     112  ?_0
      50  DAC_ClearFlag
      50  DAC_ClearITPendingBit
      96  DAC_Cmd
      88  DAC_DMACmd
      24  DAC_DeInit
      70  DAC_DualSoftwareTriggerCmd
      50  DAC_GetDataOutputValue
      70  DAC_GetFlagStatus
      88  DAC_GetITStatus
     102  DAC_ITConfig
     368  DAC_Init
      74  DAC_SetChannel1Data
      74  DAC_SetChannel2Data
     124  DAC_SetDualChannelData
     100  DAC_SoftwareTriggerCmd
      18  DAC_StructInit
     110  DAC_WaveGenerationCmd

 
   112 bytes in section .rodata
 1 572 bytes in section .text
 
 1 572 bytes of CODE  memory
   112 bytes of CONST memory

Errors: none
Warnings: none
