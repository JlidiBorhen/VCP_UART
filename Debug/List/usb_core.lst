###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       06/May/2016  23:31:37
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  D:\IAR Workspace\STM32F407\VCP_ESP\usb_lib\otg\usb_core.c
#    Command line =  
#        "D:\IAR Workspace\STM32F407\VCP_ESP\usb_lib\otg\usb_core.c" -D
#        USE_STDPERIPH_DRIVER -D STM32F4XX -D USE_FULL_ASSERT -lCN "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\List" -o "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\Obj" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\Include\" -I
#        "D:\IAR Workspace\STM32F407\VCP_ESP\..\Utilities\STM32F4-Discovery\"
#        -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\ST\STM32F4xx\Include\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_conf\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\cdc\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\otg\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\core\" -On --use_c++_inline -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    List file    =  D:\IAR Workspace\STM32F407\VCP_ESP\Debug\List\usb_core.lst
#    Object file  =  D:\IAR Workspace\STM32F407\VCP_ESP\Debug\Obj\usb_core.o
#
###############################################################################

D:\IAR Workspace\STM32F407\VCP_ESP\usb_lib\otg\usb_core.c
      1          /**
      2            ******************************************************************************
      3            * @file    usb_core.c
      4            * @author  MCD Application Team
      5            * @version V2.0.0
      6            * @date    22-July-2011
      7            * @brief   USB-OTG Core Layer
      8            ******************************************************************************
      9            * @attention 
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE 
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "usb_core.h"
     24          #include "usb_bsp.h"
     25          
     26          
     27          /** @addtogroup USB_OTG_DRIVER
     28          * @{
     29          */
     30          
     31          /** @defgroup USB_CORE 
     32          * @brief This file includes the USB-OTG Core Layer
     33          * @{
     34          */
     35          
     36          
     37          /** @defgroup USB_CORE_Private_Defines
     38          * @{
     39          */ 
     40          
     41          /**
     42          * @}
     43          */ 
     44          
     45          
     46          /** @defgroup USB_CORE_Private_TypesDefinitions
     47          * @{
     48          */ 
     49          /**
     50          * @}
     51          */ 
     52          
     53          
     54          
     55          /** @defgroup USB_CORE_Private_Macros
     56          * @{
     57          */ 
     58          /**
     59          * @}
     60          */ 
     61          
     62          
     63          /** @defgroup USB_CORE_Private_Variables
     64          * @{
     65          */ 
     66          /**
     67          * @}
     68          */ 
     69          
     70          
     71          /** @defgroup USB_CORE_Private_FunctionPrototypes
     72          * @{
     73          */ 
     74          /**
     75          * @}
     76          */ 
     77          
     78          
     79          /** @defgroup USB_CORE_Private_Functions
     80          * @{
     81          */ 
     82          
     83          /**
     84          * @brief  USB_OTG_EnableCommonInt
     85          *         Initializes the commmon interrupts, used in both device and modes
     86          * @param  pdev : Selected device
     87          * @retval None
     88          */

   \                                 In section .text, align 2, keep-with-next
     89          static void USB_OTG_EnableCommonInt(USB_OTG_CORE_HANDLE *pdev)
     90          {
     91            USB_OTG_GINTMSK_TypeDef  int_mask;
     92            
     93            int_mask.d32 = 0;
   \                     USB_OTG_EnableCommonInt: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x0011             MOVS     R1,R2
     94            /* Clear any pending USB_OTG Interrupts */
     95          #ifndef USE_OTG_MODE
     96            USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GOTGINT, 0xFFFFFFFF);
   \   00000004   0xF05F 0x32FF      MOVS     R2,#-1
   \   00000008   0x68C3             LDR      R3,[R0, #+12]
   \   0000000A   0x605A             STR      R2,[R3, #+4]
     97          #endif
     98            /* Clear any pending interrupts */
     99            USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
   \   0000000C   0xF05F 0x32FF      MOVS     R2,#-1
   \   00000010   0x68C3             LDR      R3,[R0, #+12]
   \   00000012   0x615A             STR      R2,[R3, #+20]
    100            /* Enable the interrupts in the INTMSK */
    101            int_mask.b.wkupintr = 1;
   \   00000014   0xF051 0x4100      ORRS     R1,R1,#0x80000000
    102            int_mask.b.usbsuspend = 1; 
   \   00000018   0xF451 0x6100      ORRS     R1,R1,#0x800
    103            
    104          #ifdef USE_OTG_MODE
    105            int_mask.b.otgintr = 1;
    106            int_mask.b.sessreqintr = 1;
    107            int_mask.b.conidstschng = 1;
    108          #endif
    109            USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32);
   \   0000001C   0x68C2             LDR      R2,[R0, #+12]
   \   0000001E   0x6191             STR      R1,[R2, #+24]
    110          }
   \   00000020   0x4770             BX       LR               ;; return
    111          
    112          /**
    113          * @brief  USB_OTG_CoreReset : Soft reset of the core
    114          * @param  pdev : Selected device
    115          * @retval USB_OTG_STS : status
    116          */

   \                                 In section .text, align 2, keep-with-next
    117          static USB_OTG_STS USB_OTG_CoreReset(USB_OTG_CORE_HANDLE *pdev)
    118          {
   \                     USB_OTG_CoreReset: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    119            USB_OTG_STS status = USB_OTG_OK;
   \   00000006   0x2500             MOVS     R5,#+0
    120            __IO USB_OTG_GRSTCTL_TypeDef  greset;
    121            uint32_t count = 0;
   \   00000008   0x2600             MOVS     R6,#+0
    122            
    123            greset.d32 = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9000             STR      R0,[SP, #+0]
    124            /* Wait for AHB master IDLE state. */
    125            do
    126            {
    127              USB_OTG_BSP_uDelay(3);
   \                     ??USB_OTG_CoreReset_0: (+1)
   \   0000000E   0x2003             MOVS     R0,#+3
   \   00000010   0x.... 0x....      BL       USB_OTG_BSP_uDelay
    128              greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
   \   00000014   0x68E0             LDR      R0,[R4, #+12]
   \   00000016   0x6900             LDR      R0,[R0, #+16]
   \   00000018   0x9000             STR      R0,[SP, #+0]
    129              if (++count > 200000)
   \   0000001A   0x1C76             ADDS     R6,R6,#+1
   \   0000001C   0x....             LDR.N    R0,??DataTable3  ;; 0x30d41
   \   0000001E   0x4286             CMP      R6,R0
   \   00000020   0xD301             BCC.N    ??USB_OTG_CoreReset_1
    130              {
    131                return USB_OTG_OK;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE01B             B.N      ??USB_OTG_CoreReset_2
    132              }
    133            }
    134            while (greset.b.ahbidle == 0);
   \                     ??USB_OTG_CoreReset_1: (+1)
   \   00000026   0x9800             LDR      R0,[SP, #+0]
   \   00000028   0x0FC0             LSRS     R0,R0,#+31
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD0EF             BEQ.N    ??USB_OTG_CoreReset_0
    135            /* Core Soft Reset */
    136            count = 0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x0006             MOVS     R6,R0
    137            greset.b.csftrst = 1;
   \   00000032   0x9800             LDR      R0,[SP, #+0]
   \   00000034   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000038   0x9000             STR      R0,[SP, #+0]
    138            USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
   \   0000003A   0x9800             LDR      R0,[SP, #+0]
   \   0000003C   0x68E1             LDR      R1,[R4, #+12]
   \   0000003E   0x6108             STR      R0,[R1, #+16]
    139            do
    140            {
    141              greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
   \                     ??USB_OTG_CoreReset_3: (+1)
   \   00000040   0x68E0             LDR      R0,[R4, #+12]
   \   00000042   0x6900             LDR      R0,[R0, #+16]
   \   00000044   0x9000             STR      R0,[SP, #+0]
    142              if (++count > 200000)
   \   00000046   0x1C76             ADDS     R6,R6,#+1
   \   00000048   0x....             LDR.N    R0,??DataTable3  ;; 0x30d41
   \   0000004A   0x4286             CMP      R6,R0
   \   0000004C   0xD202             BCS.N    ??USB_OTG_CoreReset_4
    143              {
    144                break;
    145              }
    146            }
    147            while (greset.b.csftrst == 1);
   \                     ??USB_OTG_CoreReset_5: (+1)
   \   0000004E   0x9800             LDR      R0,[SP, #+0]
   \   00000050   0x07C0             LSLS     R0,R0,#+31
   \   00000052   0xD4F5             BMI.N    ??USB_OTG_CoreReset_3
    148            /* Wait for 3 PHY Clocks*/
    149            USB_OTG_BSP_uDelay(3);
   \                     ??USB_OTG_CoreReset_4: (+1)
   \   00000054   0x2003             MOVS     R0,#+3
   \   00000056   0x.... 0x....      BL       USB_OTG_BSP_uDelay
    150            return status;
   \   0000005A   0x0028             MOVS     R0,R5
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_OTG_CoreReset_2: (+1)
   \   0000005E   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    151          }
    152          
    153          /**
    154          * @brief  USB_OTG_WritePacket : Writes a packet into the Tx FIFO associated 
    155          *         with the EP
    156          * @param  pdev : Selected device
    157          * @param  src : source pointer
    158          * @param  ch_ep_num : end point number
    159          * @param  bytes : No. of bytes
    160          * @retval USB_OTG_STS : status
    161          */

   \                                 In section .text, align 2, keep-with-next
    162          USB_OTG_STS USB_OTG_WritePacket(USB_OTG_CORE_HANDLE *pdev, 
    163                                          uint8_t             *src, 
    164                                          uint8_t             ch_ep_num, 
    165                                          uint16_t            len)
    166          {
   \                     USB_OTG_WritePacket: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    167            USB_OTG_STS status = USB_OTG_OK;
   \   00000004   0x2000             MOVS     R0,#+0
    168            if (pdev->cfg.dma_enable == 0)
   \   00000006   0x78E5             LDRB     R5,[R4, #+3]
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD11B             BNE.N    ??USB_OTG_WritePacket_0
    169            {
    170              uint32_t count32b= 0 , i= 0;
   \   0000000C   0x2500             MOVS     R5,#+0
   \   0000000E   0x2600             MOVS     R6,#+0
    171              __IO uint32_t *fifo;
    172              
    173              count32b =  (len + 3) / 4;
   \   00000010   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000012   0xF113 0x0C03      ADDS     R12,R3,#+3
   \   00000016   0xF05F 0x0E04      MOVS     LR,#+4
   \   0000001A   0xFB9C 0xFCFE      SDIV     R12,R12,LR
   \   0000001E   0x4665             MOV      R5,R12
    174              fifo = pdev->regs.DFIFO[ch_ep_num];
   \   00000020   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000022   0xEB14 0x0C82      ADDS     R12,R4,R2, LSL #+2
   \   00000026   0xF8DC 0xC0D0      LDR      R12,[R12, #+208]
   \   0000002A   0x4667             MOV      R7,R12
    175              for (i = 0; i < count32b; i++, src+=4)
   \   0000002C   0xF05F 0x0C00      MOVS     R12,#+0
   \   00000030   0x4666             MOV      R6,R12
   \                     ??USB_OTG_WritePacket_1: (+1)
   \   00000032   0x42AE             CMP      R6,R5
   \   00000034   0xD206             BCS.N    ??USB_OTG_WritePacket_0
    176              {
    177                USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
   \   00000036   0xF8D1 0xC000      LDR      R12,[R1, #+0]
   \   0000003A   0xF8C7 0xC000      STR      R12,[R7, #+0]
    178              }
   \   0000003E   0x1C76             ADDS     R6,R6,#+1
   \   00000040   0x1D09             ADDS     R1,R1,#+4
   \   00000042   0xE7F6             B.N      ??USB_OTG_WritePacket_1
    179            }
    180            return status;
   \                     ??USB_OTG_WritePacket_0: (+1)
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0xBDF0             POP      {R4-R7,PC}       ;; return
    181          }
    182          
    183          
    184          /**
    185          * @brief  USB_OTG_ReadPacket : Reads a packet from the Rx FIFO
    186          * @param  pdev : Selected device
    187          * @param  dest : Destination Pointer
    188          * @param  bytes : No. of bytes
    189          * @retval None
    190          */

   \                                 In section .text, align 2, keep-with-next
    191          void *USB_OTG_ReadPacket(USB_OTG_CORE_HANDLE *pdev, 
    192                                   uint8_t *dest, 
    193                                   uint16_t len)
    194          {
   \                     USB_OTG_ReadPacket: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0003             MOVS     R3,R0
   \   00000004   0x0008             MOVS     R0,R1
    195            uint32_t i=0;
   \   00000006   0x2100             MOVS     R1,#+0
    196            uint32_t count32b = (len + 3) / 4;
   \   00000008   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000A   0x1CD4             ADDS     R4,R2,#+3
   \   0000000C   0x2504             MOVS     R5,#+4
   \   0000000E   0xFB94 0xF4F5      SDIV     R4,R4,R5
    197            
    198            __IO uint32_t *fifo = pdev->regs.DFIFO[0];
   \   00000012   0xF8D3 0x50D0      LDR      R5,[R3, #+208]
    199            
    200            for ( i = 0; i < count32b; i++, dest += 4 )
   \   00000016   0x2600             MOVS     R6,#+0
   \   00000018   0x0031             MOVS     R1,R6
   \                     ??USB_OTG_ReadPacket_0: (+1)
   \   0000001A   0x42A1             CMP      R1,R4
   \   0000001C   0xD204             BCS.N    ??USB_OTG_ReadPacket_1
    201            {
    202              *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
   \   0000001E   0x682E             LDR      R6,[R5, #+0]
   \   00000020   0x6006             STR      R6,[R0, #+0]
    203              
    204            }
   \   00000022   0x1C49             ADDS     R1,R1,#+1
   \   00000024   0x1D00             ADDS     R0,R0,#+4
   \   00000026   0xE7F8             B.N      ??USB_OTG_ReadPacket_0
    205            return ((void *)dest);
   \                     ??USB_OTG_ReadPacket_1: (+1)
   \   00000028   0xBC70             POP      {R4-R6}
   \   0000002A   0x4770             BX       LR               ;; return
    206          }
    207          
    208          /**
    209          * @brief  USB_OTG_SelectCore 
    210          *         Initialize core registers address.
    211          * @param  pdev : Selected device
    212          * @param  coreID : USB OTG Core ID
    213          * @retval USB_OTG_STS : status
    214          */

   \                                 In section .text, align 2, keep-with-next
    215          USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
    216                                         USB_OTG_CORE_ID_TypeDef coreID)
    217          {
   \                     USB_OTG_SelectCore: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0002             MOVS     R2,R0
    218            uint32_t i , baseAddress = 0;
   \   00000004   0x2400             MOVS     R4,#+0
    219            USB_OTG_STS status = USB_OTG_OK;
   \   00000006   0x2000             MOVS     R0,#+0
    220            
    221            pdev->cfg.dma_enable       = 0;
   \   00000008   0x2500             MOVS     R5,#+0
   \   0000000A   0x70D5             STRB     R5,[R2, #+3]
    222            
    223            /* at startup the core is in FS mode */
    224            pdev->cfg.speed            = USB_OTG_SPEED_FULL;
   \   0000000C   0x2501             MOVS     R5,#+1
   \   0000000E   0x7095             STRB     R5,[R2, #+2]
    225            pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
   \   00000010   0x2540             MOVS     R5,#+64
   \   00000012   0x8095             STRH     R5,[R2, #+4]
    226              
    227            /* initialize device cfg following its address */
    228            if (coreID == USB_OTG_FS_CORE_ID)
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x2901             CMP      R1,#+1
   \   00000018   0xD10E             BNE.N    ??USB_OTG_SelectCore_0
    229            {
    230              baseAddress                = USB_OTG_FS_BASE_ADDR;
   \   0000001A   0xF05F 0x45A0      MOVS     R5,#+1342177280
   \   0000001E   0x002C             MOVS     R4,R5
    231              pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
   \   00000020   0x2501             MOVS     R5,#+1
   \   00000022   0x72D5             STRB     R5,[R2, #+11]
    232              pdev->cfg.host_channels    = 8 ;
   \   00000024   0x2508             MOVS     R5,#+8
   \   00000026   0x7015             STRB     R5,[R2, #+0]
    233              pdev->cfg.dev_endpoints    = 4 ;
   \   00000028   0x2504             MOVS     R5,#+4
   \   0000002A   0x7055             STRB     R5,[R2, #+1]
    234              pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
   \   0000002C   0xF44F 0x75A0      MOV      R5,#+320
   \   00000030   0x80D5             STRH     R5,[R2, #+6]
    235              pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;     
   \   00000032   0x2502             MOVS     R5,#+2
   \   00000034   0x7215             STRB     R5,[R2, #+8]
   \   00000036   0xE00D             B.N      ??USB_OTG_SelectCore_1
    236              
    237          #ifdef USB_OTG_FS_SOF_OUTPUT_ENABLED    
    238              pdev->cfg.Sof_output       = 1;    
    239          #endif 
    240              
    241          #ifdef USB_OTG_FS_LOW_PWR_MGMT_SUPPORT    
    242              pdev->cfg.low_power        = 1;    
    243          #endif     
    244            }
    245            else if (coreID == USB_OTG_HS_CORE_ID)
   \                     ??USB_OTG_SelectCore_0: (+1)
   \   00000038   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003A   0x2900             CMP      R1,#+0
   \   0000003C   0xD10A             BNE.N    ??USB_OTG_SelectCore_1
    246            {
    247              baseAddress                = USB_OTG_HS_BASE_ADDR;
   \   0000003E   0x....             LDR.N    R5,??DataTable3_1  ;; 0x40040000
   \   00000040   0x002C             MOVS     R4,R5
    248              pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
   \   00000042   0x2500             MOVS     R5,#+0
   \   00000044   0x72D5             STRB     R5,[R2, #+11]
    249              pdev->cfg.host_channels    = 12 ;
   \   00000046   0x250C             MOVS     R5,#+12
   \   00000048   0x7015             STRB     R5,[R2, #+0]
    250              pdev->cfg.dev_endpoints    = 6 ;
   \   0000004A   0x2506             MOVS     R5,#+6
   \   0000004C   0x7055             STRB     R5,[R2, #+1]
    251              pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
   \   0000004E   0xF44F 0x65A0      MOV      R5,#+1280
   \   00000052   0x80D5             STRH     R5,[R2, #+6]
    252              
    253          #ifdef USB_OTG_ULPI_PHY_ENABLED
    254              pdev->cfg.phy_itface       = USB_OTG_ULPI_PHY;
    255          #else    
    256           #ifdef USB_OTG_EMBEDDED_PHY_ENABLED
    257              pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;
    258           #else   
    259             #ifdef USB_OTG_I2C_PHY_ENABLED    
    260              pdev->cfg.phy_itface       = USB_OTG_I2C_PHY; 
    261             #endif
    262           #endif  
    263          #endif      
    264              
    265          #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED    
    266              pdev->cfg.dma_enable       = 1;    
    267          #endif
    268              
    269          #ifdef USB_OTG_HS_SOF_OUTPUT_ENABLED    
    270              pdev->cfg.Sof_output       = 1;    
    271          #endif 
    272              
    273          #ifdef USB_OTG_HS_LOW_PWR_MGMT_SUPPORT    
    274              pdev->cfg.low_power        = 1;    
    275          #endif 
    276              
    277            }
    278            
    279            pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    280              USB_OTG_CORE_GLOBAL_REGS_OFFSET);
   \                     ??USB_OTG_SelectCore_1: (+1)
   \   00000054   0x60D4             STR      R4,[R2, #+12]
    281            pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    282              USB_OTG_DEV_GLOBAL_REG_OFFSET);
   \   00000056   0xF514 0x6500      ADDS     R5,R4,#+2048
   \   0000005A   0x6115             STR      R5,[R2, #+16]
    283            
    284            for (i = 0; i < pdev->cfg.dev_endpoints; i++)
   \   0000005C   0x2500             MOVS     R5,#+0
   \   0000005E   0x002B             MOVS     R3,R5
   \                     ??USB_OTG_SelectCore_2: (+1)
   \   00000060   0x7855             LDRB     R5,[R2, #+1]
   \   00000062   0x42AB             CMP      R3,R5
   \   00000064   0xD20F             BCS.N    ??USB_OTG_SelectCore_3
    285            {
    286              pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
    287                (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
    288                  (i * USB_OTG_EP_REG_OFFSET));
   \   00000066   0xEB14 0x1543      ADDS     R5,R4,R3, LSL #+5
   \   0000006A   0xF515 0x6510      ADDS     R5,R5,#+2304
   \   0000006E   0xEB12 0x0683      ADDS     R6,R2,R3, LSL #+2
   \   00000072   0x61B5             STR      R5,[R6, #+24]
    289              pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
    290                (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
    291                  (i * USB_OTG_EP_REG_OFFSET));
   \   00000074   0xEB14 0x1543      ADDS     R5,R4,R3, LSL #+5
   \   00000078   0xF515 0x6530      ADDS     R5,R5,#+2816
   \   0000007C   0xEB12 0x0683      ADDS     R6,R2,R3, LSL #+2
   \   00000080   0x6575             STR      R5,[R6, #+84]
    292            }
   \   00000082   0x1C5B             ADDS     R3,R3,#+1
   \   00000084   0xE7EC             B.N      ??USB_OTG_SelectCore_2
    293            pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
    294              USB_OTG_HOST_GLOBAL_REG_OFFSET);
   \                     ??USB_OTG_SelectCore_3: (+1)
   \   00000086   0xF514 0x6580      ADDS     R5,R4,#+1024
   \   0000008A   0x6155             STR      R5,[R2, #+20]
    295            pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
   \   0000008C   0xF514 0x6588      ADDS     R5,R4,#+1088
   \   00000090   0xF8C2 0x50CC      STR      R5,[R2, #+204]
    296            
    297            for (i = 0; i < pdev->cfg.host_channels; i++)
   \   00000094   0x2500             MOVS     R5,#+0
   \   00000096   0x002B             MOVS     R3,R5
   \                     ??USB_OTG_SelectCore_4: (+1)
   \   00000098   0x7815             LDRB     R5,[R2, #+0]
   \   0000009A   0x42AB             CMP      R3,R5
   \   0000009C   0xD209             BCS.N    ??USB_OTG_SelectCore_5
    298            {
    299              pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
    300                USB_OTG_HOST_CHAN_REGS_OFFSET + \
    301                  (i * USB_OTG_CHAN_REGS_OFFSET));
   \   0000009E   0xEB14 0x1543      ADDS     R5,R4,R3, LSL #+5
   \   000000A2   0xF515 0x65A0      ADDS     R5,R5,#+1280
   \   000000A6   0xEB12 0x0683      ADDS     R6,R2,R3, LSL #+2
   \   000000AA   0xF8C6 0x5090      STR      R5,[R6, #+144]
    302            }
   \   000000AE   0x1C5B             ADDS     R3,R3,#+1
   \   000000B0   0xE7F2             B.N      ??USB_OTG_SelectCore_4
    303            for (i = 0; i < pdev->cfg.host_channels; i++)
   \                     ??USB_OTG_SelectCore_5: (+1)
   \   000000B2   0x2500             MOVS     R5,#+0
   \   000000B4   0x002B             MOVS     R3,R5
   \                     ??USB_OTG_SelectCore_6: (+1)
   \   000000B6   0x7815             LDRB     R5,[R2, #+0]
   \   000000B8   0x42AB             CMP      R3,R5
   \   000000BA   0xD20B             BCS.N    ??USB_OTG_SelectCore_7
    304            {
    305              pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
    306                (i * USB_OTG_DATA_FIFO_SIZE));
   \   000000BC   0xF44F 0x5580      MOV      R5,#+4096
   \   000000C0   0xFB05 0x4503      MLA      R5,R5,R3,R4
   \   000000C4   0xF515 0x5580      ADDS     R5,R5,#+4096
   \   000000C8   0xEB12 0x0683      ADDS     R6,R2,R3, LSL #+2
   \   000000CC   0xF8C6 0x50D0      STR      R5,[R6, #+208]
    307            }
   \   000000D0   0x1C5B             ADDS     R3,R3,#+1
   \   000000D2   0xE7F0             B.N      ??USB_OTG_SelectCore_6
    308            pdev->regs.PCGCCTL = (uint32_t *)(baseAddress + USB_OTG_PCGCCTL_OFFSET);
   \                     ??USB_OTG_SelectCore_7: (+1)
   \   000000D4   0xF514 0x6560      ADDS     R5,R4,#+3584
   \   000000D8   0xF8C2 0x510C      STR      R5,[R2, #+268]
    309            
    310            return status;
   \   000000DC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DE   0xBC70             POP      {R4-R6}
   \   000000E0   0x4770             BX       LR               ;; return
    311          }
    312          
    313          
    314          /**
    315          * @brief  USB_OTG_CoreInit
    316          *         Initializes the USB_OTG controller registers and prepares the core
    317          *         device mode or host mode operation.
    318          * @param  pdev : Selected device
    319          * @retval USB_OTG_STS : status
    320          */

   \                                 In section .text, align 2, keep-with-next
    321          USB_OTG_STS USB_OTG_CoreInit(USB_OTG_CORE_HANDLE *pdev)
    322          {
   \                     USB_OTG_CoreInit: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
    323            USB_OTG_STS status = USB_OTG_OK;
   \   00000006   0x2500             MOVS     R5,#+0
    324            USB_OTG_GUSBCFG_TypeDef  usbcfg;
    325            USB_OTG_GCCFG_TypeDef    gccfg;
    326            USB_OTG_GI2CCTL_TypeDef  i2cctl;
    327            USB_OTG_GAHBCFG_TypeDef  ahbcfg;
    328            
    329            usbcfg.d32 = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0006             MOVS     R6,R0
    330            gccfg.d32 = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x0007             MOVS     R7,R0
    331            ahbcfg.d32 = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4681             MOV      R9,R0
    332            
    333          
    334            
    335            if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
   \   00000014   0x7A20             LDRB     R0,[R4, #+8]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD12F             BNE.N    ??USB_OTG_CoreInit_0
    336            {
    337              gccfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GCCFG);
   \   0000001A   0x68E0             LDR      R0,[R4, #+12]
   \   0000001C   0x6B80             LDR      R0,[R0, #+56]
   \   0000001E   0x0007             MOVS     R7,R0
    338              gccfg.b.pwdn = 0;
   \   00000020   0xF437 0x3780      BICS     R7,R7,#0x10000
    339              
    340              if (pdev->cfg.Sof_output)
   \   00000024   0x7A60             LDRB     R0,[R4, #+9]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD001             BEQ.N    ??USB_OTG_CoreInit_1
    341              {
    342                gccfg.b.sofouten = 1;   
   \   0000002A   0xF457 0x1780      ORRS     R7,R7,#0x100000
    343              }
    344              USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
   \                     ??USB_OTG_CoreInit_1: (+1)
   \   0000002E   0x68E0             LDR      R0,[R4, #+12]
   \   00000030   0x6387             STR      R7,[R0, #+56]
    345              
    346              /* Init The ULPI Interface */
    347              usbcfg.d32 = 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x0006             MOVS     R6,R0
    348              usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
   \   00000036   0x68E0             LDR      R0,[R4, #+12]
   \   00000038   0x68C0             LDR      R0,[R0, #+12]
   \   0000003A   0x0006             MOVS     R6,R0
    349              
    350              usbcfg.b.physel            = 0; /* HS Interface */
   \   0000003C   0xF036 0x0640      BICS     R6,R6,#0x40
    351          #ifdef USB_OTG_INTERNAL_VBUS_ENABLED
    352              usbcfg.b.ulpi_ext_vbus_drv = 0; /* Use internal VBUS */
    353          #else
    354           #ifdef USB_OTG_EXTERNAL_VBUS_ENABLED    
    355              usbcfg.b.ulpi_ext_vbus_drv = 1; /* Use external VBUS */
    356           #endif
    357          #endif 
    358              usbcfg.b.term_sel_dl_pulse = 0; /* Data line pulsing using utmi_txvalid */    
   \   00000040   0xF436 0x0680      BICS     R6,R6,#0x400000
    359              usbcfg.b.ulpi_utmi_sel     = 1; /* ULPI seleInterfacect */
   \   00000044   0xF056 0x0610      ORRS     R6,R6,#0x10
    360              
    361              usbcfg.b.phyif             = 0; /* 8 bits */
   \   00000048   0xF036 0x0608      BICS     R6,R6,#0x8
    362              usbcfg.b.ddrsel            = 0; /* single data rate */
   \   0000004C   0xF036 0x0680      BICS     R6,R6,#0x80
    363              
    364              usbcfg.b.ulpi_fsls = 0;
   \   00000050   0xF436 0x3600      BICS     R6,R6,#0x20000
    365              usbcfg.b.ulpi_clk_sus_m = 0;
   \   00000054   0xF436 0x2600      BICS     R6,R6,#0x80000
    366              USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
   \   00000058   0x68E0             LDR      R0,[R4, #+12]
   \   0000005A   0x60C6             STR      R6,[R0, #+12]
    367              
    368              /* Reset after a PHY select  */
    369              USB_OTG_CoreReset(pdev);
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0x.... 0x....      BL       USB_OTG_CoreReset
    370              
    371              if(pdev->cfg.dma_enable == 1)
   \   00000062   0x78E0             LDRB     R0,[R4, #+3]
   \   00000064   0x2801             CMP      R0,#+1
   \   00000066   0xD153             BNE.N    ??USB_OTG_CoreInit_2
    372              {
    373                
    374                ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
   \   00000068   0x2005             MOVS     R0,#+5
   \   0000006A   0xF360 0x0944      BFI      R9,R0,#+1,#+4
    375                ahbcfg.b.dmaenable = 1;
   \   0000006E   0xF059 0x0920      ORRS     R9,R9,#0x20
    376                USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
   \   00000072   0x68E0             LDR      R0,[R4, #+12]
   \   00000074   0xF8C0 0x9008      STR      R9,[R0, #+8]
   \   00000078   0xE04A             B.N      ??USB_OTG_CoreInit_2
    377                
    378              }    
    379            }
    380            else /* FS interface (embedded Phy or I2C Phy) */
    381            {
    382              
    383              usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);;
   \                     ??USB_OTG_CoreInit_0: (+1)
   \   0000007A   0x68E0             LDR      R0,[R4, #+12]
   \   0000007C   0x68C0             LDR      R0,[R0, #+12]
   \   0000007E   0x0006             MOVS     R6,R0
    384              usbcfg.b.physel  = 1; /* FS Interface */
   \   00000080   0xF056 0x0640      ORRS     R6,R6,#0x40
    385              USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
   \   00000084   0x68E0             LDR      R0,[R4, #+12]
   \   00000086   0x60C6             STR      R6,[R0, #+12]
    386              /* Reset after a PHY select and set Host mode */
    387              USB_OTG_CoreReset(pdev);
   \   00000088   0x0020             MOVS     R0,R4
   \   0000008A   0x.... 0x....      BL       USB_OTG_CoreReset
    388              /* Enable the I2C interface and deactivate the power down*/
    389              gccfg.d32 = 0;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x0007             MOVS     R7,R0
    390              gccfg.b.pwdn = 1;
   \   00000092   0xF457 0x3780      ORRS     R7,R7,#0x10000
    391              
    392              if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
   \   00000096   0x7A20             LDRB     R0,[R4, #+8]
   \   00000098   0x2803             CMP      R0,#+3
   \   0000009A   0xD101             BNE.N    ??USB_OTG_CoreInit_3
    393              {
    394                gccfg.b.i2cifen = 1;
   \   0000009C   0xF457 0x3700      ORRS     R7,R7,#0x20000
    395              }   
    396              gccfg.b.vbussensingA = 1 ;
   \                     ??USB_OTG_CoreInit_3: (+1)
   \   000000A0   0xF457 0x2780      ORRS     R7,R7,#0x40000
    397              gccfg.b.vbussensingB = 1 ;     
   \   000000A4   0xF457 0x2700      ORRS     R7,R7,#0x80000
    398          #ifndef VBUS_SENSING_ENABLED
    399              gccfg.b.disablevbussensing = 1; 
   \   000000A8   0xF457 0x1700      ORRS     R7,R7,#0x200000
    400          #endif    
    401              
    402              if(pdev->cfg.Sof_output)
   \   000000AC   0x7A60             LDRB     R0,[R4, #+9]
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD001             BEQ.N    ??USB_OTG_CoreInit_4
    403              {
    404                gccfg.b.sofouten = 1;  
   \   000000B2   0xF457 0x1780      ORRS     R7,R7,#0x100000
    405              }
    406              
    407              USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
   \                     ??USB_OTG_CoreInit_4: (+1)
   \   000000B6   0x68E0             LDR      R0,[R4, #+12]
   \   000000B8   0x6387             STR      R7,[R0, #+56]
    408              USB_OTG_BSP_mDelay(20);
   \   000000BA   0x2014             MOVS     R0,#+20
   \   000000BC   0x.... 0x....      BL       USB_OTG_BSP_mDelay
    409              /* Program GUSBCFG.OtgUtmifsSel to I2C*/
    410              usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
   \   000000C0   0x68E0             LDR      R0,[R4, #+12]
   \   000000C2   0x68C0             LDR      R0,[R0, #+12]
   \   000000C4   0x0006             MOVS     R6,R0
    411              
    412              if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
   \   000000C6   0x7A20             LDRB     R0,[R4, #+8]
   \   000000C8   0x2803             CMP      R0,#+3
   \   000000CA   0xD101             BNE.N    ??USB_OTG_CoreInit_5
    413              {
    414                usbcfg.b.otgutmifssel = 1;
   \   000000CC   0xF456 0x3680      ORRS     R6,R6,#0x10000
    415              }
    416              
    417              USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
   \                     ??USB_OTG_CoreInit_5: (+1)
   \   000000D0   0x68E0             LDR      R0,[R4, #+12]
   \   000000D2   0x60C6             STR      R6,[R0, #+12]
    418              
    419              if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
   \   000000D4   0x7A20             LDRB     R0,[R4, #+8]
   \   000000D6   0x2803             CMP      R0,#+3
   \   000000D8   0xD11A             BNE.N    ??USB_OTG_CoreInit_2
    420              {
    421                /*Program GI2CCTL.I2CEn*/
    422                i2cctl.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GI2CCTL);
   \   000000DA   0x68E0             LDR      R0,[R4, #+12]
   \   000000DC   0x6B00             LDR      R0,[R0, #+48]
   \   000000DE   0x4680             MOV      R8,R0
    423                i2cctl.b.i2cdevaddr = 1;
   \   000000E0   0x2001             MOVS     R0,#+1
   \   000000E2   0xF360 0x689B      BFI      R8,R0,#+26,#+2
    424                i2cctl.b.i2cen = 0;
   \   000000E6   0xF438 0x0800      BICS     R8,R8,#0x800000
    425                i2cctl.b.dat_se0 = 1;
   \   000000EA   0xF058 0x5880      ORRS     R8,R8,#0x10000000
    426                i2cctl.b.addr = 0x2D;
   \   000000EE   0x202D             MOVS     R0,#+45
   \   000000F0   0xF360 0x4816      BFI      R8,R0,#+16,#+7
    427                USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
   \   000000F4   0x68E0             LDR      R0,[R4, #+12]
   \   000000F6   0xF8C0 0x8030      STR      R8,[R0, #+48]
    428                
    429                USB_OTG_BSP_mDelay(200);
   \   000000FA   0x20C8             MOVS     R0,#+200
   \   000000FC   0x.... 0x....      BL       USB_OTG_BSP_mDelay
    430                
    431                i2cctl.b.i2cen = 1;
   \   00000100   0xF458 0x0800      ORRS     R8,R8,#0x800000
    432                USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
   \   00000104   0x68E0             LDR      R0,[R4, #+12]
   \   00000106   0xF8C0 0x8030      STR      R8,[R0, #+48]
    433                USB_OTG_BSP_mDelay(200);
   \   0000010A   0x20C8             MOVS     R0,#+200
   \   0000010C   0x.... 0x....      BL       USB_OTG_BSP_mDelay
    434              }
    435            }
    436            /* case the HS core is working in FS mode */
    437            if(pdev->cfg.dma_enable == 1)
   \                     ??USB_OTG_CoreInit_2: (+1)
   \   00000110   0x78E0             LDRB     R0,[R4, #+3]
   \   00000112   0x2801             CMP      R0,#+1
   \   00000114   0xD10A             BNE.N    ??USB_OTG_CoreInit_6
    438            {
    439              
    440              ahbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GAHBCFG);
   \   00000116   0x68E0             LDR      R0,[R4, #+12]
   \   00000118   0x6880             LDR      R0,[R0, #+8]
   \   0000011A   0x4681             MOV      R9,R0
    441              ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
   \   0000011C   0x2005             MOVS     R0,#+5
   \   0000011E   0xF360 0x0944      BFI      R9,R0,#+1,#+4
    442              ahbcfg.b.dmaenable = 1;
   \   00000122   0xF059 0x0920      ORRS     R9,R9,#0x20
    443              USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
   \   00000126   0x68E0             LDR      R0,[R4, #+12]
   \   00000128   0xF8C0 0x9008      STR      R9,[R0, #+8]
    444              
    445            }
    446            /* initialize OTG features */
    447          #ifdef  USE_OTG_MODE
    448            usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
    449            usbcfg.b.hnpcap = 1;
    450            usbcfg.b.srpcap = 1;
    451            USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
    452            USB_OTG_EnableCommonInt(pdev);
    453          #endif
    454            return status;
   \                     ??USB_OTG_CoreInit_6: (+1)
   \   0000012C   0x0028             MOVS     R0,R5
   \   0000012E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000130   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    455          }
    456          /**
    457          * @brief  USB_OTG_EnableGlobalInt
    458          *         Enables the controller's Global Int in the AHB Config reg
    459          * @param  pdev : Selected device
    460          * @retval USB_OTG_STS : status
    461          */

   \                                 In section .text, align 2, keep-with-next
    462          USB_OTG_STS USB_OTG_EnableGlobalInt(USB_OTG_CORE_HANDLE *pdev)
    463          {
   \                     USB_OTG_EnableGlobalInt: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0001             MOVS     R1,R0
    464            USB_OTG_STS status = USB_OTG_OK;
   \   00000004   0x2000             MOVS     R0,#+0
    465            USB_OTG_GAHBCFG_TypeDef  ahbcfg;
    466            
    467            ahbcfg.d32 = 0;
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x001A             MOVS     R2,R3
    468            ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
   \   0000000A   0xF052 0x0201      ORRS     R2,R2,#0x1
    469            USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, 0, ahbcfg.d32);
   \   0000000E   0x68CB             LDR      R3,[R1, #+12]
   \   00000010   0x689B             LDR      R3,[R3, #+8]
   \   00000012   0x4313             ORRS     R3,R2,R3
   \   00000014   0x68CC             LDR      R4,[R1, #+12]
   \   00000016   0x60A3             STR      R3,[R4, #+8]
    470            return status;
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0xBC10             POP      {R4}
   \   0000001C   0x4770             BX       LR               ;; return
    471          }
    472          
    473          
    474          /**
    475          * @brief  USB_OTG_DisableGlobalInt
    476          *         Enables the controller's Global Int in the AHB Config reg
    477          * @param  pdev : Selected device
    478          * @retval USB_OTG_STS : status
    479          */

   \                                 In section .text, align 2, keep-with-next
    480          USB_OTG_STS USB_OTG_DisableGlobalInt(USB_OTG_CORE_HANDLE *pdev)
    481          {
   \                     USB_OTG_DisableGlobalInt: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0001             MOVS     R1,R0
    482            USB_OTG_STS status = USB_OTG_OK;
   \   00000004   0x2000             MOVS     R0,#+0
    483            USB_OTG_GAHBCFG_TypeDef  ahbcfg;
    484            ahbcfg.d32 = 0;
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x001A             MOVS     R2,R3
    485            ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
   \   0000000A   0xF052 0x0201      ORRS     R2,R2,#0x1
    486            USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32, 0);
   \   0000000E   0x68CB             LDR      R3,[R1, #+12]
   \   00000010   0x689B             LDR      R3,[R3, #+8]
   \   00000012   0x4393             BICS     R3,R3,R2
   \   00000014   0x68CC             LDR      R4,[R1, #+12]
   \   00000016   0x60A3             STR      R3,[R4, #+8]
    487            return status;
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0xBC10             POP      {R4}
   \   0000001C   0x4770             BX       LR               ;; return
    488          }
    489          
    490          
    491          /**
    492          * @brief  USB_OTG_FlushTxFifo : Flush a Tx FIFO
    493          * @param  pdev : Selected device
    494          * @param  num : FO num
    495          * @retval USB_OTG_STS : status
    496          */

   \                                 In section .text, align 2, keep-with-next
    497          USB_OTG_STS USB_OTG_FlushTxFifo (USB_OTG_CORE_HANDLE *pdev , uint32_t num )
    498          {
   \                     USB_OTG_FlushTxFifo: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    499            USB_OTG_STS status = USB_OTG_OK;
   \   00000006   0x2600             MOVS     R6,#+0
    500            __IO USB_OTG_GRSTCTL_TypeDef  greset;
    501            
    502            uint32_t count = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    503            greset.d32 = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9000             STR      R0,[SP, #+0]
    504            greset.b.txfflsh = 1;
   \   0000000E   0x9800             LDR      R0,[SP, #+0]
   \   00000010   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000014   0x9000             STR      R0,[SP, #+0]
    505            greset.b.txfnum  = num;
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0xF365 0x108A      BFI      R0,R5,#+6,#+5
   \   0000001C   0x9000             STR      R0,[SP, #+0]
    506            USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
   \   0000001E   0x9800             LDR      R0,[SP, #+0]
   \   00000020   0x68E1             LDR      R1,[R4, #+12]
   \   00000022   0x6108             STR      R0,[R1, #+16]
    507            do
    508            {
    509              greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
   \                     ??USB_OTG_FlushTxFifo_0: (+1)
   \   00000024   0x68E0             LDR      R0,[R4, #+12]
   \   00000026   0x6900             LDR      R0,[R0, #+16]
   \   00000028   0x9000             STR      R0,[SP, #+0]
    510              if (++count > 200000)
   \   0000002A   0x1C7F             ADDS     R7,R7,#+1
   \   0000002C   0x....             LDR.N    R0,??DataTable3  ;; 0x30d41
   \   0000002E   0x4287             CMP      R7,R0
   \   00000030   0xD204             BCS.N    ??USB_OTG_FlushTxFifo_1
    511              {
    512                break;
    513              }
    514            }
    515            while (greset.b.txfflsh == 1);
   \                     ??USB_OTG_FlushTxFifo_2: (+1)
   \   00000032   0x9800             LDR      R0,[SP, #+0]
   \   00000034   0xF3C0 0x1040      UBFX     R0,R0,#+5,#+1
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD1F3             BNE.N    ??USB_OTG_FlushTxFifo_0
    516            /* Wait for 3 PHY Clocks*/
    517            USB_OTG_BSP_uDelay(3);
   \                     ??USB_OTG_FlushTxFifo_1: (+1)
   \   0000003C   0x2003             MOVS     R0,#+3
   \   0000003E   0x.... 0x....      BL       USB_OTG_BSP_uDelay
    518            return status;
   \   00000042   0x0030             MOVS     R0,R6
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    519          }
    520          
    521          
    522          /**
    523          * @brief  USB_OTG_FlushRxFifo : Flush a Rx FIFO
    524          * @param  pdev : Selected device
    525          * @retval USB_OTG_STS : status
    526          */

   \                                 In section .text, align 2, keep-with-next
    527          USB_OTG_STS USB_OTG_FlushRxFifo( USB_OTG_CORE_HANDLE *pdev )
    528          {
   \                     USB_OTG_FlushRxFifo: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    529            USB_OTG_STS status = USB_OTG_OK;
   \   00000006   0x2500             MOVS     R5,#+0
    530            __IO USB_OTG_GRSTCTL_TypeDef  greset;
    531            uint32_t count = 0;
   \   00000008   0x2600             MOVS     R6,#+0
    532            
    533            greset.d32 = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9000             STR      R0,[SP, #+0]
    534            greset.b.rxfflsh = 1;
   \   0000000E   0x9800             LDR      R0,[SP, #+0]
   \   00000010   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000014   0x9000             STR      R0,[SP, #+0]
    535            USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x68E1             LDR      R1,[R4, #+12]
   \   0000001A   0x6108             STR      R0,[R1, #+16]
    536            do
    537            {
    538              greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
   \                     ??USB_OTG_FlushRxFifo_0: (+1)
   \   0000001C   0x68E0             LDR      R0,[R4, #+12]
   \   0000001E   0x6900             LDR      R0,[R0, #+16]
   \   00000020   0x9000             STR      R0,[SP, #+0]
    539              if (++count > 200000)
   \   00000022   0x1C76             ADDS     R6,R6,#+1
   \   00000024   0x....             LDR.N    R0,??DataTable3  ;; 0x30d41
   \   00000026   0x4286             CMP      R6,R0
   \   00000028   0xD204             BCS.N    ??USB_OTG_FlushRxFifo_1
    540              {
    541                break;
    542              }
    543            }
    544            while (greset.b.rxfflsh == 1);
   \                     ??USB_OTG_FlushRxFifo_2: (+1)
   \   0000002A   0x9800             LDR      R0,[SP, #+0]
   \   0000002C   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD1F3             BNE.N    ??USB_OTG_FlushRxFifo_0
    545            /* Wait for 3 PHY Clocks*/
    546            USB_OTG_BSP_uDelay(3);
   \                     ??USB_OTG_FlushRxFifo_1: (+1)
   \   00000034   0x2003             MOVS     R0,#+3
   \   00000036   0x.... 0x....      BL       USB_OTG_BSP_uDelay
    547            return status;
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    548          }
    549          
    550          
    551          /**
    552          * @brief  USB_OTG_SetCurrentMode : Set ID line
    553          * @param  pdev : Selected device
    554          * @param  mode :  (Host/device)
    555          * @retval USB_OTG_STS : status
    556          */

   \                                 In section .text, align 2, keep-with-next
    557          USB_OTG_STS USB_OTG_SetCurrentMode(USB_OTG_CORE_HANDLE *pdev , uint8_t mode)
    558          {
   \                     USB_OTG_SetCurrentMode: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    559            USB_OTG_STS status = USB_OTG_OK;
   \   00000006   0x2600             MOVS     R6,#+0
    560            USB_OTG_GUSBCFG_TypeDef  usbcfg;
    561            
    562            usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
   \   00000008   0x68E0             LDR      R0,[R4, #+12]
   \   0000000A   0x68C0             LDR      R0,[R0, #+12]
   \   0000000C   0x0007             MOVS     R7,R0
    563            
    564            usbcfg.b.force_host = 0;
   \   0000000E   0xF037 0x5700      BICS     R7,R7,#0x20000000
    565            usbcfg.b.force_dev = 0;
   \   00000012   0xF037 0x4780      BICS     R7,R7,#0x40000000
    566            
    567            if ( mode == HOST_MODE)
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x2D01             CMP      R5,#+1
   \   0000001A   0xD102             BNE.N    ??USB_OTG_SetCurrentMode_0
    568            {
    569              usbcfg.b.force_host = 1;
   \   0000001C   0xF057 0x5700      ORRS     R7,R7,#0x20000000
   \   00000020   0xE004             B.N      ??USB_OTG_SetCurrentMode_1
    570            }
    571            else if ( mode == DEVICE_MODE)
   \                     ??USB_OTG_SetCurrentMode_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD101             BNE.N    ??USB_OTG_SetCurrentMode_1
    572            {
    573              usbcfg.b.force_dev = 1;
   \   00000028   0xF057 0x4780      ORRS     R7,R7,#0x40000000
    574            }
    575            
    576            USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
   \                     ??USB_OTG_SetCurrentMode_1: (+1)
   \   0000002C   0x68E0             LDR      R0,[R4, #+12]
   \   0000002E   0x60C7             STR      R7,[R0, #+12]
    577            USB_OTG_BSP_mDelay(50);
   \   00000030   0x2032             MOVS     R0,#+50
   \   00000032   0x.... 0x....      BL       USB_OTG_BSP_mDelay
    578            return status;
   \   00000036   0x0030             MOVS     R0,R6
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    579          }
    580          
    581          
    582          /**
    583          * @brief  USB_OTG_GetMode : Get current mode
    584          * @param  pdev : Selected device
    585          * @retval current mode
    586          */

   \                                 In section .text, align 2, keep-with-next
    587          uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
    588          {
    589            return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
   \                     USB_OTG_GetMode: (+1)
   \   00000000   0x68C0             LDR      R0,[R0, #+12]
   \   00000002   0x6940             LDR      R0,[R0, #+20]
   \   00000004   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000008   0x4770             BX       LR               ;; return
    590          }
    591          
    592          
    593          /**
    594          * @brief  USB_OTG_IsDeviceMode : Check if it is device mode
    595          * @param  pdev : Selected device
    596          * @retval num_in_ep
    597          */

   \                                 In section .text, align 2, keep-with-next
    598          uint8_t USB_OTG_IsDeviceMode(USB_OTG_CORE_HANDLE *pdev)
    599          {
   \                     USB_OTG_IsDeviceMode: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    600            return (USB_OTG_GetMode(pdev) != HOST_MODE);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       USB_OTG_GetMode
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD001             BEQ.N    ??USB_OTG_IsDeviceMode_0
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE000             B.N      ??USB_OTG_IsDeviceMode_1
   \                     ??USB_OTG_IsDeviceMode_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \                     ??USB_OTG_IsDeviceMode_1: (+1)
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    601          }
    602          
    603          
    604          /**
    605          * @brief  USB_OTG_IsHostMode : Check if it is host mode
    606          * @param  pdev : Selected device
    607          * @retval num_in_ep
    608          */

   \                                 In section .text, align 2, keep-with-next
    609          uint8_t USB_OTG_IsHostMode(USB_OTG_CORE_HANDLE *pdev)
    610          {
   \                     USB_OTG_IsHostMode: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    611            return (USB_OTG_GetMode(pdev) == HOST_MODE);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       USB_OTG_GetMode
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??USB_OTG_IsHostMode_0
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE000             B.N      ??USB_OTG_IsHostMode_1
   \                     ??USB_OTG_IsHostMode_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \                     ??USB_OTG_IsHostMode_1: (+1)
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    612          }
    613          
    614          
    615          /**
    616          * @brief  USB_OTG_ReadCoreItr : returns the Core Interrupt register
    617          * @param  pdev : Selected device
    618          * @retval Status
    619          */

   \                                 In section .text, align 2, keep-with-next
    620          uint32_t USB_OTG_ReadCoreItr(USB_OTG_CORE_HANDLE *pdev)
    621          {
   \                     USB_OTG_ReadCoreItr: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    622            uint32_t v = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    623            v = USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS);
   \   00000004   0x68CA             LDR      R2,[R1, #+12]
   \   00000006   0x6952             LDR      R2,[R2, #+20]
   \   00000008   0x0010             MOVS     R0,R2
    624            v &= USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTMSK);
   \   0000000A   0x68CA             LDR      R2,[R1, #+12]
   \   0000000C   0x6992             LDR      R2,[R2, #+24]
   \   0000000E   0x4010             ANDS     R0,R2,R0
    625            return v;
   \   00000010   0x4770             BX       LR               ;; return
    626          }
    627          
    628          
    629          /**
    630          * @brief  USB_OTG_ReadOtgItr : returns the USB_OTG Interrupt register
    631          * @param  pdev : Selected device
    632          * @retval Status
    633          */

   \                                 In section .text, align 2, keep-with-next
    634          uint32_t USB_OTG_ReadOtgItr (USB_OTG_CORE_HANDLE *pdev)
    635          {
    636            return (USB_OTG_READ_REG32 (&pdev->regs.GREGS->GOTGINT));
   \                     USB_OTG_ReadOtgItr: (+1)
   \   00000000   0x68C0             LDR      R0,[R0, #+12]
   \   00000002   0x6840             LDR      R0,[R0, #+4]
   \   00000004   0x4770             BX       LR               ;; return
    637          }
    638          
    639          #ifdef USE_HOST_MODE
    640          /**
    641          * @brief  USB_OTG_CoreInitHost : Initializes USB_OTG controller for host mode
    642          * @param  pdev : Selected device
    643          * @retval status
    644          */
    645          USB_OTG_STS USB_OTG_CoreInitHost(USB_OTG_CORE_HANDLE *pdev)
    646          {
    647            USB_OTG_STS                     status = USB_OTG_OK;
    648            USB_OTG_FSIZ_TypeDef            nptxfifosize;
    649            USB_OTG_FSIZ_TypeDef            ptxfifosize;  
    650            USB_OTG_HCFG_TypeDef            hcfg;
    651            
    652          #ifdef USE_OTG_MODE
    653            USB_OTG_OTGCTL_TypeDef          gotgctl;
    654          #endif
    655            
    656            uint32_t                        i = 0;
    657            
    658            nptxfifosize.d32 = 0;  
    659            ptxfifosize.d32 = 0;
    660          #ifdef USE_OTG_MODE
    661            gotgctl.d32 = 0;
    662          #endif
    663            hcfg.d32 = 0;
    664            
    665            
    666            /* configure charge pump IO */
    667            USB_OTG_BSP_ConfigVBUS(pdev);
    668            
    669            /* Restart the Phy Clock */
    670            USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
    671            
    672            /* Initialize Host Configuration Register */
    673            USB_OTG_InitFSLSPClkSel(pdev , HCFG_48_MHZ); /* in init phase */
    674            
    675            hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
    676            hcfg.b.fslssupp = 0;
    677            USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HCFG, hcfg.d32);
    678            
    679            /* Configure data FIFO sizes */
    680            /* Rx FIFO */
    681          #ifdef USB_OTG_FS_CORE
    682            if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID)
    683            {
    684              /* set Rx FIFO size */
    685              USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
    686              nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;   
    687              nptxfifosize.b.depth = TXH_NP_FS_FIFOSIZ;  
    688              USB_OTG_WRITE_REG32(&pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32);
    689              
    690              ptxfifosize.b.startaddr = RX_FIFO_FS_SIZE + TXH_NP_FS_FIFOSIZ;
    691              ptxfifosize.b.depth     = TXH_P_FS_FIFOSIZ;
    692              USB_OTG_WRITE_REG32(&pdev->regs.GREGS->HPTXFSIZ, ptxfifosize.d32);      
    693            }
    694          #endif
    695          #ifdef USB_OTG_HS_CORE  
    696             if (pdev->cfg.coreID == USB_OTG_HS_CORE_ID)
    697            {
    698             /* set Rx FIFO size */
    699              USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_HS_SIZE);
    700              nptxfifosize.b.startaddr = RX_FIFO_HS_SIZE;   
    701              nptxfifosize.b.depth = TXH_NP_HS_FIFOSIZ;  
    702              USB_OTG_WRITE_REG32(&pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32);
    703              
    704              ptxfifosize.b.startaddr = RX_FIFO_HS_SIZE + TXH_NP_HS_FIFOSIZ;
    705              ptxfifosize.b.depth     = TXH_P_HS_FIFOSIZ;
    706              USB_OTG_WRITE_REG32(&pdev->regs.GREGS->HPTXFSIZ, ptxfifosize.d32);      
    707            }
    708          #endif  
    709            
    710          #ifdef USE_OTG_MODE
    711            /* Clear Host Set HNP Enable in the USB_OTG Control Register */
    712            gotgctl.b.hstsethnpen = 1;
    713            USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GOTGCTL, gotgctl.d32, 0);
    714          #endif
    715            
    716            /* Make sure the FIFOs are flushed. */
    717            USB_OTG_FlushTxFifo(pdev, 0x10 );         /* all Tx FIFOs */
    718            USB_OTG_FlushRxFifo(pdev);
    719            
    720            
    721            /* Clear all pending HC Interrupts */
    722            for (i = 0; i < pdev->cfg.host_channels; i++)
    723            {
    724              USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
    725              USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCGINTMSK, 0 );
    726            }
    727          #ifndef USE_OTG_MODE
    728            USB_OTG_DriveVbus(pdev, 1);
    729          #endif
    730            
    731            USB_OTG_EnableHostInt(pdev);
    732            return status;
    733          }
    734          
    735          /**
    736          * @brief  USB_OTG_IsEvenFrame 
    737          *         This function returns the frame number for sof packet
    738          * @param  pdev : Selected device
    739          * @retval Frame number
    740          */
    741          uint8_t USB_OTG_IsEvenFrame (USB_OTG_CORE_HANDLE *pdev) 
    742          {
    743            return !(USB_OTG_READ_REG32(&pdev->regs.HREGS->HFNUM) & 0x1);
    744          }
    745          
    746          /**
    747          * @brief  USB_OTG_DriveVbus : set/reset vbus
    748          * @param  pdev : Selected device
    749          * @param  state : VBUS state
    750          * @retval None
    751          */
    752          void USB_OTG_DriveVbus (USB_OTG_CORE_HANDLE *pdev, uint8_t state)
    753          {
    754            USB_OTG_HPRT0_TypeDef     hprt0;
    755            
    756            hprt0.d32 = 0;
    757            
    758            /* enable disable the external charge pump */
    759            USB_OTG_BSP_DriveVBUS(pdev, state);
    760            
    761            /* Turn on the Host port power. */
    762            hprt0.d32 = USB_OTG_ReadHPRT0(pdev);
    763            if ((hprt0.b.prtpwr == 0 ) && (state == 1 ))
    764            {
    765              hprt0.b.prtpwr = 1;
    766              USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
    767            }
    768            if ((hprt0.b.prtpwr == 1 ) && (state == 0 ))
    769            {
    770              hprt0.b.prtpwr = 0;
    771              USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
    772            }
    773            
    774            USB_OTG_BSP_mDelay(200);
    775          }
    776          /**
    777          * @brief  USB_OTG_EnableHostInt: Enables the Host mode interrupts
    778          * @param  pdev : Selected device
    779          * @retval USB_OTG_STS : status
    780          */
    781          USB_OTG_STS USB_OTG_EnableHostInt(USB_OTG_CORE_HANDLE *pdev)
    782          {
    783            USB_OTG_STS       status = USB_OTG_OK;
    784            USB_OTG_GINTMSK_TypeDef  intmsk;
    785            intmsk.d32 = 0;
    786            /* Disable all interrupts. */
    787            USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTMSK, 0);
    788            
    789            /* Clear any pending interrupts. */
    790            USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
    791            
    792            /* Enable the common interrupts */
    793            USB_OTG_EnableCommonInt(pdev);
    794            
    795            if (pdev->cfg.dma_enable == 0)
    796            {  
    797              intmsk.b.rxstsqlvl  = 1;
    798            }  
    799            intmsk.b.portintr   = 1;
    800            intmsk.b.hcintr     = 1;
    801            intmsk.b.disconnect = 1;  
    802            intmsk.b.sofintr    = 1;  
    803            intmsk.b.incomplisoout  = 1; 
    804            USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
    805            return status;
    806          }
    807          
    808          /**
    809          * @brief  USB_OTG_InitFSLSPClkSel : Initializes the FSLSPClkSel field of the 
    810          *         HCFG register on the PHY type
    811          * @param  pdev : Selected device
    812          * @param  freq : clock frequency
    813          * @retval None
    814          */
    815          void USB_OTG_InitFSLSPClkSel(USB_OTG_CORE_HANDLE *pdev , uint8_t freq)
    816          {
    817            USB_OTG_HCFG_TypeDef   hcfg;
    818            
    819            hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
    820            hcfg.b.fslspclksel = freq;
    821            USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HCFG, hcfg.d32);
    822          }
    823          
    824          
    825          /**
    826          * @brief  USB_OTG_ReadHPRT0 : Reads HPRT0 to modify later
    827          * @param  pdev : Selected device
    828          * @retval HPRT0 value
    829          */
    830          uint32_t USB_OTG_ReadHPRT0(USB_OTG_CORE_HANDLE *pdev)
    831          {
    832            USB_OTG_HPRT0_TypeDef  hprt0;
    833            
    834            hprt0.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
    835            hprt0.b.prtena = 0;
    836            hprt0.b.prtconndet = 0;
    837            hprt0.b.prtenchng = 0;
    838            hprt0.b.prtovrcurrchng = 0;
    839            return hprt0.d32;
    840          }
    841          
    842          
    843          /**
    844          * @brief  USB_OTG_ReadHostAllChannels_intr : Register PCD Callbacks
    845          * @param  pdev : Selected device
    846          * @retval Status
    847          */
    848          uint32_t USB_OTG_ReadHostAllChannels_intr (USB_OTG_CORE_HANDLE *pdev)
    849          {
    850            return (USB_OTG_READ_REG32 (&pdev->regs.HREGS->HAINT));
    851          }
    852          
    853          
    854          /**
    855          * @brief  USB_OTG_ResetPort : Reset Host Port
    856          * @param  pdev : Selected device
    857          * @retval status
    858          * @note : (1)The application must wait at least 10 ms (+ 10 ms security)
    859          *   before clearing the reset bit.
    860          */
    861          uint32_t USB_OTG_ResetPort(USB_OTG_CORE_HANDLE *pdev)
    862          {
    863            USB_OTG_HPRT0_TypeDef  hprt0;
    864            
    865            hprt0.d32 = USB_OTG_ReadHPRT0(pdev);
    866            hprt0.b.prtrst = 1;
    867            USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
    868            USB_OTG_BSP_mDelay (10);                                /* See Note #1 */
    869            hprt0.b.prtrst = 0;
    870            USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
    871            USB_OTG_BSP_mDelay (20);   
    872            return 1;
    873          }
    874          
    875          
    876          /**
    877          * @brief  USB_OTG_HC_Init : Prepares a host channel for transferring packets
    878          * @param  pdev : Selected device
    879          * @param  hc_num : channel number
    880          * @retval USB_OTG_STS : status
    881          */
    882          USB_OTG_STS USB_OTG_HC_Init(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
    883          {
    884            USB_OTG_STS status = USB_OTG_OK;
    885            uint32_t intr_enable = 0;
    886            USB_OTG_HCGINTMSK_TypeDef  hcintmsk;
    887            USB_OTG_GINTMSK_TypeDef    gintmsk;
    888            USB_OTG_HCCHAR_TypeDef     hcchar;
    889            USB_OTG_HCINTn_TypeDef     hcint;
    890            
    891            
    892            gintmsk.d32 = 0;
    893            hcintmsk.d32 = 0;
    894            hcchar.d32 = 0;
    895            
    896            /* Clear old interrupt conditions for this host channel. */
    897            hcint.d32 = 0xFFFFFFFF;
    898            USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCINT, hcint.d32);
    899            
    900            /* Enable channel interrupts required for this transfer. */
    901            hcintmsk.d32 = 0;
    902            
    903            if (pdev->cfg.dma_enable == 1)
    904            {
    905              hcintmsk.b.ahberr = 1;
    906            }
    907            
    908            switch (pdev->host.hc[hc_num].ep_type) 
    909            {
    910            case EP_TYPE_CTRL:
    911            case EP_TYPE_BULK:
    912              hcintmsk.b.xfercompl = 1;
    913              hcintmsk.b.stall = 1;
    914              hcintmsk.b.xacterr = 1;
    915              hcintmsk.b.datatglerr = 1;
    916              hcintmsk.b.nak = 1;  
    917              if (pdev->host.hc[hc_num].ep_is_in) 
    918              {
    919                hcintmsk.b.bblerr = 1;
    920              } 
    921              else 
    922              {
    923                hcintmsk.b.nyet = 1;
    924                if (pdev->host.hc[hc_num].do_ping) 
    925                {
    926                  hcintmsk.b.ack = 1;
    927                }
    928              }
    929              break;
    930            case EP_TYPE_INTR:
    931              hcintmsk.b.xfercompl = 1;
    932              hcintmsk.b.nak = 1;
    933              hcintmsk.b.stall = 1;
    934              hcintmsk.b.xacterr = 1;
    935              hcintmsk.b.datatglerr = 1;
    936              hcintmsk.b.frmovrun = 1;
    937              
    938              if (pdev->host.hc[hc_num].ep_is_in) 
    939              {
    940                hcintmsk.b.bblerr = 1;
    941              }
    942              
    943              break;
    944            case EP_TYPE_ISOC:
    945              hcintmsk.b.xfercompl = 1;
    946              hcintmsk.b.frmovrun = 1;
    947              hcintmsk.b.ack = 1;
    948              
    949              if (pdev->host.hc[hc_num].ep_is_in) 
    950              {
    951                hcintmsk.b.xacterr = 1;
    952                hcintmsk.b.bblerr = 1;
    953              }
    954              break;
    955            }
    956            
    957            
    958            USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCGINTMSK, hcintmsk.d32);
    959            
    960            
    961            /* Enable the top level host channel interrupt. */
    962            intr_enable = (1 << hc_num);
    963            USB_OTG_MODIFY_REG32(&pdev->regs.HREGS->HAINTMSK, 0, intr_enable);
    964            
    965            /* Make sure host channel interrupts are enabled. */
    966            gintmsk.b.hcintr = 1;
    967            USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, 0, gintmsk.d32);
    968            
    969            /* Program the HCCHAR register */
    970            hcchar.d32 = 0;
    971            hcchar.b.devaddr = pdev->host.hc[hc_num].dev_addr;
    972            hcchar.b.epnum   = pdev->host.hc[hc_num].ep_num;
    973            hcchar.b.epdir   = pdev->host.hc[hc_num].ep_is_in;
    974            hcchar.b.lspddev = (pdev->host.hc[hc_num].speed == HPRT0_PRTSPD_LOW_SPEED);
    975            hcchar.b.eptype  = pdev->host.hc[hc_num].ep_type;
    976            hcchar.b.mps     = pdev->host.hc[hc_num].max_packet;
    977            if (pdev->host.hc[hc_num].ep_type == HCCHAR_INTR)
    978            {
    979              hcchar.b.oddfrm  = 1;
    980            }
    981            USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
    982            return status;
    983          }
    984          
    985          
    986          /**
    987          * @brief  USB_OTG_HC_StartXfer : Start transfer
    988          * @param  pdev : Selected device
    989          * @param  hc_num : channel number
    990          * @retval USB_OTG_STS : status
    991          */
    992          USB_OTG_STS USB_OTG_HC_StartXfer(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
    993          {
    994            USB_OTG_STS status = USB_OTG_OK;
    995            USB_OTG_HCCHAR_TypeDef   hcchar;
    996            USB_OTG_HCTSIZn_TypeDef  hctsiz;
    997            USB_OTG_HNPTXSTS_TypeDef hnptxsts; 
    998            USB_OTG_HPTXSTS_TypeDef  hptxsts; 
    999            USB_OTG_GINTMSK_TypeDef  intmsk;
   1000            uint16_t                 len_words = 0;   
   1001            
   1002            uint16_t num_packets;
   1003            uint16_t max_hc_pkt_count;
   1004            
   1005            max_hc_pkt_count = 256;
   1006            hctsiz.d32 = 0;
   1007            hcchar.d32 = 0;
   1008            intmsk.d32 = 0;
   1009            
   1010            /* Compute the expected number of packets associated to the transfer */
   1011            if (pdev->host.hc[hc_num].xfer_len > 0)
   1012            {
   1013              num_packets = (pdev->host.hc[hc_num].xfer_len + \
   1014                pdev->host.hc[hc_num].max_packet - 1) / pdev->host.hc[hc_num].max_packet;
   1015              
   1016              if (num_packets > max_hc_pkt_count)
   1017              {
   1018                num_packets = max_hc_pkt_count;
   1019                pdev->host.hc[hc_num].xfer_len = num_packets * \
   1020                  pdev->host.hc[hc_num].max_packet;
   1021              }
   1022            }
   1023            else
   1024            {
   1025              num_packets = 1;
   1026            }
   1027            if (pdev->host.hc[hc_num].ep_is_in)
   1028            {
   1029              pdev->host.hc[hc_num].xfer_len = num_packets * \
   1030                pdev->host.hc[hc_num].max_packet;
   1031            }
   1032            /* Initialize the HCTSIZn register */
   1033            hctsiz.b.xfersize = pdev->host.hc[hc_num].xfer_len;
   1034            hctsiz.b.pktcnt = num_packets;
   1035            hctsiz.b.pid = pdev->host.hc[hc_num].data_pid;
   1036            USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
   1037            
   1038            if (pdev->cfg.dma_enable == 1)
   1039            {
   1040              USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCDMA, (unsigned int)pdev->host.hc[hc_num].xfer_buff);
   1041            }
   1042            
   1043            
   1044            hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
   1045            hcchar.b.oddfrm = USB_OTG_IsEvenFrame(pdev);
   1046            
   1047            /* Set host channel enable */
   1048            hcchar.b.chen = 1;
   1049            hcchar.b.chdis = 0;
   1050            USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
   1051          
   1052            if (pdev->cfg.dma_enable == 0) /* Slave mode */
   1053            {  
   1054              if((pdev->host.hc[hc_num].ep_is_in == 0) && 
   1055                  (pdev->host.hc[hc_num].xfer_len > 0))
   1056              {
   1057                switch(pdev->host.hc[hc_num].ep_type) 
   1058                {
   1059                  /* Non periodic transfer */
   1060                case EP_TYPE_CTRL:
   1061                case EP_TYPE_BULK:
   1062                  
   1063                  hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
   1064                  len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
   1065                  
   1066                  /* check if there is enough space in FIFO space */
   1067                  if(len_words > hnptxsts.b.nptxfspcavail)
   1068                  {
   1069                    /* need to process data in nptxfempty interrupt */
   1070                    intmsk.b.nptxfempty = 1;
   1071                    USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);  
   1072                  }
   1073                  
   1074                  break;
   1075                  /* Periodic transfer */
   1076                case EP_TYPE_INTR:
   1077                case EP_TYPE_ISOC:
   1078                  hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
   1079                  len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
   1080                  /* check if there is enough space in FIFO space */
   1081                  if(len_words > hptxsts.b.ptxfspcavail) /* split the transfer */
   1082                  {
   1083                    /* need to process data in ptxfempty interrupt */
   1084                    intmsk.b.ptxfempty = 1;
   1085                    USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);  
   1086                  }
   1087                  break;
   1088                  
   1089                default:
   1090                  break;
   1091                }
   1092                
   1093                /* Write packet into the Tx FIFO. */
   1094                USB_OTG_WritePacket(pdev, 
   1095                                    pdev->host.hc[hc_num].xfer_buff , 
   1096                                    hc_num, pdev->host.hc[hc_num].xfer_len);
   1097              }
   1098            }
   1099            return status;
   1100          }
   1101          
   1102          
   1103          /**
   1104          * @brief  USB_OTG_HC_Halt : Halt channel
   1105          * @param  pdev : Selected device
   1106          * @param  hc_num : channel number
   1107          * @retval USB_OTG_STS : status
   1108          */
   1109          USB_OTG_STS USB_OTG_HC_Halt(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
   1110          {
   1111            USB_OTG_STS status = USB_OTG_OK;
   1112            USB_OTG_HNPTXSTS_TypeDef            nptxsts;
   1113            USB_OTG_HPTXSTS_TypeDef             hptxsts;
   1114            USB_OTG_HCCHAR_TypeDef              hcchar;
   1115            
   1116            nptxsts.d32 = 0;
   1117            hptxsts.d32 = 0;
   1118            hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
   1119            hcchar.b.chen = 1;
   1120            hcchar.b.chdis = 1;
   1121            
   1122            /* Check for space in the request queue to issue the halt. */
   1123            if (hcchar.b.eptype == HCCHAR_CTRL || hcchar.b.eptype == HCCHAR_BULK)
   1124            {
   1125              nptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
   1126              if (nptxsts.b.nptxqspcavail == 0)
   1127              {
   1128                hcchar.b.chen = 0;
   1129              }
   1130            }
   1131            else
   1132            {
   1133              hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
   1134              if (hptxsts.b.ptxqspcavail == 0)
   1135              {
   1136                hcchar.b.chen = 0;
   1137              }
   1138            }
   1139            USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
   1140            return status;
   1141          }
   1142          
   1143          /**
   1144          * @brief  Issue a ping token
   1145          * @param  None
   1146          * @retval : None
   1147          */
   1148          USB_OTG_STS USB_OTG_HC_DoPing(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
   1149          {
   1150            USB_OTG_STS               status = USB_OTG_OK;
   1151            USB_OTG_HCCHAR_TypeDef    hcchar;
   1152            USB_OTG_HCTSIZn_TypeDef   hctsiz;  
   1153           
   1154            hctsiz.d32 = 0;
   1155            hctsiz.b.dopng = 1;
   1156            hctsiz.b.pktcnt = 1;
   1157            USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
   1158            
   1159            hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
   1160            hcchar.b.chen = 1;
   1161            hcchar.b.chdis = 0;
   1162            USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
   1163            return status;  
   1164          }
   1165          
   1166          /**
   1167          * @brief  Stop the device and clean up fifo's
   1168          * @param  None
   1169          * @retval : None
   1170          */
   1171          void USB_OTG_StopHost(USB_OTG_CORE_HANDLE *pdev)
   1172          {
   1173            USB_OTG_HCCHAR_TypeDef  hcchar;
   1174            uint32_t                i;
   1175            
   1176            USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINTMSK , 0);
   1177            USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINT,      0xFFFFFFFF);
   1178            /* Flush out any leftover queued requests. */
   1179            
   1180            for (i = 0; i < pdev->cfg.host_channels; i++)
   1181            {
   1182              hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
   1183              hcchar.b.chen = 0;
   1184              hcchar.b.chdis = 1;
   1185              hcchar.b.epdir = 0;
   1186              USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
   1187            }
   1188            
   1189            /* Flush the FIFO */
   1190            USB_OTG_FlushRxFifo(pdev);
   1191            USB_OTG_FlushTxFifo(pdev ,  0x10 );  
   1192          }
   1193          #endif
   1194          #ifdef USE_DEVICE_MODE
   1195          /*         PCD Core Layer       */
   1196          
   1197          /**
   1198          * @brief  USB_OTG_InitDevSpeed :Initializes the DevSpd field of DCFG register 
   1199          *         depending the PHY type and the enumeration speed of the device.
   1200          * @param  pdev : Selected device
   1201          * @retval : None
   1202          */

   \                                 In section .text, align 2, keep-with-next
   1203          void USB_OTG_InitDevSpeed(USB_OTG_CORE_HANDLE *pdev , uint8_t speed)
   1204          {
   1205            USB_OTG_DCFG_TypeDef   dcfg;
   1206            
   1207            dcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCFG);
   \                     USB_OTG_InitDevSpeed: (+1)
   \   00000000   0x6903             LDR      R3,[R0, #+16]
   \   00000002   0x681B             LDR      R3,[R3, #+0]
   \   00000004   0x001A             MOVS     R2,R3
   1208            dcfg.b.devspd = speed;
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0xF361 0x0201      BFI      R2,R1,#+0,#+2
   1209            USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCFG, dcfg.d32);
   \   0000000C   0x6903             LDR      R3,[R0, #+16]
   \   0000000E   0x601A             STR      R2,[R3, #+0]
   1210          }
   \   00000010   0x4770             BX       LR               ;; return
   1211          
   1212          
   1213          /**
   1214          * @brief  USB_OTG_CoreInitDev : Initializes the USB_OTG controller registers 
   1215          *         for device mode
   1216          * @param  pdev : Selected device
   1217          * @retval USB_OTG_STS : status
   1218          */

   \                                 In section .text, align 2, keep-with-next
   1219          USB_OTG_STS USB_OTG_CoreInitDev (USB_OTG_CORE_HANDLE *pdev)
   1220          {
   \                     USB_OTG_CoreInitDev: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   1221            USB_OTG_STS             status       = USB_OTG_OK;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1222            USB_OTG_DEPCTL_TypeDef  depctl;
   1223            uint32_t i;
   1224            USB_OTG_DCFG_TypeDef    dcfg;
   1225            USB_OTG_FSIZ_TypeDef    nptxfifosize;
   1226            USB_OTG_FSIZ_TypeDef    txfifosize;
   1227            USB_OTG_DIEPMSK_TypeDef msk;
   1228            USB_OTG_DTHRCTL_TypeDef dthrctl;  
   1229            
   1230            depctl.d32 = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x0005             MOVS     R5,R0
   1231            dcfg.d32 = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4681             MOV      R9,R0
   1232            nptxfifosize.d32 = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4682             MOV      R10,R0
   1233            txfifosize.d32 = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4683             MOV      R11,R0
   1234            msk.d32 = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x0007             MOVS     R7,R0
   1235            
   1236            /* Restart the Phy Clock */
   1237            USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xF8D4 0x110C      LDR      R1,[R4, #+268]
   \   00000026   0x6008             STR      R0,[R1, #+0]
   1238            /* Device configuration register */
   1239            dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
   \   00000028   0x6920             LDR      R0,[R4, #+16]
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x4681             MOV      R9,R0
   1240            dcfg.b.perfrint = DCFG_FRAME_INTERVAL_80;
   \   0000002E   0xF439 0x59C0      BICS     R9,R9,#0x1800
   1241            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DCFG, dcfg.d32 );
   \   00000032   0x6920             LDR      R0,[R4, #+16]
   \   00000034   0xF8C0 0x9000      STR      R9,[R0, #+0]
   1242            
   1243          #ifdef USB_OTG_FS_CORE
   1244            if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID  )
   \   00000038   0x7AE0             LDRB     R0,[R4, #+11]
   \   0000003A   0x2801             CMP      R0,#+1
   \   0000003C   0xD12B             BNE.N    ??USB_OTG_CoreInitDev_0
   1245            {  
   1246              
   1247              /* Set Full speed phy */
   1248              USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_FULL);
   \   0000003E   0x2103             MOVS     R1,#+3
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       USB_OTG_InitDevSpeed
   1249              
   1250              /* set Rx FIFO size */
   1251              USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
   \   00000046   0x2080             MOVS     R0,#+128
   \   00000048   0x68E1             LDR      R1,[R4, #+12]
   \   0000004A   0x6248             STR      R0,[R1, #+36]
   1252              
   1253              /* EP0 TX*/
   1254              nptxfifosize.b.depth     = TX0_FIFO_FS_SIZE;
   \   0000004C   0x2040             MOVS     R0,#+64
   \   0000004E   0xF360 0x4A1F      BFI      R10,R0,#+16,#+16
   1255              nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;
   \   00000052   0x2080             MOVS     R0,#+128
   \   00000054   0xF360 0x0A0F      BFI      R10,R0,#+0,#+16
   1256              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
   \   00000058   0x68E0             LDR      R0,[R4, #+12]
   \   0000005A   0xF8C0 0xA028      STR      R10,[R0, #+40]
   1257              
   1258              
   1259              /* EP1 TX*/
   1260              txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
   \   0000005E   0xEB1A 0x401A      ADDS     R0,R10,R10, LSR #+16
   \   00000062   0xF360 0x0B0F      BFI      R11,R0,#+0,#+16
   1261              txfifosize.b.depth = TX1_FIFO_FS_SIZE;
   \   00000066   0x2080             MOVS     R0,#+128
   \   00000068   0xF360 0x4B1F      BFI      R11,R0,#+16,#+16
   1262              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[0], txfifosize.d32 );
   \   0000006C   0x68E0             LDR      R0,[R4, #+12]
   \   0000006E   0xF8C0 0xB104      STR      R11,[R0, #+260]
   1263              
   1264              
   1265              /* EP2 TX*/
   1266              txfifosize.b.startaddr += txfifosize.b.depth;
   \   00000072   0xEB1B 0x401B      ADDS     R0,R11,R11, LSR #+16
   \   00000076   0xEAC0 0x0B0B      PKHBT    R11,R0,R11
   1267              txfifosize.b.depth = TX2_FIFO_FS_SIZE;
   \   0000007A   0xFA1F 0xFB8B      UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   1268              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[1], txfifosize.d32 );
   \   0000007E   0x68E0             LDR      R0,[R4, #+12]
   \   00000080   0xF8C0 0xB108      STR      R11,[R0, #+264]
   1269              
   1270              
   1271              /* EP3 TX*/  
   1272              txfifosize.b.startaddr += txfifosize.b.depth;
   \   00000084   0xEB1B 0x401B      ADDS     R0,R11,R11, LSR #+16
   \   00000088   0xEAC0 0x0B0B      PKHBT    R11,R0,R11
   1273              txfifosize.b.depth = TX3_FIFO_FS_SIZE;
   \   0000008C   0xFA1F 0xFB8B      UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   1274              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[2], txfifosize.d32 );
   \   00000090   0x68E0             LDR      R0,[R4, #+12]
   \   00000092   0xF8C0 0xB10C      STR      R11,[R0, #+268]
   1275            }
   1276          #endif
   1277          #ifdef USB_OTG_HS_CORE
   1278            if(pdev->cfg.coreID == USB_OTG_HS_CORE_ID  )
   1279            {
   1280              
   1281              /* Set High speed phy */
   1282              
   1283              if(pdev->cfg.phy_itface  == USB_OTG_ULPI_PHY)
   1284              {
   1285                 USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_HIGH);
   1286              }
   1287              else /* set High speed phy in Full speed mode */
   1288              {
   1289                USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_HIGH_IN_FULL);
   1290              }
   1291              
   1292              /* set Rx FIFO size */
   1293              USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_HS_SIZE);
   1294              
   1295              /* EP0 TX*/
   1296              nptxfifosize.b.depth     = TX0_FIFO_HS_SIZE;
   1297              nptxfifosize.b.startaddr = RX_FIFO_HS_SIZE;
   1298              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
   1299              
   1300              
   1301              /* EP1 TX*/
   1302              txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
   1303              txfifosize.b.depth = TX1_FIFO_HS_SIZE;
   1304              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[0], txfifosize.d32 );
   1305              
   1306              
   1307              /* EP2 TX*/
   1308              txfifosize.b.startaddr += txfifosize.b.depth;
   1309              txfifosize.b.depth = TX2_FIFO_HS_SIZE;
   1310              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[1], txfifosize.d32 );
   1311              
   1312              
   1313              /* EP3 TX*/  
   1314              txfifosize.b.startaddr += txfifosize.b.depth;
   1315              txfifosize.b.depth = TX3_FIFO_HS_SIZE;
   1316              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[2], txfifosize.d32 );
   1317              
   1318              /* EP4 TX*/
   1319              txfifosize.b.startaddr += txfifosize.b.depth;
   1320              txfifosize.b.depth = TX4_FIFO_HS_SIZE;
   1321              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[3], txfifosize.d32 );
   1322              
   1323              
   1324              /* EP5 TX*/  
   1325              txfifosize.b.startaddr += txfifosize.b.depth;
   1326              txfifosize.b.depth = TX5_FIFO_HS_SIZE;
   1327              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[4], txfifosize.d32 );
   1328            }
   1329          #endif  
   1330            /* Flush the FIFOs */
   1331            USB_OTG_FlushTxFifo(pdev , 0x10); /* all Tx FIFOs */
   \                     ??USB_OTG_CoreInitDev_0: (+1)
   \   00000096   0x2110             MOVS     R1,#+16
   \   00000098   0x0020             MOVS     R0,R4
   \   0000009A   0x.... 0x....      BL       USB_OTG_FlushTxFifo
   1332            USB_OTG_FlushRxFifo(pdev);
   \   0000009E   0x0020             MOVS     R0,R4
   \   000000A0   0x.... 0x....      BL       USB_OTG_FlushRxFifo
   1333            /* Clear all pending Device Interrupts */
   1334            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x6921             LDR      R1,[R4, #+16]
   \   000000A8   0x6108             STR      R0,[R1, #+16]
   1335            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x6921             LDR      R1,[R4, #+16]
   \   000000AE   0x6148             STR      R0,[R1, #+20]
   1336            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
   \   000000B0   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000B4   0x6921             LDR      R1,[R4, #+16]
   \   000000B6   0x6188             STR      R0,[R1, #+24]
   1337            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x6921             LDR      R1,[R4, #+16]
   \   000000BC   0x61C8             STR      R0,[R1, #+28]
   1338            
   1339            for (i = 0; i < pdev->cfg.dev_endpoints; i++)
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x0006             MOVS     R6,R0
   \                     ??USB_OTG_CoreInitDev_1: (+1)
   \   000000C2   0x7860             LDRB     R0,[R4, #+1]
   \   000000C4   0x4286             CMP      R6,R0
   \   000000C6   0xD220             BCS.N    ??USB_OTG_CoreInitDev_2
   1340            {
   1341              depctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[i]->DIEPCTL);
   \   000000C8   0xEB14 0x0086      ADDS     R0,R4,R6, LSL #+2
   \   000000CC   0x6980             LDR      R0,[R0, #+24]
   \   000000CE   0x6800             LDR      R0,[R0, #+0]
   \   000000D0   0x0005             MOVS     R5,R0
   1342              if (depctl.b.epena)
   \   000000D2   0x0FE8             LSRS     R0,R5,#+31
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD006             BEQ.N    ??USB_OTG_CoreInitDev_3
   1343              {
   1344                depctl.d32 = 0;
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0x0005             MOVS     R5,R0
   1345                depctl.b.epdis = 1;
   \   000000DC   0xF055 0x4580      ORRS     R5,R5,#0x40000000
   1346                depctl.b.snak = 1;
   \   000000E0   0xF055 0x6500      ORRS     R5,R5,#0x8000000
   \   000000E4   0xE001             B.N      ??USB_OTG_CoreInitDev_4
   1347              }
   1348              else
   1349              {
   1350                depctl.d32 = 0;
   \                     ??USB_OTG_CoreInitDev_3: (+1)
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0x0005             MOVS     R5,R0
   1351              }
   1352              USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPCTL, depctl.d32);
   \                     ??USB_OTG_CoreInitDev_4: (+1)
   \   000000EA   0xEB14 0x0086      ADDS     R0,R4,R6, LSL #+2
   \   000000EE   0x6980             LDR      R0,[R0, #+24]
   \   000000F0   0x6005             STR      R5,[R0, #+0]
   1353              USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPTSIZ, 0);
   \   000000F2   0xEB14 0x0086      ADDS     R0,R4,R6, LSL #+2
   \   000000F6   0x6980             LDR      R0,[R0, #+24]
   \   000000F8   0x2100             MOVS     R1,#+0
   \   000000FA   0x6101             STR      R1,[R0, #+16]
   1354              USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
   \   000000FC   0xEB14 0x0086      ADDS     R0,R4,R6, LSL #+2
   \   00000100   0x6980             LDR      R0,[R0, #+24]
   \   00000102   0x21FF             MOVS     R1,#+255
   \   00000104   0x6081             STR      R1,[R0, #+8]
   1355            }
   \   00000106   0x1C76             ADDS     R6,R6,#+1
   \   00000108   0xE7DB             B.N      ??USB_OTG_CoreInitDev_1
   1356            for (i = 0; i <  pdev->cfg.dev_endpoints; i++)
   \                     ??USB_OTG_CoreInitDev_2: (+1)
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0x0006             MOVS     R6,R0
   \                     ??USB_OTG_CoreInitDev_5: (+1)
   \   0000010E   0x7860             LDRB     R0,[R4, #+1]
   \   00000110   0x4286             CMP      R6,R0
   \   00000112   0xD220             BCS.N    ??USB_OTG_CoreInitDev_6
   1357            {
   1358              USB_OTG_DEPCTL_TypeDef  depctl;
   1359              depctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[i]->DOEPCTL);
   \   00000114   0xEB14 0x0186      ADDS     R1,R4,R6, LSL #+2
   \   00000118   0x6D49             LDR      R1,[R1, #+84]
   \   0000011A   0x6809             LDR      R1,[R1, #+0]
   \   0000011C   0x0008             MOVS     R0,R1
   1360              if (depctl.b.epena)
   \   0000011E   0x0FC1             LSRS     R1,R0,#+31
   \   00000120   0x2900             CMP      R1,#+0
   \   00000122   0xD006             BEQ.N    ??USB_OTG_CoreInitDev_7
   1361              {
   1362                depctl.d32 = 0;
   \   00000124   0x2100             MOVS     R1,#+0
   \   00000126   0x0008             MOVS     R0,R1
   1363                depctl.b.epdis = 1;
   \   00000128   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   1364                depctl.b.snak = 1;
   \   0000012C   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   00000130   0xE001             B.N      ??USB_OTG_CoreInitDev_8
   1365              }
   1366              else
   1367              {
   1368                depctl.d32 = 0;
   \                     ??USB_OTG_CoreInitDev_7: (+1)
   \   00000132   0x2100             MOVS     R1,#+0
   \   00000134   0x0008             MOVS     R0,R1
   1369              }
   1370              USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPCTL, depctl.d32);
   \                     ??USB_OTG_CoreInitDev_8: (+1)
   \   00000136   0xEB14 0x0186      ADDS     R1,R4,R6, LSL #+2
   \   0000013A   0x6D49             LDR      R1,[R1, #+84]
   \   0000013C   0x6008             STR      R0,[R1, #+0]
   1371              USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPTSIZ, 0);
   \   0000013E   0xEB14 0x0186      ADDS     R1,R4,R6, LSL #+2
   \   00000142   0x6D49             LDR      R1,[R1, #+84]
   \   00000144   0x2200             MOVS     R2,#+0
   \   00000146   0x610A             STR      R2,[R1, #+16]
   1372              USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
   \   00000148   0xEB14 0x0186      ADDS     R1,R4,R6, LSL #+2
   \   0000014C   0x6D49             LDR      R1,[R1, #+84]
   \   0000014E   0x22FF             MOVS     R2,#+255
   \   00000150   0x608A             STR      R2,[R1, #+8]
   1373            }
   \   00000152   0x1C76             ADDS     R6,R6,#+1
   \   00000154   0xE7DB             B.N      ??USB_OTG_CoreInitDev_5
   1374            msk.d32 = 0;
   \                     ??USB_OTG_CoreInitDev_6: (+1)
   \   00000156   0x2000             MOVS     R0,#+0
   \   00000158   0x0007             MOVS     R7,R0
   1375            msk.b.txfifoundrn = 1;
   \   0000015A   0xF457 0x7780      ORRS     R7,R7,#0x100
   1376            USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPMSK, msk.d32, msk.d32);
   \   0000015E   0x6920             LDR      R0,[R4, #+16]
   \   00000160   0x6900             LDR      R0,[R0, #+16]
   \   00000162   0x43B8             BICS     R0,R0,R7
   \   00000164   0x4338             ORRS     R0,R7,R0
   \   00000166   0x6921             LDR      R1,[R4, #+16]
   \   00000168   0x6108             STR      R0,[R1, #+16]
   1377            
   1378            if (pdev->cfg.dma_enable == 1)
   \   0000016A   0x78E0             LDRB     R0,[R4, #+3]
   \   0000016C   0x2801             CMP      R0,#+1
   \   0000016E   0xD110             BNE.N    ??USB_OTG_CoreInitDev_9
   1379            {
   1380              dthrctl.d32 = 0;
   \   00000170   0x2000             MOVS     R0,#+0
   \   00000172   0x4680             MOV      R8,R0
   1381              dthrctl.b.non_iso_thr_en = 1;
   \   00000174   0xF058 0x0801      ORRS     R8,R8,#0x1
   1382              dthrctl.b.iso_thr_en = 1;
   \   00000178   0xF058 0x0802      ORRS     R8,R8,#0x2
   1383              dthrctl.b.tx_thr_len = 64;
   \   0000017C   0x2040             MOVS     R0,#+64
   \   0000017E   0xF360 0x088A      BFI      R8,R0,#+2,#+9
   1384              dthrctl.b.rx_thr_en = 1;
   \   00000182   0xF458 0x3880      ORRS     R8,R8,#0x10000
   1385              dthrctl.b.rx_thr_len = 64;
   \   00000186   0x2040             MOVS     R0,#+64
   \   00000188   0xF360 0x4859      BFI      R8,R0,#+17,#+9
   1386              USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DTHRCTL, dthrctl.d32);  
   \   0000018C   0x6920             LDR      R0,[R4, #+16]
   \   0000018E   0xF8C0 0x8030      STR      R8,[R0, #+48]
   1387            }
   1388            USB_OTG_EnableDevInt(pdev);
   \                     ??USB_OTG_CoreInitDev_9: (+1)
   \   00000192   0x0020             MOVS     R0,R4
   \   00000194   0x.... 0x....      BL       USB_OTG_EnableDevInt
   1389            return status;
   \   00000198   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000019C   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1390          }
   1391          
   1392          
   1393          /**
   1394          * @brief  USB_OTG_EnableDevInt : Enables the Device mode interrupts
   1395          * @param  pdev : Selected device
   1396          * @retval USB_OTG_STS : status
   1397          */

   \                                 In section .text, align 2, keep-with-next
   1398          USB_OTG_STS USB_OTG_EnableDevInt(USB_OTG_CORE_HANDLE *pdev)
   1399          {
   \                     USB_OTG_EnableDevInt: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1400            USB_OTG_STS status = USB_OTG_OK;
   \   00000004   0x2500             MOVS     R5,#+0
   1401            USB_OTG_GINTMSK_TypeDef  intmsk;
   1402            
   1403            intmsk.d32 = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x0006             MOVS     R6,R0
   1404            
   1405            /* Disable all interrupts. */
   1406            USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, 0);
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x68E1             LDR      R1,[R4, #+12]
   \   0000000E   0x6188             STR      R0,[R1, #+24]
   1407            /* Clear any pending interrupts */
   1408            USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
   \   00000010   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000014   0x68E1             LDR      R1,[R4, #+12]
   \   00000016   0x6148             STR      R0,[R1, #+20]
   1409            /* Enable the common interrupts */
   1410            USB_OTG_EnableCommonInt(pdev);
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       USB_OTG_EnableCommonInt
   1411            
   1412            if (pdev->cfg.dma_enable == 0)
   \   0000001E   0x78E0             LDRB     R0,[R4, #+3]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD101             BNE.N    ??USB_OTG_EnableDevInt_0
   1413            {
   1414              intmsk.b.rxstsqlvl = 1;
   \   00000024   0xF056 0x0610      ORRS     R6,R6,#0x10
   1415            }
   1416            
   1417            /* Enable interrupts matching to the Device mode ONLY */
   1418            intmsk.b.usbsuspend = 1;
   \                     ??USB_OTG_EnableDevInt_0: (+1)
   \   00000028   0xF456 0x6600      ORRS     R6,R6,#0x800
   1419            intmsk.b.usbreset   = 1;
   \   0000002C   0xF456 0x5680      ORRS     R6,R6,#0x1000
   1420            intmsk.b.enumdone   = 1;
   \   00000030   0xF456 0x5600      ORRS     R6,R6,#0x2000
   1421            intmsk.b.inepintr   = 1;
   \   00000034   0xF456 0x2680      ORRS     R6,R6,#0x40000
   1422            intmsk.b.outepintr  = 1;
   \   00000038   0xF456 0x2600      ORRS     R6,R6,#0x80000
   1423            intmsk.b.sofintr    = 1; 
   \   0000003C   0xF056 0x0608      ORRS     R6,R6,#0x8
   1424          
   1425            intmsk.b.incomplisoin    = 1; 
   \   00000040   0xF456 0x1680      ORRS     R6,R6,#0x100000
   1426            intmsk.b.incomplisoout    = 1;   
   \   00000044   0xF456 0x1600      ORRS     R6,R6,#0x200000
   1427          #ifdef VBUS_SENSING_ENABLED
   1428            intmsk.b.sessreqintr    = 1; 
   1429            intmsk.b.otgintr    = 1;    
   1430          #endif  
   1431            USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
   \   00000048   0x68E0             LDR      R0,[R4, #+12]
   \   0000004A   0x6980             LDR      R0,[R0, #+24]
   \   0000004C   0x43B0             BICS     R0,R0,R6
   \   0000004E   0x4330             ORRS     R0,R6,R0
   \   00000050   0x68E1             LDR      R1,[R4, #+12]
   \   00000052   0x6188             STR      R0,[R1, #+24]
   1432            return status;
   \   00000054   0x0028             MOVS     R0,R5
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000058   0xBD70             POP      {R4-R6,PC}       ;; return
   1433          }
   1434          
   1435          
   1436          /**
   1437          * @brief  USB_OTG_GetDeviceSpeed
   1438          *         Get the device speed from the device status register
   1439          * @param  None
   1440          * @retval status
   1441          */

   \                                 In section .text, align 2, keep-with-next
   1442          enum USB_OTG_SPEED USB_OTG_GetDeviceSpeed (USB_OTG_CORE_HANDLE *pdev)
   1443          {
   \                     USB_OTG_GetDeviceSpeed: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1444            USB_OTG_DSTS_TypeDef  dsts;
   1445            enum USB_OTG_SPEED speed = USB_SPEED_UNKNOWN;
   \   00000002   0x2000             MOVS     R0,#+0
   1446            
   1447            
   1448            dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
   \   00000004   0x690B             LDR      R3,[R1, #+16]
   \   00000006   0x689B             LDR      R3,[R3, #+8]
   \   00000008   0x001A             MOVS     R2,R3
   1449            
   1450            switch (dsts.b.enumspd)
   \   0000000A   0x0853             LSRS     R3,R2,#+1
   \   0000000C   0xF013 0x0303      ANDS     R3,R3,#0x3
   \   00000010   0x2B00             CMP      R3,#+0
   \   00000012   0xD005             BEQ.N    ??USB_OTG_GetDeviceSpeed_0
   \   00000014   0x2B02             CMP      R3,#+2
   \   00000016   0xD009             BEQ.N    ??USB_OTG_GetDeviceSpeed_1
   \   00000018   0xD305             BCC.N    ??USB_OTG_GetDeviceSpeed_2
   \   0000001A   0x2B03             CMP      R3,#+3
   \   0000001C   0xD003             BEQ.N    ??USB_OTG_GetDeviceSpeed_2
   \   0000001E   0xE007             B.N      ??USB_OTG_GetDeviceSpeed_3
   1451            {
   1452            case DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ:
   1453              speed = USB_SPEED_HIGH;
   \                     ??USB_OTG_GetDeviceSpeed_0: (+1)
   \   00000020   0x2303             MOVS     R3,#+3
   \   00000022   0x0018             MOVS     R0,R3
   1454              break;
   \   00000024   0xE004             B.N      ??USB_OTG_GetDeviceSpeed_3
   1455            case DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
   1456            case DSTS_ENUMSPD_FS_PHY_48MHZ:
   1457              speed = USB_SPEED_FULL;
   \                     ??USB_OTG_GetDeviceSpeed_2: (+1)
   \   00000026   0x2302             MOVS     R3,#+2
   \   00000028   0x0018             MOVS     R0,R3
   1458              break;
   \   0000002A   0xE001             B.N      ??USB_OTG_GetDeviceSpeed_3
   1459              
   1460            case DSTS_ENUMSPD_LS_PHY_6MHZ:
   1461              speed = USB_SPEED_LOW;
   \                     ??USB_OTG_GetDeviceSpeed_1: (+1)
   \   0000002C   0x2301             MOVS     R3,#+1
   \   0000002E   0x0018             MOVS     R0,R3
   1462              break;
   1463            }
   1464            
   1465            return speed;
   \                     ??USB_OTG_GetDeviceSpeed_3: (+1)
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x4770             BX       LR               ;; return
   1466          }
   1467          /**
   1468          * @brief  enables EP0 OUT to receive SETUP packets and configures EP0
   1469          *   for transmitting packets
   1470          * @param  None
   1471          * @retval USB_OTG_STS : status
   1472          */

   \                                 In section .text, align 2, keep-with-next
   1473          USB_OTG_STS  USB_OTG_EP0Activate(USB_OTG_CORE_HANDLE *pdev)
   1474          {
   \                     USB_OTG_EP0Activate: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0001             MOVS     R1,R0
   1475            USB_OTG_STS             status = USB_OTG_OK;
   \   00000004   0x2000             MOVS     R0,#+0
   1476            USB_OTG_DSTS_TypeDef    dsts;
   1477            USB_OTG_DEPCTL_TypeDef  diepctl;
   1478            USB_OTG_DCTL_TypeDef    dctl;
   1479            
   1480            dctl.d32 = 0;
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0x002C             MOVS     R4,R5
   1481            /* Read the Device Status and Endpoint 0 Control registers */
   1482            dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
   \   0000000A   0x690D             LDR      R5,[R1, #+16]
   \   0000000C   0x68AD             LDR      R5,[R5, #+8]
   \   0000000E   0x002A             MOVS     R2,R5
   1483            diepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL);
   \   00000010   0x698D             LDR      R5,[R1, #+24]
   \   00000012   0x682D             LDR      R5,[R5, #+0]
   \   00000014   0x002B             MOVS     R3,R5
   1484            /* Set the MPS of the IN EP based on the enumeration speed */
   1485            switch (dsts.b.enumspd)
   \   00000016   0x0855             LSRS     R5,R2,#+1
   \   00000018   0xF015 0x0503      ANDS     R5,R5,#0x3
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD004             BEQ.N    ??USB_OTG_EP0Activate_0
   \   00000020   0x2D02             CMP      R5,#+2
   \   00000022   0xD005             BEQ.N    ??USB_OTG_EP0Activate_1
   \   00000024   0xD301             BCC.N    ??USB_OTG_EP0Activate_0
   \   00000026   0x2D03             CMP      R5,#+3
   \   00000028   0xD105             BNE.N    ??USB_OTG_EP0Activate_2
   1486            {
   1487            case DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ:
   1488            case DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
   1489            case DSTS_ENUMSPD_FS_PHY_48MHZ:
   1490              diepctl.b.mps = DEP0CTL_MPS_64;
   \                     ??USB_OTG_EP0Activate_0: (+1)
   \   0000002A   0x0ADB             LSRS     R3,R3,#+11
   \   0000002C   0x02DB             LSLS     R3,R3,#+11
   1491              break;
   \   0000002E   0xE002             B.N      ??USB_OTG_EP0Activate_2
   1492            case DSTS_ENUMSPD_LS_PHY_6MHZ:
   1493              diepctl.b.mps = DEP0CTL_MPS_8;
   \                     ??USB_OTG_EP0Activate_1: (+1)
   \   00000030   0x2503             MOVS     R5,#+3
   \   00000032   0xF365 0x030A      BFI      R3,R5,#+0,#+11
   1494              break;
   1495            }
   1496            USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL, diepctl.d32);
   \                     ??USB_OTG_EP0Activate_2: (+1)
   \   00000036   0x698D             LDR      R5,[R1, #+24]
   \   00000038   0x602B             STR      R3,[R5, #+0]
   1497            dctl.b.cgnpinnak = 1;
   \   0000003A   0xF454 0x7480      ORRS     R4,R4,#0x100
   1498            USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, dctl.d32);
   \   0000003E   0x690D             LDR      R5,[R1, #+16]
   \   00000040   0x686D             LDR      R5,[R5, #+4]
   \   00000042   0x43A5             BICS     R5,R5,R4
   \   00000044   0x4325             ORRS     R5,R4,R5
   \   00000046   0x690E             LDR      R6,[R1, #+16]
   \   00000048   0x6075             STR      R5,[R6, #+4]
   1499            return status;
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0xBC70             POP      {R4-R6}
   \   0000004E   0x4770             BX       LR               ;; return
   1500          }
   1501          
   1502          
   1503          /**
   1504          * @brief  USB_OTG_EPActivate : Activates an EP
   1505          * @param  pdev : Selected device
   1506          * @retval USB_OTG_STS : status
   1507          */

   \                                 In section .text, align 2, keep-with-next
   1508          USB_OTG_STS USB_OTG_EPActivate(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
   1509          {
   \                     USB_OTG_EPActivate: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0002             MOVS     R2,R0
   1510            USB_OTG_STS status = USB_OTG_OK;
   \   00000004   0x2000             MOVS     R0,#+0
   1511            USB_OTG_DEPCTL_TypeDef  depctl;
   1512            USB_OTG_DAINT_TypeDef  daintmsk;
   1513            __IO uint32_t *addr;
   1514            
   1515            
   1516            depctl.d32 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x0033             MOVS     R3,R6
   1517            daintmsk.d32 = 0;
   \   0000000A   0x2600             MOVS     R6,#+0
   \   0000000C   0x0034             MOVS     R4,R6
   1518            /* Read DEPCTLn register */
   1519            if (ep->is_in == 1)
   \   0000000E   0x784E             LDRB     R6,[R1, #+1]
   \   00000010   0x2E01             CMP      R6,#+1
   \   00000012   0xD10B             BNE.N    ??USB_OTG_EPActivate_0
   1520            {
   1521              addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
   \   00000014   0x780E             LDRB     R6,[R1, #+0]
   \   00000016   0xEB12 0x0686      ADDS     R6,R2,R6, LSL #+2
   \   0000001A   0x69B6             LDR      R6,[R6, #+24]
   \   0000001C   0x0035             MOVS     R5,R6
   1522              daintmsk.ep.in = 1 << ep->num;
   \   0000001E   0x2601             MOVS     R6,#+1
   \   00000020   0xF991 0x7000      LDRSB    R7,[R1, #+0]
   \   00000024   0x40BE             LSLS     R6,R6,R7
   \   00000026   0xF366 0x040F      BFI      R4,R6,#+0,#+16
   \   0000002A   0xE00A             B.N      ??USB_OTG_EPActivate_1
   1523            }
   1524            else
   1525            {
   1526              addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
   \                     ??USB_OTG_EPActivate_0: (+1)
   \   0000002C   0x780E             LDRB     R6,[R1, #+0]
   \   0000002E   0xEB12 0x0686      ADDS     R6,R2,R6, LSL #+2
   \   00000032   0x6D76             LDR      R6,[R6, #+84]
   \   00000034   0x0035             MOVS     R5,R6
   1527              daintmsk.ep.out = 1 << ep->num;
   \   00000036   0x2601             MOVS     R6,#+1
   \   00000038   0xF991 0x7000      LDRSB    R7,[R1, #+0]
   \   0000003C   0x40BE             LSLS     R6,R6,R7
   \   0000003E   0xF366 0x441F      BFI      R4,R6,#+16,#+16
   1528            }
   1529            /* If the EP is already active don't change the EP Control
   1530            * register. */
   1531            depctl.d32 = USB_OTG_READ_REG32(addr);
   \                     ??USB_OTG_EPActivate_1: (+1)
   \   00000042   0x682E             LDR      R6,[R5, #+0]
   \   00000044   0x0033             MOVS     R3,R6
   1532            if (!depctl.b.usbactep)
   \   00000046   0xF3C3 0x36C0      UBFX     R6,R3,#+15,#+1
   \   0000004A   0x2E00             CMP      R6,#+0
   \   0000004C   0xD10D             BNE.N    ??USB_OTG_EPActivate_2
   1533            {
   1534              depctl.b.mps    = ep->maxpacket;
   \   0000004E   0x688E             LDR      R6,[R1, #+8]
   \   00000050   0xF366 0x030A      BFI      R3,R6,#+0,#+11
   1535              depctl.b.eptype = ep->type;
   \   00000054   0x78CE             LDRB     R6,[R1, #+3]
   \   00000056   0xF366 0x4393      BFI      R3,R6,#+18,#+2
   1536              depctl.b.txfnum = ep->tx_fifo_num;
   \   0000005A   0x88CE             LDRH     R6,[R1, #+6]
   \   0000005C   0xF366 0x5399      BFI      R3,R6,#+22,#+4
   1537              depctl.b.setd0pid = 1;
   \   00000060   0xF053 0x5380      ORRS     R3,R3,#0x10000000
   1538              depctl.b.usbactep = 1;
   \   00000064   0xF453 0x4300      ORRS     R3,R3,#0x8000
   1539              USB_OTG_WRITE_REG32(addr, depctl.d32);
   \   00000068   0x602B             STR      R3,[R5, #+0]
   1540            }
   1541            /* Enable the Interrupt for this EP */
   1542          #ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED
   1543            if((ep->num == 1)&&(pdev->cfg.coreID == USB_OTG_HS_CORE_ID))
   1544            {
   1545              USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, 0, daintmsk.d32);
   1546            }
   1547            else
   1548          #endif   
   1549              USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, 0, daintmsk.d32);
   \                     ??USB_OTG_EPActivate_2: (+1)
   \   0000006A   0x6916             LDR      R6,[R2, #+16]
   \   0000006C   0x69F6             LDR      R6,[R6, #+28]
   \   0000006E   0x4326             ORRS     R6,R4,R6
   \   00000070   0x6917             LDR      R7,[R2, #+16]
   \   00000072   0x61FE             STR      R6,[R7, #+28]
   1550            return status;
   \   00000074   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000076   0xBCF0             POP      {R4-R7}
   \   00000078   0x4770             BX       LR               ;; return
   1551          }
   1552          
   1553          
   1554          /**
   1555          * @brief  USB_OTG_EPDeactivate : Deactivates an EP
   1556          * @param  pdev : Selected device
   1557          * @retval USB_OTG_STS : status
   1558          */

   \                                 In section .text, align 2, keep-with-next
   1559          USB_OTG_STS USB_OTG_EPDeactivate(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
   1560          {
   \                     USB_OTG_EPDeactivate: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0002             MOVS     R2,R0
   1561            USB_OTG_STS status = USB_OTG_OK;
   \   00000004   0x2000             MOVS     R0,#+0
   1562            USB_OTG_DEPCTL_TypeDef  depctl;
   1563            USB_OTG_DAINT_TypeDef  daintmsk;
   1564            __IO uint32_t *addr;
   1565            
   1566            depctl.d32 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x0033             MOVS     R3,R6
   1567            daintmsk.d32 = 0;  
   \   0000000A   0x2600             MOVS     R6,#+0
   \   0000000C   0x0034             MOVS     R4,R6
   1568            /* Read DEPCTLn register */
   1569            if (ep->is_in == 1)
   \   0000000E   0x784E             LDRB     R6,[R1, #+1]
   \   00000010   0x2E01             CMP      R6,#+1
   \   00000012   0xD10B             BNE.N    ??USB_OTG_EPDeactivate_0
   1570            {
   1571              addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
   \   00000014   0x780E             LDRB     R6,[R1, #+0]
   \   00000016   0xEB12 0x0686      ADDS     R6,R2,R6, LSL #+2
   \   0000001A   0x69B6             LDR      R6,[R6, #+24]
   \   0000001C   0x0035             MOVS     R5,R6
   1572              daintmsk.ep.in = 1 << ep->num;
   \   0000001E   0x2601             MOVS     R6,#+1
   \   00000020   0xF991 0x7000      LDRSB    R7,[R1, #+0]
   \   00000024   0x40BE             LSLS     R6,R6,R7
   \   00000026   0xF366 0x040F      BFI      R4,R6,#+0,#+16
   \   0000002A   0xE00A             B.N      ??USB_OTG_EPDeactivate_1
   1573            }
   1574            else
   1575            {
   1576              addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
   \                     ??USB_OTG_EPDeactivate_0: (+1)
   \   0000002C   0x780E             LDRB     R6,[R1, #+0]
   \   0000002E   0xEB12 0x0686      ADDS     R6,R2,R6, LSL #+2
   \   00000032   0x6D76             LDR      R6,[R6, #+84]
   \   00000034   0x0035             MOVS     R5,R6
   1577              daintmsk.ep.out = 1 << ep->num;
   \   00000036   0x2601             MOVS     R6,#+1
   \   00000038   0xF991 0x7000      LDRSB    R7,[R1, #+0]
   \   0000003C   0x40BE             LSLS     R6,R6,R7
   \   0000003E   0xF366 0x441F      BFI      R4,R6,#+16,#+16
   1578            }
   1579            depctl.b.usbactep = 0;
   \                     ??USB_OTG_EPDeactivate_1: (+1)
   \   00000042   0xF433 0x4300      BICS     R3,R3,#0x8000
   1580            USB_OTG_WRITE_REG32(addr, depctl.d32);
   \   00000046   0x602B             STR      R3,[R5, #+0]
   1581            /* Disable the Interrupt for this EP */
   1582            
   1583          #ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED
   1584            if((ep->num == 1)&&(pdev->cfg.coreID == USB_OTG_HS_CORE_ID))
   1585            {
   1586              USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, daintmsk.d32, 0);
   1587            }
   1588            else
   1589          #endif    
   1590              USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, daintmsk.d32, 0);
   \   00000048   0x6916             LDR      R6,[R2, #+16]
   \   0000004A   0x69F6             LDR      R6,[R6, #+28]
   \   0000004C   0x43A6             BICS     R6,R6,R4
   \   0000004E   0x6917             LDR      R7,[R2, #+16]
   \   00000050   0x61FE             STR      R6,[R7, #+28]
   1591            return status;
   \   00000052   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000054   0xBCF0             POP      {R4-R7}
   \   00000056   0x4770             BX       LR               ;; return
   1592          }
   1593          
   1594          
   1595          /**
   1596          * @brief  USB_OTG_EPStartXfer : Handle the setup for data xfer for an EP and 
   1597          *         starts the xfer
   1598          * @param  pdev : Selected device
   1599          * @retval USB_OTG_STS : status
   1600          */

   \                                 In section .text, align 2, keep-with-next
   1601          USB_OTG_STS USB_OTG_EPStartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
   1602          {
   \                     USB_OTG_EPStartXfer: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1603            USB_OTG_STS status = USB_OTG_OK;
   \   00000008   0x2600             MOVS     R6,#+0
   1604            USB_OTG_DEPCTL_TypeDef     depctl;
   1605            USB_OTG_DEPXFRSIZ_TypeDef  deptsiz;
   1606            USB_OTG_DSTS_TypeDef       dsts;    
   1607            uint32_t fifoemptymsk = 0;  
   \   0000000A   0xF05F 0x0900      MOVS     R9,#+0
   1608            
   1609            depctl.d32 = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x0007             MOVS     R7,R0
   1610            deptsiz.d32 = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x4682             MOV      R10,R0
   1611            /* IN endpoint */
   1612            if (ep->is_in == 1)
   \   00000016   0x7868             LDRB     R0,[R5, #+1]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD16B             BNE.N    ??USB_OTG_EPStartXfer_0
   1613            {
   1614              depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPCTL));
   \   0000001C   0x7828             LDRB     R0,[R5, #+0]
   \   0000001E   0xEB14 0x0080      ADDS     R0,R4,R0, LSL #+2
   \   00000022   0x6980             LDR      R0,[R0, #+24]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x0007             MOVS     R7,R0
   1615              deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ));
   \   00000028   0x7828             LDRB     R0,[R5, #+0]
   \   0000002A   0xEB14 0x0080      ADDS     R0,R4,R0, LSL #+2
   \   0000002E   0x6980             LDR      R0,[R0, #+24]
   \   00000030   0x6900             LDR      R0,[R0, #+16]
   \   00000032   0x4682             MOV      R10,R0
   1616              /* Zero Length Packet? */
   1617              if (ep->xfer_len == 0)
   \   00000034   0x6968             LDR      R0,[R5, #+20]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD107             BNE.N    ??USB_OTG_EPStartXfer_1
   1618              {
   1619                deptsiz.b.xfersize = 0;
   \   0000003A   0xEA5F 0x4ADA      LSRS     R10,R10,#+19
   \   0000003E   0xEA5F 0x4ACA      LSLS     R10,R10,#+19
   1620                deptsiz.b.pktcnt = 1;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xF360 0x4ADC      BFI      R10,R0,#+19,#+10
   \   00000048   0xE011             B.N      ??USB_OTG_EPStartXfer_2
   1621              }
   1622              else
   1623              {
   1624                /* Program the transfer size and packet count
   1625                * as follows: xfersize = N * maxpacket +
   1626                * short_packet pktcnt = N + (short_packet
   1627                * exist ? 1 : 0)
   1628                */
   1629                deptsiz.b.xfersize = ep->xfer_len;
   \                     ??USB_OTG_EPStartXfer_1: (+1)
   \   0000004A   0x6968             LDR      R0,[R5, #+20]
   \   0000004C   0xF360 0x0A12      BFI      R10,R0,#+0,#+19
   1630                deptsiz.b.pktcnt = (ep->xfer_len - 1 + ep->maxpacket) / ep->maxpacket;
   \   00000050   0x6968             LDR      R0,[R5, #+20]
   \   00000052   0x68A9             LDR      R1,[R5, #+8]
   \   00000054   0x1808             ADDS     R0,R1,R0
   \   00000056   0x1E40             SUBS     R0,R0,#+1
   \   00000058   0x68A9             LDR      R1,[R5, #+8]
   \   0000005A   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000005E   0xF360 0x4ADC      BFI      R10,R0,#+19,#+10
   1631          
   1632                if (ep->type == EP_TYPE_ISOC)
   \   00000062   0x78E8             LDRB     R0,[R5, #+3]
   \   00000064   0x2801             CMP      R0,#+1
   \   00000066   0xD102             BNE.N    ??USB_OTG_EPStartXfer_2
   1633                {
   1634                  deptsiz.b.mc = 1;
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0xF360 0x7A5E      BFI      R10,R0,#+29,#+2
   1635                }       
   1636              }
   1637              USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ, deptsiz.d32);
   \                     ??USB_OTG_EPStartXfer_2: (+1)
   \   0000006E   0x7828             LDRB     R0,[R5, #+0]
   \   00000070   0xEB14 0x0080      ADDS     R0,R4,R0, LSL #+2
   \   00000074   0x6980             LDR      R0,[R0, #+24]
   \   00000076   0xF8C0 0xA010      STR      R10,[R0, #+16]
   1638              
   1639              if (pdev->cfg.dma_enable == 1)
   \   0000007A   0x78E0             LDRB     R0,[R4, #+3]
   \   0000007C   0x2801             CMP      R0,#+1
   \   0000007E   0xD106             BNE.N    ??USB_OTG_EPStartXfer_3
   1640              {
   1641                USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);
   \   00000080   0x7828             LDRB     R0,[R5, #+0]
   \   00000082   0xEB14 0x0080      ADDS     R0,R4,R0, LSL #+2
   \   00000086   0x6980             LDR      R0,[R0, #+24]
   \   00000088   0x6929             LDR      R1,[R5, #+16]
   \   0000008A   0x6141             STR      R1,[R0, #+20]
   \   0000008C   0xE010             B.N      ??USB_OTG_EPStartXfer_4
   1642              }
   1643              else
   1644              {
   1645                if (ep->type != EP_TYPE_ISOC)
   \                     ??USB_OTG_EPStartXfer_3: (+1)
   \   0000008E   0x78E8             LDRB     R0,[R5, #+3]
   \   00000090   0x2801             CMP      R0,#+1
   \   00000092   0xD00D             BEQ.N    ??USB_OTG_EPStartXfer_4
   1646                {
   1647                  /* Enable the Tx FIFO Empty Interrupt for this EP */
   1648                  if (ep->xfer_len > 0)
   \   00000094   0x6968             LDR      R0,[R5, #+20]
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD00A             BEQ.N    ??USB_OTG_EPStartXfer_4
   1649                  {
   1650                    fifoemptymsk = 1 << ep->num;
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0xF995 0x1000      LDRSB    R1,[R5, #+0]
   \   000000A0   0x4088             LSLS     R0,R0,R1
   \   000000A2   0x4681             MOV      R9,R0
   1651                    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
   \   000000A4   0x6920             LDR      R0,[R4, #+16]
   \   000000A6   0x6B40             LDR      R0,[R0, #+52]
   \   000000A8   0xEA59 0x0000      ORRS     R0,R9,R0
   \   000000AC   0x6921             LDR      R1,[R4, #+16]
   \   000000AE   0x6348             STR      R0,[R1, #+52]
   1652                  }
   1653                }
   1654              }
   1655              
   1656              
   1657              if (ep->type == EP_TYPE_ISOC)
   \                     ??USB_OTG_EPStartXfer_4: (+1)
   \   000000B0   0x78E8             LDRB     R0,[R5, #+3]
   \   000000B2   0x2801             CMP      R0,#+1
   \   000000B4   0xD10A             BNE.N    ??USB_OTG_EPStartXfer_5
   1658              {
   1659                dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
   \   000000B6   0x6920             LDR      R0,[R4, #+16]
   \   000000B8   0x6880             LDR      R0,[R0, #+8]
   \   000000BA   0x4680             MOV      R8,R0
   1660                
   1661                if (((dsts.b.soffn)&0x1) == 0)
   \   000000BC   0xEA5F 0x50C8      LSLS     R0,R8,#+23
   \   000000C0   0xD402             BMI.N    ??USB_OTG_EPStartXfer_6
   1662                {
   1663                  depctl.b.setd1pid = 1;
   \   000000C2   0xF057 0x5700      ORRS     R7,R7,#0x20000000
   \   000000C6   0xE001             B.N      ??USB_OTG_EPStartXfer_5
   1664                }
   1665                else
   1666                {
   1667                  depctl.b.setd0pid = 1;
   \                     ??USB_OTG_EPStartXfer_6: (+1)
   \   000000C8   0xF057 0x5780      ORRS     R7,R7,#0x10000000
   1668                }
   1669              } 
   1670              
   1671              /* EP enable, IN data in FIFO */
   1672              depctl.b.cnak = 1;
   \                     ??USB_OTG_EPStartXfer_5: (+1)
   \   000000CC   0xF057 0x6780      ORRS     R7,R7,#0x4000000
   1673              depctl.b.epena = 1;
   \   000000D0   0xF057 0x4700      ORRS     R7,R7,#0x80000000
   1674              USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPCTL, depctl.d32);
   \   000000D4   0x7828             LDRB     R0,[R5, #+0]
   \   000000D6   0xEB14 0x0080      ADDS     R0,R4,R0, LSL #+2
   \   000000DA   0x6980             LDR      R0,[R0, #+24]
   \   000000DC   0x6007             STR      R7,[R0, #+0]
   1675          
   1676              if (ep->type == EP_TYPE_ISOC)
   \   000000DE   0x78E8             LDRB     R0,[R5, #+3]
   \   000000E0   0x2801             CMP      R0,#+1
   \   000000E2   0xD14F             BNE.N    ??USB_OTG_EPStartXfer_7
   1677              {
   1678                USB_OTG_WritePacket(pdev, ep->xfer_buff, ep->num, ep->xfer_len);   
   \   000000E4   0x696B             LDR      R3,[R5, #+20]
   \   000000E6   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000E8   0x782A             LDRB     R2,[R5, #+0]
   \   000000EA   0x68E9             LDR      R1,[R5, #+12]
   \   000000EC   0x0020             MOVS     R0,R4
   \   000000EE   0x.... 0x....      BL       USB_OTG_WritePacket
   \   000000F2   0xE047             B.N      ??USB_OTG_EPStartXfer_7
   1679              }    
   1680            }
   1681            else
   1682            {
   1683              /* OUT endpoint */
   1684              depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL));
   \                     ??USB_OTG_EPStartXfer_0: (+1)
   \   000000F4   0x7828             LDRB     R0,[R5, #+0]
   \   000000F6   0xEB14 0x0080      ADDS     R0,R4,R0, LSL #+2
   \   000000FA   0x6D40             LDR      R0,[R0, #+84]
   \   000000FC   0x6800             LDR      R0,[R0, #+0]
   \   000000FE   0x0007             MOVS     R7,R0
   1685              deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ));
   \   00000100   0x7828             LDRB     R0,[R5, #+0]
   \   00000102   0xEB14 0x0080      ADDS     R0,R4,R0, LSL #+2
   \   00000106   0x6D40             LDR      R0,[R0, #+84]
   \   00000108   0x6900             LDR      R0,[R0, #+16]
   \   0000010A   0x4682             MOV      R10,R0
   1686              /* Program the transfer size and packet count as follows:
   1687              * pktcnt = N
   1688              * xfersize = N * maxpacket
   1689              */
   1690              if (ep->xfer_len == 0)
   \   0000010C   0x6968             LDR      R0,[R5, #+20]
   \   0000010E   0x2800             CMP      R0,#+0
   \   00000110   0xD106             BNE.N    ??USB_OTG_EPStartXfer_8
   1691              {
   1692                deptsiz.b.xfersize = ep->maxpacket;
   \   00000112   0x68A8             LDR      R0,[R5, #+8]
   \   00000114   0xF360 0x0A12      BFI      R10,R0,#+0,#+19
   1693                deptsiz.b.pktcnt = 1;
   \   00000118   0x2001             MOVS     R0,#+1
   \   0000011A   0xF360 0x4ADC      BFI      R10,R0,#+19,#+10
   \   0000011E   0xE00E             B.N      ??USB_OTG_EPStartXfer_9
   1694              }
   1695              else
   1696              {
   1697                deptsiz.b.pktcnt = (ep->xfer_len + (ep->maxpacket - 1)) / ep->maxpacket;
   \                     ??USB_OTG_EPStartXfer_8: (+1)
   \   00000120   0x6968             LDR      R0,[R5, #+20]
   \   00000122   0x68A9             LDR      R1,[R5, #+8]
   \   00000124   0x1808             ADDS     R0,R1,R0
   \   00000126   0x1E40             SUBS     R0,R0,#+1
   \   00000128   0x68A9             LDR      R1,[R5, #+8]
   \   0000012A   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000012E   0xF360 0x4ADC      BFI      R10,R0,#+19,#+10
   1698                deptsiz.b.xfersize = deptsiz.b.pktcnt * ep->maxpacket;
   \   00000132   0xF3CA 0x40C9      UBFX     R0,R10,#+19,#+10
   \   00000136   0x68A9             LDR      R1,[R5, #+8]
   \   00000138   0x4348             MULS     R0,R1,R0
   \   0000013A   0xF360 0x0A12      BFI      R10,R0,#+0,#+19
   1699              }
   1700              USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
   \                     ??USB_OTG_EPStartXfer_9: (+1)
   \   0000013E   0x7828             LDRB     R0,[R5, #+0]
   \   00000140   0xEB14 0x0080      ADDS     R0,R4,R0, LSL #+2
   \   00000144   0x6D40             LDR      R0,[R0, #+84]
   \   00000146   0xF8C0 0xA010      STR      R10,[R0, #+16]
   1701              
   1702              if (pdev->cfg.dma_enable == 1)
   \   0000014A   0x78E0             LDRB     R0,[R4, #+3]
   \   0000014C   0x2801             CMP      R0,#+1
   \   0000014E   0xD105             BNE.N    ??USB_OTG_EPStartXfer_10
   1703              {
   1704                USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
   \   00000150   0x7828             LDRB     R0,[R5, #+0]
   \   00000152   0xEB14 0x0080      ADDS     R0,R4,R0, LSL #+2
   \   00000156   0x6D40             LDR      R0,[R0, #+84]
   \   00000158   0x6929             LDR      R1,[R5, #+16]
   \   0000015A   0x6141             STR      R1,[R0, #+20]
   1705              }
   1706              
   1707              if (ep->type == EP_TYPE_ISOC)
   \                     ??USB_OTG_EPStartXfer_10: (+1)
   \   0000015C   0x78E8             LDRB     R0,[R5, #+3]
   \   0000015E   0x2801             CMP      R0,#+1
   \   00000160   0xD107             BNE.N    ??USB_OTG_EPStartXfer_11
   1708              {
   1709                if (ep->even_odd_frame)
   \   00000162   0x7968             LDRB     R0,[R5, #+5]
   \   00000164   0x2800             CMP      R0,#+0
   \   00000166   0xD002             BEQ.N    ??USB_OTG_EPStartXfer_12
   1710                {
   1711                  depctl.b.setd1pid = 1;
   \   00000168   0xF057 0x5700      ORRS     R7,R7,#0x20000000
   \   0000016C   0xE001             B.N      ??USB_OTG_EPStartXfer_11
   1712                }
   1713                else
   1714                {
   1715                  depctl.b.setd0pid = 1;
   \                     ??USB_OTG_EPStartXfer_12: (+1)
   \   0000016E   0xF057 0x5780      ORRS     R7,R7,#0x10000000
   1716                }
   1717              }
   1718              /* EP enable */
   1719              depctl.b.cnak = 1;
   \                     ??USB_OTG_EPStartXfer_11: (+1)
   \   00000172   0xF057 0x6780      ORRS     R7,R7,#0x4000000
   1720              depctl.b.epena = 1;
   \   00000176   0xF057 0x4700      ORRS     R7,R7,#0x80000000
   1721              USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL, depctl.d32);
   \   0000017A   0x7828             LDRB     R0,[R5, #+0]
   \   0000017C   0xEB14 0x0080      ADDS     R0,R4,R0, LSL #+2
   \   00000180   0x6D40             LDR      R0,[R0, #+84]
   \   00000182   0x6007             STR      R7,[R0, #+0]
   1722            }
   1723            return status;
   \                     ??USB_OTG_EPStartXfer_7: (+1)
   \   00000184   0x0030             MOVS     R0,R6
   \   00000186   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000188   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1724          }
   1725          
   1726          
   1727          /**
   1728          * @brief  USB_OTG_EP0StartXfer : Handle the setup for a data xfer for EP0 and 
   1729          *         starts the xfer
   1730          * @param  pdev : Selected device
   1731          * @retval USB_OTG_STS : status
   1732          */

   \                                 In section .text, align 2, keep-with-next
   1733          USB_OTG_STS USB_OTG_EP0StartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
   1734          {
   \                     USB_OTG_EP0StartXfer: (+1)
   \   00000000   0xB4FC             PUSH     {R2-R7}
   \   00000002   0x0002             MOVS     R2,R0
   1735            USB_OTG_STS                 status = USB_OTG_OK;
   \   00000004   0x2000             MOVS     R0,#+0
   1736            USB_OTG_DEPCTL_TypeDef      depctl;
   1737            USB_OTG_DEP0XFRSIZ_TypeDef  deptsiz;
   1738            USB_OTG_INEPREGS          *in_regs;
   1739            uint32_t fifoemptymsk = 0;
   \   00000006   0x2500             MOVS     R5,#+0
   1740            
   1741            depctl.d32   = 0;
   \   00000008   0x2600             MOVS     R6,#+0
   \   0000000A   0x0033             MOVS     R3,R6
   1742            deptsiz.d32  = 0;
   \   0000000C   0x2600             MOVS     R6,#+0
   \   0000000E   0x9600             STR      R6,[SP, #+0]
   1743            /* IN endpoint */
   1744            if (ep->is_in == 1)
   \   00000010   0x784E             LDRB     R6,[R1, #+1]
   \   00000012   0x2E01             CMP      R6,#+1
   \   00000014   0xD149             BNE.N    ??USB_OTG_EP0StartXfer_0
   1745            {
   1746              in_regs = pdev->regs.INEP_REGS[0];
   \   00000016   0x6996             LDR      R6,[R2, #+24]
   \   00000018   0x0034             MOVS     R4,R6
   1747              depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
   \   0000001A   0x6826             LDR      R6,[R4, #+0]
   \   0000001C   0x0033             MOVS     R3,R6
   1748              deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
   \   0000001E   0x6926             LDR      R6,[R4, #+16]
   \   00000020   0x9600             STR      R6,[SP, #+0]
   1749              /* Zero Length Packet? */
   1750              if (ep->xfer_len == 0)
   \   00000022   0x694E             LDR      R6,[R1, #+20]
   \   00000024   0x2E00             CMP      R6,#+0
   \   00000026   0xD109             BNE.N    ??USB_OTG_EP0StartXfer_1
   1751              {
   1752                deptsiz.b.xfersize = 0;
   \   00000028   0x9E00             LDR      R6,[SP, #+0]
   \   0000002A   0x09F6             LSRS     R6,R6,#+7
   \   0000002C   0x01F6             LSLS     R6,R6,#+7
   \   0000002E   0x9600             STR      R6,[SP, #+0]
   1753                deptsiz.b.pktcnt = 1;
   \   00000030   0x2601             MOVS     R6,#+1
   \   00000032   0x9F00             LDR      R7,[SP, #+0]
   \   00000034   0xF366 0x47D4      BFI      R7,R6,#+19,#+2
   \   00000038   0x9700             STR      R7,[SP, #+0]
   \   0000003A   0xE015             B.N      ??USB_OTG_EP0StartXfer_2
   1754                
   1755              }
   1756              else
   1757              {
   1758                if (ep->xfer_len > ep->maxpacket)
   \                     ??USB_OTG_EP0StartXfer_1: (+1)
   \   0000003C   0x688E             LDR      R6,[R1, #+8]
   \   0000003E   0x694F             LDR      R7,[R1, #+20]
   \   00000040   0x42BE             CMP      R6,R7
   \   00000042   0xD207             BCS.N    ??USB_OTG_EP0StartXfer_3
   1759                {
   1760                  ep->xfer_len = ep->maxpacket;
   \   00000044   0x688E             LDR      R6,[R1, #+8]
   \   00000046   0x614E             STR      R6,[R1, #+20]
   1761                  deptsiz.b.xfersize = ep->maxpacket;
   \   00000048   0x688E             LDR      R6,[R1, #+8]
   \   0000004A   0x9F00             LDR      R7,[SP, #+0]
   \   0000004C   0xF366 0x0706      BFI      R7,R6,#+0,#+7
   \   00000050   0x9700             STR      R7,[SP, #+0]
   \   00000052   0xE004             B.N      ??USB_OTG_EP0StartXfer_4
   1762                }
   1763                else
   1764                {
   1765                  deptsiz.b.xfersize = ep->xfer_len;
   \                     ??USB_OTG_EP0StartXfer_3: (+1)
   \   00000054   0x694E             LDR      R6,[R1, #+20]
   \   00000056   0x9F00             LDR      R7,[SP, #+0]
   \   00000058   0xF366 0x0706      BFI      R7,R6,#+0,#+7
   \   0000005C   0x9700             STR      R7,[SP, #+0]
   1766                }
   1767                deptsiz.b.pktcnt = 1;
   \                     ??USB_OTG_EP0StartXfer_4: (+1)
   \   0000005E   0x2601             MOVS     R6,#+1
   \   00000060   0x9F00             LDR      R7,[SP, #+0]
   \   00000062   0xF366 0x47D4      BFI      R7,R6,#+19,#+2
   \   00000066   0x9700             STR      R7,[SP, #+0]
   1768              }
   1769              USB_OTG_WRITE_REG32(&in_regs->DIEPTSIZ, deptsiz.d32);
   \                     ??USB_OTG_EP0StartXfer_2: (+1)
   \   00000068   0x9E00             LDR      R6,[SP, #+0]
   \   0000006A   0x6126             STR      R6,[R4, #+16]
   1770              
   1771              if (pdev->cfg.dma_enable == 1)
   \   0000006C   0x78D6             LDRB     R6,[R2, #+3]
   \   0000006E   0x2E01             CMP      R6,#+1
   \   00000070   0xD105             BNE.N    ??USB_OTG_EP0StartXfer_5
   1772              {
   1773                USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);  
   \   00000072   0x780E             LDRB     R6,[R1, #+0]
   \   00000074   0xEB12 0x0686      ADDS     R6,R2,R6, LSL #+2
   \   00000078   0x69B6             LDR      R6,[R6, #+24]
   \   0000007A   0x690F             LDR      R7,[R1, #+16]
   \   0000007C   0x6177             STR      R7,[R6, #+20]
   1774              }
   1775              
   1776              /* EP enable, IN data in FIFO */
   1777              depctl.b.cnak = 1;
   \                     ??USB_OTG_EP0StartXfer_5: (+1)
   \   0000007E   0xF053 0x6380      ORRS     R3,R3,#0x4000000
   1778              depctl.b.epena = 1;
   \   00000082   0xF053 0x4300      ORRS     R3,R3,#0x80000000
   1779              USB_OTG_WRITE_REG32(&in_regs->DIEPCTL, depctl.d32);
   \   00000086   0x6023             STR      R3,[R4, #+0]
   1780              
   1781              
   1782              
   1783              if (pdev->cfg.dma_enable == 0)
   \   00000088   0x78D6             LDRB     R6,[R2, #+3]
   \   0000008A   0x2E00             CMP      R6,#+0
   \   0000008C   0xD14B             BNE.N    ??USB_OTG_EP0StartXfer_6
   1784              {
   1785                /* Enable the Tx FIFO Empty Interrupt for this EP */
   1786                if (ep->xfer_len > 0)
   \   0000008E   0x694E             LDR      R6,[R1, #+20]
   \   00000090   0x2E00             CMP      R6,#+0
   \   00000092   0xD048             BEQ.N    ??USB_OTG_EP0StartXfer_6
   1787                {
   1788                  {
   1789                    fifoemptymsk |= 1 << ep->num;
   \   00000094   0x2601             MOVS     R6,#+1
   \   00000096   0xF991 0x7000      LDRSB    R7,[R1, #+0]
   \   0000009A   0x40BE             LSLS     R6,R6,R7
   \   0000009C   0x4335             ORRS     R5,R6,R5
   1790                    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
   \   0000009E   0x6916             LDR      R6,[R2, #+16]
   \   000000A0   0x6B76             LDR      R6,[R6, #+52]
   \   000000A2   0x432E             ORRS     R6,R5,R6
   \   000000A4   0x6917             LDR      R7,[R2, #+16]
   \   000000A6   0x637E             STR      R6,[R7, #+52]
   \   000000A8   0xE03D             B.N      ??USB_OTG_EP0StartXfer_6
   1791                  }
   1792                }
   1793              }
   1794            }
   1795            else
   1796            {
   1797              /* OUT endpoint */
   1798              depctl.d32  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
   \                     ??USB_OTG_EP0StartXfer_0: (+1)
   \   000000AA   0x780E             LDRB     R6,[R1, #+0]
   \   000000AC   0xEB12 0x0686      ADDS     R6,R2,R6, LSL #+2
   \   000000B0   0x6D76             LDR      R6,[R6, #+84]
   \   000000B2   0x6836             LDR      R6,[R6, #+0]
   \   000000B4   0x0033             MOVS     R3,R6
   1799              deptsiz.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ);
   \   000000B6   0x780E             LDRB     R6,[R1, #+0]
   \   000000B8   0xEB12 0x0686      ADDS     R6,R2,R6, LSL #+2
   \   000000BC   0x6D76             LDR      R6,[R6, #+84]
   \   000000BE   0x6936             LDR      R6,[R6, #+16]
   \   000000C0   0x9600             STR      R6,[SP, #+0]
   1800              /* Program the transfer size and packet count as follows:
   1801              * xfersize = N * (maxpacket + 4 - (maxpacket % 4))
   1802              * pktcnt = N           */
   1803              if (ep->xfer_len == 0)
   \   000000C2   0x694E             LDR      R6,[R1, #+20]
   \   000000C4   0x2E00             CMP      R6,#+0
   \   000000C6   0xD10A             BNE.N    ??USB_OTG_EP0StartXfer_7
   1804              {
   1805                deptsiz.b.xfersize = ep->maxpacket;
   \   000000C8   0x688E             LDR      R6,[R1, #+8]
   \   000000CA   0x9F00             LDR      R7,[SP, #+0]
   \   000000CC   0xF366 0x0706      BFI      R7,R6,#+0,#+7
   \   000000D0   0x9700             STR      R7,[SP, #+0]
   1806                deptsiz.b.pktcnt = 1;
   \   000000D2   0x2601             MOVS     R6,#+1
   \   000000D4   0x9F00             LDR      R7,[SP, #+0]
   \   000000D6   0xF366 0x47D4      BFI      R7,R6,#+19,#+2
   \   000000DA   0x9700             STR      R7,[SP, #+0]
   \   000000DC   0xE00B             B.N      ??USB_OTG_EP0StartXfer_8
   1807              }
   1808              else
   1809              {
   1810                ep->xfer_len = ep->maxpacket;
   \                     ??USB_OTG_EP0StartXfer_7: (+1)
   \   000000DE   0x688E             LDR      R6,[R1, #+8]
   \   000000E0   0x614E             STR      R6,[R1, #+20]
   1811                deptsiz.b.xfersize = ep->maxpacket;
   \   000000E2   0x688E             LDR      R6,[R1, #+8]
   \   000000E4   0x9F00             LDR      R7,[SP, #+0]
   \   000000E6   0xF366 0x0706      BFI      R7,R6,#+0,#+7
   \   000000EA   0x9700             STR      R7,[SP, #+0]
   1812                deptsiz.b.pktcnt = 1;
   \   000000EC   0x2601             MOVS     R6,#+1
   \   000000EE   0x9F00             LDR      R7,[SP, #+0]
   \   000000F0   0xF366 0x47D4      BFI      R7,R6,#+19,#+2
   \   000000F4   0x9700             STR      R7,[SP, #+0]
   1813              }
   1814              USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
   \                     ??USB_OTG_EP0StartXfer_8: (+1)
   \   000000F6   0x780E             LDRB     R6,[R1, #+0]
   \   000000F8   0xEB12 0x0686      ADDS     R6,R2,R6, LSL #+2
   \   000000FC   0x6D76             LDR      R6,[R6, #+84]
   \   000000FE   0x9F00             LDR      R7,[SP, #+0]
   \   00000100   0x6137             STR      R7,[R6, #+16]
   1815              if (pdev->cfg.dma_enable == 1)
   \   00000102   0x78D6             LDRB     R6,[R2, #+3]
   \   00000104   0x2E01             CMP      R6,#+1
   \   00000106   0xD105             BNE.N    ??USB_OTG_EP0StartXfer_9
   1816              {
   1817                USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
   \   00000108   0x780E             LDRB     R6,[R1, #+0]
   \   0000010A   0xEB12 0x0686      ADDS     R6,R2,R6, LSL #+2
   \   0000010E   0x6D76             LDR      R6,[R6, #+84]
   \   00000110   0x690F             LDR      R7,[R1, #+16]
   \   00000112   0x6177             STR      R7,[R6, #+20]
   1818              }
   1819              /* EP enable */
   1820              depctl.b.cnak = 1;
   \                     ??USB_OTG_EP0StartXfer_9: (+1)
   \   00000114   0xF053 0x6380      ORRS     R3,R3,#0x4000000
   1821              depctl.b.epena = 1;
   \   00000118   0xF053 0x4300      ORRS     R3,R3,#0x80000000
   1822              USB_OTG_WRITE_REG32 (&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL), depctl.d32);
   \   0000011C   0x780E             LDRB     R6,[R1, #+0]
   \   0000011E   0xEB12 0x0686      ADDS     R6,R2,R6, LSL #+2
   \   00000122   0x6D76             LDR      R6,[R6, #+84]
   \   00000124   0x6033             STR      R3,[R6, #+0]
   1823              
   1824            }
   1825            return status;
   \                     ??USB_OTG_EP0StartXfer_6: (+1)
   \   00000126   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000128   0xBCF6             POP      {R1,R2,R4-R7}
   \   0000012A   0x4770             BX       LR               ;; return
   1826          }
   1827          
   1828          
   1829          /**
   1830          * @brief  USB_OTG_EPSetStall : Set the EP STALL
   1831          * @param  pdev : Selected device
   1832          * @retval USB_OTG_STS : status
   1833          */

   \                                 In section .text, align 2, keep-with-next
   1834          USB_OTG_STS USB_OTG_EPSetStall(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
   1835          {
   \                     USB_OTG_EPSetStall: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
   1836            USB_OTG_STS status = USB_OTG_OK;
   \   00000004   0x2000             MOVS     R0,#+0
   1837            USB_OTG_DEPCTL_TypeDef  depctl;
   1838            __IO uint32_t *depctl_addr;
   1839            
   1840            depctl.d32 = 0;
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0x002C             MOVS     R4,R5
   1841            if (ep->is_in == 1)
   \   0000000A   0x784D             LDRB     R5,[R1, #+1]
   \   0000000C   0x2D01             CMP      R5,#+1
   \   0000000E   0xD10F             BNE.N    ??USB_OTG_EPSetStall_0
   1842            {
   1843              depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
   \   00000010   0x780D             LDRB     R5,[R1, #+0]
   \   00000012   0xEB12 0x0585      ADDS     R5,R2,R5, LSL #+2
   \   00000016   0x69AD             LDR      R5,[R5, #+24]
   \   00000018   0x002B             MOVS     R3,R5
   1844              depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
   \   0000001A   0x681D             LDR      R5,[R3, #+0]
   \   0000001C   0x002C             MOVS     R4,R5
   1845              /* set the disable and stall bits */
   1846              if (depctl.b.epena)
   \   0000001E   0x0FE5             LSRS     R5,R4,#+31
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD001             BEQ.N    ??USB_OTG_EPSetStall_1
   1847              {
   1848                depctl.b.epdis = 1;
   \   00000024   0xF054 0x4480      ORRS     R4,R4,#0x40000000
   1849              }
   1850              depctl.b.stall = 1;
   \                     ??USB_OTG_EPSetStall_1: (+1)
   \   00000028   0xF454 0x1400      ORRS     R4,R4,#0x200000
   1851              USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
   \   0000002C   0x601C             STR      R4,[R3, #+0]
   \   0000002E   0xE009             B.N      ??USB_OTG_EPSetStall_2
   1852            }
   1853            else
   1854            {
   1855              depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
   \                     ??USB_OTG_EPSetStall_0: (+1)
   \   00000030   0x780D             LDRB     R5,[R1, #+0]
   \   00000032   0xEB12 0x0585      ADDS     R5,R2,R5, LSL #+2
   \   00000036   0x6D6D             LDR      R5,[R5, #+84]
   \   00000038   0x002B             MOVS     R3,R5
   1856              depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
   \   0000003A   0x681D             LDR      R5,[R3, #+0]
   \   0000003C   0x002C             MOVS     R4,R5
   1857              /* set the stall bit */
   1858              depctl.b.stall = 1;
   \   0000003E   0xF454 0x1400      ORRS     R4,R4,#0x200000
   1859              USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
   \   00000042   0x601C             STR      R4,[R3, #+0]
   1860            }
   1861            return status;
   \                     ??USB_OTG_EPSetStall_2: (+1)
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0xBC30             POP      {R4,R5}
   \   00000048   0x4770             BX       LR               ;; return
   1862          }
   1863          
   1864          
   1865          /**
   1866          * @brief  Clear the EP STALL
   1867          * @param  pdev : Selected device
   1868          * @retval USB_OTG_STS : status
   1869          */

   \                                 In section .text, align 2, keep-with-next
   1870          USB_OTG_STS USB_OTG_EPClearStall(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
   1871          {
   \                     USB_OTG_EPClearStall: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
   1872            USB_OTG_STS status = USB_OTG_OK;
   \   00000004   0x2000             MOVS     R0,#+0
   1873            USB_OTG_DEPCTL_TypeDef  depctl;
   1874            __IO uint32_t *depctl_addr;
   1875            
   1876            depctl.d32 = 0;
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0x002C             MOVS     R4,R5
   1877            
   1878            if (ep->is_in == 1)
   \   0000000A   0x784D             LDRB     R5,[R1, #+1]
   \   0000000C   0x2D01             CMP      R5,#+1
   \   0000000E   0xD105             BNE.N    ??USB_OTG_EPClearStall_0
   1879            {
   1880              depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
   \   00000010   0x780D             LDRB     R5,[R1, #+0]
   \   00000012   0xEB12 0x0585      ADDS     R5,R2,R5, LSL #+2
   \   00000016   0x69AD             LDR      R5,[R5, #+24]
   \   00000018   0x002B             MOVS     R3,R5
   \   0000001A   0xE004             B.N      ??USB_OTG_EPClearStall_1
   1881            }
   1882            else
   1883            {
   1884              depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
   \                     ??USB_OTG_EPClearStall_0: (+1)
   \   0000001C   0x780D             LDRB     R5,[R1, #+0]
   \   0000001E   0xEB12 0x0585      ADDS     R5,R2,R5, LSL #+2
   \   00000022   0x6D6D             LDR      R5,[R5, #+84]
   \   00000024   0x002B             MOVS     R3,R5
   1885            }
   1886            depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
   \                     ??USB_OTG_EPClearStall_1: (+1)
   \   00000026   0x681D             LDR      R5,[R3, #+0]
   \   00000028   0x002C             MOVS     R4,R5
   1887            /* clear the stall bits */
   1888            depctl.b.stall = 0;
   \   0000002A   0xF434 0x1400      BICS     R4,R4,#0x200000
   1889            if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
   \   0000002E   0x78CD             LDRB     R5,[R1, #+3]
   \   00000030   0x2D03             CMP      R5,#+3
   \   00000032   0xD002             BEQ.N    ??USB_OTG_EPClearStall_2
   \   00000034   0x78CD             LDRB     R5,[R1, #+3]
   \   00000036   0x2D02             CMP      R5,#+2
   \   00000038   0xD101             BNE.N    ??USB_OTG_EPClearStall_3
   1890            {
   1891              depctl.b.setd0pid = 1; /* DATA0 */
   \                     ??USB_OTG_EPClearStall_2: (+1)
   \   0000003A   0xF054 0x5480      ORRS     R4,R4,#0x10000000
   1892            }
   1893            USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
   \                     ??USB_OTG_EPClearStall_3: (+1)
   \   0000003E   0x601C             STR      R4,[R3, #+0]
   1894            return status;
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0xBC30             POP      {R4,R5}
   \   00000044   0x4770             BX       LR               ;; return
   1895          }
   1896          
   1897          
   1898          /**
   1899          * @brief  USB_OTG_ReadDevAllOutEp_itr : returns OUT endpoint interrupt bits
   1900          * @param  pdev : Selected device
   1901          * @retval OUT endpoint interrupt bits
   1902          */

   \                                 In section .text, align 2, keep-with-next
   1903          uint32_t USB_OTG_ReadDevAllOutEp_itr(USB_OTG_CORE_HANDLE *pdev)
   1904          {
   \                     USB_OTG_ReadDevAllOutEp_itr: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1905            uint32_t v;
   1906            v  = USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINT);
   \   00000002   0x690A             LDR      R2,[R1, #+16]
   \   00000004   0x6992             LDR      R2,[R2, #+24]
   \   00000006   0x0010             MOVS     R0,R2
   1907            v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINTMSK);
   \   00000008   0x690A             LDR      R2,[R1, #+16]
   \   0000000A   0x69D2             LDR      R2,[R2, #+28]
   \   0000000C   0x4010             ANDS     R0,R2,R0
   1908            return ((v & 0xffff0000) >> 16);
   \   0000000E   0x0C00             LSRS     R0,R0,#+16
   \   00000010   0x4770             BX       LR               ;; return
   1909          }
   1910          
   1911          
   1912          /**
   1913          * @brief  USB_OTG_ReadDevOutEP_itr : returns Device OUT EP Interrupt register
   1914          * @param  pdev : Selected device
   1915          * @param  ep : end point number
   1916          * @retval Device OUT EP Interrupt register
   1917          */

   \                                 In section .text, align 2, keep-with-next
   1918          uint32_t USB_OTG_ReadDevOutEP_itr(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
   1919          {
   \                     USB_OTG_ReadDevOutEP_itr: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   1920            uint32_t v;
   1921            v  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[epnum]->DOEPINT);
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0xEB12 0x0381      ADDS     R3,R2,R1, LSL #+2
   \   00000008   0x6D5B             LDR      R3,[R3, #+84]
   \   0000000A   0x689B             LDR      R3,[R3, #+8]
   \   0000000C   0x0018             MOVS     R0,R3
   1922            v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DOEPMSK);
   \   0000000E   0x6913             LDR      R3,[R2, #+16]
   \   00000010   0x695B             LDR      R3,[R3, #+20]
   \   00000012   0x4018             ANDS     R0,R3,R0
   1923            return v;
   \   00000014   0x4770             BX       LR               ;; return
   1924          }
   1925          
   1926          
   1927          /**
   1928          * @brief  USB_OTG_ReadDevAllInEPItr : Get int status register
   1929          * @param  pdev : Selected device
   1930          * @retval int status register
   1931          */

   \                                 In section .text, align 2, keep-with-next
   1932          uint32_t USB_OTG_ReadDevAllInEPItr(USB_OTG_CORE_HANDLE *pdev)
   1933          {
   \                     USB_OTG_ReadDevAllInEPItr: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1934            uint32_t v;
   1935            v = USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINT);
   \   00000002   0x690A             LDR      R2,[R1, #+16]
   \   00000004   0x6992             LDR      R2,[R2, #+24]
   \   00000006   0x0010             MOVS     R0,R2
   1936            v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINTMSK);
   \   00000008   0x690A             LDR      R2,[R1, #+16]
   \   0000000A   0x69D2             LDR      R2,[R2, #+28]
   \   0000000C   0x4010             ANDS     R0,R2,R0
   1937            return (v & 0xffff);
   \   0000000E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000010   0x4770             BX       LR               ;; return
   1938          }
   1939          
   1940          /**
   1941          * @brief  configures EPO to receive SETUP packets
   1942          * @param  None
   1943          * @retval : None
   1944          */

   \                                 In section .text, align 2, keep-with-next
   1945          void USB_OTG_EP0_OutStart(USB_OTG_CORE_HANDLE *pdev)
   1946          {
   \                     USB_OTG_EP0_OutStart: (+1)
   \   00000000   0xB082             SUB      SP,SP,#+8
   1947            USB_OTG_DEP0XFRSIZ_TypeDef  doeptsize0;
   1948            doeptsize0.d32 = 0;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x9100             STR      R1,[SP, #+0]
   1949            doeptsize0.b.supcnt = 3;
   \   00000006   0x9900             LDR      R1,[SP, #+0]
   \   00000008   0xF051 0x4140      ORRS     R1,R1,#0xC0000000
   \   0000000C   0x9100             STR      R1,[SP, #+0]
   1950            doeptsize0.b.pktcnt = 1;
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x9A00             LDR      R2,[SP, #+0]
   \   00000012   0xF361 0x42D4      BFI      R2,R1,#+19,#+2
   \   00000016   0x9200             STR      R2,[SP, #+0]
   1951            doeptsize0.b.xfersize = 8 * 3;
   \   00000018   0x2118             MOVS     R1,#+24
   \   0000001A   0x9A00             LDR      R2,[SP, #+0]
   \   0000001C   0xF361 0x0206      BFI      R2,R1,#+0,#+7
   \   00000020   0x9200             STR      R2,[SP, #+0]
   1952            USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPTSIZ, doeptsize0.d32 );
   \   00000022   0x9900             LDR      R1,[SP, #+0]
   \   00000024   0x6D42             LDR      R2,[R0, #+84]
   \   00000026   0x6111             STR      R1,[R2, #+16]
   1953            
   1954            if (pdev->cfg.dma_enable == 1)
   \   00000028   0x78C1             LDRB     R1,[R0, #+3]
   \   0000002A   0x2901             CMP      R1,#+1
   \   0000002C   0xD10F             BNE.N    ??USB_OTG_EP0_OutStart_0
   1955            {
   1956              USB_OTG_DEPCTL_TypeDef  doepctl;
   1957              doepctl.d32 = 0;
   \   0000002E   0x2200             MOVS     R2,#+0
   \   00000030   0x0011             MOVS     R1,R2
   1958              USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPDMA, 
   1959                                  (uint32_t)&pdev->dev.setup_packet);
   \   00000032   0xF510 0x62B9      ADDS     R2,R0,#+1480
   \   00000036   0x6D43             LDR      R3,[R0, #+84]
   \   00000038   0x615A             STR      R2,[R3, #+20]
   1960              
   1961              /* EP enable */
   1962              doepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[0]->DOEPCTL);
   \   0000003A   0x6D42             LDR      R2,[R0, #+84]
   \   0000003C   0x6812             LDR      R2,[R2, #+0]
   \   0000003E   0x0011             MOVS     R1,R2
   1963              doepctl.b.epena = 1;
   \   00000040   0xF051 0x4100      ORRS     R1,R1,#0x80000000
   1964              doepctl.d32 = 0x80008000;
   \   00000044   0xF05F 0x2280      MOVS     R2,#-2147450880
   \   00000048   0x0011             MOVS     R1,R2
   1965              USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPCTL, doepctl.d32);
   \   0000004A   0x6D42             LDR      R2,[R0, #+84]
   \   0000004C   0x6011             STR      R1,[R2, #+0]
   1966            }
   1967          }
   \                     ??USB_OTG_EP0_OutStart_0: (+1)
   \   0000004E   0xB002             ADD      SP,SP,#+8
   \   00000050   0x4770             BX       LR               ;; return
   1968          
   1969          /**
   1970          * @brief  USB_OTG_RemoteWakeup : active remote wakeup signalling
   1971          * @param  None
   1972          * @retval : None
   1973          */

   \                                 In section .text, align 2, keep-with-next
   1974          void USB_OTG_ActiveRemoteWakeup(USB_OTG_CORE_HANDLE *pdev)
   1975          {
   \                     USB_OTG_ActiveRemoteWakeup: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1976            
   1977            USB_OTG_DCTL_TypeDef     dctl;
   1978            USB_OTG_DSTS_TypeDef     dsts;
   1979            USB_OTG_PCGCCTL_TypeDef  power;  
   1980            
   1981            if (pdev->dev.DevRemoteWakeup) 
   \   00000004   0xF8D4 0x0114      LDR      R0,[R4, #+276]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD022             BEQ.N    ??USB_OTG_ActiveRemoteWakeup_0
   1982            {
   1983              dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
   \   0000000C   0x6920             LDR      R0,[R4, #+16]
   \   0000000E   0x6880             LDR      R0,[R0, #+8]
   \   00000010   0x0006             MOVS     R6,R0
   1984              if(dsts.b.suspsts == 1)
   \   00000012   0x07F0             LSLS     R0,R6,#+31
   \   00000014   0xD51D             BPL.N    ??USB_OTG_ActiveRemoteWakeup_0
   1985              {
   1986                if(pdev->cfg.low_power)
   \   00000016   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD009             BEQ.N    ??USB_OTG_ActiveRemoteWakeup_1
   1987                {
   1988                  /* un-gate USB Core clock */
   1989                  power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
   \   0000001C   0xF8D4 0x010C      LDR      R0,[R4, #+268]
   \   00000020   0x0007             MOVS     R7,R0
   1990                  power.b.gatehclk = 0;
   \   00000022   0xF037 0x0702      BICS     R7,R7,#0x2
   1991                  power.b.stoppclk = 0;
   \   00000026   0x087F             LSRS     R7,R7,#+1
   \   00000028   0x007F             LSLS     R7,R7,#+1
   1992                  USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
   \   0000002A   0xF8D4 0x010C      LDR      R0,[R4, #+268]
   \   0000002E   0x6007             STR      R7,[R0, #+0]
   1993                }   
   1994                /* active Remote wakeup signaling */
   1995                dctl.d32 = 0;
   \                     ??USB_OTG_ActiveRemoteWakeup_1: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x0005             MOVS     R5,R0
   1996                dctl.b.rmtwkupsig = 1;
   \   00000034   0xF055 0x0501      ORRS     R5,R5,#0x1
   1997                USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, 0, dctl.d32);
   \   00000038   0x6920             LDR      R0,[R4, #+16]
   \   0000003A   0x6840             LDR      R0,[R0, #+4]
   \   0000003C   0x4328             ORRS     R0,R5,R0
   \   0000003E   0x6921             LDR      R1,[R4, #+16]
   \   00000040   0x6048             STR      R0,[R1, #+4]
   1998                USB_OTG_BSP_mDelay(5);
   \   00000042   0x2005             MOVS     R0,#+5
   \   00000044   0x.... 0x....      BL       USB_OTG_BSP_mDelay
   1999                USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
   \   00000048   0x6920             LDR      R0,[R4, #+16]
   \   0000004A   0x6840             LDR      R0,[R0, #+4]
   \   0000004C   0x43A8             BICS     R0,R0,R5
   \   0000004E   0x6921             LDR      R1,[R4, #+16]
   \   00000050   0x6048             STR      R0,[R1, #+4]
   2000              }
   2001            }
   2002          }
   \                     ??USB_OTG_ActiveRemoteWakeup_0: (+1)
   \   00000052   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   2003          
   2004          
   2005          /**
   2006          * @brief  USB_OTG_UngateClock : active USB Core clock
   2007          * @param  None
   2008          * @retval : None
   2009          */

   \                                 In section .text, align 2, keep-with-next
   2010          void USB_OTG_UngateClock(USB_OTG_CORE_HANDLE *pdev)
   2011          {
   2012            if(pdev->cfg.low_power)
   \                     USB_OTG_UngateClock: (+1)
   \   00000000   0x7A81             LDRB     R1,[R0, #+10]
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD00E             BEQ.N    ??USB_OTG_UngateClock_0
   2013            {
   2014              
   2015              USB_OTG_DSTS_TypeDef     dsts;
   2016              USB_OTG_PCGCCTL_TypeDef  power; 
   2017              
   2018              dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
   \   00000006   0x6903             LDR      R3,[R0, #+16]
   \   00000008   0x689B             LDR      R3,[R3, #+8]
   \   0000000A   0x0019             MOVS     R1,R3
   2019              
   2020              if(dsts.b.suspsts == 1)
   \   0000000C   0x07CB             LSLS     R3,R1,#+31
   \   0000000E   0xD509             BPL.N    ??USB_OTG_UngateClock_0
   2021              {
   2022                /* un-gate USB Core clock */
   2023                power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
   \   00000010   0xF8D0 0x310C      LDR      R3,[R0, #+268]
   \   00000014   0x001A             MOVS     R2,R3
   2024                power.b.gatehclk = 0;
   \   00000016   0xF032 0x0202      BICS     R2,R2,#0x2
   2025                power.b.stoppclk = 0;
   \   0000001A   0x0852             LSRS     R2,R2,#+1
   \   0000001C   0x0052             LSLS     R2,R2,#+1
   2026                USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
   \   0000001E   0xF8D0 0x310C      LDR      R3,[R0, #+268]
   \   00000022   0x601A             STR      R2,[R3, #+0]
   2027                
   2028              }
   2029            }
   2030          }
   \                     ??USB_OTG_UngateClock_0: (+1)
   \   00000024   0x4770             BX       LR               ;; return
   2031          
   2032          /**
   2033          * @brief  Stop the device and clean up fifo's
   2034          * @param  None
   2035          * @retval : None
   2036          */

   \                                 In section .text, align 2, keep-with-next
   2037          void USB_OTG_StopDevice(USB_OTG_CORE_HANDLE *pdev)
   2038          {
   \                     USB_OTG_StopDevice: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2039            uint32_t i;
   2040            
   2041            pdev->dev.device_status = 1;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xF884 0x0112      STRB     R0,[R4, #+274]
   2042              
   2043            for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x0005             MOVS     R5,R0
   \                     ??USB_OTG_StopDevice_0: (+1)
   \   0000000E   0x7860             LDRB     R0,[R4, #+1]
   \   00000010   0x4285             CMP      R5,R0
   \   00000012   0xD20B             BCS.N    ??USB_OTG_StopDevice_1
   2044            {
   2045              USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
   \   00000014   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000018   0x6980             LDR      R0,[R0, #+24]
   \   0000001A   0x21FF             MOVS     R1,#+255
   \   0000001C   0x6081             STR      R1,[R0, #+8]
   2046              USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
   \   0000001E   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000022   0x6D40             LDR      R0,[R0, #+84]
   \   00000024   0x21FF             MOVS     R1,#+255
   \   00000026   0x6081             STR      R1,[R0, #+8]
   2047            }
   \   00000028   0x1C6D             ADDS     R5,R5,#+1
   \   0000002A   0xE7F0             B.N      ??USB_OTG_StopDevice_0
   2048          
   2049            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
   \                     ??USB_OTG_StopDevice_1: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x6921             LDR      R1,[R4, #+16]
   \   00000030   0x6108             STR      R0,[R1, #+16]
   2050            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x6921             LDR      R1,[R4, #+16]
   \   00000036   0x6148             STR      R0,[R1, #+20]
   2051            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x6921             LDR      R1,[R4, #+16]
   \   0000003C   0x61C8             STR      R0,[R1, #+28]
   2052            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );  
   \   0000003E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000042   0x6921             LDR      R1,[R4, #+16]
   \   00000044   0x6188             STR      R0,[R1, #+24]
   2053            
   2054            /* Flush the FIFO */
   2055            USB_OTG_FlushRxFifo(pdev);
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       USB_OTG_FlushRxFifo
   2056            USB_OTG_FlushTxFifo(pdev ,  0x10 );  
   \   0000004C   0x2110             MOVS     R1,#+16
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       USB_OTG_FlushTxFifo
   2057          }
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2058          
   2059          /**
   2060          * @brief  returns the EP Status
   2061          * @param  pdev : Selected device
   2062          *         ep : endpoint structure
   2063          * @retval : EP status
   2064          */
   2065          

   \                                 In section .text, align 2, keep-with-next
   2066          uint32_t USB_OTG_GetEPStatus(USB_OTG_CORE_HANDLE *pdev ,USB_OTG_EP *ep)
   2067          {
   \                     USB_OTG_GetEPStatus: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
   2068            USB_OTG_DEPCTL_TypeDef  depctl;
   2069            __IO uint32_t *depctl_addr;
   2070            uint32_t Status = 0;  
   \   00000004   0x2000             MOVS     R0,#+0
   2071            
   2072            depctl.d32 = 0;
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0x002B             MOVS     R3,R5
   2073            if (ep->is_in == 1)
   \   0000000A   0x784D             LDRB     R5,[R1, #+1]
   \   0000000C   0x2D01             CMP      R5,#+1
   \   0000000E   0xD117             BNE.N    ??USB_OTG_GetEPStatus_0
   2074            {
   2075              depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
   \   00000010   0x780D             LDRB     R5,[R1, #+0]
   \   00000012   0xEB12 0x0585      ADDS     R5,R2,R5, LSL #+2
   \   00000016   0x69AD             LDR      R5,[R5, #+24]
   \   00000018   0x002C             MOVS     R4,R5
   2076              depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
   \   0000001A   0x6825             LDR      R5,[R4, #+0]
   \   0000001C   0x002B             MOVS     R3,R5
   2077              
   2078              if (depctl.b.stall == 1)  
   \   0000001E   0xF3C3 0x5540      UBFX     R5,R3,#+21,#+1
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD002             BEQ.N    ??USB_OTG_GetEPStatus_1
   2079                Status = USB_OTG_EP_TX_STALL;
   \   00000026   0x2510             MOVS     R5,#+16
   \   00000028   0x0028             MOVS     R0,R5
   \   0000002A   0xE023             B.N      ??USB_OTG_GetEPStatus_2
   2080              else if (depctl.b.naksts == 1)
   \                     ??USB_OTG_GetEPStatus_1: (+1)
   \   0000002C   0xF3C3 0x4540      UBFX     R5,R3,#+17,#+1
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD002             BEQ.N    ??USB_OTG_GetEPStatus_3
   2081                Status = USB_OTG_EP_TX_NAK;
   \   00000034   0x2520             MOVS     R5,#+32
   \   00000036   0x0028             MOVS     R0,R5
   \   00000038   0xE01C             B.N      ??USB_OTG_GetEPStatus_2
   2082              else 
   2083                Status = USB_OTG_EP_TX_VALID;     
   \                     ??USB_OTG_GetEPStatus_3: (+1)
   \   0000003A   0x2530             MOVS     R5,#+48
   \   0000003C   0x0028             MOVS     R0,R5
   \   0000003E   0xE019             B.N      ??USB_OTG_GetEPStatus_2
   2084          
   2085            }
   2086            else
   2087            {
   2088              depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
   \                     ??USB_OTG_GetEPStatus_0: (+1)
   \   00000040   0x780D             LDRB     R5,[R1, #+0]
   \   00000042   0xEB12 0x0585      ADDS     R5,R2,R5, LSL #+2
   \   00000046   0x6D6D             LDR      R5,[R5, #+84]
   \   00000048   0x002C             MOVS     R4,R5
   2089              depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
   \   0000004A   0x6825             LDR      R5,[R4, #+0]
   \   0000004C   0x002B             MOVS     R3,R5
   2090              if (depctl.b.stall == 1)  
   \   0000004E   0xF3C3 0x5540      UBFX     R5,R3,#+21,#+1
   \   00000052   0x2D00             CMP      R5,#+0
   \   00000054   0xD003             BEQ.N    ??USB_OTG_GetEPStatus_4
   2091                Status = USB_OTG_EP_RX_STALL;
   \   00000056   0xF44F 0x5580      MOV      R5,#+4096
   \   0000005A   0x0028             MOVS     R0,R5
   \   0000005C   0xE00A             B.N      ??USB_OTG_GetEPStatus_2
   2092              else if (depctl.b.naksts == 1)
   \                     ??USB_OTG_GetEPStatus_4: (+1)
   \   0000005E   0xF3C3 0x4540      UBFX     R5,R3,#+17,#+1
   \   00000062   0x2D00             CMP      R5,#+0
   \   00000064   0xD003             BEQ.N    ??USB_OTG_GetEPStatus_5
   2093                Status = USB_OTG_EP_RX_NAK;
   \   00000066   0xF44F 0x5500      MOV      R5,#+8192
   \   0000006A   0x0028             MOVS     R0,R5
   \   0000006C   0xE002             B.N      ??USB_OTG_GetEPStatus_2
   2094              else 
   2095                Status = USB_OTG_EP_RX_VALID; 
   \                     ??USB_OTG_GetEPStatus_5: (+1)
   \   0000006E   0xF44F 0x5540      MOV      R5,#+12288
   \   00000072   0x0028             MOVS     R0,R5
   2096            } 
   2097            
   2098            /* Return the current status */
   2099            return Status;
   \                     ??USB_OTG_GetEPStatus_2: (+1)
   \   00000074   0xBC30             POP      {R4,R5}
   \   00000076   0x4770             BX       LR               ;; return
   2100          }
   2101          
   2102          /**
   2103          * @brief  Set the EP Status
   2104          * @param  pdev : Selected device
   2105          *         Status : new Status
   2106          *         ep : EP structure
   2107          * @retval : None
   2108          */

   \                                 In section .text, align 2, keep-with-next
   2109          void USB_OTG_SetEPStatus (USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep , uint32_t Status)
   2110          {
   \                     USB_OTG_SetEPStatus: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   2111            USB_OTG_DEPCTL_TypeDef  depctl;
   2112            __IO uint32_t *depctl_addr;
   2113            
   2114            depctl.d32 = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x0007             MOVS     R7,R0
   2115          
   2116            /* Process for IN endpoint */
   2117            if (ep->is_in == 1)
   \   0000000E   0x7868             LDRB     R0,[R5, #+1]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD12C             BNE.N    ??USB_OTG_SetEPStatus_0
   2118            {
   2119              depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
   \   00000014   0x7828             LDRB     R0,[R5, #+0]
   \   00000016   0xEB14 0x0080      ADDS     R0,R4,R0, LSL #+2
   \   0000001A   0x6980             LDR      R0,[R0, #+24]
   \   0000001C   0x4680             MOV      R8,R0
   2120              depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
   \   0000001E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000022   0x0007             MOVS     R7,R0
   2121              
   2122              if (Status == USB_OTG_EP_TX_STALL)  
   \   00000024   0x2E10             CMP      R6,#+16
   \   00000026   0xD104             BNE.N    ??USB_OTG_SetEPStatus_1
   2123              {
   2124                USB_OTG_EPSetStall(pdev, ep); return;
   \   00000028   0x0029             MOVS     R1,R5
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       USB_OTG_EPSetStall
   \   00000030   0xE04C             B.N      ??USB_OTG_SetEPStatus_2
   2125              }
   2126              else if (Status == USB_OTG_EP_TX_NAK)
   \                     ??USB_OTG_SetEPStatus_1: (+1)
   \   00000032   0x2E20             CMP      R6,#+32
   \   00000034   0xD102             BNE.N    ??USB_OTG_SetEPStatus_3
   2127                depctl.b.snak = 1;
   \   00000036   0xF057 0x6700      ORRS     R7,R7,#0x8000000
   \   0000003A   0xE045             B.N      ??USB_OTG_SetEPStatus_4
   2128              else if (Status == USB_OTG_EP_TX_VALID)
   \                     ??USB_OTG_SetEPStatus_3: (+1)
   \   0000003C   0x2E30             CMP      R6,#+48
   \   0000003E   0xD111             BNE.N    ??USB_OTG_SetEPStatus_5
   2129              {
   2130                if (depctl.b.stall == 1)
   \   00000040   0xF3C7 0x5040      UBFX     R0,R7,#+21,#+1
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD006             BEQ.N    ??USB_OTG_SetEPStatus_6
   2131                {  
   2132                  ep->even_odd_frame = 0;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x7168             STRB     R0,[R5, #+5]
   2133                  USB_OTG_EPClearStall(pdev, ep);
   \   0000004C   0x0029             MOVS     R1,R5
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       USB_OTG_EPClearStall
   2134                  return;
   \   00000054   0xE03A             B.N      ??USB_OTG_SetEPStatus_2
   2135                }      
   2136                depctl.b.cnak = 1;
   \                     ??USB_OTG_SetEPStatus_6: (+1)
   \   00000056   0xF057 0x6780      ORRS     R7,R7,#0x4000000
   2137                depctl.b.usbactep = 1; 
   \   0000005A   0xF457 0x4700      ORRS     R7,R7,#0x8000
   2138                depctl.b.epena = 1;
   \   0000005E   0xF057 0x4700      ORRS     R7,R7,#0x80000000
   \   00000062   0xE031             B.N      ??USB_OTG_SetEPStatus_4
   2139              }
   2140              else if (Status == USB_OTG_EP_TX_DIS)
   \                     ??USB_OTG_SetEPStatus_5: (+1)
   \   00000064   0x2E00             CMP      R6,#+0
   \   00000066   0xD12F             BNE.N    ??USB_OTG_SetEPStatus_4
   2141                depctl.b.usbactep = 0;
   \   00000068   0xF437 0x4700      BICS     R7,R7,#0x8000
   \   0000006C   0xE02C             B.N      ??USB_OTG_SetEPStatus_4
   2142            } 
   2143            else /* Process for OUT endpoint */
   2144            {
   2145              depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
   \                     ??USB_OTG_SetEPStatus_0: (+1)
   \   0000006E   0x7828             LDRB     R0,[R5, #+0]
   \   00000070   0xEB14 0x0080      ADDS     R0,R4,R0, LSL #+2
   \   00000074   0x6D40             LDR      R0,[R0, #+84]
   \   00000076   0x4680             MOV      R8,R0
   2146              depctl.d32 = USB_OTG_READ_REG32(depctl_addr);    
   \   00000078   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000007C   0x0007             MOVS     R7,R0
   2147              
   2148              if (Status == USB_OTG_EP_RX_STALL)  {
   \   0000007E   0xF5B6 0x5F80      CMP      R6,#+4096
   \   00000082   0xD102             BNE.N    ??USB_OTG_SetEPStatus_7
   2149                depctl.b.stall = 1;
   \   00000084   0xF457 0x1700      ORRS     R7,R7,#0x200000
   \   00000088   0xE01E             B.N      ??USB_OTG_SetEPStatus_4
   2150              }
   2151              else if (Status == USB_OTG_EP_RX_NAK)
   \                     ??USB_OTG_SetEPStatus_7: (+1)
   \   0000008A   0xF5B6 0x5F00      CMP      R6,#+8192
   \   0000008E   0xD102             BNE.N    ??USB_OTG_SetEPStatus_8
   2152                depctl.b.snak = 1;
   \   00000090   0xF057 0x6700      ORRS     R7,R7,#0x8000000
   \   00000094   0xE018             B.N      ??USB_OTG_SetEPStatus_4
   2153              else if (Status == USB_OTG_EP_RX_VALID)
   \                     ??USB_OTG_SetEPStatus_8: (+1)
   \   00000096   0xF5B6 0x5F40      CMP      R6,#+12288
   \   0000009A   0xD111             BNE.N    ??USB_OTG_SetEPStatus_9
   2154              {
   2155                if (depctl.b.stall == 1)
   \   0000009C   0xF3C7 0x5040      UBFX     R0,R7,#+21,#+1
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD006             BEQ.N    ??USB_OTG_SetEPStatus_10
   2156                {  
   2157                  ep->even_odd_frame = 0;
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x7168             STRB     R0,[R5, #+5]
   2158                  USB_OTG_EPClearStall(pdev, ep);
   \   000000A8   0x0029             MOVS     R1,R5
   \   000000AA   0x0020             MOVS     R0,R4
   \   000000AC   0x.... 0x....      BL       USB_OTG_EPClearStall
   2159                  return;
   \   000000B0   0xE00C             B.N      ??USB_OTG_SetEPStatus_2
   2160                }  
   2161                depctl.b.cnak = 1;
   \                     ??USB_OTG_SetEPStatus_10: (+1)
   \   000000B2   0xF057 0x6780      ORRS     R7,R7,#0x4000000
   2162                depctl.b.usbactep = 1;    
   \   000000B6   0xF457 0x4700      ORRS     R7,R7,#0x8000
   2163                depctl.b.epena = 1;
   \   000000BA   0xF057 0x4700      ORRS     R7,R7,#0x80000000
   \   000000BE   0xE003             B.N      ??USB_OTG_SetEPStatus_4
   2164              }
   2165              else if (Status == USB_OTG_EP_RX_DIS)
   \                     ??USB_OTG_SetEPStatus_9: (+1)
   \   000000C0   0x2E00             CMP      R6,#+0
   \   000000C2   0xD101             BNE.N    ??USB_OTG_SetEPStatus_4
   2166              {
   2167                depctl.b.usbactep = 0;    
   \   000000C4   0xF437 0x4700      BICS     R7,R7,#0x8000
   2168              }
   2169            }
   2170          
   2171            USB_OTG_WRITE_REG32(depctl_addr, depctl.d32); 
   \                     ??USB_OTG_SetEPStatus_4: (+1)
   \   000000C8   0xF8C8 0x7000      STR      R7,[R8, #+0]
   2172          }
   \                     ??USB_OTG_SetEPStatus_2: (+1)
   \   000000CC   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x00030D41         DC32     0x30d41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x40040000         DC32     0x40040000
   2173          
   2174          #endif
   2175          /**
   2176          * @}
   2177          */ 
   2178          
   2179          /**
   2180          * @}
   2181          */ 
   2182          
   2183          /**
   2184          * @}
   2185          */
   2186          
   2187          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   USB_OTG_ActiveRemoteWakeup
        24   -> USB_OTG_BSP_mDelay
      32   USB_OTG_CoreInit
        32   -> USB_OTG_BSP_mDelay
        32   -> USB_OTG_CoreReset
      40   USB_OTG_CoreInitDev
        40   -> USB_OTG_EnableDevInt
        40   -> USB_OTG_FlushRxFifo
        40   -> USB_OTG_FlushTxFifo
        40   -> USB_OTG_InitDevSpeed
      24   USB_OTG_CoreReset
        24   -> USB_OTG_BSP_uDelay
       4   USB_OTG_DisableGlobalInt
      12   USB_OTG_EP0Activate
      24   USB_OTG_EP0StartXfer
       8   USB_OTG_EP0_OutStart
      16   USB_OTG_EPActivate
       8   USB_OTG_EPClearStall
      16   USB_OTG_EPDeactivate
       8   USB_OTG_EPSetStall
      32   USB_OTG_EPStartXfer
        32   -> USB_OTG_WritePacket
       0   USB_OTG_EnableCommonInt
      16   USB_OTG_EnableDevInt
        16   -> USB_OTG_EnableCommonInt
       4   USB_OTG_EnableGlobalInt
      24   USB_OTG_FlushRxFifo
        24   -> USB_OTG_BSP_uDelay
      24   USB_OTG_FlushTxFifo
        24   -> USB_OTG_BSP_uDelay
       0   USB_OTG_GetDeviceSpeed
       8   USB_OTG_GetEPStatus
       0   USB_OTG_GetMode
       0   USB_OTG_InitDevSpeed
       8   USB_OTG_IsDeviceMode
         8   -> USB_OTG_GetMode
       8   USB_OTG_IsHostMode
         8   -> USB_OTG_GetMode
       0   USB_OTG_ReadCoreItr
       0   USB_OTG_ReadDevAllInEPItr
       0   USB_OTG_ReadDevAllOutEp_itr
       0   USB_OTG_ReadDevOutEP_itr
       0   USB_OTG_ReadOtgItr
      12   USB_OTG_ReadPacket
      12   USB_OTG_SelectCore
      24   USB_OTG_SetCurrentMode
        24   -> USB_OTG_BSP_mDelay
      24   USB_OTG_SetEPStatus
        24   -> USB_OTG_EPClearStall
        24   -> USB_OTG_EPSetStall
      16   USB_OTG_StopDevice
        16   -> USB_OTG_FlushRxFifo
        16   -> USB_OTG_FlushTxFifo
       0   USB_OTG_UngateClock
      20   USB_OTG_WritePacket


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
      84  USB_OTG_ActiveRemoteWakeup
     308  USB_OTG_CoreInit
     416  USB_OTG_CoreInitDev
      96  USB_OTG_CoreReset
      30  USB_OTG_DisableGlobalInt
      80  USB_OTG_EP0Activate
     300  USB_OTG_EP0StartXfer
      82  USB_OTG_EP0_OutStart
     122  USB_OTG_EPActivate
      70  USB_OTG_EPClearStall
      88  USB_OTG_EPDeactivate
      74  USB_OTG_EPSetStall
     396  USB_OTG_EPStartXfer
      34  USB_OTG_EnableCommonInt
      90  USB_OTG_EnableDevInt
      30  USB_OTG_EnableGlobalInt
      64  USB_OTG_FlushRxFifo
      72  USB_OTG_FlushTxFifo
      52  USB_OTG_GetDeviceSpeed
     120  USB_OTG_GetEPStatus
      10  USB_OTG_GetMode
      18  USB_OTG_InitDevSpeed
      24  USB_OTG_IsDeviceMode
      24  USB_OTG_IsHostMode
      18  USB_OTG_ReadCoreItr
      18  USB_OTG_ReadDevAllInEPItr
      18  USB_OTG_ReadDevAllOutEp_itr
      22  USB_OTG_ReadDevOutEP_itr
       6  USB_OTG_ReadOtgItr
      44  USB_OTG_ReadPacket
     226  USB_OTG_SelectCore
      60  USB_OTG_SetCurrentMode
     208  USB_OTG_SetEPStatus
      86  USB_OTG_StopDevice
      38  USB_OTG_UngateClock
      72  USB_OTG_WritePacket

 
 3 508 bytes in section .text
 
 3 508 bytes of CODE memory

Errors: none
Warnings: 1
