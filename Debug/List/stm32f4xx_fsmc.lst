###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       06/May/2016  23:31:33
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\IAR
#        Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_fsmc.c
#    Command line =  
#        "D:\IAR
#        Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_fsmc.c"
#        -D USE_STDPERIPH_DRIVER -D STM32F4XX -D USE_FULL_ASSERT -lCN "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\List" -o "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\Obj" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\Include\" -I
#        "D:\IAR Workspace\STM32F407\VCP_ESP\..\Utilities\STM32F4-Discovery\"
#        -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\ST\STM32F4xx\Include\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_conf\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\cdc\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\otg\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\core\" -On --use_c++_inline -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    List file    =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\Debug\List\stm32f4xx_fsmc.lst
#    Object file  =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\Debug\Obj\stm32f4xx_fsmc.o
#
###############################################################################

D:\IAR Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_fsmc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_fsmc.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    30-September-2011
      7           * @brief    This file provides firmware functions to manage the following 
      8            *          functionalities of the FSMC peripheral:           
      9            *           - Interface with SRAM, PSRAM, NOR and OneNAND memories
     10            *           - Interface with NAND memories
     11            *           - Interface with 16-bit PC Card compatible memories  
     12            *           - Interrupts and flags management   
     13            *           
     14            ******************************************************************************
     15          
     16            * @attention
     17            *
     18            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     19            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     20            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     21            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     22            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     23            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     24            *
     25            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     26            ******************************************************************************
     27            */
     28          
     29          /* Includes ------------------------------------------------------------------*/
     30          #include "stm32f4xx_fsmc.h"
     31          #include "stm32f4xx_rcc.h"
     32          
     33          /** @addtogroup STM32F4xx_StdPeriph_Driver
     34            * @{
     35            */
     36          
     37          /** @defgroup FSMC 
     38            * @brief FSMC driver modules
     39            * @{
     40            */ 
     41          
     42          /* Private typedef -----------------------------------------------------------*/
     43          /* Private define ------------------------------------------------------------*/
     44          
     45          /* --------------------- FSMC registers bit mask ---------------------------- */
     46          /* FSMC BCRx Mask */
     47          #define BCR_MBKEN_SET          ((uint32_t)0x00000001)
     48          #define BCR_MBKEN_RESET        ((uint32_t)0x000FFFFE)
     49          #define BCR_FACCEN_SET         ((uint32_t)0x00000040)
     50          
     51          /* FSMC PCRx Mask */
     52          #define PCR_PBKEN_SET          ((uint32_t)0x00000004)
     53          #define PCR_PBKEN_RESET        ((uint32_t)0x000FFFFB)
     54          #define PCR_ECCEN_SET          ((uint32_t)0x00000040)
     55          #define PCR_ECCEN_RESET        ((uint32_t)0x000FFFBF)
     56          #define PCR_MEMORYTYPE_NAND    ((uint32_t)0x00000008)
     57          
     58          /* Private macro -------------------------------------------------------------*/
     59          /* Private variables ---------------------------------------------------------*/
     60          /* Private function prototypes -----------------------------------------------*/
     61          /* Private functions ---------------------------------------------------------*/
     62          
     63          /** @defgroup FSMC_Private_Functions
     64            * @{
     65            */
     66          
     67          /** @defgroup FSMC_Group1 NOR/SRAM Controller functions
     68           *  @brief   NOR/SRAM Controller functions 
     69           *
     70          @verbatim   
     71           ===============================================================================
     72                              NOR/SRAM Controller functions
     73           ===============================================================================  
     74          
     75           The following sequence should be followed to configure the FSMC to interface with
     76           SRAM, PSRAM, NOR or OneNAND memory connected to the NOR/SRAM Bank:
     77           
     78             1. Enable the clock for the FSMC and associated GPIOs using the following functions:
     79                    RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC, ENABLE);
     80                    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);
     81          
     82             2. FSMC pins configuration 
     83                 - Connect the involved FSMC pins to AF12 using the following function 
     84                    GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_FSMC); 
     85                 - Configure these FSMC pins in alternate function mode by calling the function
     86                    GPIO_Init();    
     87                 
     88             3. Declare a FSMC_NORSRAMInitTypeDef structure, for example:
     89                    FSMC_NORSRAMInitTypeDef  FSMC_NORSRAMInitStructure;
     90                and fill the FSMC_NORSRAMInitStructure variable with the allowed values of
     91                the structure member.
     92                
     93             4. Initialize the NOR/SRAM Controller by calling the function
     94                    FSMC_NORSRAMInit(&FSMC_NORSRAMInitStructure); 
     95          
     96             5. Then enable the NOR/SRAM Bank, for example:
     97                    FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM2, ENABLE);  
     98          
     99             6. At this stage you can read/write from/to the memory connected to the NOR/SRAM Bank. 
    100             
    101          @endverbatim
    102            * @{
    103            */
    104          
    105          /**
    106            * @brief  Deinitializes the FSMC NOR/SRAM Banks registers to their default 
    107            *   reset values.
    108            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    109            *          This parameter can be one of the following values:
    110            *            @arg FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
    111            *            @arg FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
    112            *            @arg FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
    113            *            @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
    114            * @retval None
    115            */

   \                                 In section .text, align 2, keep-with-next
    116          void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)
    117          {
   \                     FSMC_NORSRAMDeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    118            /* Check the parameter */
    119            assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD00A             BEQ.N    ??FSMC_NORSRAMDeInit_0
   \   00000008   0x2C02             CMP      R4,#+2
   \   0000000A   0xD008             BEQ.N    ??FSMC_NORSRAMDeInit_0
   \   0000000C   0x2C04             CMP      R4,#+4
   \   0000000E   0xD006             BEQ.N    ??FSMC_NORSRAMDeInit_0
   \   00000010   0x2C06             CMP      R4,#+6
   \   00000012   0xD004             BEQ.N    ??FSMC_NORSRAMDeInit_0
   \   00000014   0x2177             MOVS     R1,#+119
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000001A   0x.... 0x....      BL       assert_failed
    120            
    121            /* FSMC_Bank1_NORSRAM1 */
    122            if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
   \                     ??FSMC_NORSRAMDeInit_0: (+1)
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD106             BNE.N    ??FSMC_NORSRAMDeInit_1
    123            {
    124              FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
   \   00000022   0xF243 0x00DB      MOVW     R0,#+12507
   \   00000026   0x00A1             LSLS     R1,R4,#+2
   \   00000028   0xF1B1 0x41C0      SUBS     R1,R1,#+1610612736
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   \   0000002E   0xE005             B.N      ??FSMC_NORSRAMDeInit_2
    125            }
    126            /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
    127            else
    128            {   
    129              FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
   \                     ??FSMC_NORSRAMDeInit_1: (+1)
   \   00000030   0xF243 0x00D2      MOVW     R0,#+12498
   \   00000034   0x00A1             LSLS     R1,R4,#+2
   \   00000036   0xF1B1 0x41C0      SUBS     R1,R1,#+1610612736
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    130            }
    131            FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
   \                     ??FSMC_NORSRAMDeInit_2: (+1)
   \   0000003C   0xF07F 0x4070      MVNS     R0,#-268435456
   \   00000040   0x00A1             LSLS     R1,R4,#+2
   \   00000042   0xF1B1 0x41C0      SUBS     R1,R1,#+1610612736
   \   00000046   0x6048             STR      R0,[R1, #+4]
    132            FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
   \   00000048   0xF07F 0x4070      MVNS     R0,#-268435456
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0xa0000104
   \   00000050   0xF841 0x0024      STR      R0,[R1, R4, LSL #+2]
    133          }
   \   00000054   0xBD10             POP      {R4,PC}          ;; return
    134          
    135          /**
    136            * @brief  Initializes the FSMC NOR/SRAM Banks according to the specified
    137            *         parameters in the FSMC_NORSRAMInitStruct.
    138            * @param  FSMC_NORSRAMInitStruct : pointer to a FSMC_NORSRAMInitTypeDef structure
    139            *         that contains the configuration information for the FSMC NOR/SRAM 
    140            *         specified Banks.                       
    141            * @retval None
    142            */

   \                                 In section .text, align 2, keep-with-next
    143          void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
    144          { 
   \                     FSMC_NORSRAMInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    145            /* Check the parameters */
    146            assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD00D             BEQ.N    ??FSMC_NORSRAMInit_0
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD00A             BEQ.N    ??FSMC_NORSRAMInit_0
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x2804             CMP      R0,#+4
   \   00000014   0xD007             BEQ.N    ??FSMC_NORSRAMInit_0
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x2806             CMP      R0,#+6
   \   0000001A   0xD004             BEQ.N    ??FSMC_NORSRAMInit_0
   \   0000001C   0x2192             MOVS     R1,#+146
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000022   0x.... 0x....      BL       assert_failed
    147            assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));
   \                     ??FSMC_NORSRAMInit_0: (+1)
   \   00000026   0x6860             LDR      R0,[R4, #+4]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD007             BEQ.N    ??FSMC_NORSRAMInit_1
   \   0000002C   0x6860             LDR      R0,[R4, #+4]
   \   0000002E   0x2802             CMP      R0,#+2
   \   00000030   0xD004             BEQ.N    ??FSMC_NORSRAMInit_1
   \   00000032   0x2193             MOVS     R1,#+147
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000038   0x.... 0x....      BL       assert_failed
    148            assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));
   \                     ??FSMC_NORSRAMInit_1: (+1)
   \   0000003C   0x68A0             LDR      R0,[R4, #+8]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD00A             BEQ.N    ??FSMC_NORSRAMInit_2
   \   00000042   0x68A0             LDR      R0,[R4, #+8]
   \   00000044   0x2804             CMP      R0,#+4
   \   00000046   0xD007             BEQ.N    ??FSMC_NORSRAMInit_2
   \   00000048   0x68A0             LDR      R0,[R4, #+8]
   \   0000004A   0x2808             CMP      R0,#+8
   \   0000004C   0xD004             BEQ.N    ??FSMC_NORSRAMInit_2
   \   0000004E   0x2194             MOVS     R1,#+148
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000054   0x.... 0x....      BL       assert_failed
    149            assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));
   \                     ??FSMC_NORSRAMInit_2: (+1)
   \   00000058   0x68E0             LDR      R0,[R4, #+12]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD007             BEQ.N    ??FSMC_NORSRAMInit_3
   \   0000005E   0x68E0             LDR      R0,[R4, #+12]
   \   00000060   0x2810             CMP      R0,#+16
   \   00000062   0xD004             BEQ.N    ??FSMC_NORSRAMInit_3
   \   00000064   0x2195             MOVS     R1,#+149
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000006A   0x.... 0x....      BL       assert_failed
    150            assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));
   \                     ??FSMC_NORSRAMInit_3: (+1)
   \   0000006E   0x6920             LDR      R0,[R4, #+16]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD008             BEQ.N    ??FSMC_NORSRAMInit_4
   \   00000074   0x6920             LDR      R0,[R4, #+16]
   \   00000076   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000007A   0xD004             BEQ.N    ??FSMC_NORSRAMInit_4
   \   0000007C   0x2196             MOVS     R1,#+150
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000082   0x.... 0x....      BL       assert_failed
    151            assert_param(IS_FSMC_ASYNWAIT(FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait));
   \                     ??FSMC_NORSRAMInit_4: (+1)
   \   00000086   0x6960             LDR      R0,[R4, #+20]
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD008             BEQ.N    ??FSMC_NORSRAMInit_5
   \   0000008C   0x6960             LDR      R0,[R4, #+20]
   \   0000008E   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000092   0xD004             BEQ.N    ??FSMC_NORSRAMInit_5
   \   00000094   0x2197             MOVS     R1,#+151
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000009A   0x.... 0x....      BL       assert_failed
    152            assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));
   \                     ??FSMC_NORSRAMInit_5: (+1)
   \   0000009E   0x69A0             LDR      R0,[R4, #+24]
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD008             BEQ.N    ??FSMC_NORSRAMInit_6
   \   000000A4   0x69A0             LDR      R0,[R4, #+24]
   \   000000A6   0xF5B0 0x7F00      CMP      R0,#+512
   \   000000AA   0xD004             BEQ.N    ??FSMC_NORSRAMInit_6
   \   000000AC   0x2198             MOVS     R1,#+152
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable12
   \   000000B2   0x.... 0x....      BL       assert_failed
    153            assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));
   \                     ??FSMC_NORSRAMInit_6: (+1)
   \   000000B6   0x69E0             LDR      R0,[R4, #+28]
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD008             BEQ.N    ??FSMC_NORSRAMInit_7
   \   000000BC   0x69E0             LDR      R0,[R4, #+28]
   \   000000BE   0xF5B0 0x6F80      CMP      R0,#+1024
   \   000000C2   0xD004             BEQ.N    ??FSMC_NORSRAMInit_7
   \   000000C4   0x2199             MOVS     R1,#+153
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable12
   \   000000CA   0x.... 0x....      BL       assert_failed
    154            assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));
   \                     ??FSMC_NORSRAMInit_7: (+1)
   \   000000CE   0x6A20             LDR      R0,[R4, #+32]
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD008             BEQ.N    ??FSMC_NORSRAMInit_8
   \   000000D4   0x6A20             LDR      R0,[R4, #+32]
   \   000000D6   0xF5B0 0x6F00      CMP      R0,#+2048
   \   000000DA   0xD004             BEQ.N    ??FSMC_NORSRAMInit_8
   \   000000DC   0x219A             MOVS     R1,#+154
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable12
   \   000000E2   0x.... 0x....      BL       assert_failed
    155            assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));
   \                     ??FSMC_NORSRAMInit_8: (+1)
   \   000000E6   0x6A60             LDR      R0,[R4, #+36]
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD008             BEQ.N    ??FSMC_NORSRAMInit_9
   \   000000EC   0x6A60             LDR      R0,[R4, #+36]
   \   000000EE   0xF5B0 0x5F80      CMP      R0,#+4096
   \   000000F2   0xD004             BEQ.N    ??FSMC_NORSRAMInit_9
   \   000000F4   0x219B             MOVS     R1,#+155
   \   000000F6   0x.... 0x....      LDR.W    R0,??DataTable12
   \   000000FA   0x.... 0x....      BL       assert_failed
    156            assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));
   \                     ??FSMC_NORSRAMInit_9: (+1)
   \   000000FE   0x6AA0             LDR      R0,[R4, #+40]
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD008             BEQ.N    ??FSMC_NORSRAMInit_10
   \   00000104   0x6AA0             LDR      R0,[R4, #+40]
   \   00000106   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000010A   0xD004             BEQ.N    ??FSMC_NORSRAMInit_10
   \   0000010C   0x219C             MOVS     R1,#+156
   \   0000010E   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000112   0x.... 0x....      BL       assert_failed
    157            assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));
   \                     ??FSMC_NORSRAMInit_10: (+1)
   \   00000116   0x6AE0             LDR      R0,[R4, #+44]
   \   00000118   0x2800             CMP      R0,#+0
   \   0000011A   0xD008             BEQ.N    ??FSMC_NORSRAMInit_11
   \   0000011C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000011E   0xF5B0 0x4F80      CMP      R0,#+16384
   \   00000122   0xD004             BEQ.N    ??FSMC_NORSRAMInit_11
   \   00000124   0x219D             MOVS     R1,#+157
   \   00000126   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000012A   0x.... 0x....      BL       assert_failed
    158            assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));  
   \                     ??FSMC_NORSRAMInit_11: (+1)
   \   0000012E   0x6B20             LDR      R0,[R4, #+48]
   \   00000130   0x2800             CMP      R0,#+0
   \   00000132   0xD008             BEQ.N    ??FSMC_NORSRAMInit_12
   \   00000134   0x6B20             LDR      R0,[R4, #+48]
   \   00000136   0xF5B0 0x2F00      CMP      R0,#+524288
   \   0000013A   0xD004             BEQ.N    ??FSMC_NORSRAMInit_12
   \   0000013C   0x219E             MOVS     R1,#+158
   \   0000013E   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000142   0x.... 0x....      BL       assert_failed
    159            assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));
   \                     ??FSMC_NORSRAMInit_12: (+1)
   \   00000146   0x6B60             LDR      R0,[R4, #+52]
   \   00000148   0x6800             LDR      R0,[R0, #+0]
   \   0000014A   0x2810             CMP      R0,#+16
   \   0000014C   0xD304             BCC.N    ??FSMC_NORSRAMInit_13
   \   0000014E   0x219F             MOVS     R1,#+159
   \   00000150   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000154   0x.... 0x....      BL       assert_failed
    160            assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));
   \                     ??FSMC_NORSRAMInit_13: (+1)
   \   00000158   0x6B60             LDR      R0,[R4, #+52]
   \   0000015A   0x6840             LDR      R0,[R0, #+4]
   \   0000015C   0x2810             CMP      R0,#+16
   \   0000015E   0xD304             BCC.N    ??FSMC_NORSRAMInit_14
   \   00000160   0x21A0             MOVS     R1,#+160
   \   00000162   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000166   0x.... 0x....      BL       assert_failed
    161            assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));
   \                     ??FSMC_NORSRAMInit_14: (+1)
   \   0000016A   0x6B60             LDR      R0,[R4, #+52]
   \   0000016C   0x6880             LDR      R0,[R0, #+8]
   \   0000016E   0x2800             CMP      R0,#+0
   \   00000170   0xD003             BEQ.N    ??FSMC_NORSRAMInit_15
   \   00000172   0x6B60             LDR      R0,[R4, #+52]
   \   00000174   0x6880             LDR      R0,[R0, #+8]
   \   00000176   0x28FF             CMP      R0,#+255
   \   00000178   0xD904             BLS.N    ??FSMC_NORSRAMInit_16
   \                     ??FSMC_NORSRAMInit_15: (+1)
   \   0000017A   0x21A1             MOVS     R1,#+161
   \   0000017C   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000180   0x.... 0x....      BL       assert_failed
    162            assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));
   \                     ??FSMC_NORSRAMInit_16: (+1)
   \   00000184   0x6B60             LDR      R0,[R4, #+52]
   \   00000186   0x68C0             LDR      R0,[R0, #+12]
   \   00000188   0x2810             CMP      R0,#+16
   \   0000018A   0xD304             BCC.N    ??FSMC_NORSRAMInit_17
   \   0000018C   0x21A2             MOVS     R1,#+162
   \   0000018E   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000192   0x.... 0x....      BL       assert_failed
    163            assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
   \                     ??FSMC_NORSRAMInit_17: (+1)
   \   00000196   0x6B60             LDR      R0,[R4, #+52]
   \   00000198   0x6900             LDR      R0,[R0, #+16]
   \   0000019A   0x2810             CMP      R0,#+16
   \   0000019C   0xD304             BCC.N    ??FSMC_NORSRAMInit_18
   \   0000019E   0x21A3             MOVS     R1,#+163
   \   000001A0   0x.... 0x....      LDR.W    R0,??DataTable12
   \   000001A4   0x.... 0x....      BL       assert_failed
    164            assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
   \                     ??FSMC_NORSRAMInit_18: (+1)
   \   000001A8   0x6B60             LDR      R0,[R4, #+52]
   \   000001AA   0x6940             LDR      R0,[R0, #+20]
   \   000001AC   0x2810             CMP      R0,#+16
   \   000001AE   0xD304             BCC.N    ??FSMC_NORSRAMInit_19
   \   000001B0   0x21A4             MOVS     R1,#+164
   \   000001B2   0x.... 0x....      LDR.W    R0,??DataTable12
   \   000001B6   0x.... 0x....      BL       assert_failed
    165            assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
   \                     ??FSMC_NORSRAMInit_19: (+1)
   \   000001BA   0x6B60             LDR      R0,[R4, #+52]
   \   000001BC   0x6980             LDR      R0,[R0, #+24]
   \   000001BE   0x2800             CMP      R0,#+0
   \   000001C0   0xD013             BEQ.N    ??FSMC_NORSRAMInit_20
   \   000001C2   0x6B60             LDR      R0,[R4, #+52]
   \   000001C4   0x6980             LDR      R0,[R0, #+24]
   \   000001C6   0xF1B0 0x5F80      CMP      R0,#+268435456
   \   000001CA   0xD00E             BEQ.N    ??FSMC_NORSRAMInit_20
   \   000001CC   0x6B60             LDR      R0,[R4, #+52]
   \   000001CE   0x6980             LDR      R0,[R0, #+24]
   \   000001D0   0xF1B0 0x5F00      CMP      R0,#+536870912
   \   000001D4   0xD009             BEQ.N    ??FSMC_NORSRAMInit_20
   \   000001D6   0x6B60             LDR      R0,[R4, #+52]
   \   000001D8   0x6980             LDR      R0,[R0, #+24]
   \   000001DA   0xF1B0 0x5F40      CMP      R0,#+805306368
   \   000001DE   0xD004             BEQ.N    ??FSMC_NORSRAMInit_20
   \   000001E0   0x21A5             MOVS     R1,#+165
   \   000001E2   0x.... 0x....      LDR.W    R0,??DataTable12
   \   000001E6   0x.... 0x....      BL       assert_failed
    166            
    167            /* Bank1 NOR/SRAM control register configuration */ 
    168            FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
    169                      (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
    170                      FSMC_NORSRAMInitStruct->FSMC_MemoryType |
    171                      FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
    172                      FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
    173                      FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
    174                      FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
    175                      FSMC_NORSRAMInitStruct->FSMC_WrapMode |
    176                      FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
    177                      FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
    178                      FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
    179                      FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
    180                      FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
   \                     ??FSMC_NORSRAMInit_20: (+1)
   \   000001EA   0x6860             LDR      R0,[R4, #+4]
   \   000001EC   0x68A1             LDR      R1,[R4, #+8]
   \   000001EE   0x4308             ORRS     R0,R1,R0
   \   000001F0   0x68E1             LDR      R1,[R4, #+12]
   \   000001F2   0x4308             ORRS     R0,R1,R0
   \   000001F4   0x6921             LDR      R1,[R4, #+16]
   \   000001F6   0x4308             ORRS     R0,R1,R0
   \   000001F8   0x6961             LDR      R1,[R4, #+20]
   \   000001FA   0x4308             ORRS     R0,R1,R0
   \   000001FC   0x69A1             LDR      R1,[R4, #+24]
   \   000001FE   0x4308             ORRS     R0,R1,R0
   \   00000200   0x69E1             LDR      R1,[R4, #+28]
   \   00000202   0x4308             ORRS     R0,R1,R0
   \   00000204   0x6A21             LDR      R1,[R4, #+32]
   \   00000206   0x4308             ORRS     R0,R1,R0
   \   00000208   0x6A61             LDR      R1,[R4, #+36]
   \   0000020A   0x4308             ORRS     R0,R1,R0
   \   0000020C   0x6AA1             LDR      R1,[R4, #+40]
   \   0000020E   0x4308             ORRS     R0,R1,R0
   \   00000210   0x6AE1             LDR      R1,[R4, #+44]
   \   00000212   0x4308             ORRS     R0,R1,R0
   \   00000214   0x6B21             LDR      R1,[R4, #+48]
   \   00000216   0x4308             ORRS     R0,R1,R0
   \   00000218   0x6821             LDR      R1,[R4, #+0]
   \   0000021A   0x0089             LSLS     R1,R1,#+2
   \   0000021C   0xF1B1 0x41C0      SUBS     R1,R1,#+1610612736
   \   00000220   0x6008             STR      R0,[R1, #+0]
    181            if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
   \   00000222   0x68A0             LDR      R0,[R4, #+8]
   \   00000224   0x2808             CMP      R0,#+8
   \   00000226   0xD10B             BNE.N    ??FSMC_NORSRAMInit_21
    182            {
    183              FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_SET;
   \   00000228   0x6820             LDR      R0,[R4, #+0]
   \   0000022A   0x0080             LSLS     R0,R0,#+2
   \   0000022C   0xF1B0 0x40C0      SUBS     R0,R0,#+1610612736
   \   00000230   0x6800             LDR      R0,[R0, #+0]
   \   00000232   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000236   0x6821             LDR      R1,[R4, #+0]
   \   00000238   0x0089             LSLS     R1,R1,#+2
   \   0000023A   0xF1B1 0x41C0      SUBS     R1,R1,#+1610612736
   \   0000023E   0x6008             STR      R0,[R1, #+0]
    184            }
    185            /* Bank1 NOR/SRAM timing register configuration */
    186            FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
    187                      (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
    188                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
    189                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
    190                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
    191                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
    192                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
    193                       FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
   \                     ??FSMC_NORSRAMInit_21: (+1)
   \   00000240   0x6B60             LDR      R0,[R4, #+52]
   \   00000242   0x6800             LDR      R0,[R0, #+0]
   \   00000244   0x6B61             LDR      R1,[R4, #+52]
   \   00000246   0x6849             LDR      R1,[R1, #+4]
   \   00000248   0xEA50 0x1001      ORRS     R0,R0,R1, LSL #+4
   \   0000024C   0x6B61             LDR      R1,[R4, #+52]
   \   0000024E   0x6889             LDR      R1,[R1, #+8]
   \   00000250   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000254   0x6B61             LDR      R1,[R4, #+52]
   \   00000256   0x68C9             LDR      R1,[R1, #+12]
   \   00000258   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   0000025C   0x6B61             LDR      R1,[R4, #+52]
   \   0000025E   0x6909             LDR      R1,[R1, #+16]
   \   00000260   0xEA50 0x5001      ORRS     R0,R0,R1, LSL #+20
   \   00000264   0x6B61             LDR      R1,[R4, #+52]
   \   00000266   0x6949             LDR      R1,[R1, #+20]
   \   00000268   0xEA50 0x6001      ORRS     R0,R0,R1, LSL #+24
   \   0000026C   0x6B61             LDR      R1,[R4, #+52]
   \   0000026E   0x6989             LDR      R1,[R1, #+24]
   \   00000270   0x4308             ORRS     R0,R1,R0
   \   00000272   0x6821             LDR      R1,[R4, #+0]
   \   00000274   0x0089             LSLS     R1,R1,#+2
   \   00000276   0xF1B1 0x41C0      SUBS     R1,R1,#+1610612736
   \   0000027A   0x6048             STR      R0,[R1, #+4]
    194                      
    195              
    196            /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
    197            if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
   \   0000027C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000027E   0xF5B0 0x4F80      CMP      R0,#+16384
   \   00000282   0xD163             BNE.N    ??FSMC_NORSRAMInit_22
    198            {
    199              assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));
   \   00000284   0x6BA0             LDR      R0,[R4, #+56]
   \   00000286   0x6800             LDR      R0,[R0, #+0]
   \   00000288   0x2810             CMP      R0,#+16
   \   0000028A   0xD304             BCC.N    ??FSMC_NORSRAMInit_23
   \   0000028C   0x21C7             MOVS     R1,#+199
   \   0000028E   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000292   0x.... 0x....      BL       assert_failed
    200              assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
   \                     ??FSMC_NORSRAMInit_23: (+1)
   \   00000296   0x6BA0             LDR      R0,[R4, #+56]
   \   00000298   0x6840             LDR      R0,[R0, #+4]
   \   0000029A   0x2810             CMP      R0,#+16
   \   0000029C   0xD304             BCC.N    ??FSMC_NORSRAMInit_24
   \   0000029E   0x21C8             MOVS     R1,#+200
   \   000002A0   0x.... 0x....      LDR.W    R0,??DataTable12
   \   000002A4   0x.... 0x....      BL       assert_failed
    201              assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
   \                     ??FSMC_NORSRAMInit_24: (+1)
   \   000002A8   0x6BA0             LDR      R0,[R4, #+56]
   \   000002AA   0x6880             LDR      R0,[R0, #+8]
   \   000002AC   0x2800             CMP      R0,#+0
   \   000002AE   0xD003             BEQ.N    ??FSMC_NORSRAMInit_25
   \   000002B0   0x6BA0             LDR      R0,[R4, #+56]
   \   000002B2   0x6880             LDR      R0,[R0, #+8]
   \   000002B4   0x28FF             CMP      R0,#+255
   \   000002B6   0xD904             BLS.N    ??FSMC_NORSRAMInit_26
   \                     ??FSMC_NORSRAMInit_25: (+1)
   \   000002B8   0x21C9             MOVS     R1,#+201
   \   000002BA   0x.... 0x....      LDR.W    R0,??DataTable12
   \   000002BE   0x.... 0x....      BL       assert_failed
    202              assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
   \                     ??FSMC_NORSRAMInit_26: (+1)
   \   000002C2   0x6BA0             LDR      R0,[R4, #+56]
   \   000002C4   0x6900             LDR      R0,[R0, #+16]
   \   000002C6   0x2810             CMP      R0,#+16
   \   000002C8   0xD304             BCC.N    ??FSMC_NORSRAMInit_27
   \   000002CA   0x21CA             MOVS     R1,#+202
   \   000002CC   0x.... 0x....      LDR.W    R0,??DataTable12
   \   000002D0   0x.... 0x....      BL       assert_failed
    203              assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
   \                     ??FSMC_NORSRAMInit_27: (+1)
   \   000002D4   0x6BA0             LDR      R0,[R4, #+56]
   \   000002D6   0x6940             LDR      R0,[R0, #+20]
   \   000002D8   0x2810             CMP      R0,#+16
   \   000002DA   0xD304             BCC.N    ??FSMC_NORSRAMInit_28
   \   000002DC   0x21CB             MOVS     R1,#+203
   \   000002DE   0x.... 0x....      LDR.W    R0,??DataTable12
   \   000002E2   0x.... 0x....      BL       assert_failed
    204              assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
   \                     ??FSMC_NORSRAMInit_28: (+1)
   \   000002E6   0x6BA0             LDR      R0,[R4, #+56]
   \   000002E8   0x6980             LDR      R0,[R0, #+24]
   \   000002EA   0x2800             CMP      R0,#+0
   \   000002EC   0xD013             BEQ.N    ??FSMC_NORSRAMInit_29
   \   000002EE   0x6BA0             LDR      R0,[R4, #+56]
   \   000002F0   0x6980             LDR      R0,[R0, #+24]
   \   000002F2   0xF1B0 0x5F80      CMP      R0,#+268435456
   \   000002F6   0xD00E             BEQ.N    ??FSMC_NORSRAMInit_29
   \   000002F8   0x6BA0             LDR      R0,[R4, #+56]
   \   000002FA   0x6980             LDR      R0,[R0, #+24]
   \   000002FC   0xF1B0 0x5F00      CMP      R0,#+536870912
   \   00000300   0xD009             BEQ.N    ??FSMC_NORSRAMInit_29
   \   00000302   0x6BA0             LDR      R0,[R4, #+56]
   \   00000304   0x6980             LDR      R0,[R0, #+24]
   \   00000306   0xF1B0 0x5F40      CMP      R0,#+805306368
   \   0000030A   0xD004             BEQ.N    ??FSMC_NORSRAMInit_29
   \   0000030C   0x21CC             MOVS     R1,#+204
   \   0000030E   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000312   0x.... 0x....      BL       assert_failed
    205              FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
    206                        (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
    207                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
    208                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
    209                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
    210                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
    211                         FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
   \                     ??FSMC_NORSRAMInit_29: (+1)
   \   00000316   0x6BA0             LDR      R0,[R4, #+56]
   \   00000318   0x6800             LDR      R0,[R0, #+0]
   \   0000031A   0x6BA1             LDR      R1,[R4, #+56]
   \   0000031C   0x6849             LDR      R1,[R1, #+4]
   \   0000031E   0xEA50 0x1001      ORRS     R0,R0,R1, LSL #+4
   \   00000322   0x6BA1             LDR      R1,[R4, #+56]
   \   00000324   0x6889             LDR      R1,[R1, #+8]
   \   00000326   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   0000032A   0x6BA1             LDR      R1,[R4, #+56]
   \   0000032C   0x6909             LDR      R1,[R1, #+16]
   \   0000032E   0xEA50 0x5001      ORRS     R0,R0,R1, LSL #+20
   \   00000332   0x6BA1             LDR      R1,[R4, #+56]
   \   00000334   0x6949             LDR      R1,[R1, #+20]
   \   00000336   0xEA50 0x6001      ORRS     R0,R0,R1, LSL #+24
   \   0000033A   0x6BA1             LDR      R1,[R4, #+56]
   \   0000033C   0x6989             LDR      R1,[R1, #+24]
   \   0000033E   0x4308             ORRS     R0,R1,R0
   \   00000340   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0xa0000104
   \   00000344   0x6822             LDR      R2,[R4, #+0]
   \   00000346   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
   \   0000034A   0xE006             B.N      ??FSMC_NORSRAMInit_30
    212            }
    213            else
    214            {
    215              FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
   \                     ??FSMC_NORSRAMInit_22: (+1)
   \   0000034C   0xF07F 0x4070      MVNS     R0,#-268435456
   \   00000350   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0xa0000104
   \   00000354   0x6822             LDR      R2,[R4, #+0]
   \   00000356   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
    216            }
    217          }
   \                     ??FSMC_NORSRAMInit_30: (+1)
   \   0000035A   0xBD10             POP      {R4,PC}          ;; return
    218          
    219          /**
    220            * @brief  Fills each FSMC_NORSRAMInitStruct member with its default value.
    221            * @param  FSMC_NORSRAMInitStruct: pointer to a FSMC_NORSRAMInitTypeDef structure 
    222            *         which will be initialized.
    223            * @retval None
    224            */

   \                                 In section .text, align 2, keep-with-next
    225          void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
    226          {  
    227            /* Reset NOR/SRAM Init structure parameters values */
    228            FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
   \                     FSMC_NORSRAMStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    229            FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
   \   00000004   0x2102             MOVS     R1,#+2
   \   00000006   0x6041             STR      R1,[R0, #+4]
    230            FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6081             STR      R1,[R0, #+8]
    231            FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
    232            FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6101             STR      R1,[R0, #+16]
    233            FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6141             STR      R1,[R0, #+20]
    234            FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x6181             STR      R1,[R0, #+24]
    235            FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x61C1             STR      R1,[R0, #+28]
    236            FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x6201             STR      R1,[R0, #+32]
    237            FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
   \   00000024   0xF44F 0x5180      MOV      R1,#+4096
   \   00000028   0x6241             STR      R1,[R0, #+36]
    238            FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
   \   0000002A   0xF44F 0x5100      MOV      R1,#+8192
   \   0000002E   0x6281             STR      R1,[R0, #+40]
    239            FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x62C1             STR      R1,[R0, #+44]
    240            FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x6301             STR      R1,[R0, #+48]
    241            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
   \   00000038   0x210F             MOVS     R1,#+15
   \   0000003A   0x6B42             LDR      R2,[R0, #+52]
   \   0000003C   0x6011             STR      R1,[R2, #+0]
    242            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
   \   0000003E   0x210F             MOVS     R1,#+15
   \   00000040   0x6B42             LDR      R2,[R0, #+52]
   \   00000042   0x6051             STR      R1,[R2, #+4]
    243            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
   \   00000044   0x21FF             MOVS     R1,#+255
   \   00000046   0x6B42             LDR      R2,[R0, #+52]
   \   00000048   0x6091             STR      R1,[R2, #+8]
    244            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
   \   0000004A   0x210F             MOVS     R1,#+15
   \   0000004C   0x6B42             LDR      R2,[R0, #+52]
   \   0000004E   0x60D1             STR      R1,[R2, #+12]
    245            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
   \   00000050   0x210F             MOVS     R1,#+15
   \   00000052   0x6B42             LDR      R2,[R0, #+52]
   \   00000054   0x6111             STR      R1,[R2, #+16]
    246            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
   \   00000056   0x210F             MOVS     R1,#+15
   \   00000058   0x6B42             LDR      R2,[R0, #+52]
   \   0000005A   0x6151             STR      R1,[R2, #+20]
    247            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
   \   0000005C   0x2100             MOVS     R1,#+0
   \   0000005E   0x6B42             LDR      R2,[R0, #+52]
   \   00000060   0x6191             STR      R1,[R2, #+24]
    248            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
   \   00000062   0x210F             MOVS     R1,#+15
   \   00000064   0x6B82             LDR      R2,[R0, #+56]
   \   00000066   0x6011             STR      R1,[R2, #+0]
    249            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;
   \   00000068   0x210F             MOVS     R1,#+15
   \   0000006A   0x6B82             LDR      R2,[R0, #+56]
   \   0000006C   0x6051             STR      R1,[R2, #+4]
    250            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;
   \   0000006E   0x21FF             MOVS     R1,#+255
   \   00000070   0x6B82             LDR      R2,[R0, #+56]
   \   00000072   0x6091             STR      R1,[R2, #+8]
    251            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
   \   00000074   0x210F             MOVS     R1,#+15
   \   00000076   0x6B82             LDR      R2,[R0, #+56]
   \   00000078   0x60D1             STR      R1,[R2, #+12]
    252            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;
   \   0000007A   0x210F             MOVS     R1,#+15
   \   0000007C   0x6B82             LDR      R2,[R0, #+56]
   \   0000007E   0x6111             STR      R1,[R2, #+16]
    253            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;
   \   00000080   0x210F             MOVS     R1,#+15
   \   00000082   0x6B82             LDR      R2,[R0, #+56]
   \   00000084   0x6151             STR      R1,[R2, #+20]
    254            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0x6B82             LDR      R2,[R0, #+56]
   \   0000008A   0x6191             STR      R1,[R2, #+24]
    255          }
   \   0000008C   0x4770             BX       LR               ;; return
    256          
    257          /**
    258            * @brief  Enables or disables the specified NOR/SRAM Memory Bank.
    259            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    260            *          This parameter can be one of the following values:
    261            *            @arg FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
    262            *            @arg FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
    263            *            @arg FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
    264            *            @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
    265            * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.
    266            * @retval None
    267            */

   \                                 In section .text, align 2, keep-with-next
    268          void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
    269          {
   \                     FSMC_NORSRAMCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    270            assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00B             BEQ.N    ??FSMC_NORSRAMCmd_0
   \   0000000A   0x2C02             CMP      R4,#+2
   \   0000000C   0xD009             BEQ.N    ??FSMC_NORSRAMCmd_0
   \   0000000E   0x2C04             CMP      R4,#+4
   \   00000010   0xD007             BEQ.N    ??FSMC_NORSRAMCmd_0
   \   00000012   0x2C06             CMP      R4,#+6
   \   00000014   0xD005             BEQ.N    ??FSMC_NORSRAMCmd_0
   \   00000016   0xF44F 0x7187      MOV      R1,#+270
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000001E   0x.... 0x....      BL       assert_failed
    271            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??FSMC_NORSRAMCmd_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD008             BEQ.N    ??FSMC_NORSRAMCmd_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD005             BEQ.N    ??FSMC_NORSRAMCmd_1
   \   0000002E   0xF240 0x110F      MOVW     R1,#+271
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000036   0x.... 0x....      BL       assert_failed
    272            
    273            if (NewState != DISABLE)
   \                     ??FSMC_NORSRAMCmd_1: (+1)
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xD00A             BEQ.N    ??FSMC_NORSRAMCmd_2
    274            {
    275              /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
    276              FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_SET;
   \   00000040   0x00A0             LSLS     R0,R4,#+2
   \   00000042   0xF1B0 0x40C0      SUBS     R0,R0,#+1610612736
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000004C   0x00A1             LSLS     R1,R4,#+2
   \   0000004E   0xF1B1 0x41C0      SUBS     R1,R1,#+1610612736
   \   00000052   0x6008             STR      R0,[R1, #+0]
   \   00000054   0xE00A             B.N      ??FSMC_NORSRAMCmd_3
    277            }
    278            else
    279            {
    280              /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
    281              FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_RESET;
   \                     ??FSMC_NORSRAMCmd_2: (+1)
   \   00000056   0x00A0             LSLS     R0,R4,#+2
   \   00000058   0xF1B0 0x40C0      SUBS     R0,R0,#+1610612736
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0xffffe
   \   00000062   0x4008             ANDS     R0,R1,R0
   \   00000064   0x00A1             LSLS     R1,R4,#+2
   \   00000066   0xF1B1 0x41C0      SUBS     R1,R1,#+1610612736
   \   0000006A   0x6008             STR      R0,[R1, #+0]
    282            }
    283          }
   \                     ??FSMC_NORSRAMCmd_3: (+1)
   \   0000006C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    284          /**
    285            * @}
    286            */
    287          
    288          /** @defgroup FSMC_Group2 NAND Controller functions
    289           *  @brief   NAND Controller functions 
    290           *
    291          @verbatim   
    292           ===============================================================================
    293                              NAND Controller functions
    294           ===============================================================================  
    295          
    296           The following sequence should be followed to configure the FSMC to interface with
    297           8-bit or 16-bit NAND memory connected to the NAND Bank:
    298           
    299             1. Enable the clock for the FSMC and associated GPIOs using the following functions:
    300                    RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC, ENABLE);
    301                    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);
    302          
    303             2. FSMC pins configuration 
    304                 - Connect the involved FSMC pins to AF12 using the following function 
    305                    GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_FSMC); 
    306                 - Configure these FSMC pins in alternate function mode by calling the function
    307                    GPIO_Init();    
    308                 
    309             3. Declare a FSMC_NANDInitTypeDef structure, for example:
    310                    FSMC_NANDInitTypeDef  FSMC_NANDInitStructure;
    311                and fill the FSMC_NANDInitStructure variable with the allowed values of
    312                the structure member.
    313                
    314             4. Initialize the NAND Controller by calling the function
    315                    FSMC_NANDInit(&FSMC_NANDInitStructure); 
    316          
    317             5. Then enable the NAND Bank, for example:
    318                    FSMC_NANDCmd(FSMC_Bank3_NAND, ENABLE);  
    319          
    320             6. At this stage you can read/write from/to the memory connected to the NAND Bank. 
    321             
    322          @note To enable the Error Correction Code (ECC), you have to use the function
    323                    FSMC_NANDECCCmd(FSMC_Bank3_NAND, ENABLE);  
    324                and to get the current ECC value you have to use the function
    325                    ECCval = FSMC_GetECC(FSMC_Bank3_NAND); 
    326          
    327          @endverbatim
    328            * @{
    329            */
    330            
    331          /**
    332            * @brief  Deinitializes the FSMC NAND Banks registers to their default reset values.
    333            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    334            *          This parameter can be one of the following values:
    335            *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    336            *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND 
    337            * @retval None
    338            */

   \                                 In section .text, align 2, keep-with-next
    339          void FSMC_NANDDeInit(uint32_t FSMC_Bank)
    340          {
   \                     FSMC_NANDDeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    341            /* Check the parameter */
    342            assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
   \   00000004   0x2C10             CMP      R4,#+16
   \   00000006   0xD008             BEQ.N    ??FSMC_NANDDeInit_0
   \   00000008   0xF5B4 0x7F80      CMP      R4,#+256
   \   0000000C   0xD005             BEQ.N    ??FSMC_NANDDeInit_0
   \   0000000E   0xF44F 0x71AB      MOV      R1,#+342
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000016   0x.... 0x....      BL       assert_failed
    343            
    344            if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     ??FSMC_NANDDeInit_0: (+1)
   \   0000001A   0x2C10             CMP      R4,#+16
   \   0000001C   0xD112             BNE.N    ??FSMC_NANDDeInit_1
    345            {
    346              /* Set the FSMC_Bank2 registers to their reset values */
    347              FSMC_Bank2->PCR2 = 0x00000018;
   \   0000001E   0x2018             MOVS     R0,#+24
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable15_1  ;; 0xa0000060
   \   00000024   0x6008             STR      R0,[R1, #+0]
    348              FSMC_Bank2->SR2 = 0x00000040;
   \   00000026   0x2040             MOVS     R0,#+64
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable15_2  ;; 0xa0000064
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    349              FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
   \   0000002E   0xF05F 0x30FC      MOVS     R0,#-50529028
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable15_3  ;; 0xa0000068
   \   00000036   0x6008             STR      R0,[R1, #+0]
    350              FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
   \   00000038   0xF05F 0x30FC      MOVS     R0,#-50529028
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable15_4  ;; 0xa000006c
   \   00000040   0x6008             STR      R0,[R1, #+0]
   \   00000042   0xE011             B.N      ??FSMC_NANDDeInit_2
    351            }
    352            /* FSMC_Bank3_NAND */  
    353            else
    354            {
    355              /* Set the FSMC_Bank3 registers to their reset values */
    356              FSMC_Bank3->PCR3 = 0x00000018;
   \                     ??FSMC_NANDDeInit_1: (+1)
   \   00000044   0x2018             MOVS     R0,#+24
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable15_5  ;; 0xa0000080
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    357              FSMC_Bank3->SR3 = 0x00000040;
   \   0000004C   0x2040             MOVS     R0,#+64
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable15_6  ;; 0xa0000084
   \   00000052   0x6008             STR      R0,[R1, #+0]
    358              FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
   \   00000054   0xF05F 0x30FC      MOVS     R0,#-50529028
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable15_7  ;; 0xa0000088
   \   0000005C   0x6008             STR      R0,[R1, #+0]
    359              FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
   \   0000005E   0xF05F 0x30FC      MOVS     R0,#-50529028
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable15_8  ;; 0xa000008c
   \   00000066   0x6008             STR      R0,[R1, #+0]
    360            }  
    361          }
   \                     ??FSMC_NANDDeInit_2: (+1)
   \   00000068   0xBD10             POP      {R4,PC}          ;; return
    362          
    363          /**
    364            * @brief  Initializes the FSMC NAND Banks according to the specified parameters
    365            *         in the FSMC_NANDInitStruct.
    366            * @param  FSMC_NANDInitStruct : pointer to a FSMC_NANDInitTypeDef structure that
    367            *         contains the configuration information for the FSMC NAND specified Banks.                       
    368            * @retval None
    369            */

   \                                 In section .text, align 2, keep-with-next
    370          void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
    371          {
   \                     FSMC_NANDInit: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    372            uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x2700             MOVS     R7,#+0
    373              
    374            /* Check the parameters */
    375            assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x2810             CMP      R0,#+16
   \   0000000E   0xD009             BEQ.N    ??FSMC_NANDInit_0
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000016   0xD005             BEQ.N    ??FSMC_NANDInit_0
   \   00000018   0xF240 0x1177      MOVW     R1,#+375
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000020   0x.... 0x....      BL       assert_failed
    376            assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));
   \                     ??FSMC_NANDInit_0: (+1)
   \   00000024   0x6860             LDR      R0,[R4, #+4]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD008             BEQ.N    ??FSMC_NANDInit_1
   \   0000002A   0x6860             LDR      R0,[R4, #+4]
   \   0000002C   0x2802             CMP      R0,#+2
   \   0000002E   0xD005             BEQ.N    ??FSMC_NANDInit_1
   \   00000030   0xF44F 0x71BC      MOV      R1,#+376
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000038   0x.... 0x....      BL       assert_failed
    377            assert_param( IS_FSMC_MEMORY_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));
   \                     ??FSMC_NANDInit_1: (+1)
   \   0000003C   0x68A0             LDR      R0,[R4, #+8]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD008             BEQ.N    ??FSMC_NANDInit_2
   \   00000042   0x68A0             LDR      R0,[R4, #+8]
   \   00000044   0x2810             CMP      R0,#+16
   \   00000046   0xD005             BEQ.N    ??FSMC_NANDInit_2
   \   00000048   0xF240 0x1179      MOVW     R1,#+377
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000050   0x.... 0x....      BL       assert_failed
    378            assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));
   \                     ??FSMC_NANDInit_2: (+1)
   \   00000054   0x68E0             LDR      R0,[R4, #+12]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD008             BEQ.N    ??FSMC_NANDInit_3
   \   0000005A   0x68E0             LDR      R0,[R4, #+12]
   \   0000005C   0x2840             CMP      R0,#+64
   \   0000005E   0xD005             BEQ.N    ??FSMC_NANDInit_3
   \   00000060   0xF44F 0x71BD      MOV      R1,#+378
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000068   0x.... 0x....      BL       assert_failed
    379            assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));
   \                     ??FSMC_NANDInit_3: (+1)
   \   0000006C   0x6920             LDR      R0,[R4, #+16]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD019             BEQ.N    ??FSMC_NANDInit_4
   \   00000072   0x6920             LDR      R0,[R4, #+16]
   \   00000074   0xF5B0 0x3F00      CMP      R0,#+131072
   \   00000078   0xD015             BEQ.N    ??FSMC_NANDInit_4
   \   0000007A   0x6920             LDR      R0,[R4, #+16]
   \   0000007C   0xF5B0 0x2F80      CMP      R0,#+262144
   \   00000080   0xD011             BEQ.N    ??FSMC_NANDInit_4
   \   00000082   0x6920             LDR      R0,[R4, #+16]
   \   00000084   0xF5B0 0x2FC0      CMP      R0,#+393216
   \   00000088   0xD00D             BEQ.N    ??FSMC_NANDInit_4
   \   0000008A   0x6920             LDR      R0,[R4, #+16]
   \   0000008C   0xF5B0 0x2F00      CMP      R0,#+524288
   \   00000090   0xD009             BEQ.N    ??FSMC_NANDInit_4
   \   00000092   0x6920             LDR      R0,[R4, #+16]
   \   00000094   0xF5B0 0x2F20      CMP      R0,#+655360
   \   00000098   0xD005             BEQ.N    ??FSMC_NANDInit_4
   \   0000009A   0xF240 0x117B      MOVW     R1,#+379
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable12
   \   000000A2   0x.... 0x....      BL       assert_failed
    380            assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));
   \                     ??FSMC_NANDInit_4: (+1)
   \   000000A6   0x6960             LDR      R0,[R4, #+20]
   \   000000A8   0x28FF             CMP      R0,#+255
   \   000000AA   0xD905             BLS.N    ??FSMC_NANDInit_5
   \   000000AC   0xF44F 0x71BE      MOV      R1,#+380
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable12
   \   000000B4   0x.... 0x....      BL       assert_failed
    381            assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));
   \                     ??FSMC_NANDInit_5: (+1)
   \   000000B8   0x69A0             LDR      R0,[R4, #+24]
   \   000000BA   0x28FF             CMP      R0,#+255
   \   000000BC   0xD905             BLS.N    ??FSMC_NANDInit_6
   \   000000BE   0xF240 0x117D      MOVW     R1,#+381
   \   000000C2   0x.... 0x....      LDR.W    R0,??DataTable12
   \   000000C6   0x.... 0x....      BL       assert_failed
    382            assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
   \                     ??FSMC_NANDInit_6: (+1)
   \   000000CA   0x69E0             LDR      R0,[R4, #+28]
   \   000000CC   0x6800             LDR      R0,[R0, #+0]
   \   000000CE   0x28FF             CMP      R0,#+255
   \   000000D0   0xD905             BLS.N    ??FSMC_NANDInit_7
   \   000000D2   0xF44F 0x71BF      MOV      R1,#+382
   \   000000D6   0x.... 0x....      LDR.W    R0,??DataTable12
   \   000000DA   0x.... 0x....      BL       assert_failed
    383            assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
   \                     ??FSMC_NANDInit_7: (+1)
   \   000000DE   0x69E0             LDR      R0,[R4, #+28]
   \   000000E0   0x6840             LDR      R0,[R0, #+4]
   \   000000E2   0x28FF             CMP      R0,#+255
   \   000000E4   0xD905             BLS.N    ??FSMC_NANDInit_8
   \   000000E6   0xF240 0x117F      MOVW     R1,#+383
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable12
   \   000000EE   0x.... 0x....      BL       assert_failed
    384            assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
   \                     ??FSMC_NANDInit_8: (+1)
   \   000000F2   0x69E0             LDR      R0,[R4, #+28]
   \   000000F4   0x6880             LDR      R0,[R0, #+8]
   \   000000F6   0x28FF             CMP      R0,#+255
   \   000000F8   0xD905             BLS.N    ??FSMC_NANDInit_9
   \   000000FA   0xF44F 0x71C0      MOV      R1,#+384
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000102   0x.... 0x....      BL       assert_failed
    385            assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
   \                     ??FSMC_NANDInit_9: (+1)
   \   00000106   0x69E0             LDR      R0,[R4, #+28]
   \   00000108   0x68C0             LDR      R0,[R0, #+12]
   \   0000010A   0x28FF             CMP      R0,#+255
   \   0000010C   0xD905             BLS.N    ??FSMC_NANDInit_10
   \   0000010E   0xF240 0x1181      MOVW     R1,#+385
   \   00000112   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000116   0x.... 0x....      BL       assert_failed
    386            assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
   \                     ??FSMC_NANDInit_10: (+1)
   \   0000011A   0x6A20             LDR      R0,[R4, #+32]
   \   0000011C   0x6800             LDR      R0,[R0, #+0]
   \   0000011E   0x28FF             CMP      R0,#+255
   \   00000120   0xD905             BLS.N    ??FSMC_NANDInit_11
   \   00000122   0xF44F 0x71C1      MOV      R1,#+386
   \   00000126   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000012A   0x.... 0x....      BL       assert_failed
    387            assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
   \                     ??FSMC_NANDInit_11: (+1)
   \   0000012E   0x6A20             LDR      R0,[R4, #+32]
   \   00000130   0x6840             LDR      R0,[R0, #+4]
   \   00000132   0x28FF             CMP      R0,#+255
   \   00000134   0xD905             BLS.N    ??FSMC_NANDInit_12
   \   00000136   0xF240 0x1183      MOVW     R1,#+387
   \   0000013A   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000013E   0x.... 0x....      BL       assert_failed
    388            assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
   \                     ??FSMC_NANDInit_12: (+1)
   \   00000142   0x6A20             LDR      R0,[R4, #+32]
   \   00000144   0x6880             LDR      R0,[R0, #+8]
   \   00000146   0x28FF             CMP      R0,#+255
   \   00000148   0xD905             BLS.N    ??FSMC_NANDInit_13
   \   0000014A   0xF44F 0x71C2      MOV      R1,#+388
   \   0000014E   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000152   0x.... 0x....      BL       assert_failed
    389            assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
   \                     ??FSMC_NANDInit_13: (+1)
   \   00000156   0x6A20             LDR      R0,[R4, #+32]
   \   00000158   0x68C0             LDR      R0,[R0, #+12]
   \   0000015A   0x28FF             CMP      R0,#+255
   \   0000015C   0xD905             BLS.N    ??FSMC_NANDInit_14
   \   0000015E   0xF240 0x1185      MOVW     R1,#+389
   \   00000162   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000166   0x.... 0x....      BL       assert_failed
    390            
    391            /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
    392            tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
    393                      PCR_MEMORYTYPE_NAND |
    394                      FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
    395                      FSMC_NANDInitStruct->FSMC_ECC |
    396                      FSMC_NANDInitStruct->FSMC_ECCPageSize |
    397                      (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
    398                      (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
   \                     ??FSMC_NANDInit_14: (+1)
   \   0000016A   0x6860             LDR      R0,[R4, #+4]
   \   0000016C   0x68A1             LDR      R1,[R4, #+8]
   \   0000016E   0x4308             ORRS     R0,R1,R0
   \   00000170   0x68E1             LDR      R1,[R4, #+12]
   \   00000172   0x4308             ORRS     R0,R1,R0
   \   00000174   0x6921             LDR      R1,[R4, #+16]
   \   00000176   0x4308             ORRS     R0,R1,R0
   \   00000178   0x6961             LDR      R1,[R4, #+20]
   \   0000017A   0xEA50 0x2041      ORRS     R0,R0,R1, LSL #+9
   \   0000017E   0x69A1             LDR      R1,[R4, #+24]
   \   00000180   0xEA50 0x3041      ORRS     R0,R0,R1, LSL #+13
   \   00000184   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000188   0x0005             MOVS     R5,R0
    399                      
    400            /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
    401            tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
    402                      (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    403                      (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    404                      (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
   \   0000018A   0x69E0             LDR      R0,[R4, #+28]
   \   0000018C   0x6800             LDR      R0,[R0, #+0]
   \   0000018E   0x69E1             LDR      R1,[R4, #+28]
   \   00000190   0x6849             LDR      R1,[R1, #+4]
   \   00000192   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000196   0x69E1             LDR      R1,[R4, #+28]
   \   00000198   0x6889             LDR      R1,[R1, #+8]
   \   0000019A   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   0000019E   0x69E1             LDR      R1,[R4, #+28]
   \   000001A0   0x68C9             LDR      R1,[R1, #+12]
   \   000001A2   0xEA50 0x6001      ORRS     R0,R0,R1, LSL #+24
   \   000001A6   0x0006             MOVS     R6,R0
    405                      
    406            /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
    407            tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
    408                      (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    409                      (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    410                      (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
   \   000001A8   0x6A20             LDR      R0,[R4, #+32]
   \   000001AA   0x6800             LDR      R0,[R0, #+0]
   \   000001AC   0x6A21             LDR      R1,[R4, #+32]
   \   000001AE   0x6849             LDR      R1,[R1, #+4]
   \   000001B0   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   000001B4   0x6A21             LDR      R1,[R4, #+32]
   \   000001B6   0x6889             LDR      R1,[R1, #+8]
   \   000001B8   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   000001BC   0x6A21             LDR      R1,[R4, #+32]
   \   000001BE   0x68C9             LDR      R1,[R1, #+12]
   \   000001C0   0xEA50 0x6001      ORRS     R0,R0,R1, LSL #+24
   \   000001C4   0x0007             MOVS     R7,R0
    411            
    412            if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
   \   000001C6   0x6820             LDR      R0,[R4, #+0]
   \   000001C8   0x2810             CMP      R0,#+16
   \   000001CA   0xD109             BNE.N    ??FSMC_NANDInit_15
    413            {
    414              /* FSMC_Bank2_NAND registers configuration */
    415              FSMC_Bank2->PCR2 = tmppcr;
   \   000001CC   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0xa0000060
   \   000001D0   0x6005             STR      R5,[R0, #+0]
    416              FSMC_Bank2->PMEM2 = tmppmem;
   \   000001D2   0x.... 0x....      LDR.W    R0,??DataTable15_3  ;; 0xa0000068
   \   000001D6   0x6006             STR      R6,[R0, #+0]
    417              FSMC_Bank2->PATT2 = tmppatt;
   \   000001D8   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0xa000006c
   \   000001DC   0x6007             STR      R7,[R0, #+0]
   \   000001DE   0xE008             B.N      ??FSMC_NANDInit_16
    418            }
    419            else
    420            {
    421              /* FSMC_Bank3_NAND registers configuration */
    422              FSMC_Bank3->PCR3 = tmppcr;
   \                     ??FSMC_NANDInit_15: (+1)
   \   000001E0   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0xa0000080
   \   000001E4   0x6005             STR      R5,[R0, #+0]
    423              FSMC_Bank3->PMEM3 = tmppmem;
   \   000001E6   0x.... 0x....      LDR.W    R0,??DataTable15_7  ;; 0xa0000088
   \   000001EA   0x6006             STR      R6,[R0, #+0]
    424              FSMC_Bank3->PATT3 = tmppatt;
   \   000001EC   0x.... 0x....      LDR.W    R0,??DataTable15_8  ;; 0xa000008c
   \   000001F0   0x6007             STR      R7,[R0, #+0]
    425            }
    426          }
   \                     ??FSMC_NANDInit_16: (+1)
   \   000001F2   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    427          
    428          
    429          /**
    430            * @brief  Fills each FSMC_NANDInitStruct member with its default value.
    431            * @param  FSMC_NANDInitStruct: pointer to a FSMC_NANDInitTypeDef structure which
    432            *         will be initialized.
    433            * @retval None
    434            */

   \                                 In section .text, align 2, keep-with-next
    435          void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
    436          { 
    437            /* Reset NAND Init structure parameters values */
    438            FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
   \                     FSMC_NANDStructInit: (+1)
   \   00000000   0x2110             MOVS     R1,#+16
   \   00000002   0x6001             STR      R1,[R0, #+0]
    439            FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6041             STR      R1,[R0, #+4]
    440            FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6081             STR      R1,[R0, #+8]
    441            FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
    442            FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6101             STR      R1,[R0, #+16]
    443            FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6141             STR      R1,[R0, #+20]
    444            FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x6181             STR      R1,[R0, #+24]
    445            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \   0000001C   0x21FC             MOVS     R1,#+252
   \   0000001E   0x69C2             LDR      R2,[R0, #+28]
   \   00000020   0x6011             STR      R1,[R2, #+0]
    446            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \   00000022   0x21FC             MOVS     R1,#+252
   \   00000024   0x69C2             LDR      R2,[R0, #+28]
   \   00000026   0x6051             STR      R1,[R2, #+4]
    447            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \   00000028   0x21FC             MOVS     R1,#+252
   \   0000002A   0x69C2             LDR      R2,[R0, #+28]
   \   0000002C   0x6091             STR      R1,[R2, #+8]
    448            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
   \   0000002E   0x21FC             MOVS     R1,#+252
   \   00000030   0x69C2             LDR      R2,[R0, #+28]
   \   00000032   0x60D1             STR      R1,[R2, #+12]
    449            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \   00000034   0x21FC             MOVS     R1,#+252
   \   00000036   0x6A02             LDR      R2,[R0, #+32]
   \   00000038   0x6011             STR      R1,[R2, #+0]
    450            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \   0000003A   0x21FC             MOVS     R1,#+252
   \   0000003C   0x6A02             LDR      R2,[R0, #+32]
   \   0000003E   0x6051             STR      R1,[R2, #+4]
    451            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \   00000040   0x21FC             MOVS     R1,#+252
   \   00000042   0x6A02             LDR      R2,[R0, #+32]
   \   00000044   0x6091             STR      R1,[R2, #+8]
    452            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
   \   00000046   0x21FC             MOVS     R1,#+252
   \   00000048   0x6A02             LDR      R2,[R0, #+32]
   \   0000004A   0x60D1             STR      R1,[R2, #+12]
    453          }
   \   0000004C   0x4770             BX       LR               ;; return
    454          
    455          /**
    456            * @brief  Enables or disables the specified NAND Memory Bank.
    457            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    458            *          This parameter can be one of the following values:
    459            *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    460            *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    461            * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.
    462            * @retval None
    463            */

   \                                 In section .text, align 2, keep-with-next
    464          void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
    465          {
   \                     FSMC_NANDCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    466            assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
   \   00000006   0x2C10             CMP      R4,#+16
   \   00000008   0xD008             BEQ.N    ??FSMC_NANDCmd_0
   \   0000000A   0xF5B4 0x7F80      CMP      R4,#+256
   \   0000000E   0xD005             BEQ.N    ??FSMC_NANDCmd_0
   \   00000010   0xF44F 0x71E9      MOV      R1,#+466
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000018   0x.... 0x....      BL       assert_failed
    467            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??FSMC_NANDCmd_0: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD008             BEQ.N    ??FSMC_NANDCmd_1
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD005             BEQ.N    ??FSMC_NANDCmd_1
   \   00000028   0xF240 0x11D3      MOVW     R1,#+467
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000030   0x.... 0x....      BL       assert_failed
    468            
    469            if (NewState != DISABLE)
   \                     ??FSMC_NANDCmd_1: (+1)
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0xD013             BEQ.N    ??FSMC_NANDCmd_2
    470            {
    471              /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
    472              if(FSMC_Bank == FSMC_Bank2_NAND)
   \   0000003A   0x2C10             CMP      R4,#+16
   \   0000003C   0xD108             BNE.N    ??FSMC_NANDCmd_3
    473              {
    474                FSMC_Bank2->PCR2 |= PCR_PBKEN_SET;
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0xa0000060
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable15_1  ;; 0xa0000060
   \   0000004C   0x6008             STR      R0,[R1, #+0]
   \   0000004E   0xE01D             B.N      ??FSMC_NANDCmd_4
    475              }
    476              else
    477              {
    478                FSMC_Bank3->PCR3 |= PCR_PBKEN_SET;
   \                     ??FSMC_NANDCmd_3: (+1)
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0xa0000080
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable15_5  ;; 0xa0000080
   \   0000005E   0x6008             STR      R0,[R1, #+0]
   \   00000060   0xE014             B.N      ??FSMC_NANDCmd_4
    479              }
    480            }
    481            else
    482            {
    483              /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
    484              if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     ??FSMC_NANDCmd_2: (+1)
   \   00000062   0x2C10             CMP      R4,#+16
   \   00000064   0xD109             BNE.N    ??FSMC_NANDCmd_5
    485              {
    486                FSMC_Bank2->PCR2 &= PCR_PBKEN_RESET;
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0xa0000060
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable15_9  ;; 0xffffb
   \   00000070   0x4008             ANDS     R0,R1,R0
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable15_1  ;; 0xa0000060
   \   00000076   0x6008             STR      R0,[R1, #+0]
   \   00000078   0xE008             B.N      ??FSMC_NANDCmd_4
    487              }
    488              else
    489              {
    490                FSMC_Bank3->PCR3 &= PCR_PBKEN_RESET;
   \                     ??FSMC_NANDCmd_5: (+1)
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0xa0000080
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable15_9  ;; 0xffffb
   \   00000084   0x4008             ANDS     R0,R1,R0
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable15_5  ;; 0xa0000080
   \   0000008A   0x6008             STR      R0,[R1, #+0]
    491              }
    492            }
    493          }
   \                     ??FSMC_NANDCmd_4: (+1)
   \   0000008C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    494          /**
    495            * @brief  Enables or disables the FSMC NAND ECC feature.
    496            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    497            *          This parameter can be one of the following values:
    498            *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    499            *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    500            * @param  NewState: new state of the FSMC NAND ECC feature.  
    501            *          This parameter can be: ENABLE or DISABLE.
    502            * @retval None
    503            */

   \                                 In section .text, align 2, keep-with-next
    504          void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
    505          {
   \                     FSMC_NANDECCCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    506            assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
   \   00000006   0x2C10             CMP      R4,#+16
   \   00000008   0xD008             BEQ.N    ??FSMC_NANDECCCmd_0
   \   0000000A   0xF5B4 0x7F80      CMP      R4,#+256
   \   0000000E   0xD005             BEQ.N    ??FSMC_NANDECCCmd_0
   \   00000010   0xF44F 0x71FD      MOV      R1,#+506
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000018   0x.... 0x....      BL       assert_failed
    507            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??FSMC_NANDECCCmd_0: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD008             BEQ.N    ??FSMC_NANDECCCmd_1
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD005             BEQ.N    ??FSMC_NANDECCCmd_1
   \   00000028   0xF240 0x11FB      MOVW     R1,#+507
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000030   0x.... 0x....      BL       assert_failed
    508            
    509            if (NewState != DISABLE)
   \                     ??FSMC_NANDECCCmd_1: (+1)
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0xD013             BEQ.N    ??FSMC_NANDECCCmd_2
    510            {
    511              /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
    512              if(FSMC_Bank == FSMC_Bank2_NAND)
   \   0000003A   0x2C10             CMP      R4,#+16
   \   0000003C   0xD108             BNE.N    ??FSMC_NANDECCCmd_3
    513              {
    514                FSMC_Bank2->PCR2 |= PCR_ECCEN_SET;
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0xa0000060
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable15_1  ;; 0xa0000060
   \   0000004C   0x6008             STR      R0,[R1, #+0]
   \   0000004E   0xE01D             B.N      ??FSMC_NANDECCCmd_4
    515              }
    516              else
    517              {
    518                FSMC_Bank3->PCR3 |= PCR_ECCEN_SET;
   \                     ??FSMC_NANDECCCmd_3: (+1)
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0xa0000080
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable15_5  ;; 0xa0000080
   \   0000005E   0x6008             STR      R0,[R1, #+0]
   \   00000060   0xE014             B.N      ??FSMC_NANDECCCmd_4
    519              }
    520            }
    521            else
    522            {
    523              /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
    524              if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     ??FSMC_NANDECCCmd_2: (+1)
   \   00000062   0x2C10             CMP      R4,#+16
   \   00000064   0xD109             BNE.N    ??FSMC_NANDECCCmd_5
    525              {
    526                FSMC_Bank2->PCR2 &= PCR_ECCEN_RESET;
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0xa0000060
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable15_10  ;; 0xfffbf
   \   00000070   0x4008             ANDS     R0,R1,R0
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable15_1  ;; 0xa0000060
   \   00000076   0x6008             STR      R0,[R1, #+0]
   \   00000078   0xE008             B.N      ??FSMC_NANDECCCmd_4
    527              }
    528              else
    529              {
    530                FSMC_Bank3->PCR3 &= PCR_ECCEN_RESET;
   \                     ??FSMC_NANDECCCmd_5: (+1)
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0xa0000080
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable15_10  ;; 0xfffbf
   \   00000084   0x4008             ANDS     R0,R1,R0
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable15_5  ;; 0xa0000080
   \   0000008A   0x6008             STR      R0,[R1, #+0]
    531              }
    532            }
    533          }
   \                     ??FSMC_NANDECCCmd_4: (+1)
   \   0000008C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    534          
    535          /**
    536            * @brief  Returns the error correction code register value.
    537            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    538            *          This parameter can be one of the following values:
    539            *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    540            *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    541            * @retval The Error Correction Code (ECC) value.
    542            */

   \                                 In section .text, align 2, keep-with-next
    543          uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
    544          {
   \                     FSMC_GetECC: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    545            uint32_t eccval = 0x00000000;
   \   00000002   0x2000             MOVS     R0,#+0
    546            
    547            if(FSMC_Bank == FSMC_Bank2_NAND)
   \   00000004   0x2910             CMP      R1,#+16
   \   00000006   0xD104             BNE.N    ??FSMC_GetECC_0
    548            {
    549              /* Get the ECCR2 register value */
    550              eccval = FSMC_Bank2->ECCR2;
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable15_11  ;; 0xa0000074
   \   0000000C   0x6812             LDR      R2,[R2, #+0]
   \   0000000E   0x0010             MOVS     R0,R2
   \   00000010   0xE003             B.N      ??FSMC_GetECC_1
    551            }
    552            else
    553            {
    554              /* Get the ECCR3 register value */
    555              eccval = FSMC_Bank3->ECCR3;
   \                     ??FSMC_GetECC_0: (+1)
   \   00000012   0x.... 0x....      LDR.W    R2,??DataTable15_12  ;; 0xa0000094
   \   00000016   0x6812             LDR      R2,[R2, #+0]
   \   00000018   0x0010             MOVS     R0,R2
    556            }
    557            /* Return the error correction code value */
    558            return(eccval);
   \                     ??FSMC_GetECC_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    559          }
    560          /**
    561            * @}
    562            */
    563          
    564          /** @defgroup FSMC_Group3 PCCARD Controller functions
    565           *  @brief   PCCARD Controller functions 
    566           *
    567          @verbatim   
    568           ===============================================================================
    569                              PCCARD Controller functions
    570           ===============================================================================  
    571          
    572           The following sequence should be followed to configure the FSMC to interface with
    573           16-bit PC Card compatible memory connected to the PCCARD Bank:
    574           
    575             1. Enable the clock for the FSMC and associated GPIOs using the following functions:
    576                    RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC, ENABLE);
    577                    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);
    578          
    579             2. FSMC pins configuration 
    580                 - Connect the involved FSMC pins to AF12 using the following function 
    581                    GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_FSMC); 
    582                 - Configure these FSMC pins in alternate function mode by calling the function
    583                    GPIO_Init();    
    584                 
    585             3. Declare a FSMC_PCCARDInitTypeDef structure, for example:
    586                    FSMC_PCCARDInitTypeDef  FSMC_PCCARDInitStructure;
    587                and fill the FSMC_PCCARDInitStructure variable with the allowed values of
    588                the structure member.
    589                
    590             4. Initialize the PCCARD Controller by calling the function
    591                    FSMC_PCCARDInit(&FSMC_PCCARDInitStructure); 
    592          
    593             5. Then enable the PCCARD Bank:
    594                    FSMC_PCCARDCmd(ENABLE);  
    595          
    596             6. At this stage you can read/write from/to the memory connected to the PCCARD Bank. 
    597           
    598          @endverbatim
    599            * @{
    600            */
    601          
    602          /**
    603            * @brief  Deinitializes the FSMC PCCARD Bank registers to their default reset values.
    604            * @param  None                       
    605            * @retval None
    606            */

   \                                 In section .text, align 2, keep-with-next
    607          void FSMC_PCCARDDeInit(void)
    608          {
    609            /* Set the FSMC_Bank4 registers to their reset values */
    610            FSMC_Bank4->PCR4 = 0x00000018; 
   \                     FSMC_PCCARDDeInit: (+1)
   \   00000000   0x2018             MOVS     R0,#+24
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable15_13  ;; 0xa00000a0
   \   00000006   0x6008             STR      R0,[R1, #+0]
    611            FSMC_Bank4->SR4 = 0x00000000;	
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable15_14  ;; 0xa00000a4
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    612            FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
   \   00000010   0xF05F 0x30FC      MOVS     R0,#-50529028
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable15_15  ;; 0xa00000a8
   \   00000018   0x6008             STR      R0,[R1, #+0]
    613            FSMC_Bank4->PATT4 = 0xFCFCFCFC;
   \   0000001A   0xF05F 0x30FC      MOVS     R0,#-50529028
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable15_16  ;; 0xa00000ac
   \   00000022   0x6008             STR      R0,[R1, #+0]
    614            FSMC_Bank4->PIO4 = 0xFCFCFCFC;
   \   00000024   0xF05F 0x30FC      MOVS     R0,#-50529028
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable15_17  ;; 0xa00000b0
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    615          }
   \   0000002E   0x4770             BX       LR               ;; return
    616          
    617          /**
    618            * @brief  Initializes the FSMC PCCARD Bank according to the specified parameters
    619            *         in the FSMC_PCCARDInitStruct.
    620            * @param  FSMC_PCCARDInitStruct : pointer to a FSMC_PCCARDInitTypeDef structure
    621            *         that contains the configuration information for the FSMC PCCARD Bank.                       
    622            * @retval None
    623            */

   \                                 In section .text, align 2, keep-with-next
    624          void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
    625          {
   \                     FSMC_PCCARDInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    626            /* Check the parameters */
    627            assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD007             BEQ.N    ??FSMC_PCCARDInit_0
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD004             BEQ.N    ??FSMC_PCCARDInit_0
   \   00000010   0xF240 0x2173      MOVW     R1,#+627
   \   00000014   0x....             LDR.N    R0,??DataTable12
   \   00000016   0x.... 0x....      BL       assert_failed
    628            assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));
   \                     ??FSMC_PCCARDInit_0: (+1)
   \   0000001A   0x6860             LDR      R0,[R4, #+4]
   \   0000001C   0x28FF             CMP      R0,#+255
   \   0000001E   0xD904             BLS.N    ??FSMC_PCCARDInit_1
   \   00000020   0xF44F 0x711D      MOV      R1,#+628
   \   00000024   0x....             LDR.N    R0,??DataTable12
   \   00000026   0x.... 0x....      BL       assert_failed
    629            assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));
   \                     ??FSMC_PCCARDInit_1: (+1)
   \   0000002A   0x68A0             LDR      R0,[R4, #+8]
   \   0000002C   0x28FF             CMP      R0,#+255
   \   0000002E   0xD904             BLS.N    ??FSMC_PCCARDInit_2
   \   00000030   0xF240 0x2175      MOVW     R1,#+629
   \   00000034   0x....             LDR.N    R0,??DataTable12
   \   00000036   0x.... 0x....      BL       assert_failed
    630           
    631            assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
   \                     ??FSMC_PCCARDInit_2: (+1)
   \   0000003A   0x68E0             LDR      R0,[R4, #+12]
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x28FF             CMP      R0,#+255
   \   00000040   0xD904             BLS.N    ??FSMC_PCCARDInit_3
   \   00000042   0xF240 0x2177      MOVW     R1,#+631
   \   00000046   0x....             LDR.N    R0,??DataTable12
   \   00000048   0x.... 0x....      BL       assert_failed
    632            assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
   \                     ??FSMC_PCCARDInit_3: (+1)
   \   0000004C   0x68E0             LDR      R0,[R4, #+12]
   \   0000004E   0x6840             LDR      R0,[R0, #+4]
   \   00000050   0x28FF             CMP      R0,#+255
   \   00000052   0xD904             BLS.N    ??FSMC_PCCARDInit_4
   \   00000054   0xF44F 0x711E      MOV      R1,#+632
   \   00000058   0x....             LDR.N    R0,??DataTable12
   \   0000005A   0x.... 0x....      BL       assert_failed
    633            assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
   \                     ??FSMC_PCCARDInit_4: (+1)
   \   0000005E   0x68E0             LDR      R0,[R4, #+12]
   \   00000060   0x6880             LDR      R0,[R0, #+8]
   \   00000062   0x28FF             CMP      R0,#+255
   \   00000064   0xD904             BLS.N    ??FSMC_PCCARDInit_5
   \   00000066   0xF240 0x2179      MOVW     R1,#+633
   \   0000006A   0x....             LDR.N    R0,??DataTable12
   \   0000006C   0x.... 0x....      BL       assert_failed
    634            assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
   \                     ??FSMC_PCCARDInit_5: (+1)
   \   00000070   0x68E0             LDR      R0,[R4, #+12]
   \   00000072   0x68C0             LDR      R0,[R0, #+12]
   \   00000074   0x28FF             CMP      R0,#+255
   \   00000076   0xD904             BLS.N    ??FSMC_PCCARDInit_6
   \   00000078   0xF240 0x217A      MOVW     R1,#+634
   \   0000007C   0x....             LDR.N    R0,??DataTable12
   \   0000007E   0x.... 0x....      BL       assert_failed
    635            
    636            assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
   \                     ??FSMC_PCCARDInit_6: (+1)
   \   00000082   0x6920             LDR      R0,[R4, #+16]
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x28FF             CMP      R0,#+255
   \   00000088   0xD904             BLS.N    ??FSMC_PCCARDInit_7
   \   0000008A   0xF44F 0x711F      MOV      R1,#+636
   \   0000008E   0x....             LDR.N    R0,??DataTable12
   \   00000090   0x.... 0x....      BL       assert_failed
    637            assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
   \                     ??FSMC_PCCARDInit_7: (+1)
   \   00000094   0x6920             LDR      R0,[R4, #+16]
   \   00000096   0x6840             LDR      R0,[R0, #+4]
   \   00000098   0x28FF             CMP      R0,#+255
   \   0000009A   0xD904             BLS.N    ??FSMC_PCCARDInit_8
   \   0000009C   0xF240 0x217D      MOVW     R1,#+637
   \   000000A0   0x....             LDR.N    R0,??DataTable12
   \   000000A2   0x.... 0x....      BL       assert_failed
    638            assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
   \                     ??FSMC_PCCARDInit_8: (+1)
   \   000000A6   0x6920             LDR      R0,[R4, #+16]
   \   000000A8   0x6880             LDR      R0,[R0, #+8]
   \   000000AA   0x28FF             CMP      R0,#+255
   \   000000AC   0xD904             BLS.N    ??FSMC_PCCARDInit_9
   \   000000AE   0xF240 0x217E      MOVW     R1,#+638
   \   000000B2   0x....             LDR.N    R0,??DataTable12
   \   000000B4   0x.... 0x....      BL       assert_failed
    639            assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
   \                     ??FSMC_PCCARDInit_9: (+1)
   \   000000B8   0x6920             LDR      R0,[R4, #+16]
   \   000000BA   0x68C0             LDR      R0,[R0, #+12]
   \   000000BC   0x28FF             CMP      R0,#+255
   \   000000BE   0xD904             BLS.N    ??FSMC_PCCARDInit_10
   \   000000C0   0xF240 0x217F      MOVW     R1,#+639
   \   000000C4   0x....             LDR.N    R0,??DataTable12
   \   000000C6   0x.... 0x....      BL       assert_failed
    640            assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));
   \                     ??FSMC_PCCARDInit_10: (+1)
   \   000000CA   0x6960             LDR      R0,[R4, #+20]
   \   000000CC   0x6800             LDR      R0,[R0, #+0]
   \   000000CE   0x28FF             CMP      R0,#+255
   \   000000D0   0xD904             BLS.N    ??FSMC_PCCARDInit_11
   \   000000D2   0xF44F 0x7120      MOV      R1,#+640
   \   000000D6   0x....             LDR.N    R0,??DataTable12
   \   000000D8   0x.... 0x....      BL       assert_failed
    641            assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
   \                     ??FSMC_PCCARDInit_11: (+1)
   \   000000DC   0x6960             LDR      R0,[R4, #+20]
   \   000000DE   0x6840             LDR      R0,[R0, #+4]
   \   000000E0   0x28FF             CMP      R0,#+255
   \   000000E2   0xD904             BLS.N    ??FSMC_PCCARDInit_12
   \   000000E4   0xF240 0x2181      MOVW     R1,#+641
   \   000000E8   0x....             LDR.N    R0,??DataTable12
   \   000000EA   0x.... 0x....      BL       assert_failed
    642            assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
   \                     ??FSMC_PCCARDInit_12: (+1)
   \   000000EE   0x6960             LDR      R0,[R4, #+20]
   \   000000F0   0x6880             LDR      R0,[R0, #+8]
   \   000000F2   0x28FF             CMP      R0,#+255
   \   000000F4   0xD904             BLS.N    ??FSMC_PCCARDInit_13
   \   000000F6   0xF240 0x2182      MOVW     R1,#+642
   \   000000FA   0x....             LDR.N    R0,??DataTable12
   \   000000FC   0x.... 0x....      BL       assert_failed
    643            assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
   \                     ??FSMC_PCCARDInit_13: (+1)
   \   00000100   0x6960             LDR      R0,[R4, #+20]
   \   00000102   0x68C0             LDR      R0,[R0, #+12]
   \   00000104   0x28FF             CMP      R0,#+255
   \   00000106   0xD904             BLS.N    ??FSMC_PCCARDInit_14
   \   00000108   0xF240 0x2183      MOVW     R1,#+643
   \   0000010C   0x....             LDR.N    R0,??DataTable12
   \   0000010E   0x.... 0x....      BL       assert_failed
    644            
    645            /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
    646            FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
    647                               FSMC_MemoryDataWidth_16b |  
    648                               (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
    649                               (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
   \                     ??FSMC_PCCARDInit_14: (+1)
   \   00000112   0x6820             LDR      R0,[R4, #+0]
   \   00000114   0x6861             LDR      R1,[R4, #+4]
   \   00000116   0xEA50 0x2041      ORRS     R0,R0,R1, LSL #+9
   \   0000011A   0x68A1             LDR      R1,[R4, #+8]
   \   0000011C   0xEA50 0x3041      ORRS     R0,R0,R1, LSL #+13
   \   00000120   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000124   0x.... 0x....      LDR.W    R1,??DataTable15_13  ;; 0xa00000a0
   \   00000128   0x6008             STR      R0,[R1, #+0]
    650                      
    651            /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
    652            FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
    653                                (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    654                                (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    655                                (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
   \   0000012A   0x68E0             LDR      R0,[R4, #+12]
   \   0000012C   0x6800             LDR      R0,[R0, #+0]
   \   0000012E   0x68E1             LDR      R1,[R4, #+12]
   \   00000130   0x6849             LDR      R1,[R1, #+4]
   \   00000132   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000136   0x68E1             LDR      R1,[R4, #+12]
   \   00000138   0x6889             LDR      R1,[R1, #+8]
   \   0000013A   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   0000013E   0x68E1             LDR      R1,[R4, #+12]
   \   00000140   0x68C9             LDR      R1,[R1, #+12]
   \   00000142   0xEA50 0x6001      ORRS     R0,R0,R1, LSL #+24
   \   00000146   0x.... 0x....      LDR.W    R1,??DataTable15_15  ;; 0xa00000a8
   \   0000014A   0x6008             STR      R0,[R1, #+0]
    656                      
    657            /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
    658            FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
    659                                (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    660                                (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    661                                (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
   \   0000014C   0x6920             LDR      R0,[R4, #+16]
   \   0000014E   0x6800             LDR      R0,[R0, #+0]
   \   00000150   0x6921             LDR      R1,[R4, #+16]
   \   00000152   0x6849             LDR      R1,[R1, #+4]
   \   00000154   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000158   0x6921             LDR      R1,[R4, #+16]
   \   0000015A   0x6889             LDR      R1,[R1, #+8]
   \   0000015C   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   00000160   0x6921             LDR      R1,[R4, #+16]
   \   00000162   0x68C9             LDR      R1,[R1, #+12]
   \   00000164   0xEA50 0x6001      ORRS     R0,R0,R1, LSL #+24
   \   00000168   0x.... 0x....      LDR.W    R1,??DataTable15_16  ;; 0xa00000ac
   \   0000016C   0x6008             STR      R0,[R1, #+0]
    662                      
    663            /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
    664            FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
    665                               (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    666                               (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    667                               (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
   \   0000016E   0x6960             LDR      R0,[R4, #+20]
   \   00000170   0x6800             LDR      R0,[R0, #+0]
   \   00000172   0x6961             LDR      R1,[R4, #+20]
   \   00000174   0x6849             LDR      R1,[R1, #+4]
   \   00000176   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   0000017A   0x6961             LDR      R1,[R4, #+20]
   \   0000017C   0x6889             LDR      R1,[R1, #+8]
   \   0000017E   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   00000182   0x6961             LDR      R1,[R4, #+20]
   \   00000184   0x68C9             LDR      R1,[R1, #+12]
   \   00000186   0xEA50 0x6001      ORRS     R0,R0,R1, LSL #+24
   \   0000018A   0x.... 0x....      LDR.W    R1,??DataTable15_17  ;; 0xa00000b0
   \   0000018E   0x6008             STR      R0,[R1, #+0]
    668          }
   \   00000190   0xBD10             POP      {R4,PC}          ;; return
    669          
    670          /**
    671            * @brief  Fills each FSMC_PCCARDInitStruct member with its default value.
    672            * @param  FSMC_PCCARDInitStruct: pointer to a FSMC_PCCARDInitTypeDef structure
    673            *         which will be initialized.
    674            * @retval None
    675            */

   \                                 In section .text, align 2, keep-with-next
    676          void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
    677          {
    678            /* Reset PCCARD Init structure parameters values */
    679            FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
   \                     FSMC_PCCARDStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    680            FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6041             STR      R1,[R0, #+4]
    681            FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6081             STR      R1,[R0, #+8]
    682            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \   0000000C   0x21FC             MOVS     R1,#+252
   \   0000000E   0x68C2             LDR      R2,[R0, #+12]
   \   00000010   0x6011             STR      R1,[R2, #+0]
    683            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \   00000012   0x21FC             MOVS     R1,#+252
   \   00000014   0x68C2             LDR      R2,[R0, #+12]
   \   00000016   0x6051             STR      R1,[R2, #+4]
    684            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \   00000018   0x21FC             MOVS     R1,#+252
   \   0000001A   0x68C2             LDR      R2,[R0, #+12]
   \   0000001C   0x6091             STR      R1,[R2, #+8]
    685            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
   \   0000001E   0x21FC             MOVS     R1,#+252
   \   00000020   0x68C2             LDR      R2,[R0, #+12]
   \   00000022   0x60D1             STR      R1,[R2, #+12]
    686            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \   00000024   0x21FC             MOVS     R1,#+252
   \   00000026   0x6902             LDR      R2,[R0, #+16]
   \   00000028   0x6011             STR      R1,[R2, #+0]
    687            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \   0000002A   0x21FC             MOVS     R1,#+252
   \   0000002C   0x6902             LDR      R2,[R0, #+16]
   \   0000002E   0x6051             STR      R1,[R2, #+4]
    688            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \   00000030   0x21FC             MOVS     R1,#+252
   \   00000032   0x6902             LDR      R2,[R0, #+16]
   \   00000034   0x6091             STR      R1,[R2, #+8]
    689            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
   \   00000036   0x21FC             MOVS     R1,#+252
   \   00000038   0x6902             LDR      R2,[R0, #+16]
   \   0000003A   0x60D1             STR      R1,[R2, #+12]
    690            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \   0000003C   0x21FC             MOVS     R1,#+252
   \   0000003E   0x6942             LDR      R2,[R0, #+20]
   \   00000040   0x6011             STR      R1,[R2, #+0]
    691            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \   00000042   0x21FC             MOVS     R1,#+252
   \   00000044   0x6942             LDR      R2,[R0, #+20]
   \   00000046   0x6051             STR      R1,[R2, #+4]
    692            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \   00000048   0x21FC             MOVS     R1,#+252
   \   0000004A   0x6942             LDR      R2,[R0, #+20]
   \   0000004C   0x6091             STR      R1,[R2, #+8]
    693            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
   \   0000004E   0x21FC             MOVS     R1,#+252
   \   00000050   0x6942             LDR      R2,[R0, #+20]
   \   00000052   0x60D1             STR      R1,[R2, #+12]
    694          }
   \   00000054   0x4770             BX       LR               ;; return
    695          
    696          /**
    697            * @brief  Enables or disables the PCCARD Memory Bank.
    698            * @param  NewState: new state of the PCCARD Memory Bank.  
    699            *          This parameter can be: ENABLE or DISABLE.
    700            * @retval None
    701            */

   \                                 In section .text, align 2, keep-with-next
    702          void FSMC_PCCARDCmd(FunctionalState NewState)
    703          {
   \                     FSMC_PCCARDCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    704            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??FSMC_PCCARDCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??FSMC_PCCARDCmd_0
   \   00000010   0xF44F 0x7130      MOV      R1,#+704
   \   00000014   0x....             LDR.N    R0,??DataTable12
   \   00000016   0x.... 0x....      BL       assert_failed
    705            
    706            if (NewState != DISABLE)
   \                     ??FSMC_PCCARDCmd_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD006             BEQ.N    ??FSMC_PCCARDCmd_1
    707            {
    708              /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
    709              FSMC_Bank4->PCR4 |= PCR_PBKEN_SET;
   \   00000020   0x....             LDR.N    R0,??DataTable15_13  ;; 0xa00000a0
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000028   0x....             LDR.N    R1,??DataTable15_13  ;; 0xa00000a0
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   \   0000002C   0xE005             B.N      ??FSMC_PCCARDCmd_2
    710            }
    711            else
    712            {
    713              /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
    714              FSMC_Bank4->PCR4 &= PCR_PBKEN_RESET;
   \                     ??FSMC_PCCARDCmd_1: (+1)
   \   0000002E   0x....             LDR.N    R0,??DataTable15_13  ;; 0xa00000a0
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x....             LDR.N    R1,??DataTable15_9  ;; 0xffffb
   \   00000034   0x4008             ANDS     R0,R1,R0
   \   00000036   0x....             LDR.N    R1,??DataTable15_13  ;; 0xa00000a0
   \   00000038   0x6008             STR      R0,[R1, #+0]
    715            }
    716          }
   \                     ??FSMC_PCCARDCmd_2: (+1)
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    717          /**
    718            * @}
    719            */
    720          
    721          /** @defgroup FSMC_Group4  Interrupts and flags management functions
    722           *  @brief    Interrupts and flags management functions
    723           *
    724          @verbatim   
    725           ===============================================================================
    726                               Interrupts and flags management functions
    727           ===============================================================================  
    728          
    729          @endverbatim
    730            * @{
    731            */
    732          
    733          /**
    734            * @brief  Enables or disables the specified FSMC interrupts.
    735            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    736            *          This parameter can be one of the following values:
    737            *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    738            *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    739            *            @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    740            * @param  FSMC_IT: specifies the FSMC interrupt sources to be enabled or disabled.
    741            *          This parameter can be any combination of the following values:
    742            *            @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
    743            *            @arg FSMC_IT_Level: Level edge detection interrupt.
    744            *            @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.
    745            * @param  NewState: new state of the specified FSMC interrupts.
    746            *          This parameter can be: ENABLE or DISABLE.
    747            * @retval None
    748            */

   \                                 In section .text, align 2, keep-with-next
    749          void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)
    750          {
   \                     FSMC_ITConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    751            assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
   \   00000008   0x2C10             CMP      R4,#+16
   \   0000000A   0xD00A             BEQ.N    ??FSMC_ITConfig_0
   \   0000000C   0xF5B4 0x7F80      CMP      R4,#+256
   \   00000010   0xD007             BEQ.N    ??FSMC_ITConfig_0
   \   00000012   0xF5B4 0x5F80      CMP      R4,#+4096
   \   00000016   0xD004             BEQ.N    ??FSMC_ITConfig_0
   \   00000018   0xF240 0x21EF      MOVW     R1,#+751
   \   0000001C   0x....             LDR.N    R0,??DataTable12
   \   0000001E   0x.... 0x....      BL       assert_failed
    752            assert_param(IS_FSMC_IT(FSMC_IT));	
   \                     ??FSMC_ITConfig_0: (+1)
   \   00000022   0xF035 0x0038      BICS     R0,R5,#0x38
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD101             BNE.N    ??FSMC_ITConfig_1
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD104             BNE.N    ??FSMC_ITConfig_2
   \                     ??FSMC_ITConfig_1: (+1)
   \   0000002E   0xF44F 0x713C      MOV      R1,#+752
   \   00000032   0x....             LDR.N    R0,??DataTable12
   \   00000034   0x.... 0x....      BL       assert_failed
    753            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??FSMC_ITConfig_2: (+1)
   \   00000038   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003A   0x2E00             CMP      R6,#+0
   \   0000003C   0xD007             BEQ.N    ??FSMC_ITConfig_3
   \   0000003E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000040   0x2E01             CMP      R6,#+1
   \   00000042   0xD004             BEQ.N    ??FSMC_ITConfig_3
   \   00000044   0xF240 0x21F1      MOVW     R1,#+753
   \   00000048   0x....             LDR.N    R0,??DataTable12
   \   0000004A   0x.... 0x....      BL       assert_failed
    754            
    755            if (NewState != DISABLE)
   \                     ??FSMC_ITConfig_3: (+1)
   \   0000004E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000050   0x2E00             CMP      R6,#+0
   \   00000052   0xD016             BEQ.N    ??FSMC_ITConfig_4
    756            {
    757              /* Enable the selected FSMC_Bank2 interrupts */
    758              if(FSMC_Bank == FSMC_Bank2_NAND)
   \   00000054   0x2C10             CMP      R4,#+16
   \   00000056   0xD105             BNE.N    ??FSMC_ITConfig_5
    759              {
    760                FSMC_Bank2->SR2 |= FSMC_IT;
   \   00000058   0x....             LDR.N    R0,??DataTable15_2  ;; 0xa0000064
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x4328             ORRS     R0,R5,R0
   \   0000005E   0x....             LDR.N    R1,??DataTable15_2  ;; 0xa0000064
   \   00000060   0x6008             STR      R0,[R1, #+0]
   \   00000062   0xE024             B.N      ??FSMC_ITConfig_6
    761              }
    762              /* Enable the selected FSMC_Bank3 interrupts */
    763              else if (FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ITConfig_5: (+1)
   \   00000064   0xF5B4 0x7F80      CMP      R4,#+256
   \   00000068   0xD105             BNE.N    ??FSMC_ITConfig_7
    764              {
    765                FSMC_Bank3->SR3 |= FSMC_IT;
   \   0000006A   0x....             LDR.N    R0,??DataTable15_6  ;; 0xa0000084
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x4328             ORRS     R0,R5,R0
   \   00000070   0x....             LDR.N    R1,??DataTable15_6  ;; 0xa0000084
   \   00000072   0x6008             STR      R0,[R1, #+0]
   \   00000074   0xE01B             B.N      ??FSMC_ITConfig_6
    766              }
    767              /* Enable the selected FSMC_Bank4 interrupts */
    768              else
    769              {
    770                FSMC_Bank4->SR4 |= FSMC_IT;    
   \                     ??FSMC_ITConfig_7: (+1)
   \   00000076   0x....             LDR.N    R0,??DataTable15_14  ;; 0xa00000a4
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x4328             ORRS     R0,R5,R0
   \   0000007C   0x....             LDR.N    R1,??DataTable15_14  ;; 0xa00000a4
   \   0000007E   0x6008             STR      R0,[R1, #+0]
   \   00000080   0xE015             B.N      ??FSMC_ITConfig_6
    771              }
    772            }
    773            else
    774            {
    775              /* Disable the selected FSMC_Bank2 interrupts */
    776              if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     ??FSMC_ITConfig_4: (+1)
   \   00000082   0x2C10             CMP      R4,#+16
   \   00000084   0xD105             BNE.N    ??FSMC_ITConfig_8
    777              {
    778                
    779                FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
   \   00000086   0x....             LDR.N    R0,??DataTable15_2  ;; 0xa0000064
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0x43A8             BICS     R0,R0,R5
   \   0000008C   0x....             LDR.N    R1,??DataTable15_2  ;; 0xa0000064
   \   0000008E   0x6008             STR      R0,[R1, #+0]
   \   00000090   0xE00D             B.N      ??FSMC_ITConfig_6
    780              }
    781              /* Disable the selected FSMC_Bank3 interrupts */
    782              else if (FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ITConfig_8: (+1)
   \   00000092   0xF5B4 0x7F80      CMP      R4,#+256
   \   00000096   0xD105             BNE.N    ??FSMC_ITConfig_9
    783              {
    784                FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
   \   00000098   0x....             LDR.N    R0,??DataTable15_6  ;; 0xa0000084
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0x43A8             BICS     R0,R0,R5
   \   0000009E   0x....             LDR.N    R1,??DataTable15_6  ;; 0xa0000084
   \   000000A0   0x6008             STR      R0,[R1, #+0]
   \   000000A2   0xE004             B.N      ??FSMC_ITConfig_6
    785              }
    786              /* Disable the selected FSMC_Bank4 interrupts */
    787              else
    788              {
    789                FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
   \                     ??FSMC_ITConfig_9: (+1)
   \   000000A4   0x....             LDR.N    R0,??DataTable15_14  ;; 0xa00000a4
   \   000000A6   0x6800             LDR      R0,[R0, #+0]
   \   000000A8   0x43A8             BICS     R0,R0,R5
   \   000000AA   0x....             LDR.N    R1,??DataTable15_14  ;; 0xa00000a4
   \   000000AC   0x6008             STR      R0,[R1, #+0]
    790              }
    791            }
    792          }
   \                     ??FSMC_ITConfig_6: (+1)
   \   000000AE   0xBD70             POP      {R4-R6,PC}       ;; return
    793          
    794          /**
    795            * @brief  Checks whether the specified FSMC flag is set or not.
    796            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    797            *          This parameter can be one of the following values:
    798            *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    799            *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    800            *            @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    801            * @param  FSMC_FLAG: specifies the flag to check.
    802            *          This parameter can be one of the following values:
    803            *            @arg FSMC_FLAG_RisingEdge: Rising edge detection Flag.
    804            *            @arg FSMC_FLAG_Level: Level detection Flag.
    805            *            @arg FSMC_FLAG_FallingEdge: Falling edge detection Flag.
    806            *            @arg FSMC_FLAG_FEMPT: Fifo empty Flag. 
    807            * @retval The new state of FSMC_FLAG (SET or RESET).
    808            */

   \                                 In section .text, align 2, keep-with-next
    809          FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
    810          {
   \                     FSMC_GetFlagStatus: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    811            FlagStatus bitstatus = RESET;
   \   00000006   0x2600             MOVS     R6,#+0
    812            uint32_t tmpsr = 0x00000000;
   \   00000008   0x2700             MOVS     R7,#+0
    813            
    814            /* Check the parameters */
    815            assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
   \   0000000A   0x2C10             CMP      R4,#+16
   \   0000000C   0xD00A             BEQ.N    ??FSMC_GetFlagStatus_0
   \   0000000E   0xF5B4 0x7F80      CMP      R4,#+256
   \   00000012   0xD007             BEQ.N    ??FSMC_GetFlagStatus_0
   \   00000014   0xF5B4 0x5F80      CMP      R4,#+4096
   \   00000018   0xD004             BEQ.N    ??FSMC_GetFlagStatus_0
   \   0000001A   0xF240 0x312F      MOVW     R1,#+815
   \   0000001E   0x....             LDR.N    R0,??DataTable12
   \   00000020   0x.... 0x....      BL       assert_failed
    816            assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
   \                     ??FSMC_GetFlagStatus_0: (+1)
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD00A             BEQ.N    ??FSMC_GetFlagStatus_1
   \   00000028   0x2D02             CMP      R5,#+2
   \   0000002A   0xD008             BEQ.N    ??FSMC_GetFlagStatus_1
   \   0000002C   0x2D04             CMP      R5,#+4
   \   0000002E   0xD006             BEQ.N    ??FSMC_GetFlagStatus_1
   \   00000030   0x2D40             CMP      R5,#+64
   \   00000032   0xD004             BEQ.N    ??FSMC_GetFlagStatus_1
   \   00000034   0xF44F 0x714C      MOV      R1,#+816
   \   00000038   0x....             LDR.N    R0,??DataTable12
   \   0000003A   0x.... 0x....      BL       assert_failed
    817            
    818            if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     ??FSMC_GetFlagStatus_1: (+1)
   \   0000003E   0x2C10             CMP      R4,#+16
   \   00000040   0xD103             BNE.N    ??FSMC_GetFlagStatus_2
    819            {
    820              tmpsr = FSMC_Bank2->SR2;
   \   00000042   0x....             LDR.N    R0,??DataTable15_2  ;; 0xa0000064
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x0007             MOVS     R7,R0
   \   00000048   0xE009             B.N      ??FSMC_GetFlagStatus_3
    821            }  
    822            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_GetFlagStatus_2: (+1)
   \   0000004A   0xF5B4 0x7F80      CMP      R4,#+256
   \   0000004E   0xD103             BNE.N    ??FSMC_GetFlagStatus_4
    823            {
    824              tmpsr = FSMC_Bank3->SR3;
   \   00000050   0x....             LDR.N    R0,??DataTable15_6  ;; 0xa0000084
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x0007             MOVS     R7,R0
   \   00000056   0xE002             B.N      ??FSMC_GetFlagStatus_3
    825            }
    826            /* FSMC_Bank4_PCCARD*/
    827            else
    828            {
    829              tmpsr = FSMC_Bank4->SR4;
   \                     ??FSMC_GetFlagStatus_4: (+1)
   \   00000058   0x....             LDR.N    R0,??DataTable15_14  ;; 0xa00000a4
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x0007             MOVS     R7,R0
    830            } 
    831            
    832            /* Get the flag status */
    833            if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )
   \                     ??FSMC_GetFlagStatus_3: (+1)
   \   0000005E   0x422F             TST      R7,R5
   \   00000060   0xD002             BEQ.N    ??FSMC_GetFlagStatus_5
    834            {
    835              bitstatus = SET;
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0x0006             MOVS     R6,R0
   \   00000066   0xE001             B.N      ??FSMC_GetFlagStatus_6
    836            }
    837            else
    838            {
    839              bitstatus = RESET;
   \                     ??FSMC_GetFlagStatus_5: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x0006             MOVS     R6,R0
    840            }
    841            /* Return the flag status */
    842            return bitstatus;
   \                     ??FSMC_GetFlagStatus_6: (+1)
   \   0000006C   0x0030             MOVS     R0,R6
   \   0000006E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000070   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    843          }
    844          
    845          /**
    846            * @brief  Clears the FSMC's pending flags.
    847            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    848            *          This parameter can be one of the following values:
    849            *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    850            *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    851            *            @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    852            * @param  FSMC_FLAG: specifies the flag to clear.
    853            *          This parameter can be any combination of the following values:
    854            *            @arg FSMC_FLAG_RisingEdge: Rising edge detection Flag.
    855            *            @arg FSMC_FLAG_Level: Level detection Flag.
    856            *            @arg FSMC_FLAG_FallingEdge: Falling edge detection Flag.
    857            * @retval None
    858            */

   \                                 In section .text, align 2, keep-with-next
    859          void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
    860          {
   \                     FSMC_ClearFlag: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    861           /* Check the parameters */
    862            assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
   \   00000006   0x2C10             CMP      R4,#+16
   \   00000008   0xD00A             BEQ.N    ??FSMC_ClearFlag_0
   \   0000000A   0xF5B4 0x7F80      CMP      R4,#+256
   \   0000000E   0xD007             BEQ.N    ??FSMC_ClearFlag_0
   \   00000010   0xF5B4 0x5F80      CMP      R4,#+4096
   \   00000014   0xD004             BEQ.N    ??FSMC_ClearFlag_0
   \   00000016   0xF240 0x315E      MOVW     R1,#+862
   \   0000001A   0x....             LDR.N    R0,??DataTable15_18
   \   0000001C   0x.... 0x....      BL       assert_failed
    863            assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
   \                     ??FSMC_ClearFlag_0: (+1)
   \   00000020   0x08E8             LSRS     R0,R5,#+3
   \   00000022   0x00C0             LSLS     R0,R0,#+3
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD101             BNE.N    ??FSMC_ClearFlag_1
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD104             BNE.N    ??FSMC_ClearFlag_2
   \                     ??FSMC_ClearFlag_1: (+1)
   \   0000002C   0xF240 0x315F      MOVW     R1,#+863
   \   00000030   0x....             LDR.N    R0,??DataTable15_18
   \   00000032   0x.... 0x....      BL       assert_failed
    864              
    865            if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     ??FSMC_ClearFlag_2: (+1)
   \   00000036   0x2C10             CMP      R4,#+16
   \   00000038   0xD105             BNE.N    ??FSMC_ClearFlag_3
    866            {
    867              FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
   \   0000003A   0x....             LDR.N    R0,??DataTable15_2  ;; 0xa0000064
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x43A8             BICS     R0,R0,R5
   \   00000040   0x....             LDR.N    R1,??DataTable15_2  ;; 0xa0000064
   \   00000042   0x6008             STR      R0,[R1, #+0]
   \   00000044   0xE00D             B.N      ??FSMC_ClearFlag_4
    868            }  
    869            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ClearFlag_3: (+1)
   \   00000046   0xF5B4 0x7F80      CMP      R4,#+256
   \   0000004A   0xD105             BNE.N    ??FSMC_ClearFlag_5
    870            {
    871              FSMC_Bank3->SR3 &= ~FSMC_FLAG;
   \   0000004C   0x....             LDR.N    R0,??DataTable15_6  ;; 0xa0000084
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x43A8             BICS     R0,R0,R5
   \   00000052   0x....             LDR.N    R1,??DataTable15_6  ;; 0xa0000084
   \   00000054   0x6008             STR      R0,[R1, #+0]
   \   00000056   0xE004             B.N      ??FSMC_ClearFlag_4
    872            }
    873            /* FSMC_Bank4_PCCARD*/
    874            else
    875            {
    876              FSMC_Bank4->SR4 &= ~FSMC_FLAG;
   \                     ??FSMC_ClearFlag_5: (+1)
   \   00000058   0x....             LDR.N    R0,??DataTable15_14  ;; 0xa00000a4
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x43A8             BICS     R0,R0,R5
   \   0000005E   0x....             LDR.N    R1,??DataTable15_14  ;; 0xa00000a4
   \   00000060   0x6008             STR      R0,[R1, #+0]
    877            }
    878          }
   \                     ??FSMC_ClearFlag_4: (+1)
   \   00000062   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    879          
    880          /**
    881            * @brief  Checks whether the specified FSMC interrupt has occurred or not.
    882            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    883            *          This parameter can be one of the following values:
    884            *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    885            *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    886            *            @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    887            * @param  FSMC_IT: specifies the FSMC interrupt source to check.
    888            *          This parameter can be one of the following values:
    889            *            @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
    890            *            @arg FSMC_IT_Level: Level edge detection interrupt.
    891            *            @arg FSMC_IT_FallingEdge: Falling edge detection interrupt. 
    892            * @retval The new state of FSMC_IT (SET or RESET).
    893            */

   \                                 In section .text, align 2, keep-with-next
    894          ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)
    895          {
   \                     FSMC_GetITStatus: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    896            ITStatus bitstatus = RESET;
   \   00000008   0x2600             MOVS     R6,#+0
    897            uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
    898            
    899            /* Check the parameters */
    900            assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
   \   00000014   0x2C10             CMP      R4,#+16
   \   00000016   0xD00A             BEQ.N    ??FSMC_GetITStatus_0
   \   00000018   0xF5B4 0x7F80      CMP      R4,#+256
   \   0000001C   0xD007             BEQ.N    ??FSMC_GetITStatus_0
   \   0000001E   0xF5B4 0x5F80      CMP      R4,#+4096
   \   00000022   0xD004             BEQ.N    ??FSMC_GetITStatus_0
   \   00000024   0xF44F 0x7161      MOV      R1,#+900
   \   00000028   0x....             LDR.N    R0,??DataTable15_18
   \   0000002A   0x.... 0x....      BL       assert_failed
    901            assert_param(IS_FSMC_GET_IT(FSMC_IT));
   \                     ??FSMC_GetITStatus_0: (+1)
   \   0000002E   0x2D08             CMP      R5,#+8
   \   00000030   0xD008             BEQ.N    ??FSMC_GetITStatus_1
   \   00000032   0x2D10             CMP      R5,#+16
   \   00000034   0xD006             BEQ.N    ??FSMC_GetITStatus_1
   \   00000036   0x2D20             CMP      R5,#+32
   \   00000038   0xD004             BEQ.N    ??FSMC_GetITStatus_1
   \   0000003A   0xF240 0x3185      MOVW     R1,#+901
   \   0000003E   0x....             LDR.N    R0,??DataTable15_18
   \   00000040   0x.... 0x....      BL       assert_failed
    902            
    903            if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     ??FSMC_GetITStatus_1: (+1)
   \   00000044   0x2C10             CMP      R4,#+16
   \   00000046   0xD103             BNE.N    ??FSMC_GetITStatus_2
    904            {
    905              tmpsr = FSMC_Bank2->SR2;
   \   00000048   0x....             LDR.N    R0,??DataTable15_2  ;; 0xa0000064
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x0007             MOVS     R7,R0
   \   0000004E   0xE009             B.N      ??FSMC_GetITStatus_3
    906            }  
    907            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_GetITStatus_2: (+1)
   \   00000050   0xF5B4 0x7F80      CMP      R4,#+256
   \   00000054   0xD103             BNE.N    ??FSMC_GetITStatus_4
    908            {
    909              tmpsr = FSMC_Bank3->SR3;
   \   00000056   0x....             LDR.N    R0,??DataTable15_6  ;; 0xa0000084
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x0007             MOVS     R7,R0
   \   0000005C   0xE002             B.N      ??FSMC_GetITStatus_3
    910            }
    911            /* FSMC_Bank4_PCCARD*/
    912            else
    913            {
    914              tmpsr = FSMC_Bank4->SR4;
   \                     ??FSMC_GetITStatus_4: (+1)
   \   0000005E   0x....             LDR.N    R0,??DataTable15_14  ;; 0xa00000a4
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x0007             MOVS     R7,R0
    915            } 
    916            
    917            itstatus = tmpsr & FSMC_IT;
   \                     ??FSMC_GetITStatus_3: (+1)
   \   00000064   0xEA15 0x0007      ANDS     R0,R5,R7
   \   00000068   0x4680             MOV      R8,R0
    918            
    919            itenable = tmpsr & (FSMC_IT >> 3);
   \   0000006A   0xEA17 0x00D5      ANDS     R0,R7,R5, LSR #+3
   \   0000006E   0x4681             MOV      R9,R0
    920            if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
   \   00000070   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000074   0xD005             BEQ.N    ??FSMC_GetITStatus_5
   \   00000076   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000007A   0xD002             BEQ.N    ??FSMC_GetITStatus_5
    921            {
    922              bitstatus = SET;
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0x0006             MOVS     R6,R0
   \   00000080   0xE001             B.N      ??FSMC_GetITStatus_6
    923            }
    924            else
    925            {
    926              bitstatus = RESET;
   \                     ??FSMC_GetITStatus_5: (+1)
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x0006             MOVS     R6,R0
    927            }
    928            return bitstatus; 
   \                     ??FSMC_GetITStatus_6: (+1)
   \   00000086   0x0030             MOVS     R0,R6
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    929          }
    930          
    931          /**
    932            * @brief  Clears the FSMC's interrupt pending bits.
    933            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    934            *          This parameter can be one of the following values:
    935            *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    936            *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    937            *            @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    938            * @param  FSMC_IT: specifies the interrupt pending bit to clear.
    939            *          This parameter can be any combination of the following values:
    940            *            @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
    941            *            @arg FSMC_IT_Level: Level edge detection interrupt.
    942            *            @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.
    943            * @retval None
    944            */

   \                                 In section .text, align 2, keep-with-next
    945          void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT)
    946          {
   \                     FSMC_ClearITPendingBit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    947            /* Check the parameters */
    948            assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
   \   00000006   0x2C10             CMP      R4,#+16
   \   00000008   0xD00A             BEQ.N    ??FSMC_ClearITPendingBit_0
   \   0000000A   0xF5B4 0x7F80      CMP      R4,#+256
   \   0000000E   0xD007             BEQ.N    ??FSMC_ClearITPendingBit_0
   \   00000010   0xF5B4 0x5F80      CMP      R4,#+4096
   \   00000014   0xD004             BEQ.N    ??FSMC_ClearITPendingBit_0
   \   00000016   0xF44F 0x716D      MOV      R1,#+948
   \   0000001A   0x....             LDR.N    R0,??DataTable15_18
   \   0000001C   0x.... 0x....      BL       assert_failed
    949            assert_param(IS_FSMC_IT(FSMC_IT));
   \                     ??FSMC_ClearITPendingBit_0: (+1)
   \   00000020   0xF035 0x0038      BICS     R0,R5,#0x38
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD101             BNE.N    ??FSMC_ClearITPendingBit_1
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD104             BNE.N    ??FSMC_ClearITPendingBit_2
   \                     ??FSMC_ClearITPendingBit_1: (+1)
   \   0000002C   0xF240 0x31B5      MOVW     R1,#+949
   \   00000030   0x....             LDR.N    R0,??DataTable15_18
   \   00000032   0x.... 0x....      BL       assert_failed
    950              
    951            if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     ??FSMC_ClearITPendingBit_2: (+1)
   \   00000036   0x2C10             CMP      R4,#+16
   \   00000038   0xD106             BNE.N    ??FSMC_ClearITPendingBit_3
    952            {
    953              FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
   \   0000003A   0x....             LDR.N    R0,??DataTable15_2  ;; 0xa0000064
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0xEA30 0x00D5      BICS     R0,R0,R5, LSR #+3
   \   00000042   0x....             LDR.N    R1,??DataTable15_2  ;; 0xa0000064
   \   00000044   0x6008             STR      R0,[R1, #+0]
   \   00000046   0xE00F             B.N      ??FSMC_ClearITPendingBit_4
    954            }  
    955            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ClearITPendingBit_3: (+1)
   \   00000048   0xF5B4 0x7F80      CMP      R4,#+256
   \   0000004C   0xD106             BNE.N    ??FSMC_ClearITPendingBit_5
    956            {
    957              FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
   \   0000004E   0x....             LDR.N    R0,??DataTable15_6  ;; 0xa0000084
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xEA30 0x00D5      BICS     R0,R0,R5, LSR #+3
   \   00000056   0x....             LDR.N    R1,??DataTable15_6  ;; 0xa0000084
   \   00000058   0x6008             STR      R0,[R1, #+0]
   \   0000005A   0xE005             B.N      ??FSMC_ClearITPendingBit_4
    958            }
    959            /* FSMC_Bank4_PCCARD*/
    960            else
    961            {
    962              FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
   \                     ??FSMC_ClearITPendingBit_5: (+1)
   \   0000005C   0x....             LDR.N    R0,??DataTable15_14  ;; 0xa00000a4
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xEA30 0x00D5      BICS     R0,R0,R5, LSR #+3
   \   00000064   0x....             LDR.N    R1,??DataTable15_14  ;; 0xa00000a4
   \   00000066   0x6008             STR      R0,[R1, #+0]
    963            }
    964          }
   \                     ??FSMC_ClearITPendingBit_4: (+1)
   \   00000068   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0xA0000104         DC32     0xa0000104

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x000FFFFE         DC32     0xffffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0xA0000060         DC32     0xa0000060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0xA0000064         DC32     0xa0000064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0xA0000068         DC32     0xa0000068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0xA000006C         DC32     0xa000006c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0xA0000080         DC32     0xa0000080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   0xA0000084         DC32     0xa0000084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \   00000000   0xA0000088         DC32     0xa0000088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \   00000000   0xA000008C         DC32     0xa000008c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_9:
   \   00000000   0x000FFFFB         DC32     0xffffb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_10:
   \   00000000   0x000FFFBF         DC32     0xfffbf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_11:
   \   00000000   0xA0000074         DC32     0xa0000074

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_12:
   \   00000000   0xA0000094         DC32     0xa0000094

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_13:
   \   00000000   0xA00000A0         DC32     0xa00000a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_14:
   \   00000000   0xA00000A4         DC32     0xa00000a4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_15:
   \   00000000   0xA00000A8         DC32     0xa00000a8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_16:
   \   00000000   0xA00000AC         DC32     0xa00000ac

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_17:
   \   00000000   0xA00000B0         DC32     0xa00000b0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_18:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 49H, 41H, 52H, 20H, 57H
   \              0x5C 0x49    
   \              0x41 0x52    
   \              0x20 0x57    
   \   00000008   0x6F 0x72          DC8 6FH, 72H, 6BH, 73H, 70H, 61H, 63H, 65H
   \              0x6B 0x73    
   \              0x70 0x61    
   \              0x63 0x65    
   \   00000010   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 46H, 34H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x46 0x34    
   \   00000018   0x30 0x37          DC8 30H, 37H, 5CH, 53H, 54H, 4DH, 33H, 32H
   \              0x5C 0x53    
   \              0x54 0x4D    
   \              0x33 0x32    
   \   00000020   0x46 0x34          DC8 46H, 34H, 2DH, 44H, 69H, 73H, 63H, 6FH
   \              0x2D 0x44    
   \              0x69 0x73    
   \              0x63 0x6F    
   \   00000028   0x76 0x65          DC8 76H, 65H, 72H, 79H, 5FH, 46H, 57H, 5FH
   \              0x72 0x79    
   \              0x5F 0x46    
   \              0x57 0x5F    
   \   00000030   0x56 0x31          DC8 56H, 31H, 2EH, 31H, 2EH, 30H, 5CH, 4CH
   \              0x2E 0x31    
   \              0x2E 0x30    
   \              0x5C 0x4C    
   \   00000038   0x69 0x62          DC8 69H, 62H, 72H, 61H, 72H, 69H, 65H, 73H
   \              0x72 0x61    
   \              0x72 0x69    
   \              0x65 0x73    
   \   00000040   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 46H, 34H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x46 0x34    
   \   00000048   0x78 0x78          DC8 78H, 78H, 5FH, 53H, 74H, 64H, 50H, 65H
   \              0x5F 0x53    
   \              0x74 0x64    
   \              0x50 0x65    
   \   00000050   0x72 0x69          DC8 72H, 69H, 70H, 68H, 5FH, 44H, 72H, 69H
   \              0x70 0x68    
   \              0x5F 0x44    
   \              0x72 0x69    
   \   00000058   0x76 0x65          DC8 76H, 65H, 72H, 5CH, 73H, 72H, 63H, 5CH
   \              0x72 0x5C    
   \              0x73 0x72    
   \              0x63 0x5C    
   \   00000060   0x73 0x74          DC8 73H, 74H, 6DH, 33H, 32H, 66H, 34H, 78H
   \              0x6D 0x33    
   \              0x32 0x66    
   \              0x34 0x78    
   \   00000068   0x78 0x5F          DC8 78H, 5FH, 66H, 73H, 6DH, 63H, 2EH, 63H
   \              0x66 0x73    
   \              0x6D 0x63    
   \              0x2E 0x63    
   \   00000070   0x00               DC8 0
   \   00000071   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    965          
    966          /**
    967            * @}
    968            */ 
    969          
    970          /**
    971            * @}
    972            */ 
    973          
    974          /**
    975            * @}
    976            */
    977          
    978          /**
    979            * @}
    980            */
    981          
    982          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   FSMC_ClearFlag
        16   -> assert_failed
      16   FSMC_ClearITPendingBit
        16   -> assert_failed
       0   FSMC_GetECC
      24   FSMC_GetFlagStatus
        24   -> assert_failed
      32   FSMC_GetITStatus
        32   -> assert_failed
      16   FSMC_ITConfig
        16   -> assert_failed
      16   FSMC_NANDCmd
        16   -> assert_failed
       8   FSMC_NANDDeInit
         8   -> assert_failed
      16   FSMC_NANDECCCmd
        16   -> assert_failed
      24   FSMC_NANDInit
        24   -> assert_failed
       0   FSMC_NANDStructInit
      16   FSMC_NORSRAMCmd
        16   -> assert_failed
       8   FSMC_NORSRAMDeInit
         8   -> assert_failed
       8   FSMC_NORSRAMInit
         8   -> assert_failed
       0   FSMC_NORSRAMStructInit
       8   FSMC_PCCARDCmd
         8   -> assert_failed
       0   FSMC_PCCARDDeInit
       8   FSMC_PCCARDInit
         8   -> assert_failed
       0   FSMC_PCCARDStructInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable14
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_14
       4  ??DataTable15_15
       4  ??DataTable15_16
       4  ??DataTable15_17
       4  ??DataTable15_18
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
     116  ?_0
     100  FSMC_ClearFlag
     106  FSMC_ClearITPendingBit
      28  FSMC_GetECC
     114  FSMC_GetFlagStatus
     142  FSMC_GetITStatus
     176  FSMC_ITConfig
     142  FSMC_NANDCmd
     106  FSMC_NANDDeInit
     142  FSMC_NANDECCCmd
     500  FSMC_NANDInit
      78  FSMC_NANDStructInit
     110  FSMC_NORSRAMCmd
      86  FSMC_NORSRAMDeInit
     860  FSMC_NORSRAMInit
     142  FSMC_NORSRAMStructInit
      60  FSMC_PCCARDCmd
      48  FSMC_PCCARDDeInit
     402  FSMC_PCCARDInit
      86  FSMC_PCCARDStructInit

 
   116 bytes in section .rodata
 3 512 bytes in section .text
 
 3 512 bytes of CODE  memory
   116 bytes of CONST memory

Errors: none
Warnings: none
