###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       06/May/2016  23:31:30
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\IAR
#        Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_adc.c
#    Command line =  
#        "D:\IAR
#        Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_adc.c"
#        -D USE_STDPERIPH_DRIVER -D STM32F4XX -D USE_FULL_ASSERT -lCN "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\List" -o "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\Obj" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\Include\" -I
#        "D:\IAR Workspace\STM32F407\VCP_ESP\..\Utilities\STM32F4-Discovery\"
#        -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\ST\STM32F4xx\Include\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_conf\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\cdc\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\otg\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\core\" -On --use_c++_inline -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    List file    =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\Debug\List\stm32f4xx_adc.lst
#    Object file  =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\Debug\Obj\stm32f4xx_adc.o
#
###############################################################################

D:\IAR Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_adc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_adc.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    30-September-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Analog to Digital Convertor (ADC) peripheral:
      9            *           - Initialization and Configuration (in addition to ADC multi mode 
     10            *             selection)
     11            *           - Analog Watchdog configuration
     12            *           - Temperature Sensor & Vrefint (Voltage Reference internal) & VBAT
     13            *             management 
     14            *           - Regular Channels Configuration
     15            *           - Regular Channels DMA Configuration
     16            *           - Injected channels Configuration
     17            *           - Interrupts and flags management
     18            *         
     19            *  @verbatim
     20            *
     21            *          ===================================================================
     22            *                                   How to use this driver
     23            *          ===================================================================
     24          
     25            *          1.  Enable the ADC interface clock using 
     26            *                  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADCx, ENABLE); 
     27            *     
     28            *          2. ADC pins configuration
     29            *               - Enable the clock for the ADC GPIOs using the following function:
     30            *                   RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);   
     31            *                - Configure these ADC pins in analog mode using GPIO_Init();  
     32            *
     33            *          3. Configure the ADC Prescaler, conversion resolution and data 
     34            *              alignment using the ADC_Init() function.
     35            *          4. Activate the ADC peripheral using ADC_Cmd() function.
     36            *
     37            *          Regular channels group configuration
     38            *          ====================================    
     39            *            - To configure the ADC regular channels group features, use 
     40            *              ADC_Init() and ADC_RegularChannelConfig() functions.
     41            *            - To activate the continuous mode, use the ADC_continuousModeCmd()
     42            *              function.
     43            *            - To configurate and activate the Discontinuous mode, use the 
     44            *              ADC_DiscModeChannelCountConfig() and ADC_DiscModeCmd() functions.
     45            *            - To read the ADC converted values, use the ADC_GetConversionValue()
     46            *              function.
     47            *
     48            *          Multi mode ADCs Regular channels configuration
     49            *          ===============================================
     50            *            - Refer to "Regular channels group configuration" description to
     51            *              configure the ADC1, ADC2 and ADC3 regular channels.        
     52            *            - Select the Multi mode ADC regular channels features (dual or 
     53            *              triple mode) using ADC_CommonInit() function and configure 
     54            *              the DMA mode using ADC_MultiModeDMARequestAfterLastTransferCmd() 
     55            *              functions.        
     56            *            - Read the ADCs converted values using the 
     57            *              ADC_GetMultiModeConversionValue() function.
     58            *
     59            *          DMA for Regular channels group features configuration
     60            *          ====================================================== 
     61            *           - To enable the DMA mode for regular channels group, use the 
     62            *             ADC_DMACmd() function.
     63            *           - To enable the generation of DMA requests continuously at the end
     64            *             of the last DMA transfer, use the ADC_DMARequestAfterLastTransferCmd() 
     65            *             function.
     66            *
     67            *          Injected channels group configuration
     68            *          =====================================    
     69            *            - To configure the ADC Injected channels group features, use 
     70            *              ADC_InjectedChannelConfig() and  ADC_InjectedSequencerLengthConfig()
     71            *              functions.
     72            *            - To activate the continuous mode, use the ADC_continuousModeCmd()
     73            *              function.
     74            *            - To activate the Injected Discontinuous mode, use the 
     75            *              ADC_InjectedDiscModeCmd() function.  
     76            *            - To activate the AutoInjected mode, use the ADC_AutoInjectedConvCmd() 
     77            *              function.        
     78            *            - To read the ADC converted values, use the ADC_GetInjectedConversionValue() 
     79            *              function.
     80            *
     81            *  @endverbatim
     82            *
     83            ******************************************************************************
     84            * @attention
     85            *
     86            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     87            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     88            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     89            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     90            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     91            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     92            *
     93            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     94            ******************************************************************************  
     95            */ 
     96          
     97          /* Includes ------------------------------------------------------------------*/
     98          #include "stm32f4xx_adc.h"
     99          #include "stm32f4xx_rcc.h"
    100          
    101          /** @addtogroup STM32F4xx_StdPeriph_Driver
    102            * @{
    103            */
    104          
    105          /** @defgroup ADC 
    106            * @brief ADC driver modules
    107            * @{
    108            */ 
    109          
    110          /* Private typedef -----------------------------------------------------------*/
    111          /* Private define ------------------------------------------------------------*/ 
    112          
    113          /* ADC DISCNUM mask */
    114          #define CR1_DISCNUM_RESET         ((uint32_t)0xFFFF1FFF)
    115          
    116          /* ADC AWDCH mask */
    117          #define CR1_AWDCH_RESET           ((uint32_t)0xFFFFFFE0)   
    118          
    119          /* ADC Analog watchdog enable mode mask */
    120          #define CR1_AWDMode_RESET         ((uint32_t)0xFF3FFDFF)   
    121          
    122          /* CR1 register Mask */
    123          #define CR1_CLEAR_MASK            ((uint32_t)0xFCFFFEFF)
    124          
    125          /* ADC EXTEN mask */
    126          #define CR2_EXTEN_RESET           ((uint32_t)0xCFFFFFFF)  
    127          
    128          /* ADC JEXTEN mask */
    129          #define CR2_JEXTEN_RESET          ((uint32_t)0xFFCFFFFF)  
    130          
    131          /* ADC JEXTSEL mask */
    132          #define CR2_JEXTSEL_RESET         ((uint32_t)0xFFF0FFFF)  
    133          
    134          /* CR2 register Mask */
    135          #define CR2_CLEAR_MASK            ((uint32_t)0xC0FFF7FD)
    136          
    137          /* ADC SQx mask */
    138          #define SQR3_SQ_SET               ((uint32_t)0x0000001F)  
    139          #define SQR2_SQ_SET               ((uint32_t)0x0000001F)  
    140          #define SQR1_SQ_SET               ((uint32_t)0x0000001F)  
    141          
    142          /* ADC L Mask */
    143          #define SQR1_L_RESET              ((uint32_t)0xFF0FFFFF) 
    144          
    145          /* ADC JSQx mask */
    146          #define JSQR_JSQ_SET              ((uint32_t)0x0000001F) 
    147          
    148          /* ADC JL mask */
    149          #define JSQR_JL_SET               ((uint32_t)0x00300000) 
    150          #define JSQR_JL_RESET             ((uint32_t)0xFFCFFFFF) 
    151          
    152          /* ADC SMPx mask */
    153          #define SMPR1_SMP_SET             ((uint32_t)0x00000007)  
    154          #define SMPR2_SMP_SET             ((uint32_t)0x00000007) 
    155          
    156          /* ADC JDRx registers offset */
    157          #define JDR_OFFSET                ((uint8_t)0x28) 
    158          
    159          /* ADC CDR register base address */
    160          #define CDR_ADDRESS               ((uint32_t)0x40012308)   
    161          
    162          /* ADC CCR register Mask */
    163          #define CR_CLEAR_MASK             ((uint32_t)0xFFFC30E0)  
    164          
    165          /* Private macro -------------------------------------------------------------*/
    166          /* Private variables ---------------------------------------------------------*/
    167          /* Private function prototypes -----------------------------------------------*/
    168          /* Private functions ---------------------------------------------------------*/
    169          
    170          /** @defgroup ADC_Private_Functions
    171            * @{
    172            */ 
    173          
    174          /** @defgroup ADC_Group1 Initialization and Configuration functions
    175           *  @brief    Initialization and Configuration functions 
    176           *
    177          @verbatim    
    178           ===============================================================================
    179                                Initialization and Configuration functions
    180           ===============================================================================  
    181            This section provides functions allowing to:
    182             - Initialize and configure the ADC Prescaler
    183             - ADC Conversion Resolution (12bit..6bit)
    184             - Scan Conversion Mode (multichannels or one channel) for regular group
    185             - ADC Continuous Conversion Mode (Continuous or Single conversion) for 
    186               regular group
    187             - External trigger Edge and source of regular group, 
    188             - Converted data alignment (left or right)
    189             - The number of ADC conversions that will be done using the sequencer for 
    190               regular channel group
    191             - Multi ADC mode selection
    192             - Direct memory access mode selection for multi ADC mode  
    193             - Delay between 2 sampling phases (used in dual or triple interleaved modes)
    194             - Enable or disable the ADC peripheral
    195             
    196          @endverbatim
    197            * @{
    198            */
    199          
    200          /**
    201            * @brief  Deinitializes all ADCs peripherals registers to their default reset 
    202            *         values.
    203            * @param  None
    204            * @retval None
    205            */

   \                                 In section .text, align 2, keep-with-next
    206          void ADC_DeInit(void)
    207          {
   \                     ADC_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    208            /* Enable all ADCs reset state */
    209            RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0xF44F 0x7080      MOV      R0,#+256
   \   00000008   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    210            
    211            /* Release all ADCs from reset state */
    212            RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, DISABLE);
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xF44F 0x7080      MOV      R0,#+256
   \   00000012   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    213          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    214          
    215          /**
    216            * @brief  Initializes the ADCx peripheral according to the specified parameters 
    217            *         in the ADC_InitStruct.
    218            * @note   This function is used to configure the global features of the ADC ( 
    219            *         Resolution and Data Alignment), however, the rest of the configuration
    220            *         parameters are specific to the regular channels group (scan mode 
    221            *         activation, continuous mode activation, External trigger source and 
    222            *         edge, number of conversion in the regular channels group sequencer).  
    223            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    224            * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
    225            *         the configuration information for the specified ADC peripheral.
    226            * @retval None
    227            */

   \                                 In section .text, align 2, keep-with-next
    228          void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
    229          {
   \                     ADC_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    230            uint32_t tmpreg1 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    231            uint8_t tmpreg2 = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    232            /* Check the parameters */
    233            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40012000
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD00C             BEQ.N    ??ADC_Init_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x40012100
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD008             BEQ.N    ??ADC_Init_0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable19_2  ;; 0x40012200
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD004             BEQ.N    ??ADC_Init_0
   \   00000022   0x21E9             MOVS     R1,#+233
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   00000028   0x.... 0x....      BL       assert_failed
    234            assert_param(IS_ADC_RESOLUTION(ADC_InitStruct->ADC_Resolution)); 
   \                     ??ADC_Init_0: (+1)
   \   0000002C   0x6828             LDR      R0,[R5, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD010             BEQ.N    ??ADC_Init_1
   \   00000032   0x6828             LDR      R0,[R5, #+0]
   \   00000034   0xF1B0 0x7F80      CMP      R0,#+16777216
   \   00000038   0xD00C             BEQ.N    ??ADC_Init_1
   \   0000003A   0x6828             LDR      R0,[R5, #+0]
   \   0000003C   0xF1B0 0x7F00      CMP      R0,#+33554432
   \   00000040   0xD008             BEQ.N    ??ADC_Init_1
   \   00000042   0x6828             LDR      R0,[R5, #+0]
   \   00000044   0xF1B0 0x7F40      CMP      R0,#+50331648
   \   00000048   0xD004             BEQ.N    ??ADC_Init_1
   \   0000004A   0x21EA             MOVS     R1,#+234
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   00000050   0x.... 0x....      BL       assert_failed
    235            assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
   \                     ??ADC_Init_1: (+1)
   \   00000054   0x7928             LDRB     R0,[R5, #+4]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD007             BEQ.N    ??ADC_Init_2
   \   0000005A   0x7928             LDRB     R0,[R5, #+4]
   \   0000005C   0x2801             CMP      R0,#+1
   \   0000005E   0xD004             BEQ.N    ??ADC_Init_2
   \   00000060   0x21EB             MOVS     R1,#+235
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   00000066   0x.... 0x....      BL       assert_failed
    236            assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode)); 
   \                     ??ADC_Init_2: (+1)
   \   0000006A   0x7968             LDRB     R0,[R5, #+5]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD007             BEQ.N    ??ADC_Init_3
   \   00000070   0x7968             LDRB     R0,[R5, #+5]
   \   00000072   0x2801             CMP      R0,#+1
   \   00000074   0xD004             BEQ.N    ??ADC_Init_3
   \   00000076   0x21EC             MOVS     R1,#+236
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   0000007C   0x.... 0x....      BL       assert_failed
    237            assert_param(IS_ADC_EXT_TRIG_EDGE(ADC_InitStruct->ADC_ExternalTrigConvEdge)); 
   \                     ??ADC_Init_3: (+1)
   \   00000080   0x68A8             LDR      R0,[R5, #+8]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD010             BEQ.N    ??ADC_Init_4
   \   00000086   0x68A8             LDR      R0,[R5, #+8]
   \   00000088   0xF1B0 0x5F80      CMP      R0,#+268435456
   \   0000008C   0xD00C             BEQ.N    ??ADC_Init_4
   \   0000008E   0x68A8             LDR      R0,[R5, #+8]
   \   00000090   0xF1B0 0x5F00      CMP      R0,#+536870912
   \   00000094   0xD008             BEQ.N    ??ADC_Init_4
   \   00000096   0x68A8             LDR      R0,[R5, #+8]
   \   00000098   0xF1B0 0x5F40      CMP      R0,#+805306368
   \   0000009C   0xD004             BEQ.N    ??ADC_Init_4
   \   0000009E   0x21ED             MOVS     R1,#+237
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   000000A4   0x.... 0x....      BL       assert_failed
    238            assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));    
   \                     ??ADC_Init_4: (+1)
   \   000000A8   0x68E8             LDR      R0,[R5, #+12]
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD040             BEQ.N    ??ADC_Init_5
   \   000000AE   0x68E8             LDR      R0,[R5, #+12]
   \   000000B0   0xF1B0 0x7F80      CMP      R0,#+16777216
   \   000000B4   0xD03C             BEQ.N    ??ADC_Init_5
   \   000000B6   0x68E8             LDR      R0,[R5, #+12]
   \   000000B8   0xF1B0 0x7F00      CMP      R0,#+33554432
   \   000000BC   0xD038             BEQ.N    ??ADC_Init_5
   \   000000BE   0x68E8             LDR      R0,[R5, #+12]
   \   000000C0   0xF1B0 0x7F40      CMP      R0,#+50331648
   \   000000C4   0xD034             BEQ.N    ??ADC_Init_5
   \   000000C6   0x68E8             LDR      R0,[R5, #+12]
   \   000000C8   0xF1B0 0x6F80      CMP      R0,#+67108864
   \   000000CC   0xD030             BEQ.N    ??ADC_Init_5
   \   000000CE   0x68E8             LDR      R0,[R5, #+12]
   \   000000D0   0xF1B0 0x6FA0      CMP      R0,#+83886080
   \   000000D4   0xD02C             BEQ.N    ??ADC_Init_5
   \   000000D6   0x68E8             LDR      R0,[R5, #+12]
   \   000000D8   0xF1B0 0x6FC0      CMP      R0,#+100663296
   \   000000DC   0xD028             BEQ.N    ??ADC_Init_5
   \   000000DE   0x68E8             LDR      R0,[R5, #+12]
   \   000000E0   0xF1B0 0x6FE0      CMP      R0,#+117440512
   \   000000E4   0xD024             BEQ.N    ??ADC_Init_5
   \   000000E6   0x68E8             LDR      R0,[R5, #+12]
   \   000000E8   0xF1B0 0x6F00      CMP      R0,#+134217728
   \   000000EC   0xD020             BEQ.N    ??ADC_Init_5
   \   000000EE   0x68E8             LDR      R0,[R5, #+12]
   \   000000F0   0xF1B0 0x6F10      CMP      R0,#+150994944
   \   000000F4   0xD01C             BEQ.N    ??ADC_Init_5
   \   000000F6   0x68E8             LDR      R0,[R5, #+12]
   \   000000F8   0xF1B0 0x6F20      CMP      R0,#+167772160
   \   000000FC   0xD018             BEQ.N    ??ADC_Init_5
   \   000000FE   0x68E8             LDR      R0,[R5, #+12]
   \   00000100   0xF1B0 0x6F30      CMP      R0,#+184549376
   \   00000104   0xD014             BEQ.N    ??ADC_Init_5
   \   00000106   0x68E8             LDR      R0,[R5, #+12]
   \   00000108   0xF1B0 0x6F40      CMP      R0,#+201326592
   \   0000010C   0xD010             BEQ.N    ??ADC_Init_5
   \   0000010E   0x68E8             LDR      R0,[R5, #+12]
   \   00000110   0xF1B0 0x6F50      CMP      R0,#+218103808
   \   00000114   0xD00C             BEQ.N    ??ADC_Init_5
   \   00000116   0x68E8             LDR      R0,[R5, #+12]
   \   00000118   0xF1B0 0x6F60      CMP      R0,#+234881024
   \   0000011C   0xD008             BEQ.N    ??ADC_Init_5
   \   0000011E   0x68E8             LDR      R0,[R5, #+12]
   \   00000120   0xF1B0 0x6F70      CMP      R0,#+251658240
   \   00000124   0xD004             BEQ.N    ??ADC_Init_5
   \   00000126   0x21EE             MOVS     R1,#+238
   \   00000128   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   0000012C   0x.... 0x....      BL       assert_failed
    239            assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
   \                     ??ADC_Init_5: (+1)
   \   00000130   0x6928             LDR      R0,[R5, #+16]
   \   00000132   0x2800             CMP      R0,#+0
   \   00000134   0xD008             BEQ.N    ??ADC_Init_6
   \   00000136   0x6928             LDR      R0,[R5, #+16]
   \   00000138   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000013C   0xD004             BEQ.N    ??ADC_Init_6
   \   0000013E   0x21EF             MOVS     R1,#+239
   \   00000140   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   00000144   0x.... 0x....      BL       assert_failed
    240            assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));
   \                     ??ADC_Init_6: (+1)
   \   00000148   0x7D28             LDRB     R0,[R5, #+20]
   \   0000014A   0x2800             CMP      R0,#+0
   \   0000014C   0xD002             BEQ.N    ??ADC_Init_7
   \   0000014E   0x7D28             LDRB     R0,[R5, #+20]
   \   00000150   0x2811             CMP      R0,#+17
   \   00000152   0xDB04             BLT.N    ??ADC_Init_8
   \                     ??ADC_Init_7: (+1)
   \   00000154   0x21F0             MOVS     R1,#+240
   \   00000156   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   0000015A   0x.... 0x....      BL       assert_failed
    241            
    242            /*---------------------------- ADCx CR1 Configuration -----------------*/
    243            /* Get the ADCx CR1 value */
    244            tmpreg1 = ADCx->CR1;
   \                     ??ADC_Init_8: (+1)
   \   0000015E   0x6860             LDR      R0,[R4, #+4]
   \   00000160   0x0006             MOVS     R6,R0
    245            
    246            /* Clear RES and SCAN bits */
    247            tmpreg1 &= CR1_CLEAR_MASK;
   \   00000162   0x.... 0x....      LDR.W    R0,??DataTable19_4  ;; 0xfcfffeff
   \   00000166   0x4006             ANDS     R6,R0,R6
    248            
    249            /* Configure ADCx: scan conversion mode and resolution */
    250            /* Set SCAN bit according to ADC_ScanConvMode value */
    251            /* Set RES bit according to ADC_Resolution value */ 
    252            tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
    253                                             ADC_InitStruct->ADC_Resolution);
   \   00000168   0x7928             LDRB     R0,[R5, #+4]
   \   0000016A   0x6829             LDR      R1,[R5, #+0]
   \   0000016C   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000170   0x4306             ORRS     R6,R0,R6
    254            /* Write to ADCx CR1 */
    255            ADCx->CR1 = tmpreg1;
   \   00000172   0x6066             STR      R6,[R4, #+4]
    256            /*---------------------------- ADCx CR2 Configuration -----------------*/
    257            /* Get the ADCx CR2 value */
    258            tmpreg1 = ADCx->CR2;
   \   00000174   0x68A0             LDR      R0,[R4, #+8]
   \   00000176   0x0006             MOVS     R6,R0
    259            
    260            /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */
    261            tmpreg1 &= CR2_CLEAR_MASK;
   \   00000178   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0xc0fff7fd
   \   0000017C   0x4006             ANDS     R6,R0,R6
    262            
    263            /* Configure ADCx: external trigger event and edge, data alignment and 
    264               continuous conversion mode */
    265            /* Set ALIGN bit according to ADC_DataAlign value */
    266            /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
    267            /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
    268            /* Set CONT bit according to ADC_ContinuousConvMode value */
    269            tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
    270                                  ADC_InitStruct->ADC_ExternalTrigConv | 
    271                                  ADC_InitStruct->ADC_ExternalTrigConvEdge | \
    272                                  ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
   \   0000017E   0x6928             LDR      R0,[R5, #+16]
   \   00000180   0x68E9             LDR      R1,[R5, #+12]
   \   00000182   0x4308             ORRS     R0,R1,R0
   \   00000184   0x68A9             LDR      R1,[R5, #+8]
   \   00000186   0x4308             ORRS     R0,R1,R0
   \   00000188   0x7969             LDRB     R1,[R5, #+5]
   \   0000018A   0xEA50 0x0041      ORRS     R0,R0,R1, LSL #+1
   \   0000018E   0x4306             ORRS     R6,R0,R6
    273                                  
    274            /* Write to ADCx CR2 */
    275            ADCx->CR2 = tmpreg1;
   \   00000190   0x60A6             STR      R6,[R4, #+8]
    276            /*---------------------------- ADCx SQR1 Configuration -----------------*/
    277            /* Get the ADCx SQR1 value */
    278            tmpreg1 = ADCx->SQR1;
   \   00000192   0x6AE0             LDR      R0,[R4, #+44]
   \   00000194   0x0006             MOVS     R6,R0
    279            
    280            /* Clear L bits */
    281            tmpreg1 &= SQR1_L_RESET;
   \   00000196   0xF436 0x0670      BICS     R6,R6,#0xF00000
    282            
    283            /* Configure ADCx: regular channel sequence length */
    284            /* Set L bits according to ADC_NbrOfConversion value */
    285            tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
   \   0000019A   0x7D28             LDRB     R0,[R5, #+20]
   \   0000019C   0x1E40             SUBS     R0,R0,#+1
   \   0000019E   0x4307             ORRS     R7,R0,R7
    286            tmpreg1 |= ((uint32_t)tmpreg2 << 20);
   \   000001A0   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001A2   0xEA56 0x5607      ORRS     R6,R6,R7, LSL #+20
    287            
    288            /* Write to ADCx SQR1 */
    289            ADCx->SQR1 = tmpreg1;
   \   000001A6   0x62E6             STR      R6,[R4, #+44]
    290          }
   \   000001A8   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    291          
    292          /**
    293            * @brief  Fills each ADC_InitStruct member with its default value.
    294            * @note   This function is used to initialize the global features of the ADC ( 
    295            *         Resolution and Data Alignment), however, the rest of the configuration
    296            *         parameters are specific to the regular channels group (scan mode 
    297            *         activation, continuous mode activation, External trigger source and 
    298            *         edge, number of conversion in the regular channels group sequencer).  
    299            * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure which will 
    300            *         be initialized.
    301            * @retval None
    302            */

   \                                 In section .text, align 2, keep-with-next
    303          void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
    304          {
    305            /* Initialize the ADC_Mode member */
    306            ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
   \                     ADC_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    307          
    308            /* initialize the ADC_ScanConvMode member */
    309            ADC_InitStruct->ADC_ScanConvMode = DISABLE;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7101             STRB     R1,[R0, #+4]
    310          
    311            /* Initialize the ADC_ContinuousConvMode member */
    312            ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7141             STRB     R1,[R0, #+5]
    313          
    314            /* Initialize the ADC_ExternalTrigConvEdge member */
    315            ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6081             STR      R1,[R0, #+8]
    316          
    317            /* Initialize the ADC_ExternalTrigConv member */
    318            ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x60C1             STR      R1,[R0, #+12]
    319          
    320            /* Initialize the ADC_DataAlign member */
    321            ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6101             STR      R1,[R0, #+16]
    322          
    323            /* Initialize the ADC_NbrOfConversion member */
    324            ADC_InitStruct->ADC_NbrOfConversion = 1;
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x7501             STRB     R1,[R0, #+20]
    325          }
   \   0000001C   0x4770             BX       LR               ;; return
    326          
    327          /**
    328            * @brief  Initializes the ADCs peripherals according to the specified parameters 
    329            *         in the ADC_CommonInitStruct.
    330            * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure 
    331            *         that contains the configuration information for  All ADCs peripherals.
    332            * @retval None
    333            */

   \                                 In section .text, align 2, keep-with-next
    334          void ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
    335          {
   \                     ADC_CommonInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    336            uint32_t tmpreg1 = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    337            /* Check the parameters */
    338            assert_param(IS_ADC_MODE(ADC_CommonInitStruct->ADC_Mode));
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD029             BEQ.N    ??ADC_CommonInit_0
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD026             BEQ.N    ??ADC_CommonInit_0
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD023             BEQ.N    ??ADC_CommonInit_0
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x2805             CMP      R0,#+5
   \   0000001C   0xD020             BEQ.N    ??ADC_CommonInit_0
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x2806             CMP      R0,#+6
   \   00000022   0xD01D             BEQ.N    ??ADC_CommonInit_0
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x2807             CMP      R0,#+7
   \   00000028   0xD01A             BEQ.N    ??ADC_CommonInit_0
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x2809             CMP      R0,#+9
   \   0000002E   0xD017             BEQ.N    ??ADC_CommonInit_0
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x2811             CMP      R0,#+17
   \   00000034   0xD014             BEQ.N    ??ADC_CommonInit_0
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x2812             CMP      R0,#+18
   \   0000003A   0xD011             BEQ.N    ??ADC_CommonInit_0
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x2815             CMP      R0,#+21
   \   00000040   0xD00E             BEQ.N    ??ADC_CommonInit_0
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x2816             CMP      R0,#+22
   \   00000046   0xD00B             BEQ.N    ??ADC_CommonInit_0
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x2817             CMP      R0,#+23
   \   0000004C   0xD008             BEQ.N    ??ADC_CommonInit_0
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x2819             CMP      R0,#+25
   \   00000052   0xD005             BEQ.N    ??ADC_CommonInit_0
   \   00000054   0xF44F 0x71A9      MOV      R1,#+338
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   0000005C   0x.... 0x....      BL       assert_failed
    339            assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
   \                     ??ADC_CommonInit_0: (+1)
   \   00000060   0x6860             LDR      R0,[R4, #+4]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD011             BEQ.N    ??ADC_CommonInit_1
   \   00000066   0x6860             LDR      R0,[R4, #+4]
   \   00000068   0xF5B0 0x3F80      CMP      R0,#+65536
   \   0000006C   0xD00D             BEQ.N    ??ADC_CommonInit_1
   \   0000006E   0x6860             LDR      R0,[R4, #+4]
   \   00000070   0xF5B0 0x3F00      CMP      R0,#+131072
   \   00000074   0xD009             BEQ.N    ??ADC_CommonInit_1
   \   00000076   0x6860             LDR      R0,[R4, #+4]
   \   00000078   0xF5B0 0x3F40      CMP      R0,#+196608
   \   0000007C   0xD005             BEQ.N    ??ADC_CommonInit_1
   \   0000007E   0xF240 0x1153      MOVW     R1,#+339
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   00000086   0x.... 0x....      BL       assert_failed
    340            assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
   \                     ??ADC_CommonInit_1: (+1)
   \   0000008A   0x68A0             LDR      R0,[R4, #+8]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD011             BEQ.N    ??ADC_CommonInit_2
   \   00000090   0x68A0             LDR      R0,[R4, #+8]
   \   00000092   0xF5B0 0x4F80      CMP      R0,#+16384
   \   00000096   0xD00D             BEQ.N    ??ADC_CommonInit_2
   \   00000098   0x68A0             LDR      R0,[R4, #+8]
   \   0000009A   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000009E   0xD009             BEQ.N    ??ADC_CommonInit_2
   \   000000A0   0x68A0             LDR      R0,[R4, #+8]
   \   000000A2   0xF5B0 0x4F40      CMP      R0,#+49152
   \   000000A6   0xD005             BEQ.N    ??ADC_CommonInit_2
   \   000000A8   0xF44F 0x71AA      MOV      R1,#+340
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   000000B0   0x.... 0x....      BL       assert_failed
    341            assert_param(IS_ADC_SAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));
   \                     ??ADC_CommonInit_2: (+1)
   \   000000B4   0x68E0             LDR      R0,[R4, #+12]
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD041             BEQ.N    ??ADC_CommonInit_3
   \   000000BA   0x68E0             LDR      R0,[R4, #+12]
   \   000000BC   0xF5B0 0x7F80      CMP      R0,#+256
   \   000000C0   0xD03D             BEQ.N    ??ADC_CommonInit_3
   \   000000C2   0x68E0             LDR      R0,[R4, #+12]
   \   000000C4   0xF5B0 0x7F00      CMP      R0,#+512
   \   000000C8   0xD039             BEQ.N    ??ADC_CommonInit_3
   \   000000CA   0x68E0             LDR      R0,[R4, #+12]
   \   000000CC   0xF5B0 0x7F40      CMP      R0,#+768
   \   000000D0   0xD035             BEQ.N    ??ADC_CommonInit_3
   \   000000D2   0x68E0             LDR      R0,[R4, #+12]
   \   000000D4   0xF5B0 0x6F80      CMP      R0,#+1024
   \   000000D8   0xD031             BEQ.N    ??ADC_CommonInit_3
   \   000000DA   0x68E0             LDR      R0,[R4, #+12]
   \   000000DC   0xF5B0 0x6FA0      CMP      R0,#+1280
   \   000000E0   0xD02D             BEQ.N    ??ADC_CommonInit_3
   \   000000E2   0x68E0             LDR      R0,[R4, #+12]
   \   000000E4   0xF5B0 0x6FC0      CMP      R0,#+1536
   \   000000E8   0xD029             BEQ.N    ??ADC_CommonInit_3
   \   000000EA   0x68E0             LDR      R0,[R4, #+12]
   \   000000EC   0xF5B0 0x6FE0      CMP      R0,#+1792
   \   000000F0   0xD025             BEQ.N    ??ADC_CommonInit_3
   \   000000F2   0x68E0             LDR      R0,[R4, #+12]
   \   000000F4   0xF5B0 0x6F00      CMP      R0,#+2048
   \   000000F8   0xD021             BEQ.N    ??ADC_CommonInit_3
   \   000000FA   0x68E0             LDR      R0,[R4, #+12]
   \   000000FC   0xF5B0 0x6F10      CMP      R0,#+2304
   \   00000100   0xD01D             BEQ.N    ??ADC_CommonInit_3
   \   00000102   0x68E0             LDR      R0,[R4, #+12]
   \   00000104   0xF5B0 0x6F20      CMP      R0,#+2560
   \   00000108   0xD019             BEQ.N    ??ADC_CommonInit_3
   \   0000010A   0x68E0             LDR      R0,[R4, #+12]
   \   0000010C   0xF5B0 0x6F30      CMP      R0,#+2816
   \   00000110   0xD015             BEQ.N    ??ADC_CommonInit_3
   \   00000112   0x68E0             LDR      R0,[R4, #+12]
   \   00000114   0xF5B0 0x6F40      CMP      R0,#+3072
   \   00000118   0xD011             BEQ.N    ??ADC_CommonInit_3
   \   0000011A   0x68E0             LDR      R0,[R4, #+12]
   \   0000011C   0xF5B0 0x6F50      CMP      R0,#+3328
   \   00000120   0xD00D             BEQ.N    ??ADC_CommonInit_3
   \   00000122   0x68E0             LDR      R0,[R4, #+12]
   \   00000124   0xF5B0 0x6F60      CMP      R0,#+3584
   \   00000128   0xD009             BEQ.N    ??ADC_CommonInit_3
   \   0000012A   0x68E0             LDR      R0,[R4, #+12]
   \   0000012C   0xF5B0 0x6F70      CMP      R0,#+3840
   \   00000130   0xD005             BEQ.N    ??ADC_CommonInit_3
   \   00000132   0xF240 0x1155      MOVW     R1,#+341
   \   00000136   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   0000013A   0x.... 0x....      BL       assert_failed
    342            /*---------------------------- ADC CCR Configuration -----------------*/
    343            /* Get the ADC CCR value */
    344            tmpreg1 = ADC->CCR;
   \                     ??ADC_CommonInit_3: (+1)
   \   0000013E   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0x40012304
   \   00000142   0x6800             LDR      R0,[R0, #+0]
   \   00000144   0x0005             MOVS     R5,R0
    345            
    346            /* Clear MULTI, DELAY, DMA and ADCPRE bits */
    347            tmpreg1 &= CR_CLEAR_MASK;
   \   00000146   0x.... 0x....      LDR.W    R0,??DataTable22  ;; 0xfffc30e0
   \   0000014A   0x4005             ANDS     R5,R0,R5
    348            
    349            /* Configure ADCx: Multi mode, Delay between two sampling time, ADC prescaler,
    350               and DMA access mode for multimode */
    351            /* Set MULTI bits according to ADC_Mode value */
    352            /* Set ADCPRE bits according to ADC_Prescaler value */
    353            /* Set DMA bits according to ADC_DMAAccessMode value */
    354            /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
    355            tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
    356                                  ADC_CommonInitStruct->ADC_Prescaler | 
    357                                  ADC_CommonInitStruct->ADC_DMAAccessMode | 
    358                                  ADC_CommonInitStruct->ADC_TwoSamplingDelay);
   \   0000014C   0x6820             LDR      R0,[R4, #+0]
   \   0000014E   0x6861             LDR      R1,[R4, #+4]
   \   00000150   0x4308             ORRS     R0,R1,R0
   \   00000152   0x68A1             LDR      R1,[R4, #+8]
   \   00000154   0x4308             ORRS     R0,R1,R0
   \   00000156   0x68E1             LDR      R1,[R4, #+12]
   \   00000158   0x4308             ORRS     R0,R1,R0
   \   0000015A   0x4305             ORRS     R5,R0,R5
    359                                  
    360            /* Write to ADC CCR */
    361            ADC->CCR = tmpreg1;
   \   0000015C   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0x40012304
   \   00000160   0x6005             STR      R5,[R0, #+0]
    362          }
   \   00000162   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    363          
    364          /**
    365            * @brief  Fills each ADC_CommonInitStruct member with its default value.
    366            * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure
    367            *         which will be initialized.
    368            * @retval None
    369            */

   \                                 In section .text, align 2, keep-with-next
    370          void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
    371          {
    372            /* Initialize the ADC_Mode member */
    373            ADC_CommonInitStruct->ADC_Mode = ADC_Mode_Independent;
   \                     ADC_CommonStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    374          
    375            /* initialize the ADC_Prescaler member */
    376            ADC_CommonInitStruct->ADC_Prescaler = ADC_Prescaler_Div2;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6041             STR      R1,[R0, #+4]
    377          
    378            /* Initialize the ADC_DMAAccessMode member */
    379            ADC_CommonInitStruct->ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6081             STR      R1,[R0, #+8]
    380          
    381            /* Initialize the ADC_TwoSamplingDelay member */
    382            ADC_CommonInitStruct->ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
    383          }
   \   00000010   0x4770             BX       LR               ;; return
    384          
    385          /**
    386            * @brief  Enables or disables the specified ADC peripheral.
    387            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    388            * @param  NewState: new state of the ADCx peripheral. 
    389            *          This parameter can be: ENABLE or DISABLE.
    390            * @retval None
    391            */

   \                                 In section .text, align 2, keep-with-next
    392          void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    393          {
   \                     ADC_Cmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    394            /* Check the parameters */
    395            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40012000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??ADC_Cmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x40012100
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??ADC_Cmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable19_2  ;; 0x40012200
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??ADC_Cmd_0
   \   0000001E   0xF240 0x118B      MOVW     R1,#+395
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   00000026   0x.... 0x....      BL       assert_failed
    396            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_Cmd_0: (+1)
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD008             BEQ.N    ??ADC_Cmd_1
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D01             CMP      R5,#+1
   \   00000034   0xD005             BEQ.N    ??ADC_Cmd_1
   \   00000036   0xF44F 0x71C6      MOV      R1,#+396
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   0000003E   0x.... 0x....      BL       assert_failed
    397            if (NewState != DISABLE)
   \                     ??ADC_Cmd_1: (+1)
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD004             BEQ.N    ??ADC_Cmd_2
    398            {
    399              /* Set the ADON bit to wake up the ADC from power down mode */
    400              ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
   \   00000048   0x68A0             LDR      R0,[R4, #+8]
   \   0000004A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000004E   0x60A0             STR      R0,[R4, #+8]
   \   00000050   0xE003             B.N      ??ADC_Cmd_3
    401            }
    402            else
    403            {
    404              /* Disable the selected ADC peripheral */
    405              ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
   \                     ??ADC_Cmd_2: (+1)
   \   00000052   0x68A0             LDR      R0,[R4, #+8]
   \   00000054   0x0840             LSRS     R0,R0,#+1
   \   00000056   0x0040             LSLS     R0,R0,#+1
   \   00000058   0x60A0             STR      R0,[R4, #+8]
    406            }
    407          }
   \                     ??ADC_Cmd_3: (+1)
   \   0000005A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    408          /**
    409            * @}
    410            */
    411          
    412          /** @defgroup ADC_Group2 Analog Watchdog configuration functions
    413           *  @brief    Analog Watchdog configuration functions 
    414           *
    415          @verbatim   
    416           ===============================================================================
    417                              Analog Watchdog configuration functions
    418           ===============================================================================  
    419          
    420            This section provides functions allowing to configure the Analog Watchdog
    421            (AWD) feature in the ADC.
    422            
    423            A typical configuration Analog Watchdog is done following these steps :
    424             1. the ADC guarded channel(s) is (are) selected using the 
    425                ADC_AnalogWatchdogSingleChannelConfig() function.
    426             2. The Analog watchdog lower and higher threshold are configured using the  
    427               ADC_AnalogWatchdogThresholdsConfig() function.
    428             3. The Analog watchdog is enabled and configured to enable the check, on one
    429                or more channels, using the  ADC_AnalogWatchdogCmd() function.
    430          
    431          @endverbatim
    432            * @{
    433            */
    434            
    435          /**
    436            * @brief  Enables or disables the analog watchdog on single/all regular or 
    437            *         injected channels
    438            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    439            * @param  ADC_AnalogWatchdog: the ADC analog watchdog configuration.
    440            *         This parameter can be one of the following values:
    441            *            @arg ADC_AnalogWatchdog_SingleRegEnable: Analog watchdog on a single regular channel
    442            *            @arg ADC_AnalogWatchdog_SingleInjecEnable: Analog watchdog on a single injected channel
    443            *            @arg ADC_AnalogWatchdog_SingleRegOrInjecEnable: Analog watchdog on a single regular or injected channel
    444            *            @arg ADC_AnalogWatchdog_AllRegEnable: Analog watchdog on all regular channel
    445            *            @arg ADC_AnalogWatchdog_AllInjecEnable: Analog watchdog on all injected channel
    446            *            @arg ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog on all regular and injected channels
    447            *            @arg ADC_AnalogWatchdog_None: No channel guarded by the analog watchdog
    448            * @retval None	  
    449            */

   \                                 In section .text, align 2, keep-with-next
    450          void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
    451          {
   \                     ADC_AnalogWatchdogCmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    452            uint32_t tmpreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    453            /* Check the parameters */
    454            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40012000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD00D             BEQ.N    ??ADC_AnalogWatchdogCmd_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x40012100
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD009             BEQ.N    ??ADC_AnalogWatchdogCmd_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable19_2  ;; 0x40012200
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD005             BEQ.N    ??ADC_AnalogWatchdogCmd_0
   \   00000020   0xF44F 0x71E3      MOV      R1,#+454
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   00000028   0x.... 0x....      BL       assert_failed
    455            assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
   \                     ??ADC_AnalogWatchdogCmd_0: (+1)
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x800200
   \   00000030   0x4285             CMP      R5,R0
   \   00000032   0xD018             BEQ.N    ??ADC_AnalogWatchdogCmd_1
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable25  ;; 0x400200
   \   00000038   0x4285             CMP      R5,R0
   \   0000003A   0xD014             BEQ.N    ??ADC_AnalogWatchdogCmd_1
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable25_1  ;; 0xc00200
   \   00000040   0x4285             CMP      R5,R0
   \   00000042   0xD010             BEQ.N    ??ADC_AnalogWatchdogCmd_1
   \   00000044   0xF5B5 0x0F00      CMP      R5,#+8388608
   \   00000048   0xD00D             BEQ.N    ??ADC_AnalogWatchdogCmd_1
   \   0000004A   0xF5B5 0x0F80      CMP      R5,#+4194304
   \   0000004E   0xD00A             BEQ.N    ??ADC_AnalogWatchdogCmd_1
   \   00000050   0xF5B5 0x0F40      CMP      R5,#+12582912
   \   00000054   0xD007             BEQ.N    ??ADC_AnalogWatchdogCmd_1
   \   00000056   0x2D00             CMP      R5,#+0
   \   00000058   0xD005             BEQ.N    ??ADC_AnalogWatchdogCmd_1
   \   0000005A   0xF240 0x11C7      MOVW     R1,#+455
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   00000062   0x.... 0x....      BL       assert_failed
    456            
    457            /* Get the old register value */
    458            tmpreg = ADCx->CR1;
   \                     ??ADC_AnalogWatchdogCmd_1: (+1)
   \   00000066   0x6860             LDR      R0,[R4, #+4]
   \   00000068   0x0006             MOVS     R6,R0
    459            
    460            /* Clear AWDEN, JAWDEN and AWDSGL bits */
    461            tmpreg &= CR1_AWDMode_RESET;
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable30  ;; 0xff3ffdff
   \   0000006E   0x4006             ANDS     R6,R0,R6
    462            
    463            /* Set the analog watchdog enable mode */
    464            tmpreg |= ADC_AnalogWatchdog;
   \   00000070   0x432E             ORRS     R6,R5,R6
    465            
    466            /* Store the new register value */
    467            ADCx->CR1 = tmpreg;
   \   00000072   0x6066             STR      R6,[R4, #+4]
    468          }
   \   00000074   0xBD70             POP      {R4-R6,PC}       ;; return
    469          
    470          /**
    471            * @brief  Configures the high and low thresholds of the analog watchdog.
    472            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    473            * @param  HighThreshold: the ADC analog watchdog High threshold value.
    474            *          This parameter must be a 12-bit value.
    475            * @param  LowThreshold:  the ADC analog watchdog Low threshold value.
    476            *          This parameter must be a 12-bit value.
    477            * @retval None
    478            */

   \                                 In section .text, align 2, keep-with-next
    479          void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
    480                                                  uint16_t LowThreshold)
    481          {
   \                     ADC_AnalogWatchdogThresholdsConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    482            /* Check the parameters */
    483            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40012000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD00D             BEQ.N    ??ADC_AnalogWatchdogThresholdsConfig_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x40012100
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD009             BEQ.N    ??ADC_AnalogWatchdogThresholdsConfig_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable19_2  ;; 0x40012200
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD005             BEQ.N    ??ADC_AnalogWatchdogThresholdsConfig_0
   \   00000020   0xF240 0x11E3      MOVW     R1,#+483
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   00000028   0x.... 0x....      BL       assert_failed
    484            assert_param(IS_ADC_THRESHOLD(HighThreshold));
   \                     ??ADC_AnalogWatchdogThresholdsConfig_0: (+1)
   \   0000002C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002E   0xF5B5 0x5F80      CMP      R5,#+4096
   \   00000032   0xDB05             BLT.N    ??ADC_AnalogWatchdogThresholdsConfig_1
   \   00000034   0xF44F 0x71F2      MOV      R1,#+484
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   0000003C   0x.... 0x....      BL       assert_failed
    485            assert_param(IS_ADC_THRESHOLD(LowThreshold));
   \                     ??ADC_AnalogWatchdogThresholdsConfig_1: (+1)
   \   00000040   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000042   0xF5B6 0x5F80      CMP      R6,#+4096
   \   00000046   0xDB05             BLT.N    ??ADC_AnalogWatchdogThresholdsConfig_2
   \   00000048   0xF240 0x11E5      MOVW     R1,#+485
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   00000050   0x.... 0x....      BL       assert_failed
    486            
    487            /* Set the ADCx high threshold */
    488            ADCx->HTR = HighThreshold;
   \                     ??ADC_AnalogWatchdogThresholdsConfig_2: (+1)
   \   00000054   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000056   0x6265             STR      R5,[R4, #+36]
    489            
    490            /* Set the ADCx low threshold */
    491            ADCx->LTR = LowThreshold;
   \   00000058   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000005A   0x62A6             STR      R6,[R4, #+40]
    492          }
   \   0000005C   0xBD70             POP      {R4-R6,PC}       ;; return
    493          
    494          /**
    495            * @brief  Configures the analog watchdog guarded single channel
    496            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    497            * @param  ADC_Channel: the ADC channel to configure for the analog watchdog. 
    498            *          This parameter can be one of the following values:
    499            *            @arg ADC_Channel_0: ADC Channel0 selected
    500            *            @arg ADC_Channel_1: ADC Channel1 selected
    501            *            @arg ADC_Channel_2: ADC Channel2 selected
    502            *            @arg ADC_Channel_3: ADC Channel3 selected
    503            *            @arg ADC_Channel_4: ADC Channel4 selected
    504            *            @arg ADC_Channel_5: ADC Channel5 selected
    505            *            @arg ADC_Channel_6: ADC Channel6 selected
    506            *            @arg ADC_Channel_7: ADC Channel7 selected
    507            *            @arg ADC_Channel_8: ADC Channel8 selected
    508            *            @arg ADC_Channel_9: ADC Channel9 selected
    509            *            @arg ADC_Channel_10: ADC Channel10 selected
    510            *            @arg ADC_Channel_11: ADC Channel11 selected
    511            *            @arg ADC_Channel_12: ADC Channel12 selected
    512            *            @arg ADC_Channel_13: ADC Channel13 selected
    513            *            @arg ADC_Channel_14: ADC Channel14 selected
    514            *            @arg ADC_Channel_15: ADC Channel15 selected
    515            *            @arg ADC_Channel_16: ADC Channel16 selected
    516            *            @arg ADC_Channel_17: ADC Channel17 selected
    517            *            @arg ADC_Channel_18: ADC Channel18 selected
    518            * @retval None
    519            */

   \                                 In section .text, align 2, keep-with-next
    520          void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
    521          {
   \                     ADC_AnalogWatchdogSingleChannelConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    522            uint32_t tmpreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    523            /* Check the parameters */
    524            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40012000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD00D             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x40012100
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD009             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable19_2  ;; 0x40012200
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD005             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_0
   \   00000020   0xF44F 0x7103      MOV      R1,#+524
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   00000028   0x.... 0x....      BL       assert_failed
    525            assert_param(IS_ADC_CHANNEL(ADC_Channel));
   \                     ??ADC_AnalogWatchdogSingleChannelConfig_0: (+1)
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD03B             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D01             CMP      R5,#+1
   \   00000036   0xD038             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D02             CMP      R5,#+2
   \   0000003C   0xD035             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2D03             CMP      R5,#+3
   \   00000042   0xD032             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000044   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000046   0x2D04             CMP      R5,#+4
   \   00000048   0xD02F             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   0000004A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004C   0x2D05             CMP      R5,#+5
   \   0000004E   0xD02C             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000050   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000052   0x2D06             CMP      R5,#+6
   \   00000054   0xD029             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000056   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000058   0x2D07             CMP      R5,#+7
   \   0000005A   0xD026             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   0000005C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005E   0x2D08             CMP      R5,#+8
   \   00000060   0xD023             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000062   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000064   0x2D09             CMP      R5,#+9
   \   00000066   0xD020             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000068   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000006A   0x2D0A             CMP      R5,#+10
   \   0000006C   0xD01D             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   0000006E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000070   0x2D0B             CMP      R5,#+11
   \   00000072   0xD01A             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000074   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000076   0x2D0C             CMP      R5,#+12
   \   00000078   0xD017             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   0000007A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007C   0x2D0D             CMP      R5,#+13
   \   0000007E   0xD014             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000080   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000082   0x2D0E             CMP      R5,#+14
   \   00000084   0xD011             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000086   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000088   0x2D0F             CMP      R5,#+15
   \   0000008A   0xD00E             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   0000008C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000008E   0x2D10             CMP      R5,#+16
   \   00000090   0xD00B             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000092   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000094   0x2D11             CMP      R5,#+17
   \   00000096   0xD008             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000098   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000009A   0x2D12             CMP      R5,#+18
   \   0000009C   0xD005             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   0000009E   0xF240 0x210D      MOVW     R1,#+525
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   000000A6   0x.... 0x....      BL       assert_failed
    526            
    527            /* Get the old register value */
    528            tmpreg = ADCx->CR1;
   \                     ??ADC_AnalogWatchdogSingleChannelConfig_1: (+1)
   \   000000AA   0x6860             LDR      R0,[R4, #+4]
   \   000000AC   0x0006             MOVS     R6,R0
    529            
    530            /* Clear the Analog watchdog channel select bits */
    531            tmpreg &= CR1_AWDCH_RESET;
   \   000000AE   0x0976             LSRS     R6,R6,#+5
   \   000000B0   0x0176             LSLS     R6,R6,#+5
    532            
    533            /* Set the Analog watchdog channel */
    534            tmpreg |= ADC_Channel;
   \   000000B2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B4   0x432E             ORRS     R6,R5,R6
    535            
    536            /* Store the new register value */
    537            ADCx->CR1 = tmpreg;
   \   000000B6   0x6066             STR      R6,[R4, #+4]
    538          }
   \   000000B8   0xBD70             POP      {R4-R6,PC}       ;; return
    539          /**
    540            * @}
    541            */
    542          
    543          /** @defgroup ADC_Group3 Temperature Sensor, Vrefint (Voltage Reference internal) 
    544           *            and VBAT (Voltage BATtery) management functions
    545           *  @brief   Temperature Sensor, Vrefint and VBAT management functions 
    546           *
    547          @verbatim   
    548           ===============================================================================
    549                         Temperature Sensor, Vrefint and VBAT management functions
    550           ===============================================================================  
    551          
    552            This section provides functions allowing to enable/ disable the internal 
    553            connections between the ADC and the Temperature Sensor, the Vrefint and the
    554            Vbat sources.
    555               
    556            A typical configuration to get the Temperature sensor and Vrefint channels 
    557            voltages is done following these steps :
    558             1. Enable the internal connection of Temperature sensor and Vrefint sources 
    559                with the ADC channels using ADC_TempSensorVrefintCmd() function. 
    560             2. Select the ADC_Channel_TempSensor and/or ADC_Channel_Vrefint using 
    561                ADC_RegularChannelConfig() or  ADC_InjectedChannelConfig() functions 
    562             3. Get the voltage values, using ADC_GetConversionValue() or  
    563                ADC_GetInjectedConversionValue().
    564          
    565            A typical configuration to get the VBAT channel voltage is done following 
    566            these steps :
    567             1. Enable the internal connection of VBAT source with the ADC channel using 
    568                ADC_VBATCmd() function. 
    569             2. Select the ADC_Channel_Vbat using ADC_RegularChannelConfig() or  
    570                ADC_InjectedChannelConfig() functions 
    571             3. Get the voltage value, using ADC_GetConversionValue() or  
    572                ADC_GetInjectedConversionValue().
    573           
    574          @endverbatim
    575            * @{
    576            */
    577            
    578            
    579          /**
    580            * @brief  Enables or disables the temperature sensor and Vrefint channels.
    581            * @param  NewState: new state of the temperature sensor and Vrefint channels.
    582            *          This parameter can be: ENABLE or DISABLE.
    583            * @retval None
    584            */

   \                                 In section .text, align 2, keep-with-next
    585          void ADC_TempSensorVrefintCmd(FunctionalState NewState)                
    586          {
   \                     ADC_TempSensorVrefintCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    587            /* Check the parameters */
    588            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??ADC_TempSensorVrefintCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??ADC_TempSensorVrefintCmd_0
   \   00000010   0xF44F 0x7113      MOV      R1,#+588
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   00000018   0x.... 0x....      BL       assert_failed
    589            if (NewState != DISABLE)
   \                     ??ADC_TempSensorVrefintCmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD008             BEQ.N    ??ADC_TempSensorVrefintCmd_1
    590            {
    591              /* Enable the temperature sensor and Vrefint channel*/
    592              ADC->CCR |= (uint32_t)ADC_CCR_TSVREFE;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0x40012304
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xF450 0x0000      ORRS     R0,R0,#0x800000
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable28  ;; 0x40012304
   \   00000030   0x6008             STR      R0,[R1, #+0]
   \   00000032   0xE007             B.N      ??ADC_TempSensorVrefintCmd_2
    593            }
    594            else
    595            {
    596              /* Disable the temperature sensor and Vrefint channel*/
    597              ADC->CCR &= (uint32_t)(~ADC_CCR_TSVREFE);
   \                     ??ADC_TempSensorVrefintCmd_1: (+1)
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0x40012304
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF430 0x0000      BICS     R0,R0,#0x800000
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable28  ;; 0x40012304
   \   00000042   0x6008             STR      R0,[R1, #+0]
    598            }
    599          }
   \                     ??ADC_TempSensorVrefintCmd_2: (+1)
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
    600          
    601          /**
    602            * @brief  Enables or disables the VBAT (Voltage Battery) channel.
    603            * @param  NewState: new state of the VBAT channel.
    604            *          This parameter can be: ENABLE or DISABLE.
    605            * @retval None
    606            */

   \                                 In section .text, align 2, keep-with-next
    607          void ADC_VBATCmd(FunctionalState NewState)                             
    608          {
   \                     ADC_VBATCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    609            /* Check the parameters */
    610            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??ADC_VBATCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??ADC_VBATCmd_0
   \   00000010   0xF240 0x2162      MOVW     R1,#+610
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   00000018   0x.... 0x....      BL       assert_failed
    611            if (NewState != DISABLE)
   \                     ??ADC_VBATCmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD008             BEQ.N    ??ADC_VBATCmd_1
    612            {
    613              /* Enable the VBAT channel*/
    614              ADC->CCR |= (uint32_t)ADC_CCR_VBATE;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0x40012304
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xF450 0x0080      ORRS     R0,R0,#0x400000
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable28  ;; 0x40012304
   \   00000030   0x6008             STR      R0,[R1, #+0]
   \   00000032   0xE007             B.N      ??ADC_VBATCmd_2
    615            }
    616            else
    617            {
    618              /* Disable the VBAT channel*/
    619              ADC->CCR &= (uint32_t)(~ADC_CCR_VBATE);
   \                     ??ADC_VBATCmd_1: (+1)
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0x40012304
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF430 0x0080      BICS     R0,R0,#0x400000
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable28  ;; 0x40012304
   \   00000042   0x6008             STR      R0,[R1, #+0]
    620            }
    621          }
   \                     ??ADC_VBATCmd_2: (+1)
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
    622          
    623          /**
    624            * @}
    625            */
    626          
    627          /** @defgroup ADC_Group4 Regular Channels Configuration functions
    628           *  @brief   Regular Channels Configuration functions 
    629           *
    630          @verbatim   
    631           ===============================================================================
    632                            Regular Channels Configuration functions
    633           ===============================================================================  
    634          
    635            This section provides functions allowing to manage the ADC's regular channels,
    636            it is composed of 2 sub sections : 
    637            
    638            1. Configuration and management functions for regular channels: This subsection 
    639               provides functions allowing to configure the ADC regular channels :    
    640                    - Configure the rank in the regular group sequencer for each channel
    641                    - Configure the sampling time for each channel
    642                    - select the conversion Trigger for regular channels
    643                    - select the desired EOC event behavior configuration
    644                    - Activate the continuous Mode  (*)
    645                    - Activate the Discontinuous Mode 
    646               Please Note that the following features for regular channels are configurated
    647               using the ADC_Init() function : 
    648                    - scan mode activation 
    649                    - continuous mode activation (**) 
    650                    - External trigger source  
    651                    - External trigger edge 
    652                    - number of conversion in the regular channels group sequencer.
    653               
    654               @note (*) and (**) are performing the same configuration
    655               
    656            2. Get the conversion data: This subsection provides an important function in 
    657               the ADC peripheral since it returns the converted data of the current 
    658               regular channel. When the Conversion value is read, the EOC Flag is 
    659               automatically cleared.
    660               
    661               @note For multi ADC mode, the last ADC1, ADC2 and ADC3 regular conversions 
    662                     results data (in the selected multi mode) can be returned in the same 
    663                     time using ADC_GetMultiModeConversionValue() function. 
    664                 
    665            
    666          @endverbatim
    667            * @{
    668            */
    669          /**
    670            * @brief  Configures for the selected ADC regular channel its corresponding
    671            *         rank in the sequencer and its sample time.
    672            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    673            * @param  ADC_Channel: the ADC channel to configure. 
    674            *          This parameter can be one of the following values:
    675            *            @arg ADC_Channel_0: ADC Channel0 selected
    676            *            @arg ADC_Channel_1: ADC Channel1 selected
    677            *            @arg ADC_Channel_2: ADC Channel2 selected
    678            *            @arg ADC_Channel_3: ADC Channel3 selected
    679            *            @arg ADC_Channel_4: ADC Channel4 selected
    680            *            @arg ADC_Channel_5: ADC Channel5 selected
    681            *            @arg ADC_Channel_6: ADC Channel6 selected
    682            *            @arg ADC_Channel_7: ADC Channel7 selected
    683            *            @arg ADC_Channel_8: ADC Channel8 selected
    684            *            @arg ADC_Channel_9: ADC Channel9 selected
    685            *            @arg ADC_Channel_10: ADC Channel10 selected
    686            *            @arg ADC_Channel_11: ADC Channel11 selected
    687            *            @arg ADC_Channel_12: ADC Channel12 selected
    688            *            @arg ADC_Channel_13: ADC Channel13 selected
    689            *            @arg ADC_Channel_14: ADC Channel14 selected
    690            *            @arg ADC_Channel_15: ADC Channel15 selected
    691            *            @arg ADC_Channel_16: ADC Channel16 selected
    692            *            @arg ADC_Channel_17: ADC Channel17 selected
    693            *            @arg ADC_Channel_18: ADC Channel18 selected                       
    694            * @param  Rank: The rank in the regular group sequencer.
    695            *          This parameter must be between 1 to 16.
    696            * @param  ADC_SampleTime: The sample time value to be set for the selected channel. 
    697            *          This parameter can be one of the following values:
    698            *            @arg ADC_SampleTime_3Cycles: Sample time equal to 3 cycles
    699            *            @arg ADC_SampleTime_15Cycles: Sample time equal to 15 cycles
    700            *            @arg ADC_SampleTime_28Cycles: Sample time equal to 28 cycles
    701            *            @arg ADC_SampleTime_56Cycles: Sample time equal to 56 cycles	
    702            *            @arg ADC_SampleTime_84Cycles: Sample time equal to 84 cycles	
    703            *            @arg ADC_SampleTime_112Cycles: Sample time equal to 112 cycles	
    704            *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
    705            *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
    706            * @retval None
    707            */

   \                                 In section .text, align 2, keep-with-next
    708          void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
    709          {
   \                     ADC_RegularChannelConfig: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    710            uint32_t tmpreg1 = 0, tmpreg2 = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
    711            /* Check the parameters */
    712            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40012000
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD00D             BEQ.N    ??ADC_RegularChannelConfig_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x40012100
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD009             BEQ.N    ??ADC_RegularChannelConfig_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable19_2  ;; 0x40012200
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD005             BEQ.N    ??ADC_RegularChannelConfig_0
   \   0000002C   0xF44F 0x7132      MOV      R1,#+712
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   00000034   0x.... 0x....      BL       assert_failed
    713            assert_param(IS_ADC_CHANNEL(ADC_Channel));
   \                     ??ADC_RegularChannelConfig_0: (+1)
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD03B             BEQ.N    ??ADC_RegularChannelConfig_1
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2D01             CMP      R5,#+1
   \   00000042   0xD038             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000044   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000046   0x2D02             CMP      R5,#+2
   \   00000048   0xD035             BEQ.N    ??ADC_RegularChannelConfig_1
   \   0000004A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004C   0x2D03             CMP      R5,#+3
   \   0000004E   0xD032             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000050   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000052   0x2D04             CMP      R5,#+4
   \   00000054   0xD02F             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000056   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000058   0x2D05             CMP      R5,#+5
   \   0000005A   0xD02C             BEQ.N    ??ADC_RegularChannelConfig_1
   \   0000005C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005E   0x2D06             CMP      R5,#+6
   \   00000060   0xD029             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000062   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000064   0x2D07             CMP      R5,#+7
   \   00000066   0xD026             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000068   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000006A   0x2D08             CMP      R5,#+8
   \   0000006C   0xD023             BEQ.N    ??ADC_RegularChannelConfig_1
   \   0000006E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000070   0x2D09             CMP      R5,#+9
   \   00000072   0xD020             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000074   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000076   0x2D0A             CMP      R5,#+10
   \   00000078   0xD01D             BEQ.N    ??ADC_RegularChannelConfig_1
   \   0000007A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007C   0x2D0B             CMP      R5,#+11
   \   0000007E   0xD01A             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000080   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000082   0x2D0C             CMP      R5,#+12
   \   00000084   0xD017             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000086   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000088   0x2D0D             CMP      R5,#+13
   \   0000008A   0xD014             BEQ.N    ??ADC_RegularChannelConfig_1
   \   0000008C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000008E   0x2D0E             CMP      R5,#+14
   \   00000090   0xD011             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000092   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000094   0x2D0F             CMP      R5,#+15
   \   00000096   0xD00E             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000098   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000009A   0x2D10             CMP      R5,#+16
   \   0000009C   0xD00B             BEQ.N    ??ADC_RegularChannelConfig_1
   \   0000009E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A0   0x2D11             CMP      R5,#+17
   \   000000A2   0xD008             BEQ.N    ??ADC_RegularChannelConfig_1
   \   000000A4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A6   0x2D12             CMP      R5,#+18
   \   000000A8   0xD005             BEQ.N    ??ADC_RegularChannelConfig_1
   \   000000AA   0xF240 0x21C9      MOVW     R1,#+713
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   000000B2   0x.... 0x....      BL       assert_failed
    714            assert_param(IS_ADC_REGULAR_RANK(Rank));
   \                     ??ADC_RegularChannelConfig_1: (+1)
   \   000000B6   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000B8   0x2E00             CMP      R6,#+0
   \   000000BA   0xD002             BEQ.N    ??ADC_RegularChannelConfig_2
   \   000000BC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000BE   0x2E11             CMP      R6,#+17
   \   000000C0   0xDB05             BLT.N    ??ADC_RegularChannelConfig_3
   \                     ??ADC_RegularChannelConfig_2: (+1)
   \   000000C2   0xF240 0x21CA      MOVW     R1,#+714
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   000000CA   0x.... 0x....      BL       assert_failed
    715            assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
   \                     ??ADC_RegularChannelConfig_3: (+1)
   \   000000CE   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000D0   0x2F00             CMP      R7,#+0
   \   000000D2   0xD01A             BEQ.N    ??ADC_RegularChannelConfig_4
   \   000000D4   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000D6   0x2F01             CMP      R7,#+1
   \   000000D8   0xD017             BEQ.N    ??ADC_RegularChannelConfig_4
   \   000000DA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000DC   0x2F02             CMP      R7,#+2
   \   000000DE   0xD014             BEQ.N    ??ADC_RegularChannelConfig_4
   \   000000E0   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000E2   0x2F03             CMP      R7,#+3
   \   000000E4   0xD011             BEQ.N    ??ADC_RegularChannelConfig_4
   \   000000E6   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000E8   0x2F04             CMP      R7,#+4
   \   000000EA   0xD00E             BEQ.N    ??ADC_RegularChannelConfig_4
   \   000000EC   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000EE   0x2F05             CMP      R7,#+5
   \   000000F0   0xD00B             BEQ.N    ??ADC_RegularChannelConfig_4
   \   000000F2   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000F4   0x2F06             CMP      R7,#+6
   \   000000F6   0xD008             BEQ.N    ??ADC_RegularChannelConfig_4
   \   000000F8   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000FA   0x2F07             CMP      R7,#+7
   \   000000FC   0xD005             BEQ.N    ??ADC_RegularChannelConfig_4
   \   000000FE   0xF240 0x21CB      MOVW     R1,#+715
   \   00000102   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   00000106   0x.... 0x....      BL       assert_failed
    716            
    717            /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
    718            if (ADC_Channel > ADC_Channel_9)
   \                     ??ADC_RegularChannelConfig_4: (+1)
   \   0000010A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000010C   0x2D0A             CMP      R5,#+10
   \   0000010E   0xDB19             BLT.N    ??ADC_RegularChannelConfig_5
    719            {
    720              /* Get the old register value */
    721              tmpreg1 = ADCx->SMPR1;
   \   00000110   0x68E0             LDR      R0,[R4, #+12]
   \   00000112   0x4680             MOV      R8,R0
    722              
    723              /* Calculate the mask to clear */
    724              tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
   \   00000114   0x2007             MOVS     R0,#+7
   \   00000116   0xF1B5 0x010A      SUBS     R1,R5,#+10
   \   0000011A   0x2203             MOVS     R2,#+3
   \   0000011C   0xFB11 0xF102      SMULBB   R1,R1,R2
   \   00000120   0x4088             LSLS     R0,R0,R1
   \   00000122   0x4681             MOV      R9,R0
    725              
    726              /* Clear the old sample time */
    727              tmpreg1 &= ~tmpreg2;
   \   00000124   0xEA38 0x0809      BICS     R8,R8,R9
    728              
    729              /* Calculate the mask to set */
    730              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
   \   00000128   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000012A   0xF1B5 0x000A      SUBS     R0,R5,#+10
   \   0000012E   0x2103             MOVS     R1,#+3
   \   00000130   0xFB10 0xF001      SMULBB   R0,R0,R1
   \   00000134   0xFA17 0xF000      LSLS     R0,R7,R0
   \   00000138   0x4681             MOV      R9,R0
    731              
    732              /* Set the new sample time */
    733              tmpreg1 |= tmpreg2;
   \   0000013A   0xEA59 0x0808      ORRS     R8,R9,R8
    734              
    735              /* Store the new register value */
    736              ADCx->SMPR1 = tmpreg1;
   \   0000013E   0xF8C4 0x800C      STR      R8,[R4, #+12]
   \   00000142   0xE014             B.N      ??ADC_RegularChannelConfig_6
    737            }
    738            else /* ADC_Channel include in ADC_Channel_[0..9] */
    739            {
    740              /* Get the old register value */
    741              tmpreg1 = ADCx->SMPR2;
   \                     ??ADC_RegularChannelConfig_5: (+1)
   \   00000144   0x6920             LDR      R0,[R4, #+16]
   \   00000146   0x4680             MOV      R8,R0
    742              
    743              /* Calculate the mask to clear */
    744              tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
   \   00000148   0x2007             MOVS     R0,#+7
   \   0000014A   0x2103             MOVS     R1,#+3
   \   0000014C   0xFB15 0xF101      SMULBB   R1,R5,R1
   \   00000150   0x4088             LSLS     R0,R0,R1
   \   00000152   0x4681             MOV      R9,R0
    745              
    746              /* Clear the old sample time */
    747              tmpreg1 &= ~tmpreg2;
   \   00000154   0xEA38 0x0809      BICS     R8,R8,R9
    748              
    749              /* Calculate the mask to set */
    750              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
   \   00000158   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000015A   0x2003             MOVS     R0,#+3
   \   0000015C   0xFB15 0xF000      SMULBB   R0,R5,R0
   \   00000160   0xFA17 0xF000      LSLS     R0,R7,R0
   \   00000164   0x4681             MOV      R9,R0
    751              
    752              /* Set the new sample time */
    753              tmpreg1 |= tmpreg2;
   \   00000166   0xEA59 0x0808      ORRS     R8,R9,R8
    754              
    755              /* Store the new register value */
    756              ADCx->SMPR2 = tmpreg1;
   \   0000016A   0xF8C4 0x8010      STR      R8,[R4, #+16]
    757            }
    758            /* For Rank 1 to 6 */
    759            if (Rank < 7)
   \                     ??ADC_RegularChannelConfig_6: (+1)
   \   0000016E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000170   0x2E07             CMP      R6,#+7
   \   00000172   0xDA17             BGE.N    ??ADC_RegularChannelConfig_7
    760            {
    761              /* Get the old register value */
    762              tmpreg1 = ADCx->SQR3;
   \   00000174   0x6B60             LDR      R0,[R4, #+52]
   \   00000176   0x4680             MOV      R8,R0
    763              
    764              /* Calculate the mask to clear */
    765              tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 1));
   \   00000178   0x201F             MOVS     R0,#+31
   \   0000017A   0x1E71             SUBS     R1,R6,#+1
   \   0000017C   0x2205             MOVS     R2,#+5
   \   0000017E   0xFB11 0xF102      SMULBB   R1,R1,R2
   \   00000182   0x4088             LSLS     R0,R0,R1
   \   00000184   0x4681             MOV      R9,R0
    766              
    767              /* Clear the old SQx bits for the selected rank */
    768              tmpreg1 &= ~tmpreg2;
   \   00000186   0xEA38 0x0809      BICS     R8,R8,R9
    769              
    770              /* Calculate the mask to set */
    771              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
   \   0000018A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000018C   0x1E70             SUBS     R0,R6,#+1
   \   0000018E   0x2105             MOVS     R1,#+5
   \   00000190   0xFB10 0xF001      SMULBB   R0,R0,R1
   \   00000194   0xFA15 0xF000      LSLS     R0,R5,R0
   \   00000198   0x4681             MOV      R9,R0
    772              
    773              /* Set the SQx bits for the selected rank */
    774              tmpreg1 |= tmpreg2;
   \   0000019A   0xEA59 0x0808      ORRS     R8,R9,R8
    775              
    776              /* Store the new register value */
    777              ADCx->SQR3 = tmpreg1;
   \   0000019E   0xF8C4 0x8034      STR      R8,[R4, #+52]
   \   000001A2   0xE033             B.N      ??ADC_RegularChannelConfig_8
    778            }
    779            /* For Rank 7 to 12 */
    780            else if (Rank < 13)
   \                     ??ADC_RegularChannelConfig_7: (+1)
   \   000001A4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001A6   0x2E0D             CMP      R6,#+13
   \   000001A8   0xDA17             BGE.N    ??ADC_RegularChannelConfig_9
    781            {
    782              /* Get the old register value */
    783              tmpreg1 = ADCx->SQR2;
   \   000001AA   0x6B20             LDR      R0,[R4, #+48]
   \   000001AC   0x4680             MOV      R8,R0
    784              
    785              /* Calculate the mask to clear */
    786              tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
   \   000001AE   0x201F             MOVS     R0,#+31
   \   000001B0   0x1FF1             SUBS     R1,R6,#+7
   \   000001B2   0x2205             MOVS     R2,#+5
   \   000001B4   0xFB11 0xF102      SMULBB   R1,R1,R2
   \   000001B8   0x4088             LSLS     R0,R0,R1
   \   000001BA   0x4681             MOV      R9,R0
    787              
    788              /* Clear the old SQx bits for the selected rank */
    789              tmpreg1 &= ~tmpreg2;
   \   000001BC   0xEA38 0x0809      BICS     R8,R8,R9
    790              
    791              /* Calculate the mask to set */
    792              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
   \   000001C0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001C2   0x1FF0             SUBS     R0,R6,#+7
   \   000001C4   0x2105             MOVS     R1,#+5
   \   000001C6   0xFB10 0xF001      SMULBB   R0,R0,R1
   \   000001CA   0xFA15 0xF000      LSLS     R0,R5,R0
   \   000001CE   0x4681             MOV      R9,R0
    793              
    794              /* Set the SQx bits for the selected rank */
    795              tmpreg1 |= tmpreg2;
   \   000001D0   0xEA59 0x0808      ORRS     R8,R9,R8
    796              
    797              /* Store the new register value */
    798              ADCx->SQR2 = tmpreg1;
   \   000001D4   0xF8C4 0x8030      STR      R8,[R4, #+48]
   \   000001D8   0xE018             B.N      ??ADC_RegularChannelConfig_8
    799            }
    800            /* For Rank 13 to 16 */
    801            else
    802            {
    803              /* Get the old register value */
    804              tmpreg1 = ADCx->SQR1;
   \                     ??ADC_RegularChannelConfig_9: (+1)
   \   000001DA   0x6AE0             LDR      R0,[R4, #+44]
   \   000001DC   0x4680             MOV      R8,R0
    805              
    806              /* Calculate the mask to clear */
    807              tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
   \   000001DE   0x201F             MOVS     R0,#+31
   \   000001E0   0xF1B6 0x010D      SUBS     R1,R6,#+13
   \   000001E4   0x2205             MOVS     R2,#+5
   \   000001E6   0xFB11 0xF102      SMULBB   R1,R1,R2
   \   000001EA   0x4088             LSLS     R0,R0,R1
   \   000001EC   0x4681             MOV      R9,R0
    808              
    809              /* Clear the old SQx bits for the selected rank */
    810              tmpreg1 &= ~tmpreg2;
   \   000001EE   0xEA38 0x0809      BICS     R8,R8,R9
    811              
    812              /* Calculate the mask to set */
    813              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
   \   000001F2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001F4   0xF1B6 0x000D      SUBS     R0,R6,#+13
   \   000001F8   0x2105             MOVS     R1,#+5
   \   000001FA   0xFB10 0xF001      SMULBB   R0,R0,R1
   \   000001FE   0xFA15 0xF000      LSLS     R0,R5,R0
   \   00000202   0x4681             MOV      R9,R0
    814              
    815              /* Set the SQx bits for the selected rank */
    816              tmpreg1 |= tmpreg2;
   \   00000204   0xEA59 0x0808      ORRS     R8,R9,R8
    817              
    818              /* Store the new register value */
    819              ADCx->SQR1 = tmpreg1;
   \   00000208   0xF8C4 0x802C      STR      R8,[R4, #+44]
    820            }
    821          }
   \                     ??ADC_RegularChannelConfig_8: (+1)
   \   0000020C   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    822          
    823          /**
    824            * @brief  Enables the selected ADC software start conversion of the regular channels.
    825            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    826            * @retval None
    827            */

   \                                 In section .text, align 2, keep-with-next
    828          void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)
    829          {
   \                     ADC_SoftwareStartConv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    830            /* Check the parameters */
    831            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000004   0x....             LDR.N    R0,??DataTable19  ;; 0x40012000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD00A             BEQ.N    ??ADC_SoftwareStartConv_0
   \   0000000A   0x....             LDR.N    R0,??DataTable19_1  ;; 0x40012100
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD007             BEQ.N    ??ADC_SoftwareStartConv_0
   \   00000010   0x....             LDR.N    R0,??DataTable19_2  ;; 0x40012200
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD004             BEQ.N    ??ADC_SoftwareStartConv_0
   \   00000016   0xF240 0x313F      MOVW     R1,#+831
   \   0000001A   0x....             LDR.N    R0,??DataTable19_3
   \   0000001C   0x.... 0x....      BL       assert_failed
    832            
    833            /* Enable the selected ADC conversion for regular group */
    834            ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;
   \                     ??ADC_SoftwareStartConv_0: (+1)
   \   00000020   0x68A0             LDR      R0,[R4, #+8]
   \   00000022   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \   00000026   0x60A0             STR      R0,[R4, #+8]
    835          }
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    836          
    837          /**
    838            * @brief  Gets the selected ADC Software start regular conversion Status.
    839            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    840            * @retval The new state of ADC software start conversion (SET or RESET).
    841            */

   \                                 In section .text, align 2, keep-with-next
    842          FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
    843          {
   \                     ADC_GetSoftwareStartConvStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    844            FlagStatus bitstatus = RESET;
   \   00000004   0x2500             MOVS     R5,#+0
    845            /* Check the parameters */
    846            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x....             LDR.N    R0,??DataTable19  ;; 0x40012000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00A             BEQ.N    ??ADC_GetSoftwareStartConvStatus_0
   \   0000000C   0x....             LDR.N    R0,??DataTable19_1  ;; 0x40012100
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD007             BEQ.N    ??ADC_GetSoftwareStartConvStatus_0
   \   00000012   0x....             LDR.N    R0,??DataTable19_2  ;; 0x40012200
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD004             BEQ.N    ??ADC_GetSoftwareStartConvStatus_0
   \   00000018   0xF240 0x314E      MOVW     R1,#+846
   \   0000001C   0x....             LDR.N    R0,??DataTable19_3
   \   0000001E   0x.... 0x....      BL       assert_failed
    847            
    848            /* Check the status of SWSTART bit */
    849            if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
   \                     ??ADC_GetSoftwareStartConvStatus_0: (+1)
   \   00000022   0x68A0             LDR      R0,[R4, #+8]
   \   00000024   0x0240             LSLS     R0,R0,#+9
   \   00000026   0xD502             BPL.N    ??ADC_GetSoftwareStartConvStatus_1
    850            {
    851              /* SWSTART bit is set */
    852              bitstatus = SET;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x0005             MOVS     R5,R0
   \   0000002C   0xE001             B.N      ??ADC_GetSoftwareStartConvStatus_2
    853            }
    854            else
    855            {
    856              /* SWSTART bit is reset */
    857              bitstatus = RESET;
   \                     ??ADC_GetSoftwareStartConvStatus_1: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x0005             MOVS     R5,R0
    858            }
    859            
    860            /* Return the SWSTART bit status */
    861            return  bitstatus;
   \                     ??ADC_GetSoftwareStartConvStatus_2: (+1)
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    862          }
    863          
    864          
    865          /**
    866            * @brief  Enables or disables the EOC on each regular channel conversion
    867            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    868            * @param  NewState: new state of the selected ADC EOC flag rising
    869            *          This parameter can be: ENABLE or DISABLE.
    870            * @retval None
    871            */

   \                                 In section .text, align 2, keep-with-next
    872          void ADC_EOCOnEachRegularChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    873          {
   \                     ADC_EOCOnEachRegularChannelCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    874            /* Check the parameters */
    875            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x....             LDR.N    R0,??DataTable19  ;; 0x40012000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00A             BEQ.N    ??ADC_EOCOnEachRegularChannelCmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable19_1  ;; 0x40012100
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD007             BEQ.N    ??ADC_EOCOnEachRegularChannelCmd_0
   \   00000012   0x....             LDR.N    R0,??DataTable19_2  ;; 0x40012200
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD004             BEQ.N    ??ADC_EOCOnEachRegularChannelCmd_0
   \   00000018   0xF240 0x316B      MOVW     R1,#+875
   \   0000001C   0x....             LDR.N    R0,??DataTable19_3
   \   0000001E   0x.... 0x....      BL       assert_failed
    876            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_EOCOnEachRegularChannelCmd_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD007             BEQ.N    ??ADC_EOCOnEachRegularChannelCmd_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD004             BEQ.N    ??ADC_EOCOnEachRegularChannelCmd_1
   \   0000002E   0xF44F 0x715B      MOV      R1,#+876
   \   00000032   0x....             LDR.N    R0,??DataTable19_3
   \   00000034   0x.... 0x....      BL       assert_failed
    877            
    878            if (NewState != DISABLE)
   \                     ??ADC_EOCOnEachRegularChannelCmd_1: (+1)
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD004             BEQ.N    ??ADC_EOCOnEachRegularChannelCmd_2
    879            {
    880              /* Enable the selected ADC EOC rising on each regular channel conversion */
    881              ADCx->CR2 |= (uint32_t)ADC_CR2_EOCS;
   \   0000003E   0x68A0             LDR      R0,[R4, #+8]
   \   00000040   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000044   0x60A0             STR      R0,[R4, #+8]
   \   00000046   0xE003             B.N      ??ADC_EOCOnEachRegularChannelCmd_3
    882            }
    883            else
    884            {
    885              /* Disable the selected ADC EOC rising on each regular channel conversion */
    886              ADCx->CR2 &= (uint32_t)(~ADC_CR2_EOCS);
   \                     ??ADC_EOCOnEachRegularChannelCmd_2: (+1)
   \   00000048   0x68A0             LDR      R0,[R4, #+8]
   \   0000004A   0xF430 0x6080      BICS     R0,R0,#0x400
   \   0000004E   0x60A0             STR      R0,[R4, #+8]
    887            }
    888          }
   \                     ??ADC_EOCOnEachRegularChannelCmd_3: (+1)
   \   00000050   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    889          
    890          /**
    891            * @brief  Enables or disables the ADC continuous conversion mode 
    892            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    893            * @param  NewState: new state of the selected ADC continuous conversion mode
    894            *          This parameter can be: ENABLE or DISABLE.
    895            * @retval None
    896            */

   \                                 In section .text, align 2, keep-with-next
    897          void ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    898          {
   \                     ADC_ContinuousModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    899            /* Check the parameters */
    900            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x....             LDR.N    R0,??DataTable19  ;; 0x40012000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00A             BEQ.N    ??ADC_ContinuousModeCmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable19_1  ;; 0x40012100
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD007             BEQ.N    ??ADC_ContinuousModeCmd_0
   \   00000012   0x....             LDR.N    R0,??DataTable19_2  ;; 0x40012200
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD004             BEQ.N    ??ADC_ContinuousModeCmd_0
   \   00000018   0xF44F 0x7161      MOV      R1,#+900
   \   0000001C   0x....             LDR.N    R0,??DataTable19_3
   \   0000001E   0x.... 0x....      BL       assert_failed
    901            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_ContinuousModeCmd_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD007             BEQ.N    ??ADC_ContinuousModeCmd_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD004             BEQ.N    ??ADC_ContinuousModeCmd_1
   \   0000002E   0xF240 0x3185      MOVW     R1,#+901
   \   00000032   0x....             LDR.N    R0,??DataTable19_3
   \   00000034   0x.... 0x....      BL       assert_failed
    902            
    903            if (NewState != DISABLE)
   \                     ??ADC_ContinuousModeCmd_1: (+1)
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD004             BEQ.N    ??ADC_ContinuousModeCmd_2
    904            {
    905              /* Enable the selected ADC continuous conversion mode */
    906              ADCx->CR2 |= (uint32_t)ADC_CR2_CONT;
   \   0000003E   0x68A0             LDR      R0,[R4, #+8]
   \   00000040   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000044   0x60A0             STR      R0,[R4, #+8]
   \   00000046   0xE003             B.N      ??ADC_ContinuousModeCmd_3
    907            }
    908            else
    909            {
    910              /* Disable the selected ADC continuous conversion mode */
    911              ADCx->CR2 &= (uint32_t)(~ADC_CR2_CONT);
   \                     ??ADC_ContinuousModeCmd_2: (+1)
   \   00000048   0x68A0             LDR      R0,[R4, #+8]
   \   0000004A   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000004E   0x60A0             STR      R0,[R4, #+8]
    912            }
    913          }
   \                     ??ADC_ContinuousModeCmd_3: (+1)
   \   00000050   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    914          
    915          /**
    916            * @brief  Configures the discontinuous mode for the selected ADC regular group 
    917            *         channel.
    918            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    919            * @param  Number: specifies the discontinuous mode regular channel count value.
    920            *          This number must be between 1 and 8.
    921            * @retval None
    922            */

   \                                 In section .text, align 2, keep-with-next
    923          void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
    924          {
   \                     ADC_DiscModeChannelCountConfig: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    925            uint32_t tmpreg1 = 0;
   \   00000006   0x2700             MOVS     R7,#+0
    926            uint32_t tmpreg2 = 0;
   \   00000008   0x2600             MOVS     R6,#+0
    927            
    928            /* Check the parameters */
    929            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   0000000A   0x....             LDR.N    R0,??DataTable19  ;; 0x40012000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD00A             BEQ.N    ??ADC_DiscModeChannelCountConfig_0
   \   00000010   0x....             LDR.N    R0,??DataTable19_1  ;; 0x40012100
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD007             BEQ.N    ??ADC_DiscModeChannelCountConfig_0
   \   00000016   0x....             LDR.N    R0,??DataTable19_2  ;; 0x40012200
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD004             BEQ.N    ??ADC_DiscModeChannelCountConfig_0
   \   0000001C   0xF240 0x31A1      MOVW     R1,#+929
   \   00000020   0x....             LDR.N    R0,??DataTable19_3
   \   00000022   0x.... 0x....      BL       assert_failed
    930            assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
   \                     ??ADC_DiscModeChannelCountConfig_0: (+1)
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD002             BEQ.N    ??ADC_DiscModeChannelCountConfig_1
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D09             CMP      R5,#+9
   \   00000030   0xDB04             BLT.N    ??ADC_DiscModeChannelCountConfig_2
   \                     ??ADC_DiscModeChannelCountConfig_1: (+1)
   \   00000032   0xF240 0x31A2      MOVW     R1,#+930
   \   00000036   0x....             LDR.N    R0,??DataTable19_3
   \   00000038   0x.... 0x....      BL       assert_failed
    931            
    932            /* Get the old register value */
    933            tmpreg1 = ADCx->CR1;
   \                     ??ADC_DiscModeChannelCountConfig_2: (+1)
   \   0000003C   0x6860             LDR      R0,[R4, #+4]
   \   0000003E   0x0007             MOVS     R7,R0
    934            
    935            /* Clear the old discontinuous mode channel count */
    936            tmpreg1 &= CR1_DISCNUM_RESET;
   \   00000040   0xF437 0x4760      BICS     R7,R7,#0xE000
    937            
    938            /* Set the discontinuous mode channel count */
    939            tmpreg2 = Number - 1;
   \   00000044   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000046   0x1E68             SUBS     R0,R5,#+1
   \   00000048   0x0006             MOVS     R6,R0
    940            tmpreg1 |= tmpreg2 << 13;
   \   0000004A   0xEA57 0x3746      ORRS     R7,R7,R6, LSL #+13
    941            
    942            /* Store the new register value */
    943            ADCx->CR1 = tmpreg1;
   \   0000004E   0x6067             STR      R7,[R4, #+4]
    944          }
   \   00000050   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    945          
    946          /**
    947            * @brief  Enables or disables the discontinuous mode on regular group channel 
    948            *         for the specified ADC
    949            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    950            * @param  NewState: new state of the selected ADC discontinuous mode on 
    951            *         regular group channel.
    952            *          This parameter can be: ENABLE or DISABLE.
    953            * @retval None
    954            */

   \                                 In section .text, align 2, keep-with-next
    955          void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    956          {
   \                     ADC_DiscModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    957            /* Check the parameters */
    958            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x....             LDR.N    R0,??DataTable19  ;; 0x40012000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00A             BEQ.N    ??ADC_DiscModeCmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable19_1  ;; 0x40012100
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD007             BEQ.N    ??ADC_DiscModeCmd_0
   \   00000012   0x....             LDR.N    R0,??DataTable19_2  ;; 0x40012200
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD004             BEQ.N    ??ADC_DiscModeCmd_0
   \   00000018   0xF240 0x31BE      MOVW     R1,#+958
   \   0000001C   0x....             LDR.N    R0,??DataTable19_3
   \   0000001E   0x.... 0x....      BL       assert_failed
    959            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_DiscModeCmd_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD007             BEQ.N    ??ADC_DiscModeCmd_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD004             BEQ.N    ??ADC_DiscModeCmd_1
   \   0000002E   0xF240 0x31BF      MOVW     R1,#+959
   \   00000032   0x....             LDR.N    R0,??DataTable19_3
   \   00000034   0x.... 0x....      BL       assert_failed
    960            
    961            if (NewState != DISABLE)
   \                     ??ADC_DiscModeCmd_1: (+1)
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD004             BEQ.N    ??ADC_DiscModeCmd_2
    962            {
    963              /* Enable the selected ADC regular discontinuous mode */
    964              ADCx->CR1 |= (uint32_t)ADC_CR1_DISCEN;
   \   0000003E   0x6860             LDR      R0,[R4, #+4]
   \   00000040   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   00000044   0x6060             STR      R0,[R4, #+4]
   \   00000046   0xE003             B.N      ??ADC_DiscModeCmd_3
    965            }
    966            else
    967            {
    968              /* Disable the selected ADC regular discontinuous mode */
    969              ADCx->CR1 &= (uint32_t)(~ADC_CR1_DISCEN);
   \                     ??ADC_DiscModeCmd_2: (+1)
   \   00000048   0x6860             LDR      R0,[R4, #+4]
   \   0000004A   0xF430 0x6000      BICS     R0,R0,#0x800
   \   0000004E   0x6060             STR      R0,[R4, #+4]
    970            }
    971          }
   \                     ??ADC_DiscModeCmd_3: (+1)
   \   00000050   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    972          
    973          /**
    974            * @brief  Returns the last ADCx conversion result data for regular channel.
    975            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    976            * @retval The Data conversion value.
    977            */

   \                                 In section .text, align 2, keep-with-next
    978          uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
    979          {
   \                     ADC_GetConversionValue: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    980            /* Check the parameters */
    981            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000004   0x....             LDR.N    R0,??DataTable19  ;; 0x40012000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD00A             BEQ.N    ??ADC_GetConversionValue_0
   \   0000000A   0x....             LDR.N    R0,??DataTable19_1  ;; 0x40012100
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD007             BEQ.N    ??ADC_GetConversionValue_0
   \   00000010   0x....             LDR.N    R0,??DataTable19_2  ;; 0x40012200
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD004             BEQ.N    ??ADC_GetConversionValue_0
   \   00000016   0xF240 0x31D5      MOVW     R1,#+981
   \   0000001A   0x....             LDR.N    R0,??DataTable19_3
   \   0000001C   0x.... 0x....      BL       assert_failed
    982            
    983            /* Return the selected ADC conversion value */
    984            return (uint16_t) ADCx->DR;
   \                     ??ADC_GetConversionValue_0: (+1)
   \   00000020   0x6CE0             LDR      R0,[R4, #+76]
   \   00000022   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    985          }
    986          
    987          /**
    988            * @brief  Returns the last ADC1, ADC2 and ADC3 regular conversions results 
    989            *         data in the selected multi mode.
    990            * @param  None  
    991            * @retval The Data conversion value.
    992            * @note   In dual mode, the value returned by this function is as following
    993            *           Data[15:0] : these bits contain the regular data of ADC1.
    994            *           Data[31:16]: these bits contain the regular data of ADC2.
    995            * @note   In triple mode, the value returned by this function is as following
    996            *           Data[15:0] : these bits contain alternatively the regular data of ADC1, ADC3 and ADC2.
    997            *           Data[31:16]: these bits contain alternatively the regular data of ADC2, ADC1 and ADC3.           
    998            */

   \                                 In section .text, align 2, keep-with-next
    999          uint32_t ADC_GetMultiModeConversionValue(void)
   1000          {
   1001            /* Return the multi mode conversion value */
   1002            return (*(__IO uint32_t *) CDR_ADDRESS);
   \                     ADC_GetMultiModeConversionValue: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40012308
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return
   1003          }
   1004          /**
   1005            * @}
   1006            */
   1007          
   1008          /** @defgroup ADC_Group5 Regular Channels DMA Configuration functions
   1009           *  @brief   Regular Channels DMA Configuration functions 
   1010           *
   1011          @verbatim   
   1012           ===============================================================================
   1013                             Regular Channels DMA Configuration functions
   1014           ===============================================================================  
   1015          
   1016            This section provides functions allowing to configure the DMA for ADC regular 
   1017            channels.
   1018            Since converted regular channel values are stored into a unique data register, 
   1019            it is useful to use DMA for conversion of more than one regular channel. This 
   1020            avoids the loss of the data already stored in the ADC Data register. 
   1021            
   1022            When the DMA mode is enabled (using the ADC_DMACmd() function), after each
   1023            conversion of a regular channel, a DMA request is generated.
   1024            
   1025            Depending on the "DMA disable selection for Independent ADC mode" 
   1026            configuration (using the ADC_DMARequestAfterLastTransferCmd() function), 
   1027            at the end of the last DMA transfer, two possibilities are allowed:
   1028            - No new DMA request is issued to the DMA controller (feature DISABLED) 
   1029            - Requests can continue to be generated (feature ENABLED).
   1030            
   1031            Depending on the "DMA disable selection for multi ADC mode" configuration 
   1032            (using the void ADC_MultiModeDMARequestAfterLastTransferCmd() function), 
   1033            at the end of the last DMA transfer, two possibilities are allowed:
   1034            - No new DMA request is issued to the DMA controller (feature DISABLED) 
   1035            - Requests can continue to be generated (feature ENABLED).
   1036          
   1037          @endverbatim
   1038            * @{
   1039            */
   1040            
   1041           /**
   1042            * @brief  Enables or disables the specified ADC DMA request.
   1043            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1044            * @param  NewState: new state of the selected ADC DMA transfer.
   1045            *          This parameter can be: ENABLE or DISABLE.
   1046            * @retval None
   1047            */

   \                                 In section .text, align 2, keep-with-next
   1048          void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1049          {
   \                     ADC_DMACmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1050            /* Check the parameters */
   1051            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x....             LDR.N    R0,??DataTable19  ;; 0x40012000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00A             BEQ.N    ??ADC_DMACmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable19_1  ;; 0x40012100
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD007             BEQ.N    ??ADC_DMACmd_0
   \   00000012   0x....             LDR.N    R0,??DataTable19_2  ;; 0x40012200
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD004             BEQ.N    ??ADC_DMACmd_0
   \   00000018   0xF240 0x411B      MOVW     R1,#+1051
   \   0000001C   0x....             LDR.N    R0,??DataTable19_3
   \   0000001E   0x.... 0x....      BL       assert_failed
   1052            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_DMACmd_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD007             BEQ.N    ??ADC_DMACmd_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD004             BEQ.N    ??ADC_DMACmd_1
   \   0000002E   0xF240 0x411C      MOVW     R1,#+1052
   \   00000032   0x....             LDR.N    R0,??DataTable19_3
   \   00000034   0x.... 0x....      BL       assert_failed
   1053            if (NewState != DISABLE)
   \                     ??ADC_DMACmd_1: (+1)
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD004             BEQ.N    ??ADC_DMACmd_2
   1054            {
   1055              /* Enable the selected ADC DMA request */
   1056              ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
   \   0000003E   0x68A0             LDR      R0,[R4, #+8]
   \   00000040   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000044   0x60A0             STR      R0,[R4, #+8]
   \   00000046   0xE003             B.N      ??ADC_DMACmd_3
   1057            }
   1058            else
   1059            {
   1060              /* Disable the selected ADC DMA request */
   1061              ADCx->CR2 &= (uint32_t)(~ADC_CR2_DMA);
   \                     ??ADC_DMACmd_2: (+1)
   \   00000048   0x68A0             LDR      R0,[R4, #+8]
   \   0000004A   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000004E   0x60A0             STR      R0,[R4, #+8]
   1062            }
   1063          }
   \                     ??ADC_DMACmd_3: (+1)
   \   00000050   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1064          
   1065          /**
   1066            * @brief  Enables or disables the ADC DMA request after last transfer (Single-ADC mode)  
   1067            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1068            * @param  NewState: new state of the selected ADC DMA request after last transfer.
   1069            *          This parameter can be: ENABLE or DISABLE.
   1070            * @retval None
   1071            */

   \                                 In section .text, align 2, keep-with-next
   1072          void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1073          {
   \                     ADC_DMARequestAfterLastTransferCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1074            /* Check the parameters */
   1075            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x....             LDR.N    R0,??DataTable19  ;; 0x40012000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00A             BEQ.N    ??ADC_DMARequestAfterLastTransferCmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable19_1  ;; 0x40012100
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD007             BEQ.N    ??ADC_DMARequestAfterLastTransferCmd_0
   \   00000012   0x....             LDR.N    R0,??DataTable19_2  ;; 0x40012200
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD004             BEQ.N    ??ADC_DMARequestAfterLastTransferCmd_0
   \   00000018   0xF240 0x4133      MOVW     R1,#+1075
   \   0000001C   0x....             LDR.N    R0,??DataTable19_3
   \   0000001E   0x.... 0x....      BL       assert_failed
   1076            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_DMARequestAfterLastTransferCmd_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD007             BEQ.N    ??ADC_DMARequestAfterLastTransferCmd_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD004             BEQ.N    ??ADC_DMARequestAfterLastTransferCmd_1
   \   0000002E   0xF240 0x4134      MOVW     R1,#+1076
   \   00000032   0x....             LDR.N    R0,??DataTable19_3
   \   00000034   0x.... 0x....      BL       assert_failed
   1077            if (NewState != DISABLE)
   \                     ??ADC_DMARequestAfterLastTransferCmd_1: (+1)
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD004             BEQ.N    ??ADC_DMARequestAfterLastTransferCmd_2
   1078            {
   1079              /* Enable the selected ADC DMA request after last transfer */
   1080              ADCx->CR2 |= (uint32_t)ADC_CR2_DDS;
   \   0000003E   0x68A0             LDR      R0,[R4, #+8]
   \   00000040   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000044   0x60A0             STR      R0,[R4, #+8]
   \   00000046   0xE003             B.N      ??ADC_DMARequestAfterLastTransferCmd_3
   1081            }
   1082            else
   1083            {
   1084              /* Disable the selected ADC DMA request after last transfer */
   1085              ADCx->CR2 &= (uint32_t)(~ADC_CR2_DDS);
   \                     ??ADC_DMARequestAfterLastTransferCmd_2: (+1)
   \   00000048   0x68A0             LDR      R0,[R4, #+8]
   \   0000004A   0xF430 0x7000      BICS     R0,R0,#0x200
   \   0000004E   0x60A0             STR      R0,[R4, #+8]
   1086            }
   1087          }
   \                     ??ADC_DMARequestAfterLastTransferCmd_3: (+1)
   \   00000050   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1088          
   1089          /**
   1090            * @brief  Enables or disables the ADC DMA request after last transfer in multi ADC mode       
   1091            * @param  NewState: new state of the selected ADC DMA request after last transfer.
   1092            *          This parameter can be: ENABLE or DISABLE.
   1093            * @note   if Enabled, DMA requests are issued as long as data are converted and 
   1094            *         DMA mode for multi ADC mode (selected using ADC_CommonInit() function 
   1095            *         by ADC_CommonInitStruct.ADC_DMAAccessMode structure member) is 
   1096            *          ADC_DMAAccessMode_1, ADC_DMAAccessMode_2 or ADC_DMAAccessMode_3.     
   1097            * @retval None
   1098            */

   \                                 In section .text, align 2, keep-with-next
   1099          void ADC_MultiModeDMARequestAfterLastTransferCmd(FunctionalState NewState)
   1100          {
   \                     ADC_MultiModeDMARequestAfterLastTransferCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1101            /* Check the parameters */
   1102            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??ADC_MultiModeDMARequestAfterLastTransferCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??ADC_MultiModeDMARequestAfterLastTransferCmd_0
   \   00000010   0xF240 0x414E      MOVW     R1,#+1102
   \   00000014   0x....             LDR.N    R0,??DataTable19_3
   \   00000016   0x.... 0x....      BL       assert_failed
   1103            if (NewState != DISABLE)
   \                     ??ADC_MultiModeDMARequestAfterLastTransferCmd_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD008             BEQ.N    ??ADC_MultiModeDMARequestAfterLastTransferCmd_1
   1104            {
   1105              /* Enable the selected ADC DMA request after last transfer */
   1106              ADC->CCR |= (uint32_t)ADC_CCR_DDS;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0x40012304
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable28  ;; 0x40012304
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   \   00000030   0xE007             B.N      ??ADC_MultiModeDMARequestAfterLastTransferCmd_2
   1107            }
   1108            else
   1109            {
   1110              /* Disable the selected ADC DMA request after last transfer */
   1111              ADC->CCR &= (uint32_t)(~ADC_CCR_DDS);
   \                     ??ADC_MultiModeDMARequestAfterLastTransferCmd_1: (+1)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0x40012304
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable28  ;; 0x40012304
   \   00000040   0x6008             STR      R0,[R1, #+0]
   1112            }
   1113          }
   \                     ??ADC_MultiModeDMARequestAfterLastTransferCmd_2: (+1)
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
   1114          /**
   1115            * @}
   1116            */
   1117          
   1118          /** @defgroup ADC_Group6 Injected channels Configuration functions
   1119           *  @brief   Injected channels Configuration functions 
   1120           *
   1121          @verbatim   
   1122           ===============================================================================
   1123                               Injected channels Configuration functions
   1124           ===============================================================================  
   1125          
   1126            This section provide functions allowing to configure the ADC Injected channels,
   1127            it is composed of 2 sub sections : 
   1128              
   1129            1. Configuration functions for Injected channels: This subsection provides 
   1130               functions allowing to configure the ADC injected channels :    
   1131              - Configure the rank in the injected group sequencer for each channel
   1132              - Configure the sampling time for each channel    
   1133              - Activate the Auto injected Mode  
   1134              - Activate the Discontinuous Mode 
   1135              - scan mode activation  
   1136              - External/software trigger source   
   1137              - External trigger edge 
   1138              - injected channels sequencer.
   1139              
   1140             2. Get the Specified Injected channel conversion data: This subsection 
   1141                provides an important function in the ADC peripheral since it returns the 
   1142                converted data of the specific injected channel.
   1143          
   1144          @endverbatim
   1145            * @{
   1146            */ 
   1147          /**
   1148            * @brief  Configures for the selected ADC injected channel its corresponding
   1149            *         rank in the sequencer and its sample time.
   1150            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1151            * @param  ADC_Channel: the ADC channel to configure. 
   1152            *          This parameter can be one of the following values:
   1153            *            @arg ADC_Channel_0: ADC Channel0 selected
   1154            *            @arg ADC_Channel_1: ADC Channel1 selected
   1155            *            @arg ADC_Channel_2: ADC Channel2 selected
   1156            *            @arg ADC_Channel_3: ADC Channel3 selected
   1157            *            @arg ADC_Channel_4: ADC Channel4 selected
   1158            *            @arg ADC_Channel_5: ADC Channel5 selected
   1159            *            @arg ADC_Channel_6: ADC Channel6 selected
   1160            *            @arg ADC_Channel_7: ADC Channel7 selected
   1161            *            @arg ADC_Channel_8: ADC Channel8 selected
   1162            *            @arg ADC_Channel_9: ADC Channel9 selected
   1163            *            @arg ADC_Channel_10: ADC Channel10 selected
   1164            *            @arg ADC_Channel_11: ADC Channel11 selected
   1165            *            @arg ADC_Channel_12: ADC Channel12 selected
   1166            *            @arg ADC_Channel_13: ADC Channel13 selected
   1167            *            @arg ADC_Channel_14: ADC Channel14 selected
   1168            *            @arg ADC_Channel_15: ADC Channel15 selected
   1169            *            @arg ADC_Channel_16: ADC Channel16 selected
   1170            *            @arg ADC_Channel_17: ADC Channel17 selected
   1171            *            @arg ADC_Channel_18: ADC Channel18 selected                       
   1172            * @param  Rank: The rank in the injected group sequencer. 
   1173            *          This parameter must be between 1 to 4.
   1174            * @param  ADC_SampleTime: The sample time value to be set for the selected channel. 
   1175            *          This parameter can be one of the following values:
   1176            *            @arg ADC_SampleTime_3Cycles: Sample time equal to 3 cycles
   1177            *            @arg ADC_SampleTime_15Cycles: Sample time equal to 15 cycles
   1178            *            @arg ADC_SampleTime_28Cycles: Sample time equal to 28 cycles
   1179            *            @arg ADC_SampleTime_56Cycles: Sample time equal to 56 cycles	
   1180            *            @arg ADC_SampleTime_84Cycles: Sample time equal to 84 cycles	
   1181            *            @arg ADC_SampleTime_112Cycles: Sample time equal to 112 cycles	
   1182            *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
   1183            *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
   1184            * @retval None
   1185            */

   \                                 In section .text, align 2, keep-with-next
   1186          void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
   1187          {
   \                     ADC_InjectedChannelConfig: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   1188            uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
   \   00000014   0xF05F 0x0A00      MOVS     R10,#+0
   1189            /* Check the parameters */
   1190            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable34_1  ;; 0x40012000
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD00D             BEQ.N    ??ADC_InjectedChannelConfig_0
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable34_2  ;; 0x40012100
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD009             BEQ.N    ??ADC_InjectedChannelConfig_0
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable34_3  ;; 0x40012200
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD005             BEQ.N    ??ADC_InjectedChannelConfig_0
   \   00000030   0xF240 0x41A6      MOVW     R1,#+1190
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable34_4
   \   00000038   0x.... 0x....      BL       assert_failed
   1191            assert_param(IS_ADC_CHANNEL(ADC_Channel));
   \                     ??ADC_InjectedChannelConfig_0: (+1)
   \   0000003C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0xD03B             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D01             CMP      R5,#+1
   \   00000046   0xD038             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x2D02             CMP      R5,#+2
   \   0000004C   0xD035             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   0000004E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000050   0x2D03             CMP      R5,#+3
   \   00000052   0xD032             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000054   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000056   0x2D04             CMP      R5,#+4
   \   00000058   0xD02F             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   0000005A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005C   0x2D05             CMP      R5,#+5
   \   0000005E   0xD02C             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000060   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000062   0x2D06             CMP      R5,#+6
   \   00000064   0xD029             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000066   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000068   0x2D07             CMP      R5,#+7
   \   0000006A   0xD026             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   0000006C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000006E   0x2D08             CMP      R5,#+8
   \   00000070   0xD023             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000072   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000074   0x2D09             CMP      R5,#+9
   \   00000076   0xD020             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000078   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007A   0x2D0A             CMP      R5,#+10
   \   0000007C   0xD01D             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   0000007E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000080   0x2D0B             CMP      R5,#+11
   \   00000082   0xD01A             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000084   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000086   0x2D0C             CMP      R5,#+12
   \   00000088   0xD017             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   0000008A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000008C   0x2D0D             CMP      R5,#+13
   \   0000008E   0xD014             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000090   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000092   0x2D0E             CMP      R5,#+14
   \   00000094   0xD011             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000096   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000098   0x2D0F             CMP      R5,#+15
   \   0000009A   0xD00E             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   0000009C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000009E   0x2D10             CMP      R5,#+16
   \   000000A0   0xD00B             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   000000A2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A4   0x2D11             CMP      R5,#+17
   \   000000A6   0xD008             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   000000A8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000AA   0x2D12             CMP      R5,#+18
   \   000000AC   0xD005             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   000000AE   0xF240 0x41A7      MOVW     R1,#+1191
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable34_4
   \   000000B6   0x.... 0x....      BL       assert_failed
   1192            assert_param(IS_ADC_INJECTED_RANK(Rank));
   \                     ??ADC_InjectedChannelConfig_1: (+1)
   \   000000BA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000BC   0x2E00             CMP      R6,#+0
   \   000000BE   0xD002             BEQ.N    ??ADC_InjectedChannelConfig_2
   \   000000C0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000C2   0x2E05             CMP      R6,#+5
   \   000000C4   0xDB05             BLT.N    ??ADC_InjectedChannelConfig_3
   \                     ??ADC_InjectedChannelConfig_2: (+1)
   \   000000C6   0xF44F 0x6195      MOV      R1,#+1192
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable34_4
   \   000000CE   0x.... 0x....      BL       assert_failed
   1193            assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
   \                     ??ADC_InjectedChannelConfig_3: (+1)
   \   000000D2   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000D4   0x2F00             CMP      R7,#+0
   \   000000D6   0xD01A             BEQ.N    ??ADC_InjectedChannelConfig_4
   \   000000D8   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000DA   0x2F01             CMP      R7,#+1
   \   000000DC   0xD017             BEQ.N    ??ADC_InjectedChannelConfig_4
   \   000000DE   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000E0   0x2F02             CMP      R7,#+2
   \   000000E2   0xD014             BEQ.N    ??ADC_InjectedChannelConfig_4
   \   000000E4   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000E6   0x2F03             CMP      R7,#+3
   \   000000E8   0xD011             BEQ.N    ??ADC_InjectedChannelConfig_4
   \   000000EA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000EC   0x2F04             CMP      R7,#+4
   \   000000EE   0xD00E             BEQ.N    ??ADC_InjectedChannelConfig_4
   \   000000F0   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000F2   0x2F05             CMP      R7,#+5
   \   000000F4   0xD00B             BEQ.N    ??ADC_InjectedChannelConfig_4
   \   000000F6   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000F8   0x2F06             CMP      R7,#+6
   \   000000FA   0xD008             BEQ.N    ??ADC_InjectedChannelConfig_4
   \   000000FC   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000FE   0x2F07             CMP      R7,#+7
   \   00000100   0xD005             BEQ.N    ??ADC_InjectedChannelConfig_4
   \   00000102   0xF240 0x41A9      MOVW     R1,#+1193
   \   00000106   0x.... 0x....      LDR.W    R0,??DataTable34_4
   \   0000010A   0x.... 0x....      BL       assert_failed
   1194            /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
   1195            if (ADC_Channel > ADC_Channel_9)
   \                     ??ADC_InjectedChannelConfig_4: (+1)
   \   0000010E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000110   0x2D0A             CMP      R5,#+10
   \   00000112   0xDB19             BLT.N    ??ADC_InjectedChannelConfig_5
   1196            {
   1197              /* Get the old register value */
   1198              tmpreg1 = ADCx->SMPR1;
   \   00000114   0x68E0             LDR      R0,[R4, #+12]
   \   00000116   0x4680             MOV      R8,R0
   1199              /* Calculate the mask to clear */
   1200              tmpreg2 = SMPR1_SMP_SET << (3*(ADC_Channel - 10));
   \   00000118   0x2007             MOVS     R0,#+7
   \   0000011A   0xF1B5 0x010A      SUBS     R1,R5,#+10
   \   0000011E   0x2203             MOVS     R2,#+3
   \   00000120   0xFB11 0xF102      SMULBB   R1,R1,R2
   \   00000124   0x4088             LSLS     R0,R0,R1
   \   00000126   0x4681             MOV      R9,R0
   1201              /* Clear the old sample time */
   1202              tmpreg1 &= ~tmpreg2;
   \   00000128   0xEA38 0x0809      BICS     R8,R8,R9
   1203              /* Calculate the mask to set */
   1204              tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
   \   0000012C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000012E   0xF1B5 0x000A      SUBS     R0,R5,#+10
   \   00000132   0x2103             MOVS     R1,#+3
   \   00000134   0xFB10 0xF001      SMULBB   R0,R0,R1
   \   00000138   0xFA17 0xF000      LSLS     R0,R7,R0
   \   0000013C   0x4681             MOV      R9,R0
   1205              /* Set the new sample time */
   1206              tmpreg1 |= tmpreg2;
   \   0000013E   0xEA59 0x0808      ORRS     R8,R9,R8
   1207              /* Store the new register value */
   1208              ADCx->SMPR1 = tmpreg1;
   \   00000142   0xF8C4 0x800C      STR      R8,[R4, #+12]
   \   00000146   0xE014             B.N      ??ADC_InjectedChannelConfig_6
   1209            }
   1210            else /* ADC_Channel include in ADC_Channel_[0..9] */
   1211            {
   1212              /* Get the old register value */
   1213              tmpreg1 = ADCx->SMPR2;
   \                     ??ADC_InjectedChannelConfig_5: (+1)
   \   00000148   0x6920             LDR      R0,[R4, #+16]
   \   0000014A   0x4680             MOV      R8,R0
   1214              /* Calculate the mask to clear */
   1215              tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
   \   0000014C   0x2007             MOVS     R0,#+7
   \   0000014E   0x2103             MOVS     R1,#+3
   \   00000150   0xFB15 0xF101      SMULBB   R1,R5,R1
   \   00000154   0x4088             LSLS     R0,R0,R1
   \   00000156   0x4681             MOV      R9,R0
   1216              /* Clear the old sample time */
   1217              tmpreg1 &= ~tmpreg2;
   \   00000158   0xEA38 0x0809      BICS     R8,R8,R9
   1218              /* Calculate the mask to set */
   1219              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
   \   0000015C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000015E   0x2003             MOVS     R0,#+3
   \   00000160   0xFB15 0xF000      SMULBB   R0,R5,R0
   \   00000164   0xFA17 0xF000      LSLS     R0,R7,R0
   \   00000168   0x4681             MOV      R9,R0
   1220              /* Set the new sample time */
   1221              tmpreg1 |= tmpreg2;
   \   0000016A   0xEA59 0x0808      ORRS     R8,R9,R8
   1222              /* Store the new register value */
   1223              ADCx->SMPR2 = tmpreg1;
   \   0000016E   0xF8C4 0x8010      STR      R8,[R4, #+16]
   1224            }
   1225            /* Rank configuration */
   1226            /* Get the old register value */
   1227            tmpreg1 = ADCx->JSQR;
   \                     ??ADC_InjectedChannelConfig_6: (+1)
   \   00000172   0x6BA0             LDR      R0,[R4, #+56]
   \   00000174   0x4680             MOV      R8,R0
   1228            /* Get JL value: Number = JL+1 */
   1229            tmpreg3 =  (tmpreg1 & JSQR_JL_SET)>> 20;
   \   00000176   0xF3C8 0x5001      UBFX     R0,R8,#+20,#+2
   \   0000017A   0x4682             MOV      R10,R0
   1230            /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
   1231            tmpreg2 = JSQR_JSQ_SET << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
   \   0000017C   0x201F             MOVS     R0,#+31
   \   0000017E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000180   0x1CF1             ADDS     R1,R6,#+3
   \   00000182   0xEBB1 0x010A      SUBS     R1,R1,R10
   \   00000186   0x1E49             SUBS     R1,R1,#+1
   \   00000188   0x2205             MOVS     R2,#+5
   \   0000018A   0xFB11 0xF102      SMULBB   R1,R1,R2
   \   0000018E   0x4088             LSLS     R0,R0,R1
   \   00000190   0x4681             MOV      R9,R0
   1232            /* Clear the old JSQx bits for the selected rank */
   1233            tmpreg1 &= ~tmpreg2;
   \   00000192   0xEA38 0x0809      BICS     R8,R8,R9
   1234            /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
   1235            tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
   \   00000196   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000198   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000019A   0x1CF0             ADDS     R0,R6,#+3
   \   0000019C   0xEBB0 0x000A      SUBS     R0,R0,R10
   \   000001A0   0x1E40             SUBS     R0,R0,#+1
   \   000001A2   0x2105             MOVS     R1,#+5
   \   000001A4   0xFB10 0xF001      SMULBB   R0,R0,R1
   \   000001A8   0xFA15 0xF000      LSLS     R0,R5,R0
   \   000001AC   0x4681             MOV      R9,R0
   1236            /* Set the JSQx bits for the selected rank */
   1237            tmpreg1 |= tmpreg2;
   \   000001AE   0xEA59 0x0808      ORRS     R8,R9,R8
   1238            /* Store the new register value */
   1239            ADCx->JSQR = tmpreg1;
   \   000001B2   0xF8C4 0x8038      STR      R8,[R4, #+56]
   1240          }
   \   000001B6   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1241          
   1242          /**
   1243            * @brief  Configures the sequencer length for injected channels
   1244            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1245            * @param  Length: The sequencer length. 
   1246            *          This parameter must be a number between 1 to 4.
   1247            * @retval None
   1248            */

   \                                 In section .text, align 2, keep-with-next
   1249          void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
   1250          {
   \                     ADC_InjectedSequencerLengthConfig: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1251            uint32_t tmpreg1 = 0;
   \   00000006   0x2700             MOVS     R7,#+0
   1252            uint32_t tmpreg2 = 0;
   \   00000008   0x2600             MOVS     R6,#+0
   1253            /* Check the parameters */
   1254            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable34_1  ;; 0x40012000
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD00D             BEQ.N    ??ADC_InjectedSequencerLengthConfig_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable34_2  ;; 0x40012100
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD009             BEQ.N    ??ADC_InjectedSequencerLengthConfig_0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable34_3  ;; 0x40012200
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD005             BEQ.N    ??ADC_InjectedSequencerLengthConfig_0
   \   00000022   0xF240 0x41E6      MOVW     R1,#+1254
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable34_4
   \   0000002A   0x.... 0x....      BL       assert_failed
   1255            assert_param(IS_ADC_INJECTED_LENGTH(Length));
   \                     ??ADC_InjectedSequencerLengthConfig_0: (+1)
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD002             BEQ.N    ??ADC_InjectedSequencerLengthConfig_1
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x2D05             CMP      R5,#+5
   \   00000038   0xDB05             BLT.N    ??ADC_InjectedSequencerLengthConfig_2
   \                     ??ADC_InjectedSequencerLengthConfig_1: (+1)
   \   0000003A   0xF240 0x41E7      MOVW     R1,#+1255
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable34_4
   \   00000042   0x.... 0x....      BL       assert_failed
   1256            
   1257            /* Get the old register value */
   1258            tmpreg1 = ADCx->JSQR;
   \                     ??ADC_InjectedSequencerLengthConfig_2: (+1)
   \   00000046   0x6BA0             LDR      R0,[R4, #+56]
   \   00000048   0x0007             MOVS     R7,R0
   1259            
   1260            /* Clear the old injected sequence length JL bits */
   1261            tmpreg1 &= JSQR_JL_RESET;
   \   0000004A   0xF437 0x1740      BICS     R7,R7,#0x300000
   1262            
   1263            /* Set the injected sequence length JL bits */
   1264            tmpreg2 = Length - 1; 
   \   0000004E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000050   0x1E68             SUBS     R0,R5,#+1
   \   00000052   0x0006             MOVS     R6,R0
   1265            tmpreg1 |= tmpreg2 << 20;
   \   00000054   0xEA57 0x5706      ORRS     R7,R7,R6, LSL #+20
   1266            
   1267            /* Store the new register value */
   1268            ADCx->JSQR = tmpreg1;
   \   00000058   0x63A7             STR      R7,[R4, #+56]
   1269          }
   \   0000005A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1270          
   1271          /**
   1272            * @brief  Set the injected channels conversion value offset
   1273            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1274            * @param  ADC_InjectedChannel: the ADC injected channel to set its offset. 
   1275            *          This parameter can be one of the following values:
   1276            *            @arg ADC_InjectedChannel_1: Injected Channel1 selected
   1277            *            @arg ADC_InjectedChannel_2: Injected Channel2 selected
   1278            *            @arg ADC_InjectedChannel_3: Injected Channel3 selected
   1279            *            @arg ADC_InjectedChannel_4: Injected Channel4 selected
   1280            * @param  Offset: the offset value for the selected ADC injected channel
   1281            *          This parameter must be a 12bit value.
   1282            * @retval None
   1283            */

   \                                 In section .text, align 2, keep-with-next
   1284          void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
   1285          {
   \                     ADC_SetInjectedOffset: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1286              __IO uint32_t tmp = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9000             STR      R0,[SP, #+0]
   1287            /* Check the parameters */
   1288            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable34_1  ;; 0x40012000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD00D             BEQ.N    ??ADC_SetInjectedOffset_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable34_2  ;; 0x40012100
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD009             BEQ.N    ??ADC_SetInjectedOffset_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable34_3  ;; 0x40012200
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD005             BEQ.N    ??ADC_SetInjectedOffset_0
   \   00000026   0xF44F 0x61A1      MOV      R1,#+1288
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable34_4
   \   0000002E   0x.... 0x....      BL       assert_failed
   1289            assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
   \                     ??ADC_SetInjectedOffset_0: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D14             CMP      R5,#+20
   \   00000036   0xD00E             BEQ.N    ??ADC_SetInjectedOffset_1
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D18             CMP      R5,#+24
   \   0000003C   0xD00B             BEQ.N    ??ADC_SetInjectedOffset_1
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2D1C             CMP      R5,#+28
   \   00000042   0xD008             BEQ.N    ??ADC_SetInjectedOffset_1
   \   00000044   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000046   0x2D20             CMP      R5,#+32
   \   00000048   0xD005             BEQ.N    ??ADC_SetInjectedOffset_1
   \   0000004A   0xF240 0x5109      MOVW     R1,#+1289
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable34_4
   \   00000052   0x.... 0x....      BL       assert_failed
   1290            assert_param(IS_ADC_OFFSET(Offset));
   \                     ??ADC_SetInjectedOffset_1: (+1)
   \   00000056   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000058   0xF5B6 0x5F80      CMP      R6,#+4096
   \   0000005C   0xDB05             BLT.N    ??ADC_SetInjectedOffset_2
   \   0000005E   0xF240 0x510A      MOVW     R1,#+1290
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable34_4
   \   00000066   0x.... 0x....      BL       assert_failed
   1291            
   1292            tmp = (uint32_t)ADCx;
   \                     ??ADC_SetInjectedOffset_2: (+1)
   \   0000006A   0x9400             STR      R4,[SP, #+0]
   1293            tmp += ADC_InjectedChannel;
   \   0000006C   0x9800             LDR      R0,[SP, #+0]
   \   0000006E   0xFA50 0xF085      UXTAB    R0,R0,R5
   \   00000072   0x9000             STR      R0,[SP, #+0]
   1294            
   1295            /* Set the selected injected channel data offset */
   1296           *(__IO uint32_t *) tmp = (uint32_t)Offset;
   \   00000074   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000076   0x9800             LDR      R0,[SP, #+0]
   \   00000078   0x6006             STR      R6,[R0, #+0]
   1297          }
   \   0000007A   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   1298          
   1299           /**
   1300            * @brief  Configures the ADCx external trigger for injected channels conversion.
   1301            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1302            * @param  ADC_ExternalTrigInjecConv: specifies the ADC trigger to start injected conversion.
   1303            *          This parameter can be one of the following values:                    
   1304            *            @arg ADC_ExternalTrigInjecConv_T1_CC4: Timer1 capture compare4 selected 
   1305            *            @arg ADC_ExternalTrigInjecConv_T1_TRGO: Timer1 TRGO event selected 
   1306            *            @arg ADC_ExternalTrigInjecConv_T2_CC1: Timer2 capture compare1 selected 
   1307            *            @arg ADC_ExternalTrigInjecConv_T2_TRGO: Timer2 TRGO event selected 
   1308            *            @arg ADC_ExternalTrigInjecConv_T3_CC2: Timer3 capture compare2 selected 
   1309            *            @arg ADC_ExternalTrigInjecConv_T3_CC4: Timer3 capture compare4 selected 
   1310            *            @arg ADC_ExternalTrigInjecConv_T4_CC1: Timer4 capture compare1 selected                       
   1311            *            @arg ADC_ExternalTrigInjecConv_T4_CC2: Timer4 capture compare2 selected 
   1312            *            @arg ADC_ExternalTrigInjecConv_T4_CC3: Timer4 capture compare3 selected                        
   1313            *            @arg ADC_ExternalTrigInjecConv_T4_TRGO: Timer4 TRGO event selected 
   1314            *            @arg ADC_ExternalTrigInjecConv_T5_CC4: Timer5 capture compare4 selected                        
   1315            *            @arg ADC_ExternalTrigInjecConv_T5_TRGO: Timer5 TRGO event selected                        
   1316            *            @arg ADC_ExternalTrigInjecConv_T8_CC2: Timer8 capture compare2 selected
   1317            *            @arg ADC_ExternalTrigInjecConv_T8_CC3: Timer8 capture compare3 selected                        
   1318            *            @arg ADC_ExternalTrigInjecConv_T8_CC4: Timer8 capture compare4 selected 
   1319            *            @arg ADC_ExternalTrigInjecConv_Ext_IT15: External interrupt line 15 event selected                          
   1320            * @retval None
   1321            */

   \                                 In section .text, align 2, keep-with-next
   1322          void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
   1323          {
   \                     ADC_ExternalTrigInjectedConvConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1324            uint32_t tmpreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1325            /* Check the parameters */
   1326            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable34_1  ;; 0x40012000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD00D             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable34_2  ;; 0x40012100
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD009             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable34_3  ;; 0x40012200
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD005             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_0
   \   00000020   0xF240 0x512E      MOVW     R1,#+1326
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable34_4
   \   00000028   0x.... 0x....      BL       assert_failed
   1327            assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
   \                     ??ADC_ExternalTrigInjectedConvConfig_0: (+1)
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD032             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000030   0xF5B5 0x3F80      CMP      R5,#+65536
   \   00000034   0xD02F             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000036   0xF5B5 0x3F00      CMP      R5,#+131072
   \   0000003A   0xD02C             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   0000003C   0xF5B5 0x3F40      CMP      R5,#+196608
   \   00000040   0xD029             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000042   0xF5B5 0x2F80      CMP      R5,#+262144
   \   00000046   0xD026             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000048   0xF5B5 0x2FA0      CMP      R5,#+327680
   \   0000004C   0xD023             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   0000004E   0xF5B5 0x2FC0      CMP      R5,#+393216
   \   00000052   0xD020             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000054   0xF5B5 0x2FE0      CMP      R5,#+458752
   \   00000058   0xD01D             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   0000005A   0xF5B5 0x2F00      CMP      R5,#+524288
   \   0000005E   0xD01A             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000060   0xF5B5 0x2F10      CMP      R5,#+589824
   \   00000064   0xD017             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000066   0xF5B5 0x2F20      CMP      R5,#+655360
   \   0000006A   0xD014             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   0000006C   0xF5B5 0x2F30      CMP      R5,#+720896
   \   00000070   0xD011             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000072   0xF5B5 0x2F40      CMP      R5,#+786432
   \   00000076   0xD00E             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000078   0xF5B5 0x2F50      CMP      R5,#+851968
   \   0000007C   0xD00B             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   0000007E   0xF5B5 0x2F60      CMP      R5,#+917504
   \   00000082   0xD008             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000084   0xF5B5 0x2F70      CMP      R5,#+983040
   \   00000088   0xD005             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   0000008A   0xF240 0x512F      MOVW     R1,#+1327
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable34_4
   \   00000092   0x.... 0x....      BL       assert_failed
   1328            
   1329            /* Get the old register value */
   1330            tmpreg = ADCx->CR2;
   \                     ??ADC_ExternalTrigInjectedConvConfig_1: (+1)
   \   00000096   0x68A0             LDR      R0,[R4, #+8]
   \   00000098   0x0006             MOVS     R6,R0
   1331            
   1332            /* Clear the old external event selection for injected group */
   1333            tmpreg &= CR2_JEXTSEL_RESET;
   \   0000009A   0xF436 0x2670      BICS     R6,R6,#0xF0000
   1334            
   1335            /* Set the external event selection for injected group */
   1336            tmpreg |= ADC_ExternalTrigInjecConv;
   \   0000009E   0x432E             ORRS     R6,R5,R6
   1337            
   1338            /* Store the new register value */
   1339            ADCx->CR2 = tmpreg;
   \   000000A0   0x60A6             STR      R6,[R4, #+8]
   1340          }
   \   000000A2   0xBD70             POP      {R4-R6,PC}       ;; return
   1341          
   1342          /**
   1343            * @brief  Configures the ADCx external trigger edge for injected channels conversion.
   1344            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1345            * @param  ADC_ExternalTrigInjecConvEdge: specifies the ADC external trigger edge
   1346            *         to start injected conversion. 
   1347            *          This parameter can be one of the following values:
   1348            *            @arg ADC_ExternalTrigInjecConvEdge_None: external trigger disabled for 
   1349            *                                                     injected conversion
   1350            *            @arg ADC_ExternalTrigInjecConvEdge_Rising: detection on rising edge
   1351            *            @arg ADC_ExternalTrigInjecConvEdge_Falling: detection on falling edge
   1352            *            @arg ADC_ExternalTrigInjecConvEdge_RisingFalling: detection on both rising 
   1353            *                                                               and falling edge
   1354            * @retval None
   1355            */

   \                                 In section .text, align 2, keep-with-next
   1356          void ADC_ExternalTrigInjectedConvEdgeConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConvEdge)
   1357          {
   \                     ADC_ExternalTrigInjectedConvEdgeConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1358            uint32_t tmpreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1359            /* Check the parameters */
   1360            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable34_1  ;; 0x40012000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD00D             BEQ.N    ??ADC_ExternalTrigInjectedConvEdgeConfig_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable34_2  ;; 0x40012100
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD009             BEQ.N    ??ADC_ExternalTrigInjectedConvEdgeConfig_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable34_3  ;; 0x40012200
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD005             BEQ.N    ??ADC_ExternalTrigInjectedConvEdgeConfig_0
   \   00000020   0xF44F 0x61AA      MOV      R1,#+1360
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable34_4
   \   00000028   0x.... 0x....      BL       assert_failed
   1361            assert_param(IS_ADC_EXT_INJEC_TRIG_EDGE(ADC_ExternalTrigInjecConvEdge));
   \                     ??ADC_ExternalTrigInjectedConvEdgeConfig_0: (+1)
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD00E             BEQ.N    ??ADC_ExternalTrigInjectedConvEdgeConfig_1
   \   00000030   0xF5B5 0x1F80      CMP      R5,#+1048576
   \   00000034   0xD00B             BEQ.N    ??ADC_ExternalTrigInjectedConvEdgeConfig_1
   \   00000036   0xF5B5 0x1F00      CMP      R5,#+2097152
   \   0000003A   0xD008             BEQ.N    ??ADC_ExternalTrigInjectedConvEdgeConfig_1
   \   0000003C   0xF5B5 0x1F40      CMP      R5,#+3145728
   \   00000040   0xD005             BEQ.N    ??ADC_ExternalTrigInjectedConvEdgeConfig_1
   \   00000042   0xF240 0x5151      MOVW     R1,#+1361
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable34_4
   \   0000004A   0x.... 0x....      BL       assert_failed
   1362            /* Get the old register value */
   1363            tmpreg = ADCx->CR2;
   \                     ??ADC_ExternalTrigInjectedConvEdgeConfig_1: (+1)
   \   0000004E   0x68A0             LDR      R0,[R4, #+8]
   \   00000050   0x0006             MOVS     R6,R0
   1364            /* Clear the old external trigger edge for injected group */
   1365            tmpreg &= CR2_JEXTEN_RESET;
   \   00000052   0xF436 0x1640      BICS     R6,R6,#0x300000
   1366            /* Set the new external trigger edge for injected group */
   1367            tmpreg |= ADC_ExternalTrigInjecConvEdge;
   \   00000056   0x432E             ORRS     R6,R5,R6
   1368            /* Store the new register value */
   1369            ADCx->CR2 = tmpreg;
   \   00000058   0x60A6             STR      R6,[R4, #+8]
   1370          }
   \   0000005A   0xBD70             POP      {R4-R6,PC}       ;; return
   1371          
   1372          /**
   1373            * @brief  Enables the selected ADC software start conversion of the injected channels.
   1374            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1375            * @retval None
   1376            */

   \                                 In section .text, align 2, keep-with-next
   1377          void ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx)
   1378          {
   \                     ADC_SoftwareStartInjectedConv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1379            /* Check the parameters */
   1380            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable34_1  ;; 0x40012000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00D             BEQ.N    ??ADC_SoftwareStartInjectedConv_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable34_2  ;; 0x40012100
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD009             BEQ.N    ??ADC_SoftwareStartInjectedConv_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable34_3  ;; 0x40012200
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD005             BEQ.N    ??ADC_SoftwareStartInjectedConv_0
   \   0000001C   0xF240 0x5164      MOVW     R1,#+1380
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable34_4
   \   00000024   0x.... 0x....      BL       assert_failed
   1381            /* Enable the selected ADC conversion for injected group */
   1382            ADCx->CR2 |= (uint32_t)ADC_CR2_JSWSTART;
   \                     ??ADC_SoftwareStartInjectedConv_0: (+1)
   \   00000028   0x68A0             LDR      R0,[R4, #+8]
   \   0000002A   0xF450 0x0080      ORRS     R0,R0,#0x400000
   \   0000002E   0x60A0             STR      R0,[R4, #+8]
   1383          }
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
   1384          
   1385          /**
   1386            * @brief  Gets the selected ADC Software start injected conversion Status.
   1387            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1388            * @retval The new state of ADC software start injected conversion (SET or RESET).
   1389            */

   \                                 In section .text, align 2, keep-with-next
   1390          FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
   1391          {
   \                     ADC_GetSoftwareStartInjectedConvCmdStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1392            FlagStatus bitstatus = RESET;
   \   00000004   0x2500             MOVS     R5,#+0
   1393            /* Check the parameters */
   1394            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable34_1  ;; 0x40012000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??ADC_GetSoftwareStartInjectedConvCmdStatus_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable34_2  ;; 0x40012100
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??ADC_GetSoftwareStartInjectedConvCmdStatus_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable34_3  ;; 0x40012200
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??ADC_GetSoftwareStartInjectedConvCmdStatus_0
   \   0000001E   0xF240 0x5172      MOVW     R1,#+1394
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable34_4
   \   00000026   0x.... 0x....      BL       assert_failed
   1395            
   1396            /* Check the status of JSWSTART bit */
   1397            if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
   \                     ??ADC_GetSoftwareStartInjectedConvCmdStatus_0: (+1)
   \   0000002A   0x68A0             LDR      R0,[R4, #+8]
   \   0000002C   0x0240             LSLS     R0,R0,#+9
   \   0000002E   0xD502             BPL.N    ??ADC_GetSoftwareStartInjectedConvCmdStatus_1
   1398            {
   1399              /* JSWSTART bit is set */
   1400              bitstatus = SET;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x0005             MOVS     R5,R0
   \   00000034   0xE001             B.N      ??ADC_GetSoftwareStartInjectedConvCmdStatus_2
   1401            }
   1402            else
   1403            {
   1404              /* JSWSTART bit is reset */
   1405              bitstatus = RESET;
   \                     ??ADC_GetSoftwareStartInjectedConvCmdStatus_1: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x0005             MOVS     R5,R0
   1406            }
   1407            /* Return the JSWSTART bit status */
   1408            return  bitstatus;
   \                     ??ADC_GetSoftwareStartInjectedConvCmdStatus_2: (+1)
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1409          }
   1410          
   1411          /**
   1412            * @brief  Enables or disables the selected ADC automatic injected group 
   1413            *         conversion after regular one.
   1414            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1415            * @param  NewState: new state of the selected ADC auto injected conversion
   1416            *          This parameter can be: ENABLE or DISABLE.
   1417            * @retval None
   1418            */

   \                                 In section .text, align 2, keep-with-next
   1419          void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1420          {
   \                     ADC_AutoInjectedConvCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1421            /* Check the parameters */
   1422            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable34_1  ;; 0x40012000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??ADC_AutoInjectedConvCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable34_2  ;; 0x40012100
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??ADC_AutoInjectedConvCmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable34_3  ;; 0x40012200
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??ADC_AutoInjectedConvCmd_0
   \   0000001E   0xF240 0x518E      MOVW     R1,#+1422
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable34_4
   \   00000026   0x.... 0x....      BL       assert_failed
   1423            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_AutoInjectedConvCmd_0: (+1)
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD007             BEQ.N    ??ADC_AutoInjectedConvCmd_1
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D01             CMP      R5,#+1
   \   00000034   0xD004             BEQ.N    ??ADC_AutoInjectedConvCmd_1
   \   00000036   0xF240 0x518F      MOVW     R1,#+1423
   \   0000003A   0x....             LDR.N    R0,??DataTable34_4
   \   0000003C   0x.... 0x....      BL       assert_failed
   1424            if (NewState != DISABLE)
   \                     ??ADC_AutoInjectedConvCmd_1: (+1)
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x2D00             CMP      R5,#+0
   \   00000044   0xD004             BEQ.N    ??ADC_AutoInjectedConvCmd_2
   1425            {
   1426              /* Enable the selected ADC automatic injected group conversion */
   1427              ADCx->CR1 |= (uint32_t)ADC_CR1_JAUTO;
   \   00000046   0x6860             LDR      R0,[R4, #+4]
   \   00000048   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   0000004C   0x6060             STR      R0,[R4, #+4]
   \   0000004E   0xE003             B.N      ??ADC_AutoInjectedConvCmd_3
   1428            }
   1429            else
   1430            {
   1431              /* Disable the selected ADC automatic injected group conversion */
   1432              ADCx->CR1 &= (uint32_t)(~ADC_CR1_JAUTO);
   \                     ??ADC_AutoInjectedConvCmd_2: (+1)
   \   00000050   0x6860             LDR      R0,[R4, #+4]
   \   00000052   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000056   0x6060             STR      R0,[R4, #+4]
   1433            }
   1434          }
   \                     ??ADC_AutoInjectedConvCmd_3: (+1)
   \   00000058   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1435          
   1436          /**
   1437            * @brief  Enables or disables the discontinuous mode for injected group 
   1438            *         channel for the specified ADC
   1439            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1440            * @param  NewState: new state of the selected ADC discontinuous mode on injected
   1441            *         group channel.
   1442            *          This parameter can be: ENABLE or DISABLE.
   1443            * @retval None
   1444            */

   \                                 In section .text, align 2, keep-with-next
   1445          void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1446          {
   \                     ADC_InjectedDiscModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1447            /* Check the parameters */
   1448            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x....             LDR.N    R0,??DataTable34_1  ;; 0x40012000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00A             BEQ.N    ??ADC_InjectedDiscModeCmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable34_2  ;; 0x40012100
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD007             BEQ.N    ??ADC_InjectedDiscModeCmd_0
   \   00000012   0x....             LDR.N    R0,??DataTable34_3  ;; 0x40012200
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD004             BEQ.N    ??ADC_InjectedDiscModeCmd_0
   \   00000018   0xF44F 0x61B5      MOV      R1,#+1448
   \   0000001C   0x....             LDR.N    R0,??DataTable34_4
   \   0000001E   0x.... 0x....      BL       assert_failed
   1449            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_InjectedDiscModeCmd_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD007             BEQ.N    ??ADC_InjectedDiscModeCmd_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD004             BEQ.N    ??ADC_InjectedDiscModeCmd_1
   \   0000002E   0xF240 0x51A9      MOVW     R1,#+1449
   \   00000032   0x....             LDR.N    R0,??DataTable34_4
   \   00000034   0x.... 0x....      BL       assert_failed
   1450            if (NewState != DISABLE)
   \                     ??ADC_InjectedDiscModeCmd_1: (+1)
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD004             BEQ.N    ??ADC_InjectedDiscModeCmd_2
   1451            {
   1452              /* Enable the selected ADC injected discontinuous mode */
   1453              ADCx->CR1 |= (uint32_t)ADC_CR1_JDISCEN;
   \   0000003E   0x6860             LDR      R0,[R4, #+4]
   \   00000040   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000044   0x6060             STR      R0,[R4, #+4]
   \   00000046   0xE003             B.N      ??ADC_InjectedDiscModeCmd_3
   1454            }
   1455            else
   1456            {
   1457              /* Disable the selected ADC injected discontinuous mode */
   1458              ADCx->CR1 &= (uint32_t)(~ADC_CR1_JDISCEN);
   \                     ??ADC_InjectedDiscModeCmd_2: (+1)
   \   00000048   0x6860             LDR      R0,[R4, #+4]
   \   0000004A   0xF430 0x5080      BICS     R0,R0,#0x1000
   \   0000004E   0x6060             STR      R0,[R4, #+4]
   1459            }
   1460          }
   \                     ??ADC_InjectedDiscModeCmd_3: (+1)
   \   00000050   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1461          
   1462          /**
   1463            * @brief  Returns the ADC injected channel conversion result
   1464            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1465            * @param  ADC_InjectedChannel: the converted ADC injected channel.
   1466            *          This parameter can be one of the following values:
   1467            *            @arg ADC_InjectedChannel_1: Injected Channel1 selected
   1468            *            @arg ADC_InjectedChannel_2: Injected Channel2 selected
   1469            *            @arg ADC_InjectedChannel_3: Injected Channel3 selected
   1470            *            @arg ADC_InjectedChannel_4: Injected Channel4 selected
   1471            * @retval The Data conversion value.
   1472            */

   \                                 In section .text, align 2, keep-with-next
   1473          uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
   1474          {
   \                     ADC_GetInjectedConversionValue: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1475            __IO uint32_t tmp = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
   1476            
   1477            /* Check the parameters */
   1478            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   0000000A   0x....             LDR.N    R0,??DataTable34_1  ;; 0x40012000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD00A             BEQ.N    ??ADC_GetInjectedConversionValue_0
   \   00000010   0x....             LDR.N    R0,??DataTable34_2  ;; 0x40012100
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD007             BEQ.N    ??ADC_GetInjectedConversionValue_0
   \   00000016   0x....             LDR.N    R0,??DataTable34_3  ;; 0x40012200
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD004             BEQ.N    ??ADC_GetInjectedConversionValue_0
   \   0000001C   0xF240 0x51C6      MOVW     R1,#+1478
   \   00000020   0x....             LDR.N    R0,??DataTable34_4
   \   00000022   0x.... 0x....      BL       assert_failed
   1479            assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
   \                     ??ADC_GetInjectedConversionValue_0: (+1)
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0x2D14             CMP      R5,#+20
   \   0000002A   0xD00D             BEQ.N    ??ADC_GetInjectedConversionValue_1
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D18             CMP      R5,#+24
   \   00000030   0xD00A             BEQ.N    ??ADC_GetInjectedConversionValue_1
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D1C             CMP      R5,#+28
   \   00000036   0xD007             BEQ.N    ??ADC_GetInjectedConversionValue_1
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D20             CMP      R5,#+32
   \   0000003C   0xD004             BEQ.N    ??ADC_GetInjectedConversionValue_1
   \   0000003E   0xF240 0x51C7      MOVW     R1,#+1479
   \   00000042   0x....             LDR.N    R0,??DataTable34_4
   \   00000044   0x.... 0x....      BL       assert_failed
   1480          
   1481            tmp = (uint32_t)ADCx;
   \                     ??ADC_GetInjectedConversionValue_1: (+1)
   \   00000048   0x9400             STR      R4,[SP, #+0]
   1482            tmp += ADC_InjectedChannel + JDR_OFFSET;
   \   0000004A   0x9800             LDR      R0,[SP, #+0]
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0xF115 0x0128      ADDS     R1,R5,#+40
   \   00000052   0x1808             ADDS     R0,R1,R0
   \   00000054   0x9000             STR      R0,[SP, #+0]
   1483            
   1484            /* Returns the selected injected channel conversion data value */
   1485            return (uint16_t) (*(__IO uint32_t*)  tmp); 
   \   00000056   0x9800             LDR      R0,[SP, #+0]
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000005C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1486          }
   1487          /**
   1488            * @}
   1489            */
   1490          
   1491          /** @defgroup ADC_Group7 Interrupts and flags management functions
   1492           *  @brief   Interrupts and flags management functions
   1493           *
   1494          @verbatim   
   1495           ===============================================================================
   1496                             Interrupts and flags management functions
   1497           ===============================================================================  
   1498          
   1499            This section provides functions allowing to configure the ADC Interrupts and 
   1500            to get the status and clear flags and Interrupts pending bits.
   1501            
   1502            Each ADC provides 4 Interrupts sources and 6 Flags which can be divided into 
   1503            3 groups:
   1504            
   1505            I. Flags and Interrupts for ADC regular channels
   1506            =================================================
   1507            Flags :
   1508            ---------- 
   1509               1. ADC_FLAG_OVR : Overrun detection when regular converted data are lost
   1510          
   1511               2. ADC_FLAG_EOC : Regular channel end of conversion ==> to indicate (depending 
   1512                        on EOCS bit, managed by ADC_EOCOnEachRegularChannelCmd() ) the end of:
   1513                         ==> a regular CHANNEL conversion 
   1514                         ==> sequence of regular GROUP conversions .
   1515          
   1516               3. ADC_FLAG_STRT: Regular channel start ==> to indicate when regular CHANNEL 
   1517                        conversion starts.
   1518          
   1519            Interrupts :
   1520            ------------
   1521               1. ADC_IT_OVR : specifies the interrupt source for Overrun detection event.  
   1522               2. ADC_IT_EOC : specifies the interrupt source for Regular channel end of 
   1523                               conversion event.
   1524            
   1525            
   1526            II. Flags and Interrupts for ADC Injected channels
   1527            =================================================
   1528            Flags :
   1529            ---------- 
   1530               1. ADC_FLAG_JEOC : Injected channel end of conversion ==> to indicate at 
   1531                         the end of injected GROUP conversion  
   1532                        
   1533               2. ADC_FLAG_JSTRT: Injected channel start ==> to indicate hardware when 
   1534                         injected GROUP conversion starts.
   1535          
   1536            Interrupts :
   1537            ------------
   1538               1. ADC_IT_JEOC : specifies the interrupt source for Injected channel end of 
   1539                                conversion event.     
   1540          
   1541            III. General Flags and Interrupts for the ADC
   1542            ================================================= 
   1543            Flags :
   1544            ---------- 
   1545               1. ADC_FLAG_AWD: Analog watchdog ==> to indicate if the converted voltage 
   1546                        crosses the programmed thresholds values.
   1547                        
   1548            Interrupts :
   1549            ------------
   1550               1. ADC_IT_AWD : specifies the interrupt source for Analog watchdog event. 
   1551          
   1552            
   1553            The user should identify which mode will be used in his application to manage 
   1554            the ADC controller events: Polling mode or Interrupt mode.
   1555            
   1556            In the Polling Mode it is advised to use the following functions:
   1557                - ADC_GetFlagStatus() : to check if flags events occur. 
   1558                - ADC_ClearFlag()     : to clear the flags events.
   1559                
   1560            In the Interrupt Mode it is advised to use the following functions:
   1561               - ADC_ITConfig()          : to enable or disable the interrupt source.
   1562               - ADC_GetITStatus()       : to check if Interrupt occurs.
   1563               - ADC_ClearITPendingBit() : to clear the Interrupt pending Bit 
   1564                                           (corresponding Flag). 
   1565          @endverbatim
   1566            * @{
   1567            */ 
   1568          /**
   1569            * @brief  Enables or disables the specified ADC interrupts.
   1570            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1571            * @param  ADC_IT: specifies the ADC interrupt sources to be enabled or disabled. 
   1572            *          This parameter can be one of the following values:
   1573            *            @arg ADC_IT_EOC: End of conversion interrupt mask
   1574            *            @arg ADC_IT_AWD: Analog watchdog interrupt mask
   1575            *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask
   1576            *            @arg ADC_IT_OVR: Overrun interrupt enable                       
   1577            * @param  NewState: new state of the specified ADC interrupts.
   1578            *          This parameter can be: ENABLE or DISABLE.
   1579            * @retval None
   1580            */

   \                                 In section .text, align 2, keep-with-next
   1581          void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)  
   1582          {
   \                     ADC_ITConfig: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1583            uint32_t itmask = 0;
   \   00000008   0x2700             MOVS     R7,#+0
   1584            /* Check the parameters */
   1585            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   0000000A   0x....             LDR.N    R0,??DataTable34_1  ;; 0x40012000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD00A             BEQ.N    ??ADC_ITConfig_0
   \   00000010   0x....             LDR.N    R0,??DataTable34_2  ;; 0x40012100
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD007             BEQ.N    ??ADC_ITConfig_0
   \   00000016   0x....             LDR.N    R0,??DataTable34_3  ;; 0x40012200
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD004             BEQ.N    ??ADC_ITConfig_0
   \   0000001C   0xF240 0x6131      MOVW     R1,#+1585
   \   00000020   0x....             LDR.N    R0,??DataTable34_4
   \   00000022   0x.... 0x....      BL       assert_failed
   1586            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_ITConfig_0: (+1)
   \   00000026   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000028   0x2E00             CMP      R6,#+0
   \   0000002A   0xD007             BEQ.N    ??ADC_ITConfig_1
   \   0000002C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002E   0x2E01             CMP      R6,#+1
   \   00000030   0xD004             BEQ.N    ??ADC_ITConfig_1
   \   00000032   0xF240 0x6132      MOVW     R1,#+1586
   \   00000036   0x....             LDR.N    R0,??DataTable34_4
   \   00000038   0x.... 0x....      BL       assert_failed
   1587            assert_param(IS_ADC_IT(ADC_IT)); 
   \                     ??ADC_ITConfig_1: (+1)
   \   0000003C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003E   0xF240 0x2005      MOVW     R0,#+517
   \   00000042   0x4285             CMP      R5,R0
   \   00000044   0xD012             BEQ.N    ??ADC_ITConfig_2
   \   00000046   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000048   0xF5B5 0x7F83      CMP      R5,#+262
   \   0000004C   0xD00E             BEQ.N    ??ADC_ITConfig_2
   \   0000004E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000050   0xF240 0x4007      MOVW     R0,#+1031
   \   00000054   0x4285             CMP      R5,R0
   \   00000056   0xD009             BEQ.N    ??ADC_ITConfig_2
   \   00000058   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005A   0xF242 0x001A      MOVW     R0,#+8218
   \   0000005E   0x4285             CMP      R5,R0
   \   00000060   0xD004             BEQ.N    ??ADC_ITConfig_2
   \   00000062   0xF240 0x6133      MOVW     R1,#+1587
   \   00000066   0x....             LDR.N    R0,??DataTable34_4
   \   00000068   0x.... 0x....      BL       assert_failed
   1588          
   1589            /* Get the ADC IT index */
   1590            itmask = (uint8_t)ADC_IT;
   \                     ??ADC_ITConfig_2: (+1)
   \   0000006C   0x0028             MOVS     R0,R5
   \   0000006E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000070   0x0007             MOVS     R7,R0
   1591            itmask = (uint32_t)0x01 << itmask;    
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0xFA10 0xF707      LSLS     R7,R0,R7
   1592          
   1593            if (NewState != DISABLE)
   \   00000078   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000007A   0x2E00             CMP      R6,#+0
   \   0000007C   0xD003             BEQ.N    ??ADC_ITConfig_3
   1594            {
   1595              /* Enable the selected ADC interrupts */
   1596              ADCx->CR1 |= itmask;
   \   0000007E   0x6860             LDR      R0,[R4, #+4]
   \   00000080   0x4338             ORRS     R0,R7,R0
   \   00000082   0x6060             STR      R0,[R4, #+4]
   \   00000084   0xE002             B.N      ??ADC_ITConfig_4
   1597            }
   1598            else
   1599            {
   1600              /* Disable the selected ADC interrupts */
   1601              ADCx->CR1 &= (~(uint32_t)itmask);
   \                     ??ADC_ITConfig_3: (+1)
   \   00000086   0x6860             LDR      R0,[R4, #+4]
   \   00000088   0x43B8             BICS     R0,R0,R7
   \   0000008A   0x6060             STR      R0,[R4, #+4]
   1602            }
   1603          }
   \                     ??ADC_ITConfig_4: (+1)
   \   0000008C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1604          
   1605          /**
   1606            * @brief  Checks whether the specified ADC flag is set or not.
   1607            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1608            * @param  ADC_FLAG: specifies the flag to check. 
   1609            *          This parameter can be one of the following values:
   1610            *            @arg ADC_FLAG_AWD: Analog watchdog flag
   1611            *            @arg ADC_FLAG_EOC: End of conversion flag
   1612            *            @arg ADC_FLAG_JEOC: End of injected group conversion flag
   1613            *            @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
   1614            *            @arg ADC_FLAG_STRT: Start of regular group conversion flag
   1615            *            @arg ADC_FLAG_OVR: Overrun flag                                                 
   1616            * @retval The new state of ADC_FLAG (SET or RESET).
   1617            */

   \                                 In section .text, align 2, keep-with-next
   1618          FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
   1619          {
   \                     ADC_GetFlagStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1620            FlagStatus bitstatus = RESET;
   \   00000006   0x2600             MOVS     R6,#+0
   1621            /* Check the parameters */
   1622            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000008   0x....             LDR.N    R0,??DataTable34_1  ;; 0x40012000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00A             BEQ.N    ??ADC_GetFlagStatus_0
   \   0000000E   0x....             LDR.N    R0,??DataTable34_2  ;; 0x40012100
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD007             BEQ.N    ??ADC_GetFlagStatus_0
   \   00000014   0x....             LDR.N    R0,??DataTable34_3  ;; 0x40012200
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD004             BEQ.N    ??ADC_GetFlagStatus_0
   \   0000001A   0xF240 0x6156      MOVW     R1,#+1622
   \   0000001E   0x....             LDR.N    R0,??DataTable34_4
   \   00000020   0x.... 0x....      BL       assert_failed
   1623            assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
   \                     ??ADC_GetFlagStatus_0: (+1)
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D01             CMP      R5,#+1
   \   00000028   0xD013             BEQ.N    ??ADC_GetFlagStatus_1
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x2D02             CMP      R5,#+2
   \   0000002E   0xD010             BEQ.N    ??ADC_GetFlagStatus_1
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D04             CMP      R5,#+4
   \   00000034   0xD00D             BEQ.N    ??ADC_GetFlagStatus_1
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x2D08             CMP      R5,#+8
   \   0000003A   0xD00A             BEQ.N    ??ADC_GetFlagStatus_1
   \   0000003C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003E   0x2D10             CMP      R5,#+16
   \   00000040   0xD007             BEQ.N    ??ADC_GetFlagStatus_1
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D20             CMP      R5,#+32
   \   00000046   0xD004             BEQ.N    ??ADC_GetFlagStatus_1
   \   00000048   0xF240 0x6157      MOVW     R1,#+1623
   \   0000004C   0x....             LDR.N    R0,??DataTable34_4
   \   0000004E   0x.... 0x....      BL       assert_failed
   1624          
   1625            /* Check the status of the specified ADC flag */
   1626            if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
   \                     ??ADC_GetFlagStatus_1: (+1)
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000056   0x4228             TST      R0,R5
   \   00000058   0xD002             BEQ.N    ??ADC_GetFlagStatus_2
   1627            {
   1628              /* ADC_FLAG is set */
   1629              bitstatus = SET;
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x0006             MOVS     R6,R0
   \   0000005E   0xE001             B.N      ??ADC_GetFlagStatus_3
   1630            }
   1631            else
   1632            {
   1633              /* ADC_FLAG is reset */
   1634              bitstatus = RESET;
   \                     ??ADC_GetFlagStatus_2: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x0006             MOVS     R6,R0
   1635            }
   1636            /* Return the ADC_FLAG status */
   1637            return  bitstatus;
   \                     ??ADC_GetFlagStatus_3: (+1)
   \   00000064   0x0030             MOVS     R0,R6
   \   00000066   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000068   0xBD70             POP      {R4-R6,PC}       ;; return
   1638          }
   1639          
   1640          /**
   1641            * @brief  Clears the ADCx's pending flags.
   1642            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1643            * @param  ADC_FLAG: specifies the flag to clear. 
   1644            *          This parameter can be any combination of the following values:
   1645            *            @arg ADC_FLAG_AWD: Analog watchdog flag
   1646            *            @arg ADC_FLAG_EOC: End of conversion flag
   1647            *            @arg ADC_FLAG_JEOC: End of injected group conversion flag
   1648            *            @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
   1649            *            @arg ADC_FLAG_STRT: Start of regular group conversion flag
   1650            *            @arg ADC_FLAG_OVR: Overrun flag                          
   1651            * @retval None
   1652            */

   \                                 In section .text, align 2, keep-with-next
   1653          void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
   1654          {
   \                     ADC_ClearFlag: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1655            /* Check the parameters */
   1656            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x....             LDR.N    R0,??DataTable34_1  ;; 0x40012000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00A             BEQ.N    ??ADC_ClearFlag_0
   \   0000000C   0x....             LDR.N    R0,??DataTable34_2  ;; 0x40012100
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD007             BEQ.N    ??ADC_ClearFlag_0
   \   00000012   0x....             LDR.N    R0,??DataTable34_3  ;; 0x40012200
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD004             BEQ.N    ??ADC_ClearFlag_0
   \   00000018   0xF44F 0x61CF      MOV      R1,#+1656
   \   0000001C   0x....             LDR.N    R0,??DataTable34_4
   \   0000001E   0x.... 0x....      BL       assert_failed
   1657            assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
   \                     ??ADC_ClearFlag_0: (+1)
   \   00000022   0x20C0             MOVS     R0,#+192
   \   00000024   0x4205             TST      R5,R0
   \   00000026   0xD102             BNE.N    ??ADC_ClearFlag_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD104             BNE.N    ??ADC_ClearFlag_2
   \                     ??ADC_ClearFlag_1: (+1)
   \   0000002E   0xF240 0x6179      MOVW     R1,#+1657
   \   00000032   0x....             LDR.N    R0,??DataTable34_4
   \   00000034   0x.... 0x....      BL       assert_failed
   1658          
   1659            /* Clear the selected ADC flags */
   1660            ADCx->SR = ~(uint32_t)ADC_FLAG;
   \                     ??ADC_ClearFlag_2: (+1)
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x43E8             MVNS     R0,R5
   \   0000003C   0x6020             STR      R0,[R4, #+0]
   1661          }
   \   0000003E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1662          
   1663          /**
   1664            * @brief  Checks whether the specified ADC interrupt has occurred or not.
   1665            * @param  ADCx:   where x can be 1, 2 or 3 to select the ADC peripheral.
   1666            * @param  ADC_IT: specifies the ADC interrupt source to check. 
   1667            *          This parameter can be one of the following values:
   1668            *            @arg ADC_IT_EOC: End of conversion interrupt mask
   1669            *            @arg ADC_IT_AWD: Analog watchdog interrupt mask
   1670            *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask
   1671            *            @arg ADC_IT_OVR: Overrun interrupt mask                        
   1672            * @retval The new state of ADC_IT (SET or RESET).
   1673            */

   \                                 In section .text, align 2, keep-with-next
   1674          ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
   1675          {
   \                     ADC_GetITStatus: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1676            ITStatus bitstatus = RESET;
   \   00000008   0x2600             MOVS     R6,#+0
   1677            uint32_t itmask = 0, enablestatus = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1678          
   1679            /* Check the parameters */
   1680            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000010   0x....             LDR.N    R0,??DataTable34_1  ;; 0x40012000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD00A             BEQ.N    ??ADC_GetITStatus_0
   \   00000016   0x....             LDR.N    R0,??DataTable34_2  ;; 0x40012100
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD007             BEQ.N    ??ADC_GetITStatus_0
   \   0000001C   0x....             LDR.N    R0,??DataTable34_3  ;; 0x40012200
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD004             BEQ.N    ??ADC_GetITStatus_0
   \   00000022   0xF44F 0x61D2      MOV      R1,#+1680
   \   00000026   0x....             LDR.N    R0,??DataTable34_4
   \   00000028   0x.... 0x....      BL       assert_failed
   1681            assert_param(IS_ADC_IT(ADC_IT));
   \                     ??ADC_GetITStatus_0: (+1)
   \   0000002C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002E   0xF240 0x2005      MOVW     R0,#+517
   \   00000032   0x4285             CMP      R5,R0
   \   00000034   0xD012             BEQ.N    ??ADC_GetITStatus_1
   \   00000036   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000038   0xF5B5 0x7F83      CMP      R5,#+262
   \   0000003C   0xD00E             BEQ.N    ??ADC_GetITStatus_1
   \   0000003E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000040   0xF240 0x4007      MOVW     R0,#+1031
   \   00000044   0x4285             CMP      R5,R0
   \   00000046   0xD009             BEQ.N    ??ADC_GetITStatus_1
   \   00000048   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004A   0xF242 0x001A      MOVW     R0,#+8218
   \   0000004E   0x4285             CMP      R5,R0
   \   00000050   0xD004             BEQ.N    ??ADC_GetITStatus_1
   \   00000052   0xF240 0x6191      MOVW     R1,#+1681
   \   00000056   0x....             LDR.N    R0,??DataTable34_4
   \   00000058   0x.... 0x....      BL       assert_failed
   1682          
   1683            /* Get the ADC IT index */
   1684            itmask = ADC_IT >> 8;
   \                     ??ADC_GetITStatus_1: (+1)
   \   0000005C   0x0028             MOVS     R0,R5
   \   0000005E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000060   0x0A00             LSRS     R0,R0,#+8
   \   00000062   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000064   0x0007             MOVS     R7,R0
   1685          
   1686            /* Get the ADC_IT enable bit status */
   1687            enablestatus = (ADCx->CR1 & ((uint32_t)0x01 << (uint8_t)ADC_IT)) ;
   \   00000066   0x6860             LDR      R0,[R4, #+4]
   \   00000068   0x2101             MOVS     R1,#+1
   \   0000006A   0x40A9             LSLS     R1,R1,R5
   \   0000006C   0x4008             ANDS     R0,R1,R0
   \   0000006E   0x4680             MOV      R8,R0
   1688          
   1689            /* Check the status of the specified ADC interrupt */
   1690            if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x4238             TST      R0,R7
   \   00000074   0xD005             BEQ.N    ??ADC_GetITStatus_2
   \   00000076   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000007A   0xD002             BEQ.N    ??ADC_GetITStatus_2
   1691            {
   1692              /* ADC_IT is set */
   1693              bitstatus = SET;
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0x0006             MOVS     R6,R0
   \   00000080   0xE001             B.N      ??ADC_GetITStatus_3
   1694            }
   1695            else
   1696            {
   1697              /* ADC_IT is reset */
   1698              bitstatus = RESET;
   \                     ??ADC_GetITStatus_2: (+1)
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x0006             MOVS     R6,R0
   1699            }
   1700            /* Return the ADC_IT status */
   1701            return  bitstatus;
   \                     ??ADC_GetITStatus_3: (+1)
   \   00000086   0x0030             MOVS     R0,R6
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1702          }
   1703          
   1704          /**
   1705            * @brief  Clears the ADCx's interrupt pending bits.
   1706            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1707            * @param  ADC_IT: specifies the ADC interrupt pending bit to clear.
   1708            *          This parameter can be one of the following values:
   1709            *            @arg ADC_IT_EOC: End of conversion interrupt mask
   1710            *            @arg ADC_IT_AWD: Analog watchdog interrupt mask
   1711            *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask
   1712            *            @arg ADC_IT_OVR: Overrun interrupt mask                         
   1713            * @retval None
   1714            */

   \                                 In section .text, align 2, keep-with-next
   1715          void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
   1716          {
   \                     ADC_ClearITPendingBit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1717            uint8_t itmask = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1718            /* Check the parameters */
   1719            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000008   0x....             LDR.N    R0,??DataTable34_1  ;; 0x40012000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00A             BEQ.N    ??ADC_ClearITPendingBit_0
   \   0000000E   0x....             LDR.N    R0,??DataTable34_2  ;; 0x40012100
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD007             BEQ.N    ??ADC_ClearITPendingBit_0
   \   00000014   0x....             LDR.N    R0,??DataTable34_3  ;; 0x40012200
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD004             BEQ.N    ??ADC_ClearITPendingBit_0
   \   0000001A   0xF240 0x61B7      MOVW     R1,#+1719
   \   0000001E   0x....             LDR.N    R0,??DataTable34_4
   \   00000020   0x.... 0x....      BL       assert_failed
   1720            assert_param(IS_ADC_IT(ADC_IT)); 
   \                     ??ADC_ClearITPendingBit_0: (+1)
   \   00000024   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000026   0xF240 0x2005      MOVW     R0,#+517
   \   0000002A   0x4285             CMP      R5,R0
   \   0000002C   0xD012             BEQ.N    ??ADC_ClearITPendingBit_1
   \   0000002E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000030   0xF5B5 0x7F83      CMP      R5,#+262
   \   00000034   0xD00E             BEQ.N    ??ADC_ClearITPendingBit_1
   \   00000036   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000038   0xF240 0x4007      MOVW     R0,#+1031
   \   0000003C   0x4285             CMP      R5,R0
   \   0000003E   0xD009             BEQ.N    ??ADC_ClearITPendingBit_1
   \   00000040   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000042   0xF242 0x001A      MOVW     R0,#+8218
   \   00000046   0x4285             CMP      R5,R0
   \   00000048   0xD004             BEQ.N    ??ADC_ClearITPendingBit_1
   \   0000004A   0xF44F 0x61D7      MOV      R1,#+1720
   \   0000004E   0x....             LDR.N    R0,??DataTable34_4
   \   00000050   0x.... 0x....      BL       assert_failed
   1721            /* Get the ADC IT index */
   1722            itmask = (uint8_t)(ADC_IT >> 8);
   \                     ??ADC_ClearITPendingBit_1: (+1)
   \   00000054   0x0028             MOVS     R0,R5
   \   00000056   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000058   0x0A00             LSRS     R0,R0,#+8
   \   0000005A   0x0006             MOVS     R6,R0
   1723            /* Clear the selected ADC interrupt pending bits */
   1724            ADCx->SR = ~(uint32_t)itmask;
   \   0000005C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000005E   0x43F0             MVNS     R0,R6
   \   00000060   0x6020             STR      R0,[R4, #+0]
   1725          }                    
   \   00000062   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x40012000         DC32     0x40012000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x40012100         DC32     0x40012100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0x40012200         DC32     0x40012200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \   00000000   0xFCFFFEFF         DC32     0xfcfffeff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0xFFFC30E0         DC32     0xfffc30e0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0xC0FFF7FD         DC32     0xc0fff7fd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x00800200         DC32     0x800200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x00400200         DC32     0x400200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \   00000000   0x00C00200         DC32     0xc00200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0x40012304         DC32     0x40012304

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0xFF3FFDFF         DC32     0xff3ffdff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \   00000000   0x40012308         DC32     0x40012308

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_1:
   \   00000000   0x40012000         DC32     0x40012000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_2:
   \   00000000   0x40012100         DC32     0x40012100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_3:
   \   00000000   0x40012200         DC32     0x40012200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_4:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 49H, 41H, 52H, 20H, 57H
   \              0x5C 0x49    
   \              0x41 0x52    
   \              0x20 0x57    
   \   00000008   0x6F 0x72          DC8 6FH, 72H, 6BH, 73H, 70H, 61H, 63H, 65H
   \              0x6B 0x73    
   \              0x70 0x61    
   \              0x63 0x65    
   \   00000010   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 46H, 34H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x46 0x34    
   \   00000018   0x30 0x37          DC8 30H, 37H, 5CH, 53H, 54H, 4DH, 33H, 32H
   \              0x5C 0x53    
   \              0x54 0x4D    
   \              0x33 0x32    
   \   00000020   0x46 0x34          DC8 46H, 34H, 2DH, 44H, 69H, 73H, 63H, 6FH
   \              0x2D 0x44    
   \              0x69 0x73    
   \              0x63 0x6F    
   \   00000028   0x76 0x65          DC8 76H, 65H, 72H, 79H, 5FH, 46H, 57H, 5FH
   \              0x72 0x79    
   \              0x5F 0x46    
   \              0x57 0x5F    
   \   00000030   0x56 0x31          DC8 56H, 31H, 2EH, 31H, 2EH, 30H, 5CH, 4CH
   \              0x2E 0x31    
   \              0x2E 0x30    
   \              0x5C 0x4C    
   \   00000038   0x69 0x62          DC8 69H, 62H, 72H, 61H, 72H, 69H, 65H, 73H
   \              0x72 0x61    
   \              0x72 0x69    
   \              0x65 0x73    
   \   00000040   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 46H, 34H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x46 0x34    
   \   00000048   0x78 0x78          DC8 78H, 78H, 5FH, 53H, 74H, 64H, 50H, 65H
   \              0x5F 0x53    
   \              0x74 0x64    
   \              0x50 0x65    
   \   00000050   0x72 0x69          DC8 72H, 69H, 70H, 68H, 5FH, 44H, 72H, 69H
   \              0x70 0x68    
   \              0x5F 0x44    
   \              0x72 0x69    
   \   00000058   0x76 0x65          DC8 76H, 65H, 72H, 5CH, 73H, 72H, 63H, 5CH
   \              0x72 0x5C    
   \              0x73 0x72    
   \              0x63 0x5C    
   \   00000060   0x73 0x74          DC8 73H, 74H, 6DH, 33H, 32H, 66H, 34H, 78H
   \              0x6D 0x33    
   \              0x32 0x66    
   \              0x34 0x78    
   \   00000068   0x78 0x5F          DC8 78H, 5FH, 61H, 64H, 63H, 2EH, 63H, 0
   \              0x61 0x64    
   \              0x63 0x2E    
   \              0x63 0x00    
   1726          /**
   1727            * @}
   1728            */ 
   1729          
   1730          /**
   1731            * @}
   1732            */
   1733          
   1734          /**
   1735            * @}
   1736            */ 
   1737          
   1738          /**
   1739            * @}
   1740            */ 
   1741          
   1742          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   ADC_AnalogWatchdogCmd
        16   -> assert_failed
      16   ADC_AnalogWatchdogSingleChannelConfig
        16   -> assert_failed
      16   ADC_AnalogWatchdogThresholdsConfig
        16   -> assert_failed
      16   ADC_AutoInjectedConvCmd
        16   -> assert_failed
      16   ADC_ClearFlag
        16   -> assert_failed
      16   ADC_ClearITPendingBit
        16   -> assert_failed
      16   ADC_Cmd
        16   -> assert_failed
      16   ADC_CommonInit
        16   -> assert_failed
       0   ADC_CommonStructInit
      16   ADC_ContinuousModeCmd
        16   -> assert_failed
      16   ADC_DMACmd
        16   -> assert_failed
      16   ADC_DMARequestAfterLastTransferCmd
        16   -> assert_failed
       8   ADC_DeInit
         8   -> RCC_APB2PeriphResetCmd
      24   ADC_DiscModeChannelCountConfig
        24   -> assert_failed
      16   ADC_DiscModeCmd
        16   -> assert_failed
      16   ADC_EOCOnEachRegularChannelCmd
        16   -> assert_failed
      16   ADC_ExternalTrigInjectedConvConfig
        16   -> assert_failed
      16   ADC_ExternalTrigInjectedConvEdgeConfig
        16   -> assert_failed
       8   ADC_GetConversionValue
         8   -> assert_failed
      16   ADC_GetFlagStatus
        16   -> assert_failed
      24   ADC_GetITStatus
        24   -> assert_failed
      16   ADC_GetInjectedConversionValue
        16   -> assert_failed
       0   ADC_GetMultiModeConversionValue
      16   ADC_GetSoftwareStartConvStatus
        16   -> assert_failed
      16   ADC_GetSoftwareStartInjectedConvCmdStatus
        16   -> assert_failed
      24   ADC_ITConfig
        24   -> assert_failed
      24   ADC_Init
        24   -> assert_failed
      32   ADC_InjectedChannelConfig
        32   -> assert_failed
      16   ADC_InjectedDiscModeCmd
        16   -> assert_failed
      24   ADC_InjectedSequencerLengthConfig
        24   -> assert_failed
       8   ADC_MultiModeDMARequestAfterLastTransferCmd
         8   -> assert_failed
      32   ADC_RegularChannelConfig
        32   -> assert_failed
      24   ADC_SetInjectedOffset
        24   -> assert_failed
       8   ADC_SoftwareStartConv
         8   -> assert_failed
       8   ADC_SoftwareStartInjectedConv
         8   -> assert_failed
       0   ADC_StructInit
       8   ADC_TempSensorVrefintCmd
         8   -> assert_failed
       8   ADC_VBATCmd
         8   -> assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable22
       4  ??DataTable23
       4  ??DataTable24
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable28
       4  ??DataTable30
       4  ??DataTable34
       4  ??DataTable34_1
       4  ??DataTable34_2
       4  ??DataTable34_3
       4  ??DataTable34_4
     112  ?_0
     118  ADC_AnalogWatchdogCmd
     186  ADC_AnalogWatchdogSingleChannelConfig
      94  ADC_AnalogWatchdogThresholdsConfig
      90  ADC_AutoInjectedConvCmd
      64  ADC_ClearFlag
     100  ADC_ClearITPendingBit
      92  ADC_Cmd
     356  ADC_CommonInit
      18  ADC_CommonStructInit
      82  ADC_ContinuousModeCmd
      82  ADC_DMACmd
      82  ADC_DMARequestAfterLastTransferCmd
      24  ADC_DeInit
      82  ADC_DiscModeChannelCountConfig
      82  ADC_DiscModeCmd
      82  ADC_EOCOnEachRegularChannelCmd
     164  ADC_ExternalTrigInjectedConvConfig
      92  ADC_ExternalTrigInjectedConvEdgeConfig
      38  ADC_GetConversionValue
     106  ADC_GetFlagStatus
     142  ADC_GetITStatus
      94  ADC_GetInjectedConversionValue
       8  ADC_GetMultiModeConversionValue
      56  ADC_GetSoftwareStartConvStatus
      64  ADC_GetSoftwareStartInjectedConvCmdStatus
     142  ADC_ITConfig
     426  ADC_Init
     442  ADC_InjectedChannelConfig
      82  ADC_InjectedDiscModeCmd
      92  ADC_InjectedSequencerLengthConfig
      68  ADC_MultiModeDMARequestAfterLastTransferCmd
     528  ADC_RegularChannelConfig
     124  ADC_SetInjectedOffset
      42  ADC_SoftwareStartConv
      50  ADC_SoftwareStartInjectedConv
      30  ADC_StructInit
      70  ADC_TempSensorVrefintCmd
      70  ADC_VBATCmd

 
   112 bytes in section .rodata
 4 632 bytes in section .text
 
 4 632 bytes of CODE  memory
   112 bytes of CONST memory

Errors: none
Warnings: none
