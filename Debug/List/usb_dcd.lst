###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       06/May/2016  23:31:37
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  D:\IAR Workspace\STM32F407\VCP_ESP\usb_lib\otg\usb_dcd.c
#    Command line =  
#        "D:\IAR Workspace\STM32F407\VCP_ESP\usb_lib\otg\usb_dcd.c" -D
#        USE_STDPERIPH_DRIVER -D STM32F4XX -D USE_FULL_ASSERT -lCN "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\List" -o "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\Obj" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\Include\" -I
#        "D:\IAR Workspace\STM32F407\VCP_ESP\..\Utilities\STM32F4-Discovery\"
#        -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\ST\STM32F4xx\Include\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_conf\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\cdc\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\otg\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\core\" -On --use_c++_inline -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    List file    =  D:\IAR Workspace\STM32F407\VCP_ESP\Debug\List\usb_dcd.lst
#    Object file  =  D:\IAR Workspace\STM32F407\VCP_ESP\Debug\Obj\usb_dcd.o
#
###############################################################################

D:\IAR Workspace\STM32F407\VCP_ESP\usb_lib\otg\usb_dcd.c
      1          /**
      2            ******************************************************************************
      3            * @file    usb_dcd.c
      4            * @author  MCD Application Team
      5            * @version V2.0.0
      6            * @date    22-July-2011
      7            * @brief   Peripheral Device Interface Layer
      8            ******************************************************************************
      9            * @attention 
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          #include "usb_conf.h"
     23          #ifdef USE_DEVICE_MODE
     24          /* Includes ------------------------------------------------------------------*/
     25          #include "usb_dcd.h"
     26          #include "usb_bsp.h"
     27          
     28          
     29          /** @addtogroup USB_OTG_DRIVER
     30          * @{
     31          */
     32          
     33          /** @defgroup USB_DCD 
     34          * @brief This file is the interface between EFSL ans Host mass-storage class
     35          * @{
     36          */
     37          
     38          
     39          /** @defgroup USB_DCD_Private_Defines
     40          * @{
     41          */ 
     42          /**
     43          * @}
     44          */ 
     45          
     46          
     47          /** @defgroup USB_DCD_Private_TypesDefinitions
     48          * @{
     49          */ 
     50          /**
     51          * @}
     52          */ 
     53          
     54          
     55          
     56          /** @defgroup USB_DCD_Private_Macros
     57          * @{
     58          */ 
     59          /**
     60          * @}
     61          */ 
     62          
     63          
     64          /** @defgroup USB_DCD_Private_Variables
     65          * @{
     66          */ 
     67          /**
     68          * @}
     69          */ 
     70          
     71          
     72          /** @defgroup USB_DCD_Private_FunctionPrototypes
     73          * @{
     74          */ 
     75          
     76          /**
     77          * @}
     78          */ 
     79          
     80          
     81          /** @defgroup USB_DCD_Private_Functions
     82          * @{
     83          */ 
     84          
     85          
     86          

   \                                 In section .text, align 2, keep-with-next
     87          void DCD_Init(USB_OTG_CORE_HANDLE *pdev , 
     88                        USB_OTG_CORE_ID_TypeDef coreID)
     89          {
   \                     DCD_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     90            uint32_t i;
     91            USB_OTG_EP *ep;
     92            
     93            USB_OTG_SelectCore (pdev , coreID);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       USB_OTG_SelectCore
     94            
     95            pdev->dev.device_status = USB_OTG_DEFAULT;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x0112      STRB     R0,[R4, #+274]
     96            pdev->dev.device_address = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF884 0x0113      STRB     R0,[R4, #+275]
     97            
     98            /* Init ep structure */
     99            for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x0006             MOVS     R6,R0
   \                     ??DCD_Init_0: (+1)
   \   00000020   0x7860             LDRB     R0,[R4, #+1]
   \   00000022   0x4286             CMP      R6,R0
   \   00000024   0xD213             BCS.N    ??DCD_Init_1
    100            {
    101              ep = &pdev->dev.in_ep[i];
   \   00000026   0x2028             MOVS     R0,#+40
   \   00000028   0xFB00 0x4006      MLA      R0,R0,R6,R4
   \   0000002C   0xF510 0x708C      ADDS     R0,R0,#+280
   \   00000030   0x0007             MOVS     R7,R0
    102              /* Init ep structure */
    103              ep->is_in = 1;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x7078             STRB     R0,[R7, #+1]
    104              ep->num = i;
   \   00000036   0x703E             STRB     R6,[R7, #+0]
    105              ep->tx_fifo_num = i;
   \   00000038   0x80FE             STRH     R6,[R7, #+6]
    106              /* Control until ep is actvated */
    107              ep->type = EP_TYPE_CTRL;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x70F8             STRB     R0,[R7, #+3]
    108              ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
   \   0000003E   0x2040             MOVS     R0,#+64
   \   00000040   0x60B8             STR      R0,[R7, #+8]
    109              ep->xfer_buff = 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x60F8             STR      R0,[R7, #+12]
    110              ep->xfer_len = 0;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x6178             STR      R0,[R7, #+20]
    111            }
   \   0000004A   0x1C76             ADDS     R6,R6,#+1
   \   0000004C   0xE7E8             B.N      ??DCD_Init_0
    112            
    113            for (i = 0; i < pdev->cfg.dev_endpoints; i++)
   \                     ??DCD_Init_1: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x0006             MOVS     R6,R0
   \                     ??DCD_Init_2: (+1)
   \   00000052   0x7860             LDRB     R0,[R4, #+1]
   \   00000054   0x4286             CMP      R6,R0
   \   00000056   0xD213             BCS.N    ??DCD_Init_3
    114            {
    115              ep = &pdev->dev.out_ep[i];
   \   00000058   0x2028             MOVS     R0,#+40
   \   0000005A   0xFB00 0x4006      MLA      R0,R0,R6,R4
   \   0000005E   0xF510 0x705C      ADDS     R0,R0,#+880
   \   00000062   0x0007             MOVS     R7,R0
    116              /* Init ep structure */
    117              ep->is_in = 0;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x7078             STRB     R0,[R7, #+1]
    118              ep->num = i;
   \   00000068   0x703E             STRB     R6,[R7, #+0]
    119              ep->tx_fifo_num = i;
   \   0000006A   0x80FE             STRH     R6,[R7, #+6]
    120              /* Control until ep is activated */
    121              ep->type = EP_TYPE_CTRL;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x70F8             STRB     R0,[R7, #+3]
    122              ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
   \   00000070   0x2040             MOVS     R0,#+64
   \   00000072   0x60B8             STR      R0,[R7, #+8]
    123              ep->xfer_buff = 0;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x60F8             STR      R0,[R7, #+12]
    124              ep->xfer_len = 0;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x6178             STR      R0,[R7, #+20]
    125            }
   \   0000007C   0x1C76             ADDS     R6,R6,#+1
   \   0000007E   0xE7E8             B.N      ??DCD_Init_2
    126            
    127            USB_OTG_DisableGlobalInt(pdev);
   \                     ??DCD_Init_3: (+1)
   \   00000080   0x0020             MOVS     R0,R4
   \   00000082   0x.... 0x....      BL       USB_OTG_DisableGlobalInt
    128            
    129            /*Init the Core (common init.) */
    130            USB_OTG_CoreInit(pdev);
   \   00000086   0x0020             MOVS     R0,R4
   \   00000088   0x.... 0x....      BL       USB_OTG_CoreInit
    131          
    132          
    133            /* Force Device Mode*/
    134            USB_OTG_SetCurrentMode(pdev, DEVICE_MODE);
   \   0000008C   0x2100             MOVS     R1,#+0
   \   0000008E   0x0020             MOVS     R0,R4
   \   00000090   0x.... 0x....      BL       USB_OTG_SetCurrentMode
    135            
    136            /* Init Device */
    137            USB_OTG_CoreInitDev(pdev);
   \   00000094   0x0020             MOVS     R0,R4
   \   00000096   0x.... 0x....      BL       USB_OTG_CoreInitDev
    138            
    139            
    140            /* Enable USB Global interrupt */
    141            USB_OTG_EnableGlobalInt(pdev);
   \   0000009A   0x0020             MOVS     R0,R4
   \   0000009C   0x.... 0x....      BL       USB_OTG_EnableGlobalInt
    142          }
   \   000000A0   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    143          
    144          
    145          /**
    146          * @brief  Configure an EP
    147          * @param pdev : Device instance
    148          * @param epdesc : Endpoint Descriptor
    149          * @retval : status
    150          */

   \                                 In section .text, align 2, keep-with-next
    151          uint32_t DCD_EP_Open(USB_OTG_CORE_HANDLE *pdev , 
    152                               uint8_t ep_addr,
    153                               uint16_t ep_mps,
    154                               uint8_t ep_type)
    155          {
   \                     DCD_EP_Open: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    156            USB_OTG_EP *ep;
    157            
    158            if ((ep_addr & 0x80) == 0x80)
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0x0628             LSLS     R0,R5,#+24
   \   00000010   0xD509             BPL.N    ??DCD_EP_Open_0
    159            {
    160              ep = &pdev->dev.in_ep[ep_addr & 0x7F];
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   00000018   0x2128             MOVS     R1,#+40
   \   0000001A   0xFB01 0x4000      MLA      R0,R1,R0,R4
   \   0000001E   0xF510 0x708C      ADDS     R0,R0,#+280
   \   00000022   0x4680             MOV      R8,R0
   \   00000024   0xE008             B.N      ??DCD_EP_Open_1
    161            }
    162            else
    163            {
    164              ep = &pdev->dev.out_ep[ep_addr & 0x7F];
   \                     ??DCD_EP_Open_0: (+1)
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   0000002C   0x2128             MOVS     R1,#+40
   \   0000002E   0xFB01 0x4000      MLA      R0,R1,R0,R4
   \   00000032   0xF510 0x705C      ADDS     R0,R0,#+880
   \   00000036   0x4680             MOV      R8,R0
    165            }
    166            ep->num   = ep_addr & 0x7F;
   \                     ??DCD_EP_Open_1: (+1)
   \   00000038   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   0000003C   0xF888 0x0000      STRB     R0,[R8, #+0]
    167            
    168            ep->is_in = (0x80 & ep_addr) != 0;
   \   00000040   0x0028             MOVS     R0,R5
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0x09C0             LSRS     R0,R0,#+7
   \   00000046   0xF888 0x0001      STRB     R0,[R8, #+1]
    169            ep->maxpacket = ep_mps;
   \   0000004A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000004C   0xF8C8 0x6008      STR      R6,[R8, #+8]
    170            ep->type = ep_type;
   \   00000050   0xF888 0x7003      STRB     R7,[R8, #+3]
    171            if (ep->is_in)
   \   00000054   0xF898 0x0001      LDRB     R0,[R8, #+1]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD003             BEQ.N    ??DCD_EP_Open_2
    172            {
    173              /* Assign a Tx FIFO */
    174              ep->tx_fifo_num = ep->num;
   \   0000005C   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   00000060   0xF8A8 0x0006      STRH     R0,[R8, #+6]
    175            }
    176            /* Set initial data PID. */
    177            if (ep_type == USB_OTG_EP_BULK )
   \                     ??DCD_EP_Open_2: (+1)
   \   00000064   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000066   0x2F02             CMP      R7,#+2
   \   00000068   0xD102             BNE.N    ??DCD_EP_Open_3
    178            {
    179              ep->data_pid_start = 0;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xF888 0x0004      STRB     R0,[R8, #+4]
    180            }
    181            USB_OTG_EPActivate(pdev , ep );
   \                     ??DCD_EP_Open_3: (+1)
   \   00000070   0x4641             MOV      R1,R8
   \   00000072   0x0020             MOVS     R0,R4
   \   00000074   0x.... 0x....      BL       USB_OTG_EPActivate
    182            return 0;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    183          }
    184          /**
    185          * @brief  called when an EP is disabled
    186          * @param pdev: device instance
    187          * @param ep_addr: endpoint address
    188          * @retval : status
    189          */

   \                                 In section .text, align 2, keep-with-next
    190          uint32_t DCD_EP_Close(USB_OTG_CORE_HANDLE *pdev , uint8_t  ep_addr)
    191          {
   \                     DCD_EP_Close: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    192            USB_OTG_EP *ep;
    193            
    194            if ((ep_addr&0x80) == 0x80)
   \   00000006   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000008   0x0628             LSLS     R0,R5,#+24
   \   0000000A   0xD509             BPL.N    ??DCD_EP_Close_0
    195            {
    196              ep = &pdev->dev.in_ep[ep_addr & 0x7F];
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   00000012   0x2128             MOVS     R1,#+40
   \   00000014   0xFB01 0x4000      MLA      R0,R1,R0,R4
   \   00000018   0xF510 0x708C      ADDS     R0,R0,#+280
   \   0000001C   0x0006             MOVS     R6,R0
   \   0000001E   0xE008             B.N      ??DCD_EP_Close_1
    197            }
    198            else
    199            {
    200              ep = &pdev->dev.out_ep[ep_addr & 0x7F];
   \                     ??DCD_EP_Close_0: (+1)
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   00000026   0x2128             MOVS     R1,#+40
   \   00000028   0xFB01 0x4000      MLA      R0,R1,R0,R4
   \   0000002C   0xF510 0x705C      ADDS     R0,R0,#+880
   \   00000030   0x0006             MOVS     R6,R0
    201            }
    202            ep->num   = ep_addr & 0x7F;
   \                     ??DCD_EP_Close_1: (+1)
   \   00000032   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   00000036   0x7030             STRB     R0,[R6, #+0]
    203            ep->is_in = (0x80 & ep_addr) != 0;
   \   00000038   0x0028             MOVS     R0,R5
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0x09C0             LSRS     R0,R0,#+7
   \   0000003E   0x7070             STRB     R0,[R6, #+1]
    204            USB_OTG_EPDeactivate(pdev , ep );
   \   00000040   0x0031             MOVS     R1,R6
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x.... 0x....      BL       USB_OTG_EPDeactivate
    205            return 0;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xBD70             POP      {R4-R6,PC}       ;; return
    206          }
    207          
    208          
    209          /**
    210          * @brief  DCD_EP_PrepareRx
    211          * @param pdev: device instance
    212          * @param ep_addr: endpoint address
    213          * @param pbuf: pointer to Rx buffer
    214          * @param buf_len: data length
    215          * @retval : status
    216          */

   \                                 In section .text, align 2, keep-with-next
    217          uint32_t   DCD_EP_PrepareRx( USB_OTG_CORE_HANDLE *pdev,
    218                                      uint8_t   ep_addr,
    219                                      uint8_t *pbuf,                        
    220                                      uint16_t  buf_len)
    221          {
   \                     DCD_EP_PrepareRx: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    222            USB_OTG_EP *ep;
    223            
    224            ep = &pdev->dev.out_ep[ep_addr & 0x7F];
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   00000012   0x2128             MOVS     R1,#+40
   \   00000014   0xFB01 0x4000      MLA      R0,R1,R0,R4
   \   00000018   0xF510 0x705C      ADDS     R0,R0,#+880
   \   0000001C   0x4680             MOV      R8,R0
    225            
    226            /*setup and start the Xfer */
    227            ep->xfer_buff = pbuf;  
   \   0000001E   0xF8C8 0x600C      STR      R6,[R8, #+12]
    228            ep->xfer_len = buf_len;
   \   00000022   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000024   0xF8C8 0x7014      STR      R7,[R8, #+20]
    229            ep->xfer_count = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF8C8 0x0018      STR      R0,[R8, #+24]
    230            ep->is_in = 0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF888 0x0001      STRB     R0,[R8, #+1]
    231            ep->num = ep_addr & 0x7F;
   \   00000034   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   00000038   0xF888 0x0000      STRB     R0,[R8, #+0]
    232            
    233            if (pdev->cfg.dma_enable == 1)
   \   0000003C   0x78E0             LDRB     R0,[R4, #+3]
   \   0000003E   0x2801             CMP      R0,#+1
   \   00000040   0xD101             BNE.N    ??DCD_EP_PrepareRx_0
    234            {
    235              ep->dma_addr = (uint32_t)pbuf;  
   \   00000042   0xF8C8 0x6010      STR      R6,[R8, #+16]
    236            }
    237            
    238            if ( ep->num == 0 )
   \                     ??DCD_EP_PrepareRx_0: (+1)
   \   00000046   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD104             BNE.N    ??DCD_EP_PrepareRx_1
    239            {
    240              USB_OTG_EP0StartXfer(pdev , ep);
   \   0000004E   0x4641             MOV      R1,R8
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       USB_OTG_EP0StartXfer
   \   00000056   0xE003             B.N      ??DCD_EP_PrepareRx_2
    241            }
    242            else
    243            {
    244              USB_OTG_EPStartXfer(pdev, ep );
   \                     ??DCD_EP_PrepareRx_1: (+1)
   \   00000058   0x4641             MOV      R1,R8
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x.... 0x....      BL       USB_OTG_EPStartXfer
    245            }
    246            return 0;
   \                     ??DCD_EP_PrepareRx_2: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    247          }
    248          
    249          /**
    250          * @brief  Transmit data over USB
    251          * @param pdev: device instance
    252          * @param ep_addr: endpoint address
    253          * @param pbuf: pointer to Tx buffer
    254          * @param buf_len: data length
    255          * @retval : status
    256          */

   \                                 In section .text, align 2, keep-with-next
    257          uint32_t  DCD_EP_Tx ( USB_OTG_CORE_HANDLE *pdev,
    258                               uint8_t   ep_addr,
    259                               uint8_t   *pbuf,
    260                               uint32_t   buf_len)
    261          {
   \                     DCD_EP_Tx: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    262            USB_OTG_EP *ep;
    263            
    264            ep = &pdev->dev.in_ep[ep_addr & 0x7F];
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   00000012   0x2128             MOVS     R1,#+40
   \   00000014   0xFB01 0x4000      MLA      R0,R1,R0,R4
   \   00000018   0xF510 0x708C      ADDS     R0,R0,#+280
   \   0000001C   0x4680             MOV      R8,R0
    265            
    266            /* Setup and start the Transfer */
    267            ep->is_in = 1;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF888 0x0001      STRB     R0,[R8, #+1]
    268            ep->num = ep_addr & 0x7F;  
   \   00000024   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   00000028   0xF888 0x0000      STRB     R0,[R8, #+0]
    269            ep->xfer_buff = pbuf;
   \   0000002C   0xF8C8 0x600C      STR      R6,[R8, #+12]
    270            ep->dma_addr = (uint32_t)pbuf;  
   \   00000030   0xF8C8 0x6010      STR      R6,[R8, #+16]
    271            ep->xfer_count = 0;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF8C8 0x0018      STR      R0,[R8, #+24]
    272            ep->xfer_len  = buf_len;
   \   0000003A   0xF8C8 0x7014      STR      R7,[R8, #+20]
    273            
    274            if ( ep->num == 0 )
   \   0000003E   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD104             BNE.N    ??DCD_EP_Tx_0
    275            {
    276              USB_OTG_EP0StartXfer(pdev , ep);
   \   00000046   0x4641             MOV      R1,R8
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       USB_OTG_EP0StartXfer
   \   0000004E   0xE003             B.N      ??DCD_EP_Tx_1
    277            }
    278            else
    279            {
    280              USB_OTG_EPStartXfer(pdev, ep );
   \                     ??DCD_EP_Tx_0: (+1)
   \   00000050   0x4641             MOV      R1,R8
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       USB_OTG_EPStartXfer
    281            }
    282            return 0;
   \                     ??DCD_EP_Tx_1: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    283          }
    284          
    285          
    286          /**
    287          * @brief  Stall an endpoint.
    288          * @param pdev: device instance
    289          * @param epnum: endpoint address
    290          * @retval : status
    291          */

   \                                 In section .text, align 2, keep-with-next
    292          uint32_t  DCD_EP_Stall (USB_OTG_CORE_HANDLE *pdev, uint8_t   epnum)
    293          {
   \                     DCD_EP_Stall: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    294            USB_OTG_EP *ep;
    295            if ((0x80 & epnum) == 0x80)
   \   00000006   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000008   0x0628             LSLS     R0,R5,#+24
   \   0000000A   0xD509             BPL.N    ??DCD_EP_Stall_0
    296            {
    297              ep = &pdev->dev.in_ep[epnum & 0x7F];
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   00000012   0x2128             MOVS     R1,#+40
   \   00000014   0xFB01 0x4000      MLA      R0,R1,R0,R4
   \   00000018   0xF510 0x708C      ADDS     R0,R0,#+280
   \   0000001C   0x0006             MOVS     R6,R0
   \   0000001E   0xE006             B.N      ??DCD_EP_Stall_1
    298            }
    299            else
    300            {
    301              ep = &pdev->dev.out_ep[epnum];
   \                     ??DCD_EP_Stall_0: (+1)
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2028             MOVS     R0,#+40
   \   00000024   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   00000028   0xF510 0x705C      ADDS     R0,R0,#+880
   \   0000002C   0x0006             MOVS     R6,R0
    302            }
    303          
    304            ep->is_stall = 1;
   \                     ??DCD_EP_Stall_1: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x70B0             STRB     R0,[R6, #+2]
    305            ep->num   = epnum & 0x7F;
   \   00000032   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   00000036   0x7030             STRB     R0,[R6, #+0]
    306            ep->is_in = ((epnum & 0x80) == 0x80);
   \   00000038   0x0028             MOVS     R0,R5
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0x09C0             LSRS     R0,R0,#+7
   \   0000003E   0x7070             STRB     R0,[R6, #+1]
    307            
    308            USB_OTG_EPSetStall(pdev , ep);
   \   00000040   0x0031             MOVS     R1,R6
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x.... 0x....      BL       USB_OTG_EPSetStall
    309            return (0);
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xBD70             POP      {R4-R6,PC}       ;; return
    310          }
    311          
    312          
    313          /**
    314          * @brief  Clear stall condition on endpoints.
    315          * @param pdev: device instance
    316          * @param epnum: endpoint address
    317          * @retval : status
    318          */

   \                                 In section .text, align 2, keep-with-next
    319          uint32_t  DCD_EP_ClrStall (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
    320          {
   \                     DCD_EP_ClrStall: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    321            USB_OTG_EP *ep;
    322            if ((0x80 & epnum) == 0x80)
   \   00000006   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000008   0x0628             LSLS     R0,R5,#+24
   \   0000000A   0xD509             BPL.N    ??DCD_EP_ClrStall_0
    323            {
    324              ep = &pdev->dev.in_ep[epnum & 0x7F];    
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   00000012   0x2128             MOVS     R1,#+40
   \   00000014   0xFB01 0x4000      MLA      R0,R1,R0,R4
   \   00000018   0xF510 0x708C      ADDS     R0,R0,#+280
   \   0000001C   0x0006             MOVS     R6,R0
   \   0000001E   0xE006             B.N      ??DCD_EP_ClrStall_1
    325            }
    326            else
    327            {
    328              ep = &pdev->dev.out_ep[epnum];
   \                     ??DCD_EP_ClrStall_0: (+1)
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2028             MOVS     R0,#+40
   \   00000024   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   00000028   0xF510 0x705C      ADDS     R0,R0,#+880
   \   0000002C   0x0006             MOVS     R6,R0
    329            }
    330            
    331            ep->is_stall = 0;  
   \                     ??DCD_EP_ClrStall_1: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x70B0             STRB     R0,[R6, #+2]
    332            ep->num   = epnum & 0x7F;
   \   00000032   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   00000036   0x7030             STRB     R0,[R6, #+0]
    333            ep->is_in = ((epnum & 0x80) == 0x80);
   \   00000038   0x0028             MOVS     R0,R5
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0x09C0             LSRS     R0,R0,#+7
   \   0000003E   0x7070             STRB     R0,[R6, #+1]
    334            
    335            USB_OTG_EPClearStall(pdev , ep);
   \   00000040   0x0031             MOVS     R1,R6
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x.... 0x....      BL       USB_OTG_EPClearStall
    336            return (0);
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xBD70             POP      {R4-R6,PC}       ;; return
    337          }
    338          
    339          
    340          /**
    341          * @brief  This Function flushes the FIFOs.
    342          * @param pdev: device instance
    343          * @param epnum: endpoint address
    344          * @retval : status
    345          */

   \                                 In section .text, align 2, keep-with-next
    346          uint32_t  DCD_EP_Flush (USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
    347          {
   \                     DCD_EP_Flush: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    348          
    349            if ((epnum & 0x80) == 0x80)
   \   00000006   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000008   0x0628             LSLS     R0,R5,#+24
   \   0000000A   0xD506             BPL.N    ??DCD_EP_Flush_0
    350            {
    351              USB_OTG_FlushTxFifo(pdev, epnum & 0x7F);
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0xF015 0x017F      ANDS     R1,R5,#0x7F
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       USB_OTG_FlushTxFifo
   \   00000018   0xE002             B.N      ??DCD_EP_Flush_1
    352            }
    353            else
    354            {
    355              USB_OTG_FlushRxFifo(pdev);
   \                     ??DCD_EP_Flush_0: (+1)
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       USB_OTG_FlushRxFifo
    356            }
    357          
    358            return (0);
   \                     ??DCD_EP_Flush_1: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    359          }
    360          
    361          
    362          /**
    363          * @brief  This Function set USB device address
    364          * @param pdev: device instance
    365          * @param address: new device address
    366          * @retval : status
    367          */

   \                                 In section .text, align 2, keep-with-next
    368          void  DCD_EP_SetAddress (USB_OTG_CORE_HANDLE *pdev, uint8_t address)
    369          {
   \                     DCD_EP_SetAddress: (+1)
   \   00000000   0xB410             PUSH     {R4}
    370            USB_OTG_DCFG_TypeDef  dcfg;
    371            dcfg.d32 = 0;
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x001A             MOVS     R2,R3
    372            dcfg.b.devaddr = address;
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0xF361 0x120A      BFI      R2,R1,#+4,#+7
    373            USB_OTG_MODIFY_REG32( &pdev->regs.DREGS->DCFG, 0, dcfg.d32);
   \   0000000C   0x6903             LDR      R3,[R0, #+16]
   \   0000000E   0x681B             LDR      R3,[R3, #+0]
   \   00000010   0x4313             ORRS     R3,R2,R3
   \   00000012   0x6904             LDR      R4,[R0, #+16]
   \   00000014   0x6023             STR      R3,[R4, #+0]
    374          }
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return
    375          
    376          /**
    377          * @brief  Connect device (enable internal pull-up)
    378          * @param pdev: device instance
    379          * @retval : None
    380          */

   \                                 In section .text, align 2, keep-with-next
    381          void  DCD_DevConnect (USB_OTG_CORE_HANDLE *pdev)
    382          {
   \                     DCD_DevConnect: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    383          #ifndef USE_OTG_MODE
    384            USB_OTG_DCTL_TypeDef  dctl;
    385            dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
   \   00000004   0x6920             LDR      R0,[R4, #+16]
   \   00000006   0x6840             LDR      R0,[R0, #+4]
   \   00000008   0x0005             MOVS     R5,R0
    386            /* Connect device */
    387            dctl.b.sftdiscon  = 0;
   \   0000000A   0xF035 0x0502      BICS     R5,R5,#0x2
    388            USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
   \   0000000E   0x6920             LDR      R0,[R4, #+16]
   \   00000010   0x6045             STR      R5,[R0, #+4]
    389            USB_OTG_BSP_mDelay(3);
   \   00000012   0x2003             MOVS     R0,#+3
   \   00000014   0x.... 0x....      BL       USB_OTG_BSP_mDelay
    390          #endif
    391          }
   \   00000018   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    392          
    393          
    394          /**
    395          * @brief  Disconnect device (disable internal pull-up)
    396          * @param pdev: device instance
    397          * @retval : None
    398          */

   \                                 In section .text, align 2, keep-with-next
    399          void  DCD_DevDisconnect (USB_OTG_CORE_HANDLE *pdev)
    400          {
   \                     DCD_DevDisconnect: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    401          #ifndef USE_OTG_MODE
    402            USB_OTG_DCTL_TypeDef  dctl;
    403            dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
   \   00000004   0x6920             LDR      R0,[R4, #+16]
   \   00000006   0x6840             LDR      R0,[R0, #+4]
   \   00000008   0x0005             MOVS     R5,R0
    404            /* Disconnect device for 3ms */
    405            dctl.b.sftdiscon  = 1;
   \   0000000A   0xF055 0x0502      ORRS     R5,R5,#0x2
    406            USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
   \   0000000E   0x6920             LDR      R0,[R4, #+16]
   \   00000010   0x6045             STR      R5,[R0, #+4]
    407            USB_OTG_BSP_mDelay(3);
   \   00000012   0x2003             MOVS     R0,#+3
   \   00000014   0x.... 0x....      BL       USB_OTG_BSP_mDelay
    408          #endif
    409          }
   \   00000018   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    410          
    411          
    412          /**
    413          * @brief  returns the EP Status
    414          * @param  pdev : Selected device
    415          *         epnum : endpoint address
    416          * @retval : EP status
    417          */
    418          

   \                                 In section .text, align 2, keep-with-next
    419          uint32_t DCD_GetEPStatus(USB_OTG_CORE_HANDLE *pdev ,uint8_t epnum)
    420          {
   \                     DCD_GetEPStatus: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    421            USB_OTG_EP *ep;
    422            uint32_t Status = 0;  
   \   00000006   0x2700             MOVS     R7,#+0
    423            
    424            if ((0x80 & epnum) == 0x80)
   \   00000008   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000A   0x0628             LSLS     R0,R5,#+24
   \   0000000C   0xD509             BPL.N    ??DCD_GetEPStatus_0
    425            {
    426              ep = &pdev->dev.in_ep[epnum & 0x7F];    
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   00000014   0x2128             MOVS     R1,#+40
   \   00000016   0xFB01 0x4000      MLA      R0,R1,R0,R4
   \   0000001A   0xF510 0x708C      ADDS     R0,R0,#+280
   \   0000001E   0x0006             MOVS     R6,R0
   \   00000020   0xE006             B.N      ??DCD_GetEPStatus_1
    427            }
    428            else
    429            {
    430              ep = &pdev->dev.out_ep[epnum];
   \                     ??DCD_GetEPStatus_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2028             MOVS     R0,#+40
   \   00000026   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   0000002A   0xF510 0x705C      ADDS     R0,R0,#+880
   \   0000002E   0x0006             MOVS     R6,R0
    431            }
    432            
    433            Status = USB_OTG_GetEPStatus(pdev ,ep);
   \                     ??DCD_GetEPStatus_1: (+1)
   \   00000030   0x0031             MOVS     R1,R6
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       USB_OTG_GetEPStatus
   \   00000038   0x0007             MOVS     R7,R0
    434          
    435            /* Return the current status */
    436            return Status;
   \   0000003A   0x0038             MOVS     R0,R7
   \   0000003C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    437          }
    438          
    439          /**
    440          * @brief  Set the EP Status
    441          * @param  pdev : Selected device
    442          *         Status : new Status
    443          *         epnum : EP address
    444          * @retval : None
    445          */

   \                                 In section .text, align 2, keep-with-next
    446          void DCD_SetEPStatus (USB_OTG_CORE_HANDLE *pdev , uint8_t epnum , uint32_t Status)
    447          {
   \                     DCD_SetEPStatus: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    448            USB_OTG_EP *ep;
    449            
    450            if ((0x80 & epnum) == 0x80)
   \   00000008   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000A   0x0628             LSLS     R0,R5,#+24
   \   0000000C   0xD509             BPL.N    ??DCD_SetEPStatus_0
    451            {
    452              ep = &pdev->dev.in_ep[epnum & 0x7F];    
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   00000014   0x2128             MOVS     R1,#+40
   \   00000016   0xFB01 0x4000      MLA      R0,R1,R0,R4
   \   0000001A   0xF510 0x708C      ADDS     R0,R0,#+280
   \   0000001E   0x0007             MOVS     R7,R0
   \   00000020   0xE006             B.N      ??DCD_SetEPStatus_1
    453            }
    454            else
    455            {
    456              ep = &pdev->dev.out_ep[epnum];
   \                     ??DCD_SetEPStatus_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2028             MOVS     R0,#+40
   \   00000026   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   0000002A   0xF510 0x705C      ADDS     R0,R0,#+880
   \   0000002E   0x0007             MOVS     R7,R0
    457            }
    458            
    459             USB_OTG_SetEPStatus(pdev ,ep , Status);
   \                     ??DCD_SetEPStatus_1: (+1)
   \   00000030   0x0032             MOVS     R2,R6
   \   00000032   0x0039             MOVS     R1,R7
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       USB_OTG_SetEPStatus
    460          }
   \   0000003A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    461          
    462          /**
    463          * @}
    464          */ 
    465          
    466          /**
    467          * @}
    468          */ 
    469          
    470          /**
    471          * @}
    472          */
    473          #endif
    474          
    475          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   DCD_DevConnect
        16   -> USB_OTG_BSP_mDelay
      16   DCD_DevDisconnect
        16   -> USB_OTG_BSP_mDelay
      16   DCD_EP_Close
        16   -> USB_OTG_EPDeactivate
      16   DCD_EP_ClrStall
        16   -> USB_OTG_EPClearStall
      16   DCD_EP_Flush
        16   -> USB_OTG_FlushRxFifo
        16   -> USB_OTG_FlushTxFifo
      24   DCD_EP_Open
        24   -> USB_OTG_EPActivate
      24   DCD_EP_PrepareRx
        24   -> USB_OTG_EP0StartXfer
        24   -> USB_OTG_EPStartXfer
       4   DCD_EP_SetAddress
      16   DCD_EP_Stall
        16   -> USB_OTG_EPSetStall
      24   DCD_EP_Tx
        24   -> USB_OTG_EP0StartXfer
        24   -> USB_OTG_EPStartXfer
      24   DCD_GetEPStatus
        24   -> USB_OTG_GetEPStatus
      24   DCD_Init
        24   -> USB_OTG_CoreInit
        24   -> USB_OTG_CoreInitDev
        24   -> USB_OTG_DisableGlobalInt
        24   -> USB_OTG_EnableGlobalInt
        24   -> USB_OTG_SelectCore
        24   -> USB_OTG_SetCurrentMode
      24   DCD_SetEPStatus
        24   -> USB_OTG_SetEPStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      26  DCD_DevConnect
      26  DCD_DevDisconnect
      76  DCD_EP_Close
      76  DCD_EP_ClrStall
      36  DCD_EP_Flush
     126  DCD_EP_Open
     102  DCD_EP_PrepareRx
      26  DCD_EP_SetAddress
      76  DCD_EP_Stall
      94  DCD_EP_Tx
      62  DCD_GetEPStatus
     162  DCD_Init
      60  DCD_SetEPStatus

 
 948 bytes in section .text
 
 948 bytes of CODE memory

Errors: none
Warnings: 1
