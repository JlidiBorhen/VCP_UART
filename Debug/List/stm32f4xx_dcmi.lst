###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       06/May/2016  23:31:32
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\IAR
#        Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dcmi.c
#    Command line =  
#        "D:\IAR
#        Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dcmi.c"
#        -D USE_STDPERIPH_DRIVER -D STM32F4XX -D USE_FULL_ASSERT -lCN "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\List" -o "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\Obj" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\Include\" -I
#        "D:\IAR Workspace\STM32F407\VCP_ESP\..\Utilities\STM32F4-Discovery\"
#        -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\ST\STM32F4xx\Include\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_conf\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\cdc\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\otg\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\core\" -On --use_c++_inline -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    List file    =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\Debug\List\stm32f4xx_dcmi.lst
#    Object file  =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\Debug\Obj\stm32f4xx_dcmi.o
#
###############################################################################

D:\IAR Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dcmi.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_dcmi.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    30-September-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the DCMI peripheral:           
      9            *           - Initialization and Configuration
     10            *           - Image capture functions  
     11            *           - Interrupts and flags management
     12            *
     13            *  @verbatim  
     14            *  
     15            *        
     16            *          ===================================================================
     17            *                                 How to use this driver
     18            *          ===================================================================  
     19            *         
     20            *         The sequence below describes how to use this driver to capture image
     21            *         from a camera module connected to the DCMI Interface.
     22            *         This sequence does not take into account the configuration of the  
     23            *         camera module, which should be made before to configure and enable
     24            *         the DCMI to capture images.
     25            *           
     26            *          1. Enable the clock for the DCMI and associated GPIOs using the following functions:
     27            *                 RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_DCMI, ENABLE);
     28            *                 RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);
     29            *
     30            *          2. DCMI pins configuration 
     31            *             - Connect the involved DCMI pins to AF13 using the following function 
     32            *                 GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_DCMI); 
     33            *             - Configure these DCMI pins in alternate function mode by calling the function
     34            *                 GPIO_Init();
     35            *    
     36            *          3. Declare a DCMI_InitTypeDef structure, for example:
     37            *                 DCMI_InitTypeDef  DCMI_InitStructure;
     38            *             and fill the DCMI_InitStructure variable with the allowed values
     39            *             of the structure member.
     40            *  
     41            *          4. Initialize the DCMI interface by calling the function
     42            *                 DCMI_Init(&DCMI_InitStructure); 
     43            *  
     44            *          5. Configure the DMA2_Stream1 channel1 to transfer Data from DCMI DR
     45            *             register to the destination memory buffer.
     46            *  
     47            *          6. Enable DCMI interface using the function
     48            *                 DCMI_Cmd(ENABLE);
     49            *                 
     50            *         7. Start the image capture using the function
     51            *                 DCMI_CaptureCmd(ENABLE);
     52            *                 
     53            *         8. At this stage the DCMI interface waits for the first start of frame,
     54            *            then a DMA request is generated continuously/once (depending on the
     55            *            mode used, Continuous/Snapshot) to transfer the received data into
     56            *            the destination memory. 
     57            *   
     58            *  @note  If you need to capture only a rectangular window from the received
     59            *         image, you have to use the DCMI_CROPConfig() function to configure 
     60            *         the coordinates and size of the window to be captured, then enable 
     61            *         the Crop feature using DCMI_CROPCmd(ENABLE);  
     62            *         In this case, the Crop configuration should be made before to enable
     63            *         and start the DCMI interface. 
     64            *        
     65            *  @endverbatim   
     66            *  
     67            ******************************************************************************
     68            * @attention
     69            *
     70            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     71            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     72            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     73            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     74            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     75            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     76            *
     77            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     78            ******************************************************************************
     79            */
     80          
     81          /* Includes ------------------------------------------------------------------*/
     82          #include "stm32f4xx_dcmi.h"
     83          #include "stm32f4xx_rcc.h"
     84          
     85          /** @addtogroup STM32F4xx_StdPeriph_Driver
     86            * @{
     87            */
     88          
     89          /** @defgroup DCMI 
     90            * @brief DCMI driver modules
     91            * @{
     92            */ 
     93          
     94          /* Private typedef -----------------------------------------------------------*/
     95          /* Private define ------------------------------------------------------------*/
     96          /* Private macro -------------------------------------------------------------*/
     97          /* Private variables ---------------------------------------------------------*/
     98          /* Private function prototypes -----------------------------------------------*/
     99          /* Private functions ---------------------------------------------------------*/
    100          
    101          /** @defgroup DCMI_Private_Functions
    102            * @{
    103            */ 
    104          
    105          /** @defgroup DCMI_Group1 Initialization and Configuration functions
    106           *  @brief   Initialization and Configuration functions 
    107           *
    108          @verbatim   
    109           ===============================================================================
    110                            Initialization and Configuration functions
    111           ===============================================================================  
    112          
    113          @endverbatim
    114            * @{
    115            */
    116          
    117          /**
    118            * @brief  Deinitializes the DCMI registers to their default reset values.
    119            * @param  None
    120            * @retval None
    121            */

   \                                 In section .text, align 2, keep-with-next
    122          void DCMI_DeInit(void)
    123          {
    124            DCMI->CR = 0x0;
   \                     DCMI_DeInit: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable13  ;; 0x50050000
   \   00000006   0x6008             STR      R0,[R1, #+0]
    125            DCMI->IER = 0x0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x5005000c
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    126            DCMI->ICR = 0x1F;
   \   00000010   0x201F             MOVS     R0,#+31
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable13_2  ;; 0x50050014
   \   00000016   0x6008             STR      R0,[R1, #+0]
    127            DCMI->ESCR = 0x0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable13_3  ;; 0x50050018
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    128            DCMI->ESUR = 0x0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x5005001c
   \   00000026   0x6008             STR      R0,[R1, #+0]
    129            DCMI->CWSTRTR = 0x0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable13_5  ;; 0x50050020
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    130            DCMI->CWSIZER = 0x0;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable13_6  ;; 0x50050024
   \   00000036   0x6008             STR      R0,[R1, #+0]
    131          }
   \   00000038   0x4770             BX       LR               ;; return
    132          
    133          /**
    134            * @brief  Initializes the DCMI according to the specified parameters in the DCMI_InitStruct.
    135            * @param  DCMI_InitStruct: pointer to a DCMI_InitTypeDef structure that contains 
    136            *         the configuration information for the DCMI.
    137            * @retval None
    138            */

   \                                 In section .text, align 2, keep-with-next
    139          void DCMI_Init(DCMI_InitTypeDef* DCMI_InitStruct)
    140          {
   \                     DCMI_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    141            uint32_t temp = 0x0;
   \   00000004   0x2500             MOVS     R5,#+0
    142            
    143            /* Check the parameters */
    144            assert_param(IS_DCMI_CAPTURE_MODE(DCMI_InitStruct->DCMI_CaptureMode));
   \   00000006   0x8820             LDRH     R0,[R4, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD007             BEQ.N    ??DCMI_Init_0
   \   0000000C   0x8820             LDRH     R0,[R4, #+0]
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD004             BEQ.N    ??DCMI_Init_0
   \   00000012   0x2190             MOVS     R1,#+144
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable13_7
   \   00000018   0x.... 0x....      BL       assert_failed
    145            assert_param(IS_DCMI_SYNCHRO(DCMI_InitStruct->DCMI_SynchroMode));
   \                     ??DCMI_Init_0: (+1)
   \   0000001C   0x8860             LDRH     R0,[R4, #+2]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD007             BEQ.N    ??DCMI_Init_1
   \   00000022   0x8860             LDRH     R0,[R4, #+2]
   \   00000024   0x2810             CMP      R0,#+16
   \   00000026   0xD004             BEQ.N    ??DCMI_Init_1
   \   00000028   0x2191             MOVS     R1,#+145
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable13_7
   \   0000002E   0x.... 0x....      BL       assert_failed
    146            assert_param(IS_DCMI_PCKPOLARITY(DCMI_InitStruct->DCMI_PCKPolarity));
   \                     ??DCMI_Init_1: (+1)
   \   00000032   0x88A0             LDRH     R0,[R4, #+4]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD007             BEQ.N    ??DCMI_Init_2
   \   00000038   0x88A0             LDRH     R0,[R4, #+4]
   \   0000003A   0x2820             CMP      R0,#+32
   \   0000003C   0xD004             BEQ.N    ??DCMI_Init_2
   \   0000003E   0x2192             MOVS     R1,#+146
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable13_7
   \   00000044   0x.... 0x....      BL       assert_failed
    147            assert_param(IS_DCMI_VSPOLARITY(DCMI_InitStruct->DCMI_VSPolarity));
   \                     ??DCMI_Init_2: (+1)
   \   00000048   0x88E0             LDRH     R0,[R4, #+6]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD007             BEQ.N    ??DCMI_Init_3
   \   0000004E   0x88E0             LDRH     R0,[R4, #+6]
   \   00000050   0x2880             CMP      R0,#+128
   \   00000052   0xD004             BEQ.N    ??DCMI_Init_3
   \   00000054   0x2193             MOVS     R1,#+147
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable13_7
   \   0000005A   0x.... 0x....      BL       assert_failed
    148            assert_param(IS_DCMI_HSPOLARITY(DCMI_InitStruct->DCMI_HSPolarity));
   \                     ??DCMI_Init_3: (+1)
   \   0000005E   0x8920             LDRH     R0,[R4, #+8]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD007             BEQ.N    ??DCMI_Init_4
   \   00000064   0x8920             LDRH     R0,[R4, #+8]
   \   00000066   0x2840             CMP      R0,#+64
   \   00000068   0xD004             BEQ.N    ??DCMI_Init_4
   \   0000006A   0x2194             MOVS     R1,#+148
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable13_7
   \   00000070   0x.... 0x....      BL       assert_failed
    149            assert_param(IS_DCMI_CAPTURE_RATE(DCMI_InitStruct->DCMI_CaptureRate));
   \                     ??DCMI_Init_4: (+1)
   \   00000074   0x8960             LDRH     R0,[R4, #+10]
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD00C             BEQ.N    ??DCMI_Init_5
   \   0000007A   0x8960             LDRH     R0,[R4, #+10]
   \   0000007C   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000080   0xD008             BEQ.N    ??DCMI_Init_5
   \   00000082   0x8960             LDRH     R0,[R4, #+10]
   \   00000084   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000088   0xD004             BEQ.N    ??DCMI_Init_5
   \   0000008A   0x2195             MOVS     R1,#+149
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable13_7
   \   00000090   0x.... 0x....      BL       assert_failed
    150            assert_param(IS_DCMI_EXTENDED_DATA(DCMI_InitStruct->DCMI_ExtendedDataMode));
   \                     ??DCMI_Init_5: (+1)
   \   00000094   0x89A0             LDRH     R0,[R4, #+12]
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD010             BEQ.N    ??DCMI_Init_6
   \   0000009A   0x89A0             LDRH     R0,[R4, #+12]
   \   0000009C   0xF5B0 0x6F80      CMP      R0,#+1024
   \   000000A0   0xD00C             BEQ.N    ??DCMI_Init_6
   \   000000A2   0x89A0             LDRH     R0,[R4, #+12]
   \   000000A4   0xF5B0 0x6F00      CMP      R0,#+2048
   \   000000A8   0xD008             BEQ.N    ??DCMI_Init_6
   \   000000AA   0x89A0             LDRH     R0,[R4, #+12]
   \   000000AC   0xF5B0 0x6F40      CMP      R0,#+3072
   \   000000B0   0xD004             BEQ.N    ??DCMI_Init_6
   \   000000B2   0x2196             MOVS     R1,#+150
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable13_7
   \   000000B8   0x.... 0x....      BL       assert_failed
    151          
    152            /* The DCMI configuration registers should be programmed correctly before 
    153            enabling the CR_ENABLE Bit and the CR_CAPTURE Bit */
    154            DCMI->CR &= ~(DCMI_CR_ENABLE | DCMI_CR_CAPTURE);
   \                     ??DCMI_Init_6: (+1)
   \   000000BC   0x....             LDR.N    R0,??DataTable13  ;; 0x50050000
   \   000000BE   0x6800             LDR      R0,[R0, #+0]
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable13_8  ;; 0xffffbffe
   \   000000C4   0x4008             ANDS     R0,R1,R0
   \   000000C6   0x....             LDR.N    R1,??DataTable13  ;; 0x50050000
   \   000000C8   0x6008             STR      R0,[R1, #+0]
    155             
    156            /* Reset the old DCMI configuration */
    157            temp = DCMI->CR;
   \   000000CA   0x....             LDR.N    R0,??DataTable13  ;; 0x50050000
   \   000000CC   0x6800             LDR      R0,[R0, #+0]
   \   000000CE   0x0005             MOVS     R5,R0
    158            
    159            temp &= ~((uint32_t)DCMI_CR_CM     | DCMI_CR_ESS   | DCMI_CR_PCKPOL |
    160                                DCMI_CR_HSPOL  | DCMI_CR_VSPOL | DCMI_CR_FCRC_0 | 
    161                                DCMI_CR_FCRC_1 | DCMI_CR_EDM_0 | DCMI_CR_EDM_1); 
   \   000000D0   0x....             LDR.N    R0,??DataTable13_9  ;; 0xfffff00d
   \   000000D2   0x4005             ANDS     R5,R0,R5
    162                            
    163            /* Sets the new configuration of the DCMI peripheral */
    164            temp |= ((uint32_t)DCMI_InitStruct->DCMI_CaptureMode |
    165                               DCMI_InitStruct->DCMI_SynchroMode |
    166                               DCMI_InitStruct->DCMI_PCKPolarity |
    167                               DCMI_InitStruct->DCMI_VSPolarity |
    168                               DCMI_InitStruct->DCMI_HSPolarity |
    169                               DCMI_InitStruct->DCMI_CaptureRate |
    170                               DCMI_InitStruct->DCMI_ExtendedDataMode);
   \   000000D4   0x8820             LDRH     R0,[R4, #+0]
   \   000000D6   0x8861             LDRH     R1,[R4, #+2]
   \   000000D8   0x4308             ORRS     R0,R1,R0
   \   000000DA   0x88A1             LDRH     R1,[R4, #+4]
   \   000000DC   0x4308             ORRS     R0,R1,R0
   \   000000DE   0x88E1             LDRH     R1,[R4, #+6]
   \   000000E0   0x4308             ORRS     R0,R1,R0
   \   000000E2   0x8921             LDRH     R1,[R4, #+8]
   \   000000E4   0x4308             ORRS     R0,R1,R0
   \   000000E6   0x8961             LDRH     R1,[R4, #+10]
   \   000000E8   0x4308             ORRS     R0,R1,R0
   \   000000EA   0x89A1             LDRH     R1,[R4, #+12]
   \   000000EC   0x4308             ORRS     R0,R1,R0
   \   000000EE   0x4305             ORRS     R5,R0,R5
    171          
    172            DCMI->CR = temp;                              
   \   000000F0   0x....             LDR.N    R0,??DataTable13  ;; 0x50050000
   \   000000F2   0x6005             STR      R5,[R0, #+0]
    173          }
   \   000000F4   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    174          
    175          /**
    176            * @brief  Fills each DCMI_InitStruct member with its default value.
    177            * @param  DCMI_InitStruct : pointer to a DCMI_InitTypeDef structure which will
    178            *         be initialized.
    179            * @retval None
    180            */

   \                                 In section .text, align 2, keep-with-next
    181          void DCMI_StructInit(DCMI_InitTypeDef* DCMI_InitStruct)
    182          {
    183            /* Set the default configuration */
    184            DCMI_InitStruct->DCMI_CaptureMode = DCMI_CaptureMode_Continuous;
   \                     DCMI_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    185            DCMI_InitStruct->DCMI_SynchroMode = DCMI_SynchroMode_Hardware;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x8041             STRH     R1,[R0, #+2]
    186            DCMI_InitStruct->DCMI_PCKPolarity = DCMI_PCKPolarity_Falling;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x8081             STRH     R1,[R0, #+4]
    187            DCMI_InitStruct->DCMI_VSPolarity = DCMI_VSPolarity_Low;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x80C1             STRH     R1,[R0, #+6]
    188            DCMI_InitStruct->DCMI_HSPolarity = DCMI_HSPolarity_Low;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x8101             STRH     R1,[R0, #+8]
    189            DCMI_InitStruct->DCMI_CaptureRate = DCMI_CaptureRate_All_Frame;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x8141             STRH     R1,[R0, #+10]
    190            DCMI_InitStruct->DCMI_ExtendedDataMode = DCMI_ExtendedDataMode_8b;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x8181             STRH     R1,[R0, #+12]
    191          }
   \   0000001C   0x4770             BX       LR               ;; return
    192          
    193          /**
    194            * @brief  Initializes the DCMI peripheral CROP mode according to the specified
    195            *         parameters in the DCMI_CROPInitStruct.
    196            * @note   This function should be called before to enable and start the DCMI interface.   
    197            * @param  DCMI_CROPInitStruct:  pointer to a DCMI_CROPInitTypeDef structure that 
    198            *         contains the configuration information for the DCMI peripheral CROP mode.
    199            * @retval None
    200            */

   \                                 In section .text, align 2, keep-with-next
    201          void DCMI_CROPConfig(DCMI_CROPInitTypeDef* DCMI_CROPInitStruct)
    202          {  
    203            /* Sets the CROP window coordinates */
    204            DCMI->CWSTRTR = (uint32_t)((uint32_t)DCMI_CROPInitStruct->DCMI_HorizontalOffsetCount |
    205                            ((uint32_t)DCMI_CROPInitStruct->DCMI_VerticalStartLine << 16));
   \                     DCMI_CROPConfig: (+1)
   \   00000000   0x8841             LDRH     R1,[R0, #+2]
   \   00000002   0x8802             LDRH     R2,[R0, #+0]
   \   00000004   0xEA51 0x4102      ORRS     R1,R1,R2, LSL #+16
   \   00000008   0x....             LDR.N    R2,??DataTable13_5  ;; 0x50050020
   \   0000000A   0x6011             STR      R1,[R2, #+0]
    206          
    207            /* Sets the CROP window size */
    208            DCMI->CWSIZER = (uint32_t)(DCMI_CROPInitStruct->DCMI_CaptureCount |
    209                            ((uint32_t)DCMI_CROPInitStruct->DCMI_VerticalLineCount << 16));
   \   0000000C   0x88C1             LDRH     R1,[R0, #+6]
   \   0000000E   0x8882             LDRH     R2,[R0, #+4]
   \   00000010   0xEA51 0x4102      ORRS     R1,R1,R2, LSL #+16
   \   00000014   0x....             LDR.N    R2,??DataTable13_6  ;; 0x50050024
   \   00000016   0x6011             STR      R1,[R2, #+0]
    210          }
   \   00000018   0x4770             BX       LR               ;; return
    211          
    212          /**
    213            * @brief  Enables or disables the DCMI Crop feature.
    214            * @note   This function should be called before to enable and start the DCMI interface.
    215            * @param  NewState: new state of the DCMI Crop feature. 
    216            *          This parameter can be: ENABLE or DISABLE.
    217            * @retval None
    218            */

   \                                 In section .text, align 2, keep-with-next
    219          void DCMI_CROPCmd(FunctionalState NewState)
    220          {
   \                     DCMI_CROPCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    221            /* Check the parameters */
    222            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD006             BEQ.N    ??DCMI_CROPCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD003             BEQ.N    ??DCMI_CROPCmd_0
   \   00000010   0x21DE             MOVS     R1,#+222
   \   00000012   0x....             LDR.N    R0,??DataTable13_7
   \   00000014   0x.... 0x....      BL       assert_failed
    223              
    224            if (NewState != DISABLE)
   \                     ??DCMI_CROPCmd_0: (+1)
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD006             BEQ.N    ??DCMI_CROPCmd_1
    225            {
    226              /* Enable the DCMI Crop feature */
    227              DCMI->CR |= (uint32_t)DCMI_CR_CROP;
   \   0000001E   0x....             LDR.N    R0,??DataTable13  ;; 0x50050000
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000026   0x....             LDR.N    R1,??DataTable13  ;; 0x50050000
   \   00000028   0x6008             STR      R0,[R1, #+0]
   \   0000002A   0xE005             B.N      ??DCMI_CROPCmd_2
    228            }
    229            else
    230            {
    231              /* Disable the DCMI Crop feature */
    232              DCMI->CR &= ~(uint32_t)DCMI_CR_CROP;
   \                     ??DCMI_CROPCmd_1: (+1)
   \   0000002C   0x....             LDR.N    R0,??DataTable13  ;; 0x50050000
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000034   0x....             LDR.N    R1,??DataTable13  ;; 0x50050000
   \   00000036   0x6008             STR      R0,[R1, #+0]
    233            }
    234          }
   \                     ??DCMI_CROPCmd_2: (+1)
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
    235          
    236          /**
    237            * @brief  Sets the embedded synchronization codes
    238            * @param  DCMI_CodesInitTypeDef: pointer to a DCMI_CodesInitTypeDef structure that
    239            *         contains the embedded synchronization codes for the DCMI peripheral.
    240            * @retval None
    241            */

   \                                 In section .text, align 2, keep-with-next
    242          void DCMI_SetEmbeddedSynchroCodes(DCMI_CodesInitTypeDef* DCMI_CodesInitStruct)
    243          {
    244            DCMI->ESCR = (uint32_t)(DCMI_CodesInitStruct->DCMI_FrameStartCode |
    245                                    ((uint32_t)DCMI_CodesInitStruct->DCMI_LineStartCode << 8)|
    246                                    ((uint32_t)DCMI_CodesInitStruct->DCMI_LineEndCode << 16)|
    247                                    ((uint32_t)DCMI_CodesInitStruct->DCMI_FrameEndCode << 24));
   \                     DCMI_SetEmbeddedSynchroCodes: (+1)
   \   00000000   0x7801             LDRB     R1,[R0, #+0]
   \   00000002   0x7842             LDRB     R2,[R0, #+1]
   \   00000004   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \   00000008   0x7882             LDRB     R2,[R0, #+2]
   \   0000000A   0xEA51 0x4102      ORRS     R1,R1,R2, LSL #+16
   \   0000000E   0x78C2             LDRB     R2,[R0, #+3]
   \   00000010   0xEA51 0x6102      ORRS     R1,R1,R2, LSL #+24
   \   00000014   0x....             LDR.N    R2,??DataTable13_3  ;; 0x50050018
   \   00000016   0x6011             STR      R1,[R2, #+0]
    248          }
   \   00000018   0x4770             BX       LR               ;; return
    249          
    250          /**
    251            * @brief  Enables or disables the DCMI JPEG format.
    252            * @note   The Crop and Embedded Synchronization features cannot be used in this mode.  
    253            * @param  NewState: new state of the DCMI JPEG format. 
    254            *          This parameter can be: ENABLE or DISABLE.
    255            * @retval None
    256            */

   \                                 In section .text, align 2, keep-with-next
    257          void DCMI_JPEGCmd(FunctionalState NewState)
    258          {
   \                     DCMI_JPEGCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    259            /* Check the parameters */
    260            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??DCMI_JPEGCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??DCMI_JPEGCmd_0
   \   00000010   0xF44F 0x7182      MOV      R1,#+260
   \   00000014   0x....             LDR.N    R0,??DataTable13_7
   \   00000016   0x.... 0x....      BL       assert_failed
    261           
    262            if (NewState != DISABLE)
   \                     ??DCMI_JPEGCmd_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD006             BEQ.N    ??DCMI_JPEGCmd_1
    263            {
    264              /* Enable the DCMI JPEG format */
    265              DCMI->CR |= (uint32_t)DCMI_CR_JPEG;
   \   00000020   0x....             LDR.N    R0,??DataTable13  ;; 0x50050000
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000028   0x....             LDR.N    R1,??DataTable13  ;; 0x50050000
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   \   0000002C   0xE005             B.N      ??DCMI_JPEGCmd_2
    266            }
    267            else
    268            {
    269              /* Disable the DCMI JPEG format */
    270              DCMI->CR &= ~(uint32_t)DCMI_CR_JPEG;
   \                     ??DCMI_JPEGCmd_1: (+1)
   \   0000002E   0x....             LDR.N    R0,??DataTable13  ;; 0x50050000
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xF030 0x0008      BICS     R0,R0,#0x8
   \   00000036   0x....             LDR.N    R1,??DataTable13  ;; 0x50050000
   \   00000038   0x6008             STR      R0,[R1, #+0]
    271            }
    272          }
   \                     ??DCMI_JPEGCmd_2: (+1)
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    273          /**
    274            * @}
    275            */
    276          
    277          /** @defgroup DCMI_Group2 Image capture functions
    278           *  @brief   Image capture functions
    279           *
    280          @verbatim   
    281           ===============================================================================
    282                                           Image capture functions
    283           ===============================================================================  
    284          
    285          @endverbatim
    286            * @{
    287            */
    288            
    289          /**
    290            * @brief  Enables or disables the DCMI interface.
    291            * @param  NewState: new state of the DCMI interface. 
    292            *          This parameter can be: ENABLE or DISABLE.
    293            * @retval None
    294            */

   \                                 In section .text, align 2, keep-with-next
    295          void DCMI_Cmd(FunctionalState NewState)
    296          {
   \                     DCMI_Cmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    297            /* Check the parameters */
    298            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??DCMI_Cmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??DCMI_Cmd_0
   \   00000010   0xF44F 0x7195      MOV      R1,#+298
   \   00000014   0x....             LDR.N    R0,??DataTable13_7
   \   00000016   0x.... 0x....      BL       assert_failed
    299            
    300            if (NewState != DISABLE)
   \                     ??DCMI_Cmd_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD006             BEQ.N    ??DCMI_Cmd_1
    301            {
    302              /* Enable the DCMI by setting ENABLE bit */
    303              DCMI->CR |= (uint32_t)DCMI_CR_ENABLE;
   \   00000020   0x....             LDR.N    R0,??DataTable13  ;; 0x50050000
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   00000028   0x....             LDR.N    R1,??DataTable13  ;; 0x50050000
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   \   0000002C   0xE005             B.N      ??DCMI_Cmd_2
    304            }
    305            else
    306            {
    307              /* Disable the DCMI by clearing ENABLE bit */
    308              DCMI->CR &= ~(uint32_t)DCMI_CR_ENABLE;
   \                     ??DCMI_Cmd_1: (+1)
   \   0000002E   0x....             LDR.N    R0,??DataTable13  ;; 0x50050000
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xF430 0x4080      BICS     R0,R0,#0x4000
   \   00000036   0x....             LDR.N    R1,??DataTable13  ;; 0x50050000
   \   00000038   0x6008             STR      R0,[R1, #+0]
    309            }
    310          }
   \                     ??DCMI_Cmd_2: (+1)
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    311          
    312          /**
    313            * @brief  Enables or disables the DCMI Capture.
    314            * @param  NewState: new state of the DCMI capture. 
    315            *          This parameter can be: ENABLE or DISABLE.
    316            * @retval None
    317            */

   \                                 In section .text, align 2, keep-with-next
    318          void DCMI_CaptureCmd(FunctionalState NewState)
    319          {
   \                     DCMI_CaptureCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    320            /* Check the parameters */
    321            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??DCMI_CaptureCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??DCMI_CaptureCmd_0
   \   00000010   0xF240 0x1141      MOVW     R1,#+321
   \   00000014   0x....             LDR.N    R0,??DataTable13_7
   \   00000016   0x.... 0x....      BL       assert_failed
    322              
    323            if (NewState != DISABLE)
   \                     ??DCMI_CaptureCmd_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD006             BEQ.N    ??DCMI_CaptureCmd_1
    324            {
    325              /* Enable the DCMI Capture */
    326              DCMI->CR |= (uint32_t)DCMI_CR_CAPTURE;
   \   00000020   0x....             LDR.N    R0,??DataTable13  ;; 0x50050000
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000028   0x....             LDR.N    R1,??DataTable13  ;; 0x50050000
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   \   0000002C   0xE005             B.N      ??DCMI_CaptureCmd_2
    327            }
    328            else
    329            {
    330              /* Disable the DCMI Capture */
    331              DCMI->CR &= ~(uint32_t)DCMI_CR_CAPTURE;
   \                     ??DCMI_CaptureCmd_1: (+1)
   \   0000002E   0x....             LDR.N    R0,??DataTable13  ;; 0x50050000
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x0840             LSRS     R0,R0,#+1
   \   00000034   0x0040             LSLS     R0,R0,#+1
   \   00000036   0x....             LDR.N    R1,??DataTable13  ;; 0x50050000
   \   00000038   0x6008             STR      R0,[R1, #+0]
    332            }
    333          }
   \                     ??DCMI_CaptureCmd_2: (+1)
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    334          
    335          /**
    336            * @brief  Reads the data stored in the DR register.
    337            * @param  None 
    338            * @retval Data register value
    339            */

   \                                 In section .text, align 2, keep-with-next
    340          uint32_t DCMI_ReadData(void)
    341          {
    342            return DCMI->DR;
   \                     DCMI_ReadData: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable13_10  ;; 0x50050028
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    343          }
    344          /**
    345            * @}
    346            */
    347          
    348          /** @defgroup DCMI_Group3 Interrupts and flags management functions
    349           *  @brief   Interrupts and flags management functions
    350           *
    351          @verbatim   
    352           ===============================================================================
    353                            Interrupts and flags management functions
    354           ===============================================================================  
    355          
    356          @endverbatim
    357            * @{
    358            */
    359          
    360          /**
    361            * @brief  Enables or disables the DCMI interface interrupts.
    362            * @param  DCMI_IT: specifies the DCMI interrupt sources to be enabled or disabled. 
    363            *          This parameter can be any combination of the following values:
    364            *            @arg DCMI_IT_FRAME: Frame capture complete interrupt mask
    365            *            @arg DCMI_IT_OVF: Overflow interrupt mask
    366            *            @arg DCMI_IT_ERR: Synchronization error interrupt mask
    367            *            @arg DCMI_IT_VSYNC: VSYNC interrupt mask
    368            *            @arg DCMI_IT_LINE: Line interrupt mask
    369            * @param  NewState: new state of the specified DCMI interrupts.
    370            *          This parameter can be: ENABLE or DISABLE.
    371            * @retval None
    372            */

   \                                 In section .text, align 2, keep-with-next
    373          void DCMI_ITConfig(uint16_t DCMI_IT, FunctionalState NewState)
    374          {
   \                     DCMI_ITConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    375            /* Check the parameters */
    376            assert_param(IS_DCMI_CONFIG_IT(DCMI_IT));
   \   00000006   0xF64F 0x70E0      MOVW     R0,#+65504
   \   0000000A   0x4204             TST      R4,R0
   \   0000000C   0xD102             BNE.N    ??DCMI_ITConfig_0
   \   0000000E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD104             BNE.N    ??DCMI_ITConfig_1
   \                     ??DCMI_ITConfig_0: (+1)
   \   00000014   0xF44F 0x71BC      MOV      R1,#+376
   \   00000018   0x....             LDR.N    R0,??DataTable13_7
   \   0000001A   0x.... 0x....      BL       assert_failed
    377            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??DCMI_ITConfig_1: (+1)
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD007             BEQ.N    ??DCMI_ITConfig_2
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D01             CMP      R5,#+1
   \   00000028   0xD004             BEQ.N    ??DCMI_ITConfig_2
   \   0000002A   0xF240 0x1179      MOVW     R1,#+377
   \   0000002E   0x....             LDR.N    R0,??DataTable13_7
   \   00000030   0x.... 0x....      BL       assert_failed
    378            
    379            if (NewState != DISABLE)
   \                     ??DCMI_ITConfig_2: (+1)
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0xD006             BEQ.N    ??DCMI_ITConfig_3
    380            {
    381              /* Enable the Interrupt sources */
    382              DCMI->IER |= DCMI_IT;
   \   0000003A   0x....             LDR.N    R0,??DataTable13_1  ;; 0x5005000c
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000040   0x4320             ORRS     R0,R4,R0
   \   00000042   0x....             LDR.N    R1,??DataTable13_1  ;; 0x5005000c
   \   00000044   0x6008             STR      R0,[R1, #+0]
   \   00000046   0xE006             B.N      ??DCMI_ITConfig_4
    383            }
    384            else
    385            {
    386              /* Disable the Interrupt sources */
    387              DCMI->IER &= (uint16_t)(~DCMI_IT);
   \                     ??DCMI_ITConfig_3: (+1)
   \   00000048   0x....             LDR.N    R0,??DataTable13_1  ;; 0x5005000c
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x43E1             MVNS     R1,R4
   \   0000004E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000050   0x4008             ANDS     R0,R1,R0
   \   00000052   0x....             LDR.N    R1,??DataTable13_1  ;; 0x5005000c
   \   00000054   0x6008             STR      R0,[R1, #+0]
    388            }  
    389          }
   \                     ??DCMI_ITConfig_4: (+1)
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    390          
    391          /**
    392            * @brief  Checks whether the  DCMI interface flag is set or not.
    393            * @param  DCMI_FLAG: specifies the flag to check.
    394            *          This parameter can be one of the following values:
    395            *            @arg DCMI_FLAG_FRAMERI: Frame capture complete Raw flag mask
    396            *            @arg DCMI_FLAG_OVFRI: Overflow Raw flag mask
    397            *            @arg DCMI_FLAG_ERRRI: Synchronization error Raw flag mask
    398            *            @arg DCMI_FLAG_VSYNCRI: VSYNC Raw flag mask
    399            *            @arg DCMI_FLAG_LINERI: Line Raw flag mask
    400            *            @arg DCMI_FLAG_FRAMEMI: Frame capture complete Masked flag mask
    401            *            @arg DCMI_FLAG_OVFMI: Overflow Masked flag mask
    402            *            @arg DCMI_FLAG_ERRMI: Synchronization error Masked flag mask
    403            *            @arg DCMI_FLAG_VSYNCMI: VSYNC Masked flag mask
    404            *            @arg DCMI_FLAG_LINEMI: Line Masked flag mask
    405            *            @arg DCMI_FLAG_HSYNC: HSYNC flag mask
    406            *            @arg DCMI_FLAG_VSYNC: VSYNC flag mask
    407            *            @arg DCMI_FLAG_FNE: Fifo not empty flag mask
    408            * @retval The new state of DCMI_FLAG (SET or RESET).
    409            */

   \                                 In section .text, align 2, keep-with-next
    410          FlagStatus DCMI_GetFlagStatus(uint16_t DCMI_FLAG)
    411          {
   \                     DCMI_GetFlagStatus: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    412            FlagStatus bitstatus = RESET;
   \   00000004   0x2500             MOVS     R5,#+0
    413            uint32_t dcmireg, tempreg = 0;
   \   00000006   0x2700             MOVS     R7,#+0
    414          
    415            /* Check the parameters */
    416            assert_param(IS_DCMI_GET_FLAG(DCMI_FLAG));
   \   00000008   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000000A   0xF242 0x0001      MOVW     R0,#+8193
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD036             BEQ.N    ??DCMI_GetFlagStatus_0
   \   00000012   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000014   0xF242 0x0002      MOVW     R0,#+8194
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD031             BEQ.N    ??DCMI_GetFlagStatus_0
   \   0000001C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000001E   0xF242 0x0004      MOVW     R0,#+8196
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD02C             BEQ.N    ??DCMI_GetFlagStatus_0
   \   00000026   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000028   0x2C01             CMP      R4,#+1
   \   0000002A   0xD029             BEQ.N    ??DCMI_GetFlagStatus_0
   \   0000002C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000002E   0x2C02             CMP      R4,#+2
   \   00000030   0xD026             BEQ.N    ??DCMI_GetFlagStatus_0
   \   00000032   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000034   0x2C04             CMP      R4,#+4
   \   00000036   0xD023             BEQ.N    ??DCMI_GetFlagStatus_0
   \   00000038   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000003A   0x2C08             CMP      R4,#+8
   \   0000003C   0xD020             BEQ.N    ??DCMI_GetFlagStatus_0
   \   0000003E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000040   0x2C10             CMP      R4,#+16
   \   00000042   0xD01D             BEQ.N    ??DCMI_GetFlagStatus_0
   \   00000044   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000046   0xF241 0x0001      MOVW     R0,#+4097
   \   0000004A   0x4284             CMP      R4,R0
   \   0000004C   0xD018             BEQ.N    ??DCMI_GetFlagStatus_0
   \   0000004E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000050   0xF241 0x0002      MOVW     R0,#+4098
   \   00000054   0x4284             CMP      R4,R0
   \   00000056   0xD013             BEQ.N    ??DCMI_GetFlagStatus_0
   \   00000058   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000005A   0xF241 0x0004      MOVW     R0,#+4100
   \   0000005E   0x4284             CMP      R4,R0
   \   00000060   0xD00E             BEQ.N    ??DCMI_GetFlagStatus_0
   \   00000062   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000064   0xF241 0x0008      MOVW     R0,#+4104
   \   00000068   0x4284             CMP      R4,R0
   \   0000006A   0xD009             BEQ.N    ??DCMI_GetFlagStatus_0
   \   0000006C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000006E   0xF241 0x0010      MOVW     R0,#+4112
   \   00000072   0x4284             CMP      R4,R0
   \   00000074   0xD004             BEQ.N    ??DCMI_GetFlagStatus_0
   \   00000076   0xF44F 0x71D0      MOV      R1,#+416
   \   0000007A   0x....             LDR.N    R0,??DataTable13_7
   \   0000007C   0x.... 0x....      BL       assert_failed
    417            
    418            /* Get the DCMI register index */
    419            dcmireg = (((uint16_t)DCMI_FLAG) >> 12);
   \                     ??DCMI_GetFlagStatus_0: (+1)
   \   00000080   0x0020             MOVS     R0,R4
   \   00000082   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000084   0x0B00             LSRS     R0,R0,#+12
   \   00000086   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000088   0x0006             MOVS     R6,R0
    420            
    421            if (dcmireg == 0x01) /* The FLAG is in RISR register */
   \   0000008A   0x2E01             CMP      R6,#+1
   \   0000008C   0xD103             BNE.N    ??DCMI_GetFlagStatus_1
    422            {
    423              tempreg= DCMI->RISR;
   \   0000008E   0x....             LDR.N    R0,??DataTable13_11  ;; 0x50050008
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0x0007             MOVS     R7,R0
   \   00000094   0xE008             B.N      ??DCMI_GetFlagStatus_2
    424            }
    425            else if (dcmireg == 0x02) /* The FLAG is in SR register */
   \                     ??DCMI_GetFlagStatus_1: (+1)
   \   00000096   0x2E02             CMP      R6,#+2
   \   00000098   0xD103             BNE.N    ??DCMI_GetFlagStatus_3
    426            {
    427              tempreg = DCMI->SR;
   \   0000009A   0x....             LDR.N    R0,??DataTable13_12  ;; 0x50050004
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0x0007             MOVS     R7,R0
   \   000000A0   0xE002             B.N      ??DCMI_GetFlagStatus_2
    428            }
    429            else /* The FLAG is in MISR register */
    430            {
    431              tempreg = DCMI->MISR;
   \                     ??DCMI_GetFlagStatus_3: (+1)
   \   000000A2   0x....             LDR.N    R0,??DataTable13_13  ;; 0x50050010
   \   000000A4   0x6800             LDR      R0,[R0, #+0]
   \   000000A6   0x0007             MOVS     R7,R0
    432            }
    433            
    434            if ((tempreg & DCMI_FLAG) != (uint16_t)RESET )
   \                     ??DCMI_GetFlagStatus_2: (+1)
   \   000000A8   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000AA   0x4227             TST      R7,R4
   \   000000AC   0xD002             BEQ.N    ??DCMI_GetFlagStatus_4
    435            {
    436              bitstatus = SET;
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0x0005             MOVS     R5,R0
   \   000000B2   0xE001             B.N      ??DCMI_GetFlagStatus_5
    437            }
    438            else
    439            {
    440              bitstatus = RESET;
   \                     ??DCMI_GetFlagStatus_4: (+1)
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x0005             MOVS     R5,R0
    441            }
    442            /* Return the DCMI_FLAG status */
    443            return  bitstatus;
   \                     ??DCMI_GetFlagStatus_5: (+1)
   \   000000B8   0x0028             MOVS     R0,R5
   \   000000BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BC   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    444          }
    445          
    446          /**
    447            * @brief  Clears the DCMI's pending flags.
    448            * @param  DCMI_FLAG: specifies the flag to clear.
    449            *          This parameter can be any combination of the following values:
    450            *            @arg DCMI_FLAG_FRAMERI: Frame capture complete Raw flag mask
    451            *            @arg DCMI_FLAG_OVFRI: Overflow Raw flag mask
    452            *            @arg DCMI_FLAG_ERRRI: Synchronization error Raw flag mask
    453            *            @arg DCMI_FLAG_VSYNCRI: VSYNC Raw flag mask
    454            *            @arg DCMI_FLAG_LINERI: Line Raw flag mask
    455            * @retval None
    456            */

   \                                 In section .text, align 2, keep-with-next
    457          void DCMI_ClearFlag(uint16_t DCMI_FLAG)
    458          {
   \                     DCMI_ClearFlag: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    459            /* Check the parameters */
    460            assert_param(IS_DCMI_CLEAR_FLAG(DCMI_FLAG));
   \   00000004   0xF64F 0x70E0      MOVW     R0,#+65504
   \   00000008   0x4204             TST      R4,R0
   \   0000000A   0xD102             BNE.N    ??DCMI_ClearFlag_0
   \   0000000C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD104             BNE.N    ??DCMI_ClearFlag_1
   \                     ??DCMI_ClearFlag_0: (+1)
   \   00000012   0xF44F 0x71E6      MOV      R1,#+460
   \   00000016   0x....             LDR.N    R0,??DataTable13_7
   \   00000018   0x.... 0x....      BL       assert_failed
    461            
    462            /* Clear the flag by writing in the ICR register 1 in the corresponding 
    463            Flag position*/
    464            
    465            DCMI->ICR = DCMI_FLAG;
   \                     ??DCMI_ClearFlag_1: (+1)
   \   0000001C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000001E   0x....             LDR.N    R0,??DataTable13_2  ;; 0x50050014
   \   00000020   0x6004             STR      R4,[R0, #+0]
    466          }
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    467          
    468          /**
    469            * @brief  Checks whether the DCMI interrupt has occurred or not.
    470            * @param  DCMI_IT: specifies the DCMI interrupt source to check.
    471            *          This parameter can be one of the following values:
    472            *            @arg DCMI_IT_FRAME: Frame capture complete interrupt mask
    473            *            @arg DCMI_IT_OVF: Overflow interrupt mask
    474            *            @arg DCMI_IT_ERR: Synchronization error interrupt mask
    475            *            @arg DCMI_IT_VSYNC: VSYNC interrupt mask
    476            *            @arg DCMI_IT_LINE: Line interrupt mask
    477            * @retval The new state of DCMI_IT (SET or RESET).
    478            */

   \                                 In section .text, align 2, keep-with-next
    479          ITStatus DCMI_GetITStatus(uint16_t DCMI_IT)
    480          {
   \                     DCMI_GetITStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    481            ITStatus bitstatus = RESET;
   \   00000004   0x2500             MOVS     R5,#+0
    482            uint32_t itstatus = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    483            
    484            /* Check the parameters */
    485            assert_param(IS_DCMI_GET_IT(DCMI_IT));
   \   00000008   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000000A   0x2C01             CMP      R4,#+1
   \   0000000C   0xD010             BEQ.N    ??DCMI_GetITStatus_0
   \   0000000E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000010   0x2C02             CMP      R4,#+2
   \   00000012   0xD00D             BEQ.N    ??DCMI_GetITStatus_0
   \   00000014   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000016   0x2C04             CMP      R4,#+4
   \   00000018   0xD00A             BEQ.N    ??DCMI_GetITStatus_0
   \   0000001A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000001C   0x2C08             CMP      R4,#+8
   \   0000001E   0xD007             BEQ.N    ??DCMI_GetITStatus_0
   \   00000020   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000022   0x2C10             CMP      R4,#+16
   \   00000024   0xD004             BEQ.N    ??DCMI_GetITStatus_0
   \   00000026   0xF240 0x11E5      MOVW     R1,#+485
   \   0000002A   0x....             LDR.N    R0,??DataTable13_7
   \   0000002C   0x.... 0x....      BL       assert_failed
    486            
    487            itstatus = DCMI->MISR & DCMI_IT; /* Only masked interrupts are checked */
   \                     ??DCMI_GetITStatus_0: (+1)
   \   00000030   0x....             LDR.N    R0,??DataTable13_13  ;; 0x50050010
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000036   0x4020             ANDS     R0,R4,R0
   \   00000038   0x0006             MOVS     R6,R0
    488            
    489            if ((itstatus != (uint16_t)RESET))
   \   0000003A   0x2E00             CMP      R6,#+0
   \   0000003C   0xD002             BEQ.N    ??DCMI_GetITStatus_1
    490            {
    491              bitstatus = SET;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x0005             MOVS     R5,R0
   \   00000042   0xE001             B.N      ??DCMI_GetITStatus_2
    492            }
    493            else
    494            {
    495              bitstatus = RESET;
   \                     ??DCMI_GetITStatus_1: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x0005             MOVS     R5,R0
    496            }
    497            return bitstatus;
   \                     ??DCMI_GetITStatus_2: (+1)
   \   00000048   0x0028             MOVS     R0,R5
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0xBD70             POP      {R4-R6,PC}       ;; return
    498          }
    499          
    500          /**
    501            * @brief  Clears the DCMI's interrupt pending bits.
    502            * @param  DCMI_IT: specifies the DCMI interrupt pending bit to clear.
    503            *          This parameter can be any combination of the following values:
    504            *            @arg DCMI_IT_FRAME: Frame capture complete interrupt mask
    505            *            @arg DCMI_IT_OVF: Overflow interrupt mask
    506            *            @arg DCMI_IT_ERR: Synchronization error interrupt mask
    507            *            @arg DCMI_IT_VSYNC: VSYNC interrupt mask
    508            *            @arg DCMI_IT_LINE: Line interrupt mask
    509            * @retval None
    510            */

   \                                 In section .text, align 2, keep-with-next
    511          void DCMI_ClearITPendingBit(uint16_t DCMI_IT)
    512          {
    513            /* Clear the interrupt pending Bit by writing in the ICR register 1 in the 
    514            corresponding pending Bit position*/
    515            
    516            DCMI->ICR = DCMI_IT;
   \                     DCMI_ClearITPendingBit: (+1)
   \   00000000   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000002   0x....             LDR.N    R1,??DataTable13_2  ;; 0x50050014
   \   00000004   0x6008             STR      R0,[R1, #+0]
    517          }
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x50050000         DC32     0x50050000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x5005000C         DC32     0x5005000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x50050014         DC32     0x50050014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x50050018         DC32     0x50050018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x5005001C         DC32     0x5005001c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x50050020         DC32     0x50050020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x50050024         DC32     0x50050024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0xFFFFBFFE         DC32     0xffffbffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   0xFFFFF00D         DC32     0xfffff00d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \   00000000   0x50050028         DC32     0x50050028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \   00000000   0x50050008         DC32     0x50050008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_12:
   \   00000000   0x50050004         DC32     0x50050004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_13:
   \   00000000   0x50050010         DC32     0x50050010

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 49H, 41H, 52H, 20H, 57H
   \              0x5C 0x49    
   \              0x41 0x52    
   \              0x20 0x57    
   \   00000008   0x6F 0x72          DC8 6FH, 72H, 6BH, 73H, 70H, 61H, 63H, 65H
   \              0x6B 0x73    
   \              0x70 0x61    
   \              0x63 0x65    
   \   00000010   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 46H, 34H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x46 0x34    
   \   00000018   0x30 0x37          DC8 30H, 37H, 5CH, 53H, 54H, 4DH, 33H, 32H
   \              0x5C 0x53    
   \              0x54 0x4D    
   \              0x33 0x32    
   \   00000020   0x46 0x34          DC8 46H, 34H, 2DH, 44H, 69H, 73H, 63H, 6FH
   \              0x2D 0x44    
   \              0x69 0x73    
   \              0x63 0x6F    
   \   00000028   0x76 0x65          DC8 76H, 65H, 72H, 79H, 5FH, 46H, 57H, 5FH
   \              0x72 0x79    
   \              0x5F 0x46    
   \              0x57 0x5F    
   \   00000030   0x56 0x31          DC8 56H, 31H, 2EH, 31H, 2EH, 30H, 5CH, 4CH
   \              0x2E 0x31    
   \              0x2E 0x30    
   \              0x5C 0x4C    
   \   00000038   0x69 0x62          DC8 69H, 62H, 72H, 61H, 72H, 69H, 65H, 73H
   \              0x72 0x61    
   \              0x72 0x69    
   \              0x65 0x73    
   \   00000040   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 46H, 34H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x46 0x34    
   \   00000048   0x78 0x78          DC8 78H, 78H, 5FH, 53H, 74H, 64H, 50H, 65H
   \              0x5F 0x53    
   \              0x74 0x64    
   \              0x50 0x65    
   \   00000050   0x72 0x69          DC8 72H, 69H, 70H, 68H, 5FH, 44H, 72H, 69H
   \              0x70 0x68    
   \              0x5F 0x44    
   \              0x72 0x69    
   \   00000058   0x76 0x65          DC8 76H, 65H, 72H, 5CH, 73H, 72H, 63H, 5CH
   \              0x72 0x5C    
   \              0x73 0x72    
   \              0x63 0x5C    
   \   00000060   0x73 0x74          DC8 73H, 74H, 6DH, 33H, 32H, 66H, 34H, 78H
   \              0x6D 0x33    
   \              0x32 0x66    
   \              0x34 0x78    
   \   00000068   0x78 0x5F          DC8 78H, 5FH, 64H, 63H, 6DH, 69H, 2EH, 63H
   \              0x64 0x63    
   \              0x6D 0x69    
   \              0x2E 0x63    
   \   00000070   0x00               DC8 0
   \   00000071   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    518          /**
    519            * @}
    520            */ 
    521          
    522          /**
    523            * @}
    524            */ 
    525          
    526          /**
    527            * @}
    528            */ 
    529          
    530          /**
    531            * @}
    532            */ 
    533          
    534          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   DCMI_CROPCmd
         8   -> assert_failed
       0   DCMI_CROPConfig
       8   DCMI_CaptureCmd
         8   -> assert_failed
       8   DCMI_ClearFlag
         8   -> assert_failed
       0   DCMI_ClearITPendingBit
       8   DCMI_Cmd
         8   -> assert_failed
       0   DCMI_DeInit
      24   DCMI_GetFlagStatus
        24   -> assert_failed
      16   DCMI_GetITStatus
        16   -> assert_failed
      16   DCMI_ITConfig
        16   -> assert_failed
      16   DCMI_Init
        16   -> assert_failed
       8   DCMI_JPEGCmd
         8   -> assert_failed
       0   DCMI_ReadData
       0   DCMI_SetEmbeddedSynchroCodes
       0   DCMI_StructInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_13
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
     116  ?_0
      58  DCMI_CROPCmd
      26  DCMI_CROPConfig
      60  DCMI_CaptureCmd
      36  DCMI_ClearFlag
       8  DCMI_ClearITPendingBit
      60  DCMI_Cmd
      58  DCMI_DeInit
     190  DCMI_GetFlagStatus
      78  DCMI_GetITStatus
      88  DCMI_ITConfig
     246  DCMI_Init
      60  DCMI_JPEGCmd
       6  DCMI_ReadData
      26  DCMI_SetEmbeddedSynchroCodes
      30  DCMI_StructInit

 
   116 bytes in section .rodata
 1 086 bytes in section .text
 
 1 086 bytes of CODE  memory
   116 bytes of CONST memory

Errors: none
Warnings: none
