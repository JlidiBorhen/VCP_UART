###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       06/May/2016  23:31:35
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\IAR
#        Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_sdio.c
#    Command line =  
#        "D:\IAR
#        Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_sdio.c"
#        -D USE_STDPERIPH_DRIVER -D STM32F4XX -D USE_FULL_ASSERT -lCN "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\List" -o "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\Obj" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\Include\" -I
#        "D:\IAR Workspace\STM32F407\VCP_ESP\..\Utilities\STM32F4-Discovery\"
#        -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\ST\STM32F4xx\Include\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_conf\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\cdc\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\otg\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\core\" -On --use_c++_inline -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    List file    =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\Debug\List\stm32f4xx_sdio.lst
#    Object file  =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\Debug\Obj\stm32f4xx_sdio.o
#
###############################################################################

D:\IAR Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_sdio.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_sdio.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    30-September-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Secure digital input/output interface (SDIO) 
      9            *          peripheral:
     10            *           - Initialization and Configuration
     11            *           - Command path state machine (CPSM) management
     12            *           - Data path state machine (DPSM) management
     13            *           - SDIO IO Cards mode management
     14            *           - CE-ATA mode management
     15            *           - DMA transfers management
     16            *           - Interrupts and flags management
     17            *
     18            *  @verbatim
     19            *
     20            *
     21            *          ===================================================================
     22            *                                 How to use this driver
     23            *          ===================================================================
     24            *          1. The SDIO clock (SDIOCLK = 48 MHz) is coming from a specific output
     25            *             of PLL (PLL48CLK). Before to start working with SDIO peripheral
     26            *             make sure that the PLL is well configured.
     27            *          The SDIO peripheral uses two clock signals:
     28            *              - SDIO adapter clock (SDIOCLK = 48 MHz)
     29            *              - APB2 bus clock (PCLK2)
     30            *          PCLK2 and SDIO_CK clock frequencies must respect the following condition:
     31            *                   Frequenc(PCLK2) >= (3 / 8 x Frequency(SDIO_CK))
     32            *
     33            *          2. Enable peripheral clock using RCC_APB2PeriphClockCmd(RCC_APB2Periph_SDIO, ENABLE).
     34            *
     35            *          3.  According to the SDIO mode, enable the GPIO clocks using 
     36            *              RCC_AHB1PeriphClockCmd() function. 
     37            *              The I/O can be one of the following configurations:
     38            *                 - 1-bit data length: SDIO_CMD, SDIO_CK and D0.
     39            *                 - 4-bit data length: SDIO_CMD, SDIO_CK and D[3:0].
     40            *                 - 8-bit data length: SDIO_CMD, SDIO_CK and D[7:0].      
     41            *
     42            *          4. Peripheral's alternate function: 
     43            *                 - Connect the pin to the desired peripherals' Alternate 
     44            *                   Function (AF) using GPIO_PinAFConfig() function
     45            *                 - Configure the desired pin in alternate function by:
     46            *                   GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     47            *                 - Select the type, pull-up/pull-down and output speed via 
     48            *                   GPIO_PuPd, GPIO_OType and GPIO_Speed members
     49            *                 - Call GPIO_Init() function
     50            *
     51            *          5. Program the Clock Edge, Clock Bypass, Clock Power Save, Bus Wide, 
     52            *             hardware, flow control and the Clock Divider using the SDIO_Init()
     53            *             function.
     54            *
     55            *          6. Enable the Power ON State using the SDIO_SetPowerState(SDIO_PowerState_ON) 
     56            *             function.
     57            *              
     58            *          7. Enable the clock using the SDIO_ClockCmd() function.
     59            *
     60            *          8. Enable the NVIC and the corresponding interrupt using the function 
     61            *             SDIO_ITConfig() if you need to use interrupt mode. 
     62            *
     63            *          9. When using the DMA mode 
     64            *                   - Configure the DMA using DMA_Init() function
     65            *                   - Active the needed channel Request using SDIO_DMACmd() function
     66            *
     67            *          10. Enable the DMA using the DMA_Cmd() function, when using DMA mode. 
     68            *
     69            *          11. To control the CPSM (Command Path State Machine) and send 
     70            *              commands to the card use the SDIO_SendCommand(), 
     71            *              SDIO_GetCommandResponse() and SDIO_GetResponse() functions.     
     72            *              First, user has to fill the command structure (pointer to
     73            *              SDIO_CmdInitTypeDef) according to the selected command to be sent.
     74            *                 The parameters that should be filled are:
     75            *                   - Command Argument
     76            *                   - Command Index
     77            *                   - Command Response type
     78            *                   - Command Wait
     79            *                   - CPSM Status (Enable or Disable)
     80            *
     81            *              To check if the command is well received, read the SDIO_CMDRESP
     82            *              register using the SDIO_GetCommandResponse().
     83            *              The SDIO responses registers (SDIO_RESP1 to SDIO_RESP2), use the
     84            *              SDIO_GetResponse() function.
     85            *
     86            *          12. To control the DPSM (Data Path State Machine) and send/receive 
     87            *              data to/from the card use the SDIO_DataConfig(), SDIO_GetDataCounter(), 
     88            *              SDIO_ReadData(), SDIO_WriteData() and SDIO_GetFIFOCount() functions.
     89            *
     90            *              Read Operations
     91            *              ---------------
     92            *              a) First, user has to fill the data structure (pointer to
     93            *                 SDIO_DataInitTypeDef) according to the selected data type to
     94            *                 be received.
     95            *                 The parameters that should be filled are:
     96            *                   - Data TimeOut
     97            *                   - Data Length
     98            *                   - Data Block size
     99            *                   - Data Transfer direction: should be from card (To SDIO)
    100            *                   - Data Transfer mode
    101            *                   - DPSM Status (Enable or Disable)
    102            *                                   
    103            *              b) Configure the SDIO resources to receive the data from the card
    104            *                 according to selected transfer mode (Refer to Step 8, 9 and 10).
    105            *
    106            *              c) Send the selected Read command (refer to step 11).
    107            *                  
    108            *              d) Use the SDIO flags/interrupts to check the transfer status.
    109            *
    110            *              Write Operations
    111            *              ---------------
    112            *              a) First, user has to fill the data structure (pointer to
    113            *                 SDIO_DataInitTypeDef) according to the selected data type to
    114            *                 be received.
    115            *                 The parameters that should be filled are:
    116            *                   - Data TimeOut
    117            *                   - Data Length
    118            *                   - Data Block size
    119            *                   - Data Transfer direction:  should be to card (To CARD)
    120            *                   - Data Transfer mode
    121            *                   - DPSM Status (Enable or Disable)
    122            *
    123            *              b) Configure the SDIO resources to send the data to the card
    124            *                 according to selected transfer mode (Refer to Step 8, 9 and 10).
    125            *                   
    126            *              c) Send the selected Write command (refer to step 11).
    127            *                  
    128            *              d) Use the SDIO flags/interrupts to check the transfer status.
    129            *
    130            *
    131            *  @endverbatim
    132            *
    133            *
    134            ******************************************************************************
    135            * @attention
    136            *
    137            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
    138            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
    139            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
    140            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
    141            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
    142            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
    143            *
    144            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
    145            ******************************************************************************
    146            */
    147          
    148          /* Includes ------------------------------------------------------------------*/
    149          #include "stm32f4xx_sdio.h"
    150          #include "stm32f4xx_rcc.h"
    151          
    152          /** @addtogroup STM32F4xx_StdPeriph_Driver
    153            * @{
    154            */
    155          
    156          /** @defgroup SDIO 
    157            * @brief SDIO driver modules
    158            * @{
    159            */ 
    160          
    161          /* Private typedef -----------------------------------------------------------*/
    162          /* Private define ------------------------------------------------------------*/
    163          
    164          /* ------------ SDIO registers bit address in the alias region ----------- */
    165          #define SDIO_OFFSET                (SDIO_BASE - PERIPH_BASE)
    166          
    167          /* --- CLKCR Register ---*/
    168          /* Alias word address of CLKEN bit */
    169          #define CLKCR_OFFSET              (SDIO_OFFSET + 0x04)
    170          #define CLKEN_BitNumber           0x08
    171          #define CLKCR_CLKEN_BB            (PERIPH_BB_BASE + (CLKCR_OFFSET * 32) + (CLKEN_BitNumber * 4))
    172          
    173          /* --- CMD Register ---*/
    174          /* Alias word address of SDIOSUSPEND bit */
    175          #define CMD_OFFSET                (SDIO_OFFSET + 0x0C)
    176          #define SDIOSUSPEND_BitNumber     0x0B
    177          #define CMD_SDIOSUSPEND_BB        (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (SDIOSUSPEND_BitNumber * 4))
    178          
    179          /* Alias word address of ENCMDCOMPL bit */
    180          #define ENCMDCOMPL_BitNumber      0x0C
    181          #define CMD_ENCMDCOMPL_BB         (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (ENCMDCOMPL_BitNumber * 4))
    182          
    183          /* Alias word address of NIEN bit */
    184          #define NIEN_BitNumber            0x0D
    185          #define CMD_NIEN_BB               (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (NIEN_BitNumber * 4))
    186          
    187          /* Alias word address of ATACMD bit */
    188          #define ATACMD_BitNumber          0x0E
    189          #define CMD_ATACMD_BB             (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (ATACMD_BitNumber * 4))
    190          
    191          /* --- DCTRL Register ---*/
    192          /* Alias word address of DMAEN bit */
    193          #define DCTRL_OFFSET              (SDIO_OFFSET + 0x2C)
    194          #define DMAEN_BitNumber           0x03
    195          #define DCTRL_DMAEN_BB            (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (DMAEN_BitNumber * 4))
    196          
    197          /* Alias word address of RWSTART bit */
    198          #define RWSTART_BitNumber         0x08
    199          #define DCTRL_RWSTART_BB          (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWSTART_BitNumber * 4))
    200          
    201          /* Alias word address of RWSTOP bit */
    202          #define RWSTOP_BitNumber          0x09
    203          #define DCTRL_RWSTOP_BB           (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWSTOP_BitNumber * 4))
    204          
    205          /* Alias word address of RWMOD bit */
    206          #define RWMOD_BitNumber           0x0A
    207          #define DCTRL_RWMOD_BB            (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWMOD_BitNumber * 4))
    208          
    209          /* Alias word address of SDIOEN bit */
    210          #define SDIOEN_BitNumber          0x0B
    211          #define DCTRL_SDIOEN_BB           (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (SDIOEN_BitNumber * 4))
    212          
    213          /* ---------------------- SDIO registers bit mask ------------------------ */
    214          /* --- CLKCR Register ---*/
    215          /* CLKCR register clear mask */
    216          #define CLKCR_CLEAR_MASK         ((uint32_t)0xFFFF8100) 
    217          
    218          /* --- PWRCTRL Register ---*/
    219          /* SDIO PWRCTRL Mask */
    220          #define PWR_PWRCTRL_MASK         ((uint32_t)0xFFFFFFFC)
    221          
    222          /* --- DCTRL Register ---*/
    223          /* SDIO DCTRL Clear Mask */
    224          #define DCTRL_CLEAR_MASK         ((uint32_t)0xFFFFFF08)
    225          
    226          /* --- CMD Register ---*/
    227          /* CMD Register clear mask */
    228          #define CMD_CLEAR_MASK           ((uint32_t)0xFFFFF800)
    229          
    230          /* SDIO RESP Registers Address */
    231          #define SDIO_RESP_ADDR           ((uint32_t)(SDIO_BASE + 0x14))
    232          
    233          /* Private macro -------------------------------------------------------------*/
    234          /* Private variables ---------------------------------------------------------*/
    235          /* Private function prototypes -----------------------------------------------*/
    236          /* Private functions ---------------------------------------------------------*/
    237          
    238          /** @defgroup SDIO_Private_Functions
    239            * @{
    240            */
    241          
    242          /** @defgroup SDIO_Group1 Initialization and Configuration functions
    243           *  @brief   Initialization and Configuration functions 
    244           *
    245          @verbatim   
    246           ===============================================================================
    247                           Initialization and Configuration functions
    248           ===============================================================================
    249          
    250          @endverbatim
    251            * @{
    252            */
    253          
    254          /**
    255            * @brief  Deinitializes the SDIO peripheral registers to their default reset values.
    256            * @param  None
    257            * @retval None
    258            */

   \                                 In section .text, align 2, keep-with-next
    259          void SDIO_DeInit(void)
    260          {
   \                     SDIO_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    261            RCC_APB2PeriphResetCmd(RCC_APB2Periph_SDIO, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0xF44F 0x6000      MOV      R0,#+2048
   \   00000008   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    262            RCC_APB2PeriphResetCmd(RCC_APB2Periph_SDIO, DISABLE);
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xF44F 0x6000      MOV      R0,#+2048
   \   00000012   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    263          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    264          
    265          /**
    266            * @brief  Initializes the SDIO peripheral according to the specified 
    267            *         parameters in the SDIO_InitStruct.
    268            * @param  SDIO_InitStruct : pointer to a SDIO_InitTypeDef structure 
    269            *         that contains the configuration information for the SDIO peripheral.
    270            * @retval None
    271            */

   \                                 In section .text, align 2, keep-with-next
    272          void SDIO_Init(SDIO_InitTypeDef* SDIO_InitStruct)
    273          {
   \                     SDIO_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    274            uint32_t tmpreg = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    275              
    276            /* Check the parameters */
    277            assert_param(IS_SDIO_CLOCK_EDGE(SDIO_InitStruct->SDIO_ClockEdge));
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD009             BEQ.N    ??SDIO_Init_0
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000012   0xD005             BEQ.N    ??SDIO_Init_0
   \   00000014   0xF240 0x1115      MOVW     R1,#+277
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable25
   \   0000001C   0x.... 0x....      BL       assert_failed
    278            assert_param(IS_SDIO_CLOCK_BYPASS(SDIO_InitStruct->SDIO_ClockBypass));
   \                     ??SDIO_Init_0: (+1)
   \   00000020   0x6860             LDR      R0,[R4, #+4]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD009             BEQ.N    ??SDIO_Init_1
   \   00000026   0x6860             LDR      R0,[R4, #+4]
   \   00000028   0xF5B0 0x6F80      CMP      R0,#+1024
   \   0000002C   0xD005             BEQ.N    ??SDIO_Init_1
   \   0000002E   0xF44F 0x718B      MOV      R1,#+278
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000036   0x.... 0x....      BL       assert_failed
    279            assert_param(IS_SDIO_CLOCK_POWER_SAVE(SDIO_InitStruct->SDIO_ClockPowerSave));
   \                     ??SDIO_Init_1: (+1)
   \   0000003A   0x68A0             LDR      R0,[R4, #+8]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD009             BEQ.N    ??SDIO_Init_2
   \   00000040   0x68A0             LDR      R0,[R4, #+8]
   \   00000042   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000046   0xD005             BEQ.N    ??SDIO_Init_2
   \   00000048   0xF240 0x1117      MOVW     R1,#+279
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000050   0x.... 0x....      BL       assert_failed
    280            assert_param(IS_SDIO_BUS_WIDE(SDIO_InitStruct->SDIO_BusWide));
   \                     ??SDIO_Init_2: (+1)
   \   00000054   0x68E0             LDR      R0,[R4, #+12]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD00D             BEQ.N    ??SDIO_Init_3
   \   0000005A   0x68E0             LDR      R0,[R4, #+12]
   \   0000005C   0xF5B0 0x6F00      CMP      R0,#+2048
   \   00000060   0xD009             BEQ.N    ??SDIO_Init_3
   \   00000062   0x68E0             LDR      R0,[R4, #+12]
   \   00000064   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000068   0xD005             BEQ.N    ??SDIO_Init_3
   \   0000006A   0xF44F 0x718C      MOV      R1,#+280
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000072   0x.... 0x....      BL       assert_failed
    281            assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(SDIO_InitStruct->SDIO_HardwareFlowControl)); 
   \                     ??SDIO_Init_3: (+1)
   \   00000076   0x6920             LDR      R0,[R4, #+16]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD009             BEQ.N    ??SDIO_Init_4
   \   0000007C   0x6920             LDR      R0,[R4, #+16]
   \   0000007E   0xF5B0 0x4F80      CMP      R0,#+16384
   \   00000082   0xD005             BEQ.N    ??SDIO_Init_4
   \   00000084   0xF240 0x1119      MOVW     R1,#+281
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable25
   \   0000008C   0x.... 0x....      BL       assert_failed
    282             
    283          /*---------------------------- SDIO CLKCR Configuration ------------------------*/  
    284            /* Get the SDIO CLKCR value */
    285            tmpreg = SDIO->CLKCR;
   \                     ??SDIO_Init_4: (+1)
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable25_1  ;; 0x40012c04
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0x0005             MOVS     R5,R0
    286            
    287            /* Clear CLKDIV, PWRSAV, BYPASS, WIDBUS, NEGEDGE, HWFC_EN bits */
    288            tmpreg &= CLKCR_CLEAR_MASK;
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable25_2  ;; 0xffff8100
   \   0000009C   0x4005             ANDS     R5,R0,R5
    289            
    290            /* Set CLKDIV bits according to SDIO_ClockDiv value */
    291            /* Set PWRSAV bit according to SDIO_ClockPowerSave value */
    292            /* Set BYPASS bit according to SDIO_ClockBypass value */
    293            /* Set WIDBUS bits according to SDIO_BusWide value */
    294            /* Set NEGEDGE bits according to SDIO_ClockEdge value */
    295            /* Set HWFC_EN bits according to SDIO_HardwareFlowControl value */
    296            tmpreg |= (SDIO_InitStruct->SDIO_ClockDiv  | SDIO_InitStruct->SDIO_ClockPowerSave |
    297                       SDIO_InitStruct->SDIO_ClockBypass | SDIO_InitStruct->SDIO_BusWide |
    298                       SDIO_InitStruct->SDIO_ClockEdge | SDIO_InitStruct->SDIO_HardwareFlowControl); 
   \   0000009E   0x7D20             LDRB     R0,[R4, #+20]
   \   000000A0   0x68A1             LDR      R1,[R4, #+8]
   \   000000A2   0x4308             ORRS     R0,R1,R0
   \   000000A4   0x6861             LDR      R1,[R4, #+4]
   \   000000A6   0x4308             ORRS     R0,R1,R0
   \   000000A8   0x68E1             LDR      R1,[R4, #+12]
   \   000000AA   0x4308             ORRS     R0,R1,R0
   \   000000AC   0x6821             LDR      R1,[R4, #+0]
   \   000000AE   0x4308             ORRS     R0,R1,R0
   \   000000B0   0x6921             LDR      R1,[R4, #+16]
   \   000000B2   0x4308             ORRS     R0,R1,R0
   \   000000B4   0x4305             ORRS     R5,R0,R5
    299            
    300            /* Write to SDIO CLKCR */
    301            SDIO->CLKCR = tmpreg;
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable25_1  ;; 0x40012c04
   \   000000BA   0x6005             STR      R5,[R0, #+0]
    302          }
   \   000000BC   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    303          
    304          /**
    305            * @brief  Fills each SDIO_InitStruct member with its default value.
    306            * @param  SDIO_InitStruct: pointer to an SDIO_InitTypeDef structure which 
    307            *         will be initialized.
    308            * @retval None
    309            */

   \                                 In section .text, align 2, keep-with-next
    310          void SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct)
    311          {
    312            /* SDIO_InitStruct members default value */
    313            SDIO_InitStruct->SDIO_ClockDiv = 0x00;
   \                     SDIO_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7501             STRB     R1,[R0, #+20]
    314            SDIO_InitStruct->SDIO_ClockEdge = SDIO_ClockEdge_Rising;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6001             STR      R1,[R0, #+0]
    315            SDIO_InitStruct->SDIO_ClockBypass = SDIO_ClockBypass_Disable;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6041             STR      R1,[R0, #+4]
    316            SDIO_InitStruct->SDIO_ClockPowerSave = SDIO_ClockPowerSave_Disable;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6081             STR      R1,[R0, #+8]
    317            SDIO_InitStruct->SDIO_BusWide = SDIO_BusWide_1b;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x60C1             STR      R1,[R0, #+12]
    318            SDIO_InitStruct->SDIO_HardwareFlowControl = SDIO_HardwareFlowControl_Disable;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6101             STR      R1,[R0, #+16]
    319          }
   \   00000018   0x4770             BX       LR               ;; return
    320          
    321          /**
    322            * @brief  Enables or disables the SDIO Clock.
    323            * @param  NewState: new state of the SDIO Clock. 
    324            *         This parameter can be: ENABLE or DISABLE.
    325            * @retval None
    326            */

   \                                 In section .text, align 2, keep-with-next
    327          void SDIO_ClockCmd(FunctionalState NewState)
    328          {
   \                     SDIO_ClockCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    329            /* Check the parameters */
    330            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??SDIO_ClockCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??SDIO_ClockCmd_0
   \   00000010   0xF44F 0x71A5      MOV      R1,#+330
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000018   0x.... 0x....      BL       assert_failed
    331            
    332            *(__IO uint32_t *) CLKCR_CLKEN_BB = (uint32_t)NewState;
   \                     ??SDIO_ClockCmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable25_3  ;; 0x422580a0
   \   00000022   0x6004             STR      R4,[R0, #+0]
    333          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    334          
    335          /**
    336            * @brief  Sets the power status of the controller.
    337            * @param  SDIO_PowerState: new state of the Power state. 
    338            *          This parameter can be one of the following values:
    339            *            @arg SDIO_PowerState_OFF: SDIO Power OFF
    340            *            @arg SDIO_PowerState_ON: SDIO Power ON
    341            * @retval None
    342            */

   \                                 In section .text, align 2, keep-with-next
    343          void SDIO_SetPowerState(uint32_t SDIO_PowerState)
    344          {
   \                     SDIO_SetPowerState: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    345            /* Check the parameters */
    346            assert_param(IS_SDIO_POWER_STATE(SDIO_PowerState));
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD007             BEQ.N    ??SDIO_SetPowerState_0
   \   00000008   0x2C03             CMP      R4,#+3
   \   0000000A   0xD005             BEQ.N    ??SDIO_SetPowerState_0
   \   0000000C   0xF44F 0x71AD      MOV      R1,#+346
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000014   0x.... 0x....      BL       assert_failed
    347            
    348            SDIO->POWER = SDIO_PowerState;
   \                     ??SDIO_SetPowerState_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable25_4  ;; 0x40012c00
   \   0000001C   0x6004             STR      R4,[R0, #+0]
    349          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    350          
    351          /**
    352            * @brief  Gets the power status of the controller.
    353            * @param  None
    354            * @retval Power status of the controller. The returned value can be one of the 
    355            *         following values:
    356            *            - 0x00: Power OFF
    357            *            - 0x02: Power UP
    358            *            - 0x03: Power ON 
    359            */

   \                                 In section .text, align 2, keep-with-next
    360          uint32_t SDIO_GetPowerState(void)
    361          {
    362            return (SDIO->POWER & (~PWR_PWRCTRL_MASK));
   \                     SDIO_GetPowerState: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable25_4  ;; 0x40012c00
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   0000000A   0x4770             BX       LR               ;; return
    363          }
    364          
    365          /**
    366            * @}
    367            */
    368          
    369          /** @defgroup SDIO_Group2 Command path state machine (CPSM) management functions
    370           *  @brief   Command path state machine (CPSM) management functions 
    371           *
    372          @verbatim   
    373           ===============================================================================
    374                        Command path state machine (CPSM) management functions
    375           ===============================================================================  
    376          
    377            This section provide functions allowing to program and read the Command path 
    378            state machine (CPSM).
    379          
    380          @endverbatim
    381            * @{
    382            */
    383          
    384          /**
    385            * @brief  Initializes the SDIO Command according to the specified 
    386            *         parameters in the SDIO_CmdInitStruct and send the command.
    387            * @param  SDIO_CmdInitStruct : pointer to a SDIO_CmdInitTypeDef 
    388            *         structure that contains the configuration information for the SDIO 
    389            *         command.
    390            * @retval None
    391            */

   \                                 In section .text, align 2, keep-with-next
    392          void SDIO_SendCommand(SDIO_CmdInitTypeDef *SDIO_CmdInitStruct)
    393          {
   \                     SDIO_SendCommand: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    394            uint32_t tmpreg = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    395            
    396            /* Check the parameters */
    397            assert_param(IS_SDIO_CMD_INDEX(SDIO_CmdInitStruct->SDIO_CmdIndex));
   \   00000006   0x6860             LDR      R0,[R4, #+4]
   \   00000008   0x2840             CMP      R0,#+64
   \   0000000A   0xD305             BCC.N    ??SDIO_SendCommand_0
   \   0000000C   0xF240 0x118D      MOVW     R1,#+397
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000014   0x.... 0x....      BL       assert_failed
    398            assert_param(IS_SDIO_RESPONSE(SDIO_CmdInitStruct->SDIO_Response));
   \                     ??SDIO_SendCommand_0: (+1)
   \   00000018   0x68A0             LDR      R0,[R4, #+8]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD00B             BEQ.N    ??SDIO_SendCommand_1
   \   0000001E   0x68A0             LDR      R0,[R4, #+8]
   \   00000020   0x2840             CMP      R0,#+64
   \   00000022   0xD008             BEQ.N    ??SDIO_SendCommand_1
   \   00000024   0x68A0             LDR      R0,[R4, #+8]
   \   00000026   0x28C0             CMP      R0,#+192
   \   00000028   0xD005             BEQ.N    ??SDIO_SendCommand_1
   \   0000002A   0xF44F 0x71C7      MOV      R1,#+398
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000032   0x.... 0x....      BL       assert_failed
    399            assert_param(IS_SDIO_WAIT(SDIO_CmdInitStruct->SDIO_Wait));
   \                     ??SDIO_SendCommand_1: (+1)
   \   00000036   0x68E0             LDR      R0,[R4, #+12]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD00D             BEQ.N    ??SDIO_SendCommand_2
   \   0000003C   0x68E0             LDR      R0,[R4, #+12]
   \   0000003E   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000042   0xD009             BEQ.N    ??SDIO_SendCommand_2
   \   00000044   0x68E0             LDR      R0,[R4, #+12]
   \   00000046   0xF5B0 0x7F00      CMP      R0,#+512
   \   0000004A   0xD005             BEQ.N    ??SDIO_SendCommand_2
   \   0000004C   0xF240 0x118F      MOVW     R1,#+399
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000054   0x.... 0x....      BL       assert_failed
    400            assert_param(IS_SDIO_CPSM(SDIO_CmdInitStruct->SDIO_CPSM));
   \                     ??SDIO_SendCommand_2: (+1)
   \   00000058   0x6920             LDR      R0,[R4, #+16]
   \   0000005A   0xF5B0 0x6F80      CMP      R0,#+1024
   \   0000005E   0xD008             BEQ.N    ??SDIO_SendCommand_3
   \   00000060   0x6920             LDR      R0,[R4, #+16]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD005             BEQ.N    ??SDIO_SendCommand_3
   \   00000066   0xF44F 0x71C8      MOV      R1,#+400
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable25
   \   0000006E   0x.... 0x....      BL       assert_failed
    401            
    402          /*---------------------------- SDIO ARG Configuration ------------------------*/
    403            /* Set the SDIO Argument value */
    404            SDIO->ARG = SDIO_CmdInitStruct->SDIO_Argument;
   \                     ??SDIO_SendCommand_3: (+1)
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable25_5  ;; 0x40012c08
   \   00000078   0x6008             STR      R0,[R1, #+0]
    405            
    406          /*---------------------------- SDIO CMD Configuration ------------------------*/  
    407            /* Get the SDIO CMD value */
    408            tmpreg = SDIO->CMD;
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable25_6  ;; 0x40012c0c
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x0005             MOVS     R5,R0
    409            /* Clear CMDINDEX, WAITRESP, WAITINT, WAITPEND, CPSMEN bits */
    410            tmpreg &= CMD_CLEAR_MASK;
   \   00000082   0x0AED             LSRS     R5,R5,#+11
   \   00000084   0x02ED             LSLS     R5,R5,#+11
    411            /* Set CMDINDEX bits according to SDIO_CmdIndex value */
    412            /* Set WAITRESP bits according to SDIO_Response value */
    413            /* Set WAITINT and WAITPEND bits according to SDIO_Wait value */
    414            /* Set CPSMEN bits according to SDIO_CPSM value */
    415            tmpreg |= (uint32_t)SDIO_CmdInitStruct->SDIO_CmdIndex | SDIO_CmdInitStruct->SDIO_Response
    416                     | SDIO_CmdInitStruct->SDIO_Wait | SDIO_CmdInitStruct->SDIO_CPSM;
   \   00000086   0x6860             LDR      R0,[R4, #+4]
   \   00000088   0x68A1             LDR      R1,[R4, #+8]
   \   0000008A   0x4308             ORRS     R0,R1,R0
   \   0000008C   0x68E1             LDR      R1,[R4, #+12]
   \   0000008E   0x4308             ORRS     R0,R1,R0
   \   00000090   0x6921             LDR      R1,[R4, #+16]
   \   00000092   0x4308             ORRS     R0,R1,R0
   \   00000094   0x4305             ORRS     R5,R0,R5
    417            
    418            /* Write to SDIO CMD */
    419            SDIO->CMD = tmpreg;
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable25_6  ;; 0x40012c0c
   \   0000009A   0x6005             STR      R5,[R0, #+0]
    420          }
   \   0000009C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    421          
    422          /**
    423            * @brief  Fills each SDIO_CmdInitStruct member with its default value.
    424            * @param  SDIO_CmdInitStruct: pointer to an SDIO_CmdInitTypeDef 
    425            *         structure which will be initialized.
    426            * @retval None
    427            */

   \                                 In section .text, align 2, keep-with-next
    428          void SDIO_CmdStructInit(SDIO_CmdInitTypeDef* SDIO_CmdInitStruct)
    429          {
    430            /* SDIO_CmdInitStruct members default value */
    431            SDIO_CmdInitStruct->SDIO_Argument = 0x00;
   \                     SDIO_CmdStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    432            SDIO_CmdInitStruct->SDIO_CmdIndex = 0x00;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6041             STR      R1,[R0, #+4]
    433            SDIO_CmdInitStruct->SDIO_Response = SDIO_Response_No;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6081             STR      R1,[R0, #+8]
    434            SDIO_CmdInitStruct->SDIO_Wait = SDIO_Wait_No;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
    435            SDIO_CmdInitStruct->SDIO_CPSM = SDIO_CPSM_Disable;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6101             STR      R1,[R0, #+16]
    436          }
   \   00000014   0x4770             BX       LR               ;; return
    437          
    438          /**
    439            * @brief  Returns command index of last command for which response received.
    440            * @param  None
    441            * @retval Returns the command index of the last command response received.
    442            */

   \                                 In section .text, align 2, keep-with-next
    443          uint8_t SDIO_GetCommandResponse(void)
    444          {
    445            return (uint8_t)(SDIO->RESPCMD);
   \                     SDIO_GetCommandResponse: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable25_7  ;; 0x40012c10
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x4770             BX       LR               ;; return
    446          }
    447          
    448          /**
    449            * @brief  Returns response received from the card for the last command.
    450            * @param  SDIO_RESP: Specifies the SDIO response register. 
    451            *          This parameter can be one of the following values:
    452            *            @arg SDIO_RESP1: Response Register 1
    453            *            @arg SDIO_RESP2: Response Register 2
    454            *            @arg SDIO_RESP3: Response Register 3
    455            *            @arg SDIO_RESP4: Response Register 4
    456            * @retval The Corresponding response register value.
    457            */

   \                                 In section .text, align 2, keep-with-next
    458          uint32_t SDIO_GetResponse(uint32_t SDIO_RESP)
    459          {
   \                     SDIO_GetResponse: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    460            __IO uint32_t tmp = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
    461          
    462            /* Check the parameters */
    463            assert_param(IS_SDIO_RESP(SDIO_RESP));
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD00B             BEQ.N    ??SDIO_GetResponse_0
   \   0000000E   0x2C04             CMP      R4,#+4
   \   00000010   0xD009             BEQ.N    ??SDIO_GetResponse_0
   \   00000012   0x2C08             CMP      R4,#+8
   \   00000014   0xD007             BEQ.N    ??SDIO_GetResponse_0
   \   00000016   0x2C0C             CMP      R4,#+12
   \   00000018   0xD005             BEQ.N    ??SDIO_GetResponse_0
   \   0000001A   0xF240 0x11CF      MOVW     R1,#+463
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000022   0x.... 0x....      BL       assert_failed
    464          
    465            tmp = SDIO_RESP_ADDR + SDIO_RESP;
   \                     ??SDIO_GetResponse_0: (+1)
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable25_8  ;; 0x40012c14
   \   0000002A   0x1900             ADDS     R0,R0,R4
   \   0000002C   0x9000             STR      R0,[SP, #+0]
    466            
    467            return (*(__IO uint32_t *) tmp); 
   \   0000002E   0x9800             LDR      R0,[SP, #+0]
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    468          }
    469          
    470          /**
    471            * @}
    472            */
    473          
    474          /** @defgroup SDIO_Group3 Data path state machine (DPSM) management functions
    475           *  @brief   Data path state machine (DPSM) management functions
    476           *
    477          @verbatim   
    478           ===============================================================================
    479                        Data path state machine (DPSM) management functions
    480           ===============================================================================  
    481          
    482            This section provide functions allowing to program and read the Data path 
    483            state machine (DPSM).
    484          
    485          @endverbatim
    486            * @{
    487            */
    488          
    489          /**
    490            * @brief  Initializes the SDIO data path according to the specified 
    491            *         parameters in the SDIO_DataInitStruct.
    492            * @param  SDIO_DataInitStruct : pointer to a SDIO_DataInitTypeDef structure 
    493            *         that contains the configuration information for the SDIO command.
    494            * @retval None
    495            */

   \                                 In section .text, align 2, keep-with-next
    496          void SDIO_DataConfig(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
    497          {
   \                     SDIO_DataConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    498            uint32_t tmpreg = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    499            
    500            /* Check the parameters */
    501            assert_param(IS_SDIO_DATA_LENGTH(SDIO_DataInitStruct->SDIO_DataLength));
   \   00000006   0x6860             LDR      R0,[R4, #+4]
   \   00000008   0xF1B0 0x7F00      CMP      R0,#+33554432
   \   0000000C   0xD305             BCC.N    ??SDIO_DataConfig_0
   \   0000000E   0xF240 0x11F5      MOVW     R1,#+501
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000016   0x.... 0x....      BL       assert_failed
    502            assert_param(IS_SDIO_BLOCK_SIZE(SDIO_DataInitStruct->SDIO_DataBlockSize));
   \                     ??SDIO_DataConfig_0: (+1)
   \   0000001A   0x68A0             LDR      R0,[R4, #+8]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD02F             BEQ.N    ??SDIO_DataConfig_1
   \   00000020   0x68A0             LDR      R0,[R4, #+8]
   \   00000022   0x2810             CMP      R0,#+16
   \   00000024   0xD02C             BEQ.N    ??SDIO_DataConfig_1
   \   00000026   0x68A0             LDR      R0,[R4, #+8]
   \   00000028   0x2820             CMP      R0,#+32
   \   0000002A   0xD029             BEQ.N    ??SDIO_DataConfig_1
   \   0000002C   0x68A0             LDR      R0,[R4, #+8]
   \   0000002E   0x2830             CMP      R0,#+48
   \   00000030   0xD026             BEQ.N    ??SDIO_DataConfig_1
   \   00000032   0x68A0             LDR      R0,[R4, #+8]
   \   00000034   0x2840             CMP      R0,#+64
   \   00000036   0xD023             BEQ.N    ??SDIO_DataConfig_1
   \   00000038   0x68A0             LDR      R0,[R4, #+8]
   \   0000003A   0x2850             CMP      R0,#+80
   \   0000003C   0xD020             BEQ.N    ??SDIO_DataConfig_1
   \   0000003E   0x68A0             LDR      R0,[R4, #+8]
   \   00000040   0x2860             CMP      R0,#+96
   \   00000042   0xD01D             BEQ.N    ??SDIO_DataConfig_1
   \   00000044   0x68A0             LDR      R0,[R4, #+8]
   \   00000046   0x2870             CMP      R0,#+112
   \   00000048   0xD01A             BEQ.N    ??SDIO_DataConfig_1
   \   0000004A   0x68A0             LDR      R0,[R4, #+8]
   \   0000004C   0x2880             CMP      R0,#+128
   \   0000004E   0xD017             BEQ.N    ??SDIO_DataConfig_1
   \   00000050   0x68A0             LDR      R0,[R4, #+8]
   \   00000052   0x2890             CMP      R0,#+144
   \   00000054   0xD014             BEQ.N    ??SDIO_DataConfig_1
   \   00000056   0x68A0             LDR      R0,[R4, #+8]
   \   00000058   0x28A0             CMP      R0,#+160
   \   0000005A   0xD011             BEQ.N    ??SDIO_DataConfig_1
   \   0000005C   0x68A0             LDR      R0,[R4, #+8]
   \   0000005E   0x28B0             CMP      R0,#+176
   \   00000060   0xD00E             BEQ.N    ??SDIO_DataConfig_1
   \   00000062   0x68A0             LDR      R0,[R4, #+8]
   \   00000064   0x28C0             CMP      R0,#+192
   \   00000066   0xD00B             BEQ.N    ??SDIO_DataConfig_1
   \   00000068   0x68A0             LDR      R0,[R4, #+8]
   \   0000006A   0x28D0             CMP      R0,#+208
   \   0000006C   0xD008             BEQ.N    ??SDIO_DataConfig_1
   \   0000006E   0x68A0             LDR      R0,[R4, #+8]
   \   00000070   0x28E0             CMP      R0,#+224
   \   00000072   0xD005             BEQ.N    ??SDIO_DataConfig_1
   \   00000074   0xF44F 0x71FB      MOV      R1,#+502
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable25
   \   0000007C   0x.... 0x....      BL       assert_failed
    503            assert_param(IS_SDIO_TRANSFER_DIR(SDIO_DataInitStruct->SDIO_TransferDir));
   \                     ??SDIO_DataConfig_1: (+1)
   \   00000080   0x68E0             LDR      R0,[R4, #+12]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD008             BEQ.N    ??SDIO_DataConfig_2
   \   00000086   0x68E0             LDR      R0,[R4, #+12]
   \   00000088   0x2802             CMP      R0,#+2
   \   0000008A   0xD005             BEQ.N    ??SDIO_DataConfig_2
   \   0000008C   0xF240 0x11F7      MOVW     R1,#+503
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000094   0x.... 0x....      BL       assert_failed
    504            assert_param(IS_SDIO_TRANSFER_MODE(SDIO_DataInitStruct->SDIO_TransferMode));
   \                     ??SDIO_DataConfig_2: (+1)
   \   00000098   0x6920             LDR      R0,[R4, #+16]
   \   0000009A   0x2804             CMP      R0,#+4
   \   0000009C   0xD008             BEQ.N    ??SDIO_DataConfig_3
   \   0000009E   0x6920             LDR      R0,[R4, #+16]
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD005             BEQ.N    ??SDIO_DataConfig_3
   \   000000A4   0xF44F 0x71FC      MOV      R1,#+504
   \   000000A8   0x.... 0x....      LDR.W    R0,??DataTable25
   \   000000AC   0x.... 0x....      BL       assert_failed
    505            assert_param(IS_SDIO_DPSM(SDIO_DataInitStruct->SDIO_DPSM));
   \                     ??SDIO_DataConfig_3: (+1)
   \   000000B0   0x6960             LDR      R0,[R4, #+20]
   \   000000B2   0x2801             CMP      R0,#+1
   \   000000B4   0xD008             BEQ.N    ??SDIO_DataConfig_4
   \   000000B6   0x6960             LDR      R0,[R4, #+20]
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD005             BEQ.N    ??SDIO_DataConfig_4
   \   000000BC   0xF240 0x11F9      MOVW     R1,#+505
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable25
   \   000000C4   0x.... 0x....      BL       assert_failed
    506          
    507          /*---------------------------- SDIO DTIMER Configuration ---------------------*/
    508            /* Set the SDIO Data TimeOut value */
    509            SDIO->DTIMER = SDIO_DataInitStruct->SDIO_DataTimeOut;
   \                     ??SDIO_DataConfig_4: (+1)
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable25_9  ;; 0x40012c24
   \   000000CE   0x6008             STR      R0,[R1, #+0]
    510          
    511          /*---------------------------- SDIO DLEN Configuration -----------------------*/
    512            /* Set the SDIO DataLength value */
    513            SDIO->DLEN = SDIO_DataInitStruct->SDIO_DataLength;
   \   000000D0   0x6860             LDR      R0,[R4, #+4]
   \   000000D2   0x.... 0x....      LDR.W    R1,??DataTable25_10  ;; 0x40012c28
   \   000000D6   0x6008             STR      R0,[R1, #+0]
    514          
    515          /*---------------------------- SDIO DCTRL Configuration ----------------------*/  
    516            /* Get the SDIO DCTRL value */
    517            tmpreg = SDIO->DCTRL;
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable25_11  ;; 0x40012c2c
   \   000000DC   0x6800             LDR      R0,[R0, #+0]
   \   000000DE   0x0005             MOVS     R5,R0
    518            /* Clear DEN, DTMODE, DTDIR and DBCKSIZE bits */
    519            tmpreg &= DCTRL_CLEAR_MASK;
   \   000000E0   0xF035 0x05F7      BICS     R5,R5,#0xF7
    520            /* Set DEN bit according to SDIO_DPSM value */
    521            /* Set DTMODE bit according to SDIO_TransferMode value */
    522            /* Set DTDIR bit according to SDIO_TransferDir value */
    523            /* Set DBCKSIZE bits according to SDIO_DataBlockSize value */
    524            tmpreg |= (uint32_t)SDIO_DataInitStruct->SDIO_DataBlockSize | SDIO_DataInitStruct->SDIO_TransferDir
    525                     | SDIO_DataInitStruct->SDIO_TransferMode | SDIO_DataInitStruct->SDIO_DPSM;
   \   000000E4   0x68A0             LDR      R0,[R4, #+8]
   \   000000E6   0x68E1             LDR      R1,[R4, #+12]
   \   000000E8   0x4308             ORRS     R0,R1,R0
   \   000000EA   0x6921             LDR      R1,[R4, #+16]
   \   000000EC   0x4308             ORRS     R0,R1,R0
   \   000000EE   0x6961             LDR      R1,[R4, #+20]
   \   000000F0   0x4308             ORRS     R0,R1,R0
   \   000000F2   0x4305             ORRS     R5,R0,R5
    526          
    527            /* Write to SDIO DCTRL */
    528            SDIO->DCTRL = tmpreg;
   \   000000F4   0x.... 0x....      LDR.W    R0,??DataTable25_11  ;; 0x40012c2c
   \   000000F8   0x6005             STR      R5,[R0, #+0]
    529          }
   \   000000FA   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    530          
    531          /**
    532            * @brief  Fills each SDIO_DataInitStruct member with its default value.
    533            * @param  SDIO_DataInitStruct: pointer to an SDIO_DataInitTypeDef structure 
    534            *         which will be initialized.
    535            * @retval None
    536            */

   \                                 In section .text, align 2, keep-with-next
    537          void SDIO_DataStructInit(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
    538          {
    539            /* SDIO_DataInitStruct members default value */
    540            SDIO_DataInitStruct->SDIO_DataTimeOut = 0xFFFFFFFF;
   \                     SDIO_DataStructInit: (+1)
   \   00000000   0xF05F 0x31FF      MOVS     R1,#-1
   \   00000004   0x6001             STR      R1,[R0, #+0]
    541            SDIO_DataInitStruct->SDIO_DataLength = 0x00;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6041             STR      R1,[R0, #+4]
    542            SDIO_DataInitStruct->SDIO_DataBlockSize = SDIO_DataBlockSize_1b;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6081             STR      R1,[R0, #+8]
    543            SDIO_DataInitStruct->SDIO_TransferDir = SDIO_TransferDir_ToCard;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x60C1             STR      R1,[R0, #+12]
    544            SDIO_DataInitStruct->SDIO_TransferMode = SDIO_TransferMode_Block;  
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x6101             STR      R1,[R0, #+16]
    545            SDIO_DataInitStruct->SDIO_DPSM = SDIO_DPSM_Disable;
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x6141             STR      R1,[R0, #+20]
    546          }
   \   0000001A   0x4770             BX       LR               ;; return
    547          
    548          /**
    549            * @brief  Returns number of remaining data bytes to be transferred.
    550            * @param  None
    551            * @retval Number of remaining data bytes to be transferred
    552            */

   \                                 In section .text, align 2, keep-with-next
    553          uint32_t SDIO_GetDataCounter(void)
    554          { 
    555            return SDIO->DCOUNT;
   \                     SDIO_GetDataCounter: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable25_12  ;; 0x40012c30
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return
    556          }
    557          
    558          /**
    559            * @brief  Read one data word from Rx FIFO.
    560            * @param  None
    561            * @retval Data received
    562            */

   \                                 In section .text, align 2, keep-with-next
    563          uint32_t SDIO_ReadData(void)
    564          { 
    565            return SDIO->FIFO;
   \                     SDIO_ReadData: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable25_13  ;; 0x40012c80
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return
    566          }
    567          
    568          /**
    569            * @brief  Write one data word to Tx FIFO.
    570            * @param  Data: 32-bit data word to write.
    571            * @retval None
    572            */

   \                                 In section .text, align 2, keep-with-next
    573          void SDIO_WriteData(uint32_t Data)
    574          { 
    575            SDIO->FIFO = Data;
   \                     SDIO_WriteData: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable25_13  ;; 0x40012c80
   \   00000004   0x6008             STR      R0,[R1, #+0]
    576          }
   \   00000006   0x4770             BX       LR               ;; return
    577          
    578          /**
    579            * @brief  Returns the number of words left to be written to or read from FIFO.	
    580            * @param  None
    581            * @retval Remaining number of words.
    582            */

   \                                 In section .text, align 2, keep-with-next
    583          uint32_t SDIO_GetFIFOCount(void)
    584          { 
    585            return SDIO->FIFOCNT;
   \                     SDIO_GetFIFOCount: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable25_14  ;; 0x40012c48
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return
    586          }
    587          
    588          /**
    589            * @}
    590            */
    591          
    592          /** @defgroup SDIO_Group4 SDIO IO Cards mode management functions
    593           *  @brief   SDIO IO Cards mode management functions
    594           *
    595          @verbatim   
    596           ===============================================================================
    597                        SDIO IO Cards mode management functions
    598           ===============================================================================  
    599          
    600            This section provide functions allowing to program and read the SDIO IO Cards.
    601          
    602          @endverbatim
    603            * @{
    604            */
    605          
    606          /**
    607            * @brief  Starts the SD I/O Read Wait operation.	
    608            * @param  NewState: new state of the Start SDIO Read Wait operation. 
    609            *         This parameter can be: ENABLE or DISABLE.
    610            * @retval None
    611            */

   \                                 In section .text, align 2, keep-with-next
    612          void SDIO_StartSDIOReadWait(FunctionalState NewState)
    613          { 
   \                     SDIO_StartSDIOReadWait: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    614            /* Check the parameters */
    615            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??SDIO_StartSDIOReadWait_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??SDIO_StartSDIOReadWait_0
   \   00000010   0xF240 0x2167      MOVW     R1,#+615
   \   00000014   0x....             LDR.N    R0,??DataTable25
   \   00000016   0x.... 0x....      BL       assert_failed
    616            
    617            *(__IO uint32_t *) DCTRL_RWSTART_BB = (uint32_t) NewState;
   \                     ??SDIO_StartSDIOReadWait_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable25_15  ;; 0x422585a0
   \   00000020   0x6004             STR      R4,[R0, #+0]
    618          }
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    619          
    620          /**
    621            * @brief  Stops the SD I/O Read Wait operation.	
    622            * @param  NewState: new state of the Stop SDIO Read Wait operation. 
    623            *         This parameter can be: ENABLE or DISABLE.
    624            * @retval None
    625            */

   \                                 In section .text, align 2, keep-with-next
    626          void SDIO_StopSDIOReadWait(FunctionalState NewState)
    627          { 
   \                     SDIO_StopSDIOReadWait: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    628            /* Check the parameters */
    629            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??SDIO_StopSDIOReadWait_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??SDIO_StopSDIOReadWait_0
   \   00000010   0xF240 0x2175      MOVW     R1,#+629
   \   00000014   0x....             LDR.N    R0,??DataTable25
   \   00000016   0x.... 0x....      BL       assert_failed
    630            
    631            *(__IO uint32_t *) DCTRL_RWSTOP_BB = (uint32_t) NewState;
   \                     ??SDIO_StopSDIOReadWait_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable25_16  ;; 0x422585a4
   \   00000020   0x6004             STR      R4,[R0, #+0]
    632          }
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    633          
    634          /**
    635            * @brief  Sets one of the two options of inserting read wait interval.
    636            * @param  SDIO_ReadWaitMode: SD I/O Read Wait operation mode.
    637            *          This parameter can be:
    638            *            @arg SDIO_ReadWaitMode_CLK: Read Wait control by stopping SDIOCLK
    639            *            @arg SDIO_ReadWaitMode_DATA2: Read Wait control using SDIO_DATA2
    640            * @retval None
    641            */

   \                                 In section .text, align 2, keep-with-next
    642          void SDIO_SetSDIOReadWaitMode(uint32_t SDIO_ReadWaitMode)
    643          {
   \                     SDIO_SetSDIOReadWaitMode: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    644            /* Check the parameters */
    645            assert_param(IS_SDIO_READWAIT_MODE(SDIO_ReadWaitMode));
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD006             BEQ.N    ??SDIO_SetSDIOReadWaitMode_0
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD004             BEQ.N    ??SDIO_SetSDIOReadWaitMode_0
   \   0000000C   0xF240 0x2185      MOVW     R1,#+645
   \   00000010   0x....             LDR.N    R0,??DataTable25
   \   00000012   0x.... 0x....      BL       assert_failed
    646            
    647            *(__IO uint32_t *) DCTRL_RWMOD_BB = SDIO_ReadWaitMode;
   \                     ??SDIO_SetSDIOReadWaitMode_0: (+1)
   \   00000016   0x....             LDR.N    R0,??DataTable25_17  ;; 0x422585a8
   \   00000018   0x6004             STR      R4,[R0, #+0]
    648          }
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    649          
    650          /**
    651            * @brief  Enables or disables the SD I/O Mode Operation.
    652            * @param  NewState: new state of SDIO specific operation. 
    653            *         This parameter can be: ENABLE or DISABLE.
    654            * @retval None
    655            */

   \                                 In section .text, align 2, keep-with-next
    656          void SDIO_SetSDIOOperation(FunctionalState NewState)
    657          { 
   \                     SDIO_SetSDIOOperation: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    658            /* Check the parameters */
    659            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??SDIO_SetSDIOOperation_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??SDIO_SetSDIOOperation_0
   \   00000010   0xF240 0x2193      MOVW     R1,#+659
   \   00000014   0x....             LDR.N    R0,??DataTable25
   \   00000016   0x.... 0x....      BL       assert_failed
    660            
    661            *(__IO uint32_t *) DCTRL_SDIOEN_BB = (uint32_t)NewState;
   \                     ??SDIO_SetSDIOOperation_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x....             LDR.N    R0,??DataTable25_18  ;; 0x422585ac
   \   0000001E   0x6004             STR      R4,[R0, #+0]
    662          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    663          
    664          /**
    665            * @brief  Enables or disables the SD I/O Mode suspend command sending.
    666            * @param  NewState: new state of the SD I/O Mode suspend command.
    667            *         This parameter can be: ENABLE or DISABLE.
    668            * @retval None
    669            */

   \                                 In section .text, align 2, keep-with-next
    670          void SDIO_SendSDIOSuspendCmd(FunctionalState NewState)
    671          { 
   \                     SDIO_SendSDIOSuspendCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    672            /* Check the parameters */
    673            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??SDIO_SendSDIOSuspendCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??SDIO_SendSDIOSuspendCmd_0
   \   00000010   0xF240 0x21A1      MOVW     R1,#+673
   \   00000014   0x....             LDR.N    R0,??DataTable25
   \   00000016   0x.... 0x....      BL       assert_failed
    674            
    675            *(__IO uint32_t *) CMD_SDIOSUSPEND_BB = (uint32_t)NewState;
   \                     ??SDIO_SendSDIOSuspendCmd_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x....             LDR.N    R0,??DataTable25_19  ;; 0x422581ac
   \   0000001E   0x6004             STR      R4,[R0, #+0]
    676          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    677          
    678          /**
    679            * @}
    680            */
    681          
    682          /** @defgroup SDIO_Group5 CE-ATA mode management functions
    683           *  @brief   CE-ATA mode management functions
    684           *
    685          @verbatim   
    686           ===============================================================================
    687                        CE-ATA mode management functions
    688           ===============================================================================  
    689          
    690            This section provide functions allowing to program and read the CE-ATA card.
    691          
    692          @endverbatim
    693            * @{
    694            */
    695          
    696          /**
    697            * @brief  Enables or disables the command completion signal.
    698            * @param  NewState: new state of command completion signal. 
    699            *         This parameter can be: ENABLE or DISABLE.
    700            * @retval None
    701            */

   \                                 In section .text, align 2, keep-with-next
    702          void SDIO_CommandCompletionCmd(FunctionalState NewState)
    703          { 
   \                     SDIO_CommandCompletionCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    704            /* Check the parameters */
    705            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??SDIO_CommandCompletionCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??SDIO_CommandCompletionCmd_0
   \   00000010   0xF240 0x21C1      MOVW     R1,#+705
   \   00000014   0x....             LDR.N    R0,??DataTable25
   \   00000016   0x.... 0x....      BL       assert_failed
    706            
    707            *(__IO uint32_t *) CMD_ENCMDCOMPL_BB = (uint32_t)NewState;
   \                     ??SDIO_CommandCompletionCmd_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x....             LDR.N    R0,??DataTable25_20  ;; 0x422581b0
   \   0000001E   0x6004             STR      R4,[R0, #+0]
    708          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    709          
    710          /**
    711            * @brief  Enables or disables the CE-ATA interrupt.
    712            * @param  NewState: new state of CE-ATA interrupt. 
    713            *         This parameter can be: ENABLE or DISABLE.
    714            * @retval None
    715            */

   \                                 In section .text, align 2, keep-with-next
    716          void SDIO_CEATAITCmd(FunctionalState NewState)
    717          { 
   \                     SDIO_CEATAITCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    718            /* Check the parameters */
    719            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??SDIO_CEATAITCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??SDIO_CEATAITCmd_0
   \   00000010   0xF240 0x21CF      MOVW     R1,#+719
   \   00000014   0x....             LDR.N    R0,??DataTable25
   \   00000016   0x.... 0x....      BL       assert_failed
    720            
    721            *(__IO uint32_t *) CMD_NIEN_BB = (uint32_t)((~((uint32_t)NewState)) & ((uint32_t)0x1));
   \                     ??SDIO_CEATAITCmd_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x43E0             MVNS     R0,R4
   \   0000001E   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000022   0x....             LDR.N    R1,??DataTable25_21  ;; 0x422581b4
   \   00000024   0x6008             STR      R0,[R1, #+0]
    722          }
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    723          
    724          /**
    725            * @brief  Sends CE-ATA command (CMD61).
    726            * @param  NewState: new state of CE-ATA command. 
    727            *         This parameter can be: ENABLE or DISABLE.
    728            * @retval None
    729            */

   \                                 In section .text, align 2, keep-with-next
    730          void SDIO_SendCEATACmd(FunctionalState NewState)
    731          { 
   \                     SDIO_SendCEATACmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    732            /* Check the parameters */
    733            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??SDIO_SendCEATACmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??SDIO_SendCEATACmd_0
   \   00000010   0xF240 0x21DD      MOVW     R1,#+733
   \   00000014   0x....             LDR.N    R0,??DataTable25
   \   00000016   0x.... 0x....      BL       assert_failed
    734            
    735            *(__IO uint32_t *) CMD_ATACMD_BB = (uint32_t)NewState;
   \                     ??SDIO_SendCEATACmd_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x....             LDR.N    R0,??DataTable25_22  ;; 0x422581b8
   \   0000001E   0x6004             STR      R4,[R0, #+0]
    736          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    737          
    738          /**
    739            * @}
    740            */
    741          
    742          /** @defgroup SDIO_Group6 DMA transfers management functions
    743           *  @brief   DMA transfers management functions
    744           *
    745          @verbatim   
    746           ===============================================================================
    747                        DMA transfers management functions
    748           ===============================================================================  
    749          
    750            This section provide functions allowing to program SDIO DMA transfer.
    751          
    752          @endverbatim
    753            * @{
    754            */
    755          
    756          /**
    757            * @brief  Enables or disables the SDIO DMA request.
    758            * @param  NewState: new state of the selected SDIO DMA request.
    759            *          This parameter can be: ENABLE or DISABLE.
    760            * @retval None
    761            */

   \                                 In section .text, align 2, keep-with-next
    762          void SDIO_DMACmd(FunctionalState NewState)
    763          {
   \                     SDIO_DMACmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    764            /* Check the parameters */
    765            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??SDIO_DMACmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??SDIO_DMACmd_0
   \   00000010   0xF240 0x21FD      MOVW     R1,#+765
   \   00000014   0x....             LDR.N    R0,??DataTable25
   \   00000016   0x.... 0x....      BL       assert_failed
    766            
    767            *(__IO uint32_t *) DCTRL_DMAEN_BB = (uint32_t)NewState;
   \                     ??SDIO_DMACmd_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x....             LDR.N    R0,??DataTable25_23  ;; 0x4225858c
   \   0000001E   0x6004             STR      R4,[R0, #+0]
    768          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    769          
    770          /**
    771            * @}
    772            */
    773          
    774          /** @defgroup SDIO_Group7 Interrupts and flags management functions
    775           *  @brief   Interrupts and flags management functions  
    776           *
    777          @verbatim   
    778           ===============================================================================
    779                                 Interrupts and flags management functions
    780           ===============================================================================  
    781          
    782          
    783          @endverbatim
    784            * @{
    785            */
    786          
    787          /**
    788            * @brief  Enables or disables the SDIO interrupts.
    789            * @param  SDIO_IT: specifies the SDIO interrupt sources to be enabled or disabled.
    790            *          This parameter can be one or a combination of the following values:
    791            *            @arg SDIO_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
    792            *            @arg SDIO_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
    793            *            @arg SDIO_IT_CTIMEOUT: Command response timeout interrupt
    794            *            @arg SDIO_IT_DTIMEOUT: Data timeout interrupt
    795            *            @arg SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt
    796            *            @arg SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt
    797            *            @arg SDIO_IT_CMDREND:  Command response received (CRC check passed) interrupt
    798            *            @arg SDIO_IT_CMDSENT:  Command sent (no response required) interrupt
    799            *            @arg SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt
    800            *            @arg SDIO_IT_STBITERR: Start bit not detected on all data signals in wide 
    801            *                                   bus mode interrupt
    802            *            @arg SDIO_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt
    803            *            @arg SDIO_IT_CMDACT:   Command transfer in progress interrupt
    804            *            @arg SDIO_IT_TXACT:    Data transmit in progress interrupt
    805            *            @arg SDIO_IT_RXACT:    Data receive in progress interrupt
    806            *            @arg SDIO_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt
    807            *            @arg SDIO_IT_RXFIFOHF: Receive FIFO Half Full interrupt
    808            *            @arg SDIO_IT_TXFIFOF:  Transmit FIFO full interrupt
    809            *            @arg SDIO_IT_RXFIFOF:  Receive FIFO full interrupt
    810            *            @arg SDIO_IT_TXFIFOE:  Transmit FIFO empty interrupt
    811            *            @arg SDIO_IT_RXFIFOE:  Receive FIFO empty interrupt
    812            *            @arg SDIO_IT_TXDAVL:   Data available in transmit FIFO interrupt
    813            *            @arg SDIO_IT_RXDAVL:   Data available in receive FIFO interrupt
    814            *            @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt
    815            *            @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61 interrupt
    816            * @param  NewState: new state of the specified SDIO interrupts.
    817            *          This parameter can be: ENABLE or DISABLE.
    818            * @retval None 
    819            */

   \                                 In section .text, align 2, keep-with-next
    820          void SDIO_ITConfig(uint32_t SDIO_IT, FunctionalState NewState)
    821          {
   \                     SDIO_ITConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    822            /* Check the parameters */
    823            assert_param(IS_SDIO_IT(SDIO_IT));
   \   00000006   0xF014 0x4F7F      TST      R4,#0xFF000000
   \   0000000A   0xD101             BNE.N    ??SDIO_ITConfig_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD104             BNE.N    ??SDIO_ITConfig_1
   \                     ??SDIO_ITConfig_0: (+1)
   \   00000010   0xF240 0x3137      MOVW     R1,#+823
   \   00000014   0x....             LDR.N    R0,??DataTable25
   \   00000016   0x.... 0x....      BL       assert_failed
    824            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??SDIO_ITConfig_1: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD007             BEQ.N    ??SDIO_ITConfig_2
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD004             BEQ.N    ??SDIO_ITConfig_2
   \   00000026   0xF44F 0x714E      MOV      R1,#+824
   \   0000002A   0x....             LDR.N    R0,??DataTable25
   \   0000002C   0x.... 0x....      BL       assert_failed
    825            
    826            if (NewState != DISABLE)
   \                     ??SDIO_ITConfig_2: (+1)
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD005             BEQ.N    ??SDIO_ITConfig_3
    827            {
    828              /* Enable the SDIO interrupts */
    829              SDIO->MASK |= SDIO_IT;
   \   00000036   0x....             LDR.N    R0,??DataTable25_24  ;; 0x40012c3c
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x4320             ORRS     R0,R4,R0
   \   0000003C   0x....             LDR.N    R1,??DataTable25_24  ;; 0x40012c3c
   \   0000003E   0x6008             STR      R0,[R1, #+0]
   \   00000040   0xE004             B.N      ??SDIO_ITConfig_4
    830            }
    831            else
    832            {
    833              /* Disable the SDIO interrupts */
    834              SDIO->MASK &= ~SDIO_IT;
   \                     ??SDIO_ITConfig_3: (+1)
   \   00000042   0x....             LDR.N    R0,??DataTable25_24  ;; 0x40012c3c
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x43A0             BICS     R0,R0,R4
   \   00000048   0x....             LDR.N    R1,??DataTable25_24  ;; 0x40012c3c
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    835            } 
    836          }
   \                     ??SDIO_ITConfig_4: (+1)
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    837          
    838          /**
    839            * @brief  Checks whether the specified SDIO flag is set or not.
    840            * @param  SDIO_FLAG: specifies the flag to check. 
    841            *          This parameter can be one of the following values:
    842            *            @arg SDIO_FLAG_CCRCFAIL: Command response received (CRC check failed)
    843            *            @arg SDIO_FLAG_DCRCFAIL: Data block sent/received (CRC check failed)
    844            *            @arg SDIO_FLAG_CTIMEOUT: Command response timeout
    845            *            @arg SDIO_FLAG_DTIMEOUT: Data timeout
    846            *            @arg SDIO_FLAG_TXUNDERR: Transmit FIFO underrun error
    847            *            @arg SDIO_FLAG_RXOVERR:  Received FIFO overrun error
    848            *            @arg SDIO_FLAG_CMDREND:  Command response received (CRC check passed)
    849            *            @arg SDIO_FLAG_CMDSENT:  Command sent (no response required)
    850            *            @arg SDIO_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is zero)
    851            *            @arg SDIO_FLAG_STBITERR: Start bit not detected on all data signals in wide bus mode.
    852            *            @arg SDIO_FLAG_DBCKEND:  Data block sent/received (CRC check passed)
    853            *            @arg SDIO_FLAG_CMDACT:   Command transfer in progress
    854            *            @arg SDIO_FLAG_TXACT:    Data transmit in progress
    855            *            @arg SDIO_FLAG_RXACT:    Data receive in progress
    856            *            @arg SDIO_FLAG_TXFIFOHE: Transmit FIFO Half Empty
    857            *            @arg SDIO_FLAG_RXFIFOHF: Receive FIFO Half Full
    858            *            @arg SDIO_FLAG_TXFIFOF:  Transmit FIFO full
    859            *            @arg SDIO_FLAG_RXFIFOF:  Receive FIFO full
    860            *            @arg SDIO_FLAG_TXFIFOE:  Transmit FIFO empty
    861            *            @arg SDIO_FLAG_RXFIFOE:  Receive FIFO empty
    862            *            @arg SDIO_FLAG_TXDAVL:   Data available in transmit FIFO
    863            *            @arg SDIO_FLAG_RXDAVL:   Data available in receive FIFO
    864            *            @arg SDIO_FLAG_SDIOIT:   SD I/O interrupt received
    865            *            @arg SDIO_FLAG_CEATAEND: CE-ATA command completion signal received for CMD61
    866            * @retval The new state of SDIO_FLAG (SET or RESET).
    867            */

   \                                 In section .text, align 2, keep-with-next
    868          FlagStatus SDIO_GetFlagStatus(uint32_t SDIO_FLAG)
    869          { 
   \                     SDIO_GetFlagStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    870            FlagStatus bitstatus = RESET;
   \   00000004   0x2500             MOVS     R5,#+0
    871            
    872            /* Check the parameters */
    873            assert_param(IS_SDIO_FLAG(SDIO_FLAG));
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD042             BEQ.N    ??SDIO_GetFlagStatus_0
   \   0000000A   0x2C02             CMP      R4,#+2
   \   0000000C   0xD040             BEQ.N    ??SDIO_GetFlagStatus_0
   \   0000000E   0x2C04             CMP      R4,#+4
   \   00000010   0xD03E             BEQ.N    ??SDIO_GetFlagStatus_0
   \   00000012   0x2C08             CMP      R4,#+8
   \   00000014   0xD03C             BEQ.N    ??SDIO_GetFlagStatus_0
   \   00000016   0x2C10             CMP      R4,#+16
   \   00000018   0xD03A             BEQ.N    ??SDIO_GetFlagStatus_0
   \   0000001A   0x2C20             CMP      R4,#+32
   \   0000001C   0xD038             BEQ.N    ??SDIO_GetFlagStatus_0
   \   0000001E   0x2C40             CMP      R4,#+64
   \   00000020   0xD036             BEQ.N    ??SDIO_GetFlagStatus_0
   \   00000022   0x2C80             CMP      R4,#+128
   \   00000024   0xD034             BEQ.N    ??SDIO_GetFlagStatus_0
   \   00000026   0xF5B4 0x7F80      CMP      R4,#+256
   \   0000002A   0xD031             BEQ.N    ??SDIO_GetFlagStatus_0
   \   0000002C   0xF5B4 0x7F00      CMP      R4,#+512
   \   00000030   0xD02E             BEQ.N    ??SDIO_GetFlagStatus_0
   \   00000032   0xF5B4 0x6F80      CMP      R4,#+1024
   \   00000036   0xD02B             BEQ.N    ??SDIO_GetFlagStatus_0
   \   00000038   0xF5B4 0x6F00      CMP      R4,#+2048
   \   0000003C   0xD028             BEQ.N    ??SDIO_GetFlagStatus_0
   \   0000003E   0xF5B4 0x5F80      CMP      R4,#+4096
   \   00000042   0xD025             BEQ.N    ??SDIO_GetFlagStatus_0
   \   00000044   0xF5B4 0x5F00      CMP      R4,#+8192
   \   00000048   0xD022             BEQ.N    ??SDIO_GetFlagStatus_0
   \   0000004A   0xF5B4 0x4F80      CMP      R4,#+16384
   \   0000004E   0xD01F             BEQ.N    ??SDIO_GetFlagStatus_0
   \   00000050   0xF5B4 0x4F00      CMP      R4,#+32768
   \   00000054   0xD01C             BEQ.N    ??SDIO_GetFlagStatus_0
   \   00000056   0xF5B4 0x3F80      CMP      R4,#+65536
   \   0000005A   0xD019             BEQ.N    ??SDIO_GetFlagStatus_0
   \   0000005C   0xF5B4 0x3F00      CMP      R4,#+131072
   \   00000060   0xD016             BEQ.N    ??SDIO_GetFlagStatus_0
   \   00000062   0xF5B4 0x2F80      CMP      R4,#+262144
   \   00000066   0xD013             BEQ.N    ??SDIO_GetFlagStatus_0
   \   00000068   0xF5B4 0x2F00      CMP      R4,#+524288
   \   0000006C   0xD010             BEQ.N    ??SDIO_GetFlagStatus_0
   \   0000006E   0xF5B4 0x1F80      CMP      R4,#+1048576
   \   00000072   0xD00D             BEQ.N    ??SDIO_GetFlagStatus_0
   \   00000074   0xF5B4 0x1F00      CMP      R4,#+2097152
   \   00000078   0xD00A             BEQ.N    ??SDIO_GetFlagStatus_0
   \   0000007A   0xF5B4 0x0F80      CMP      R4,#+4194304
   \   0000007E   0xD007             BEQ.N    ??SDIO_GetFlagStatus_0
   \   00000080   0xF5B4 0x0F00      CMP      R4,#+8388608
   \   00000084   0xD004             BEQ.N    ??SDIO_GetFlagStatus_0
   \   00000086   0xF240 0x3169      MOVW     R1,#+873
   \   0000008A   0x....             LDR.N    R0,??DataTable25
   \   0000008C   0x.... 0x....      BL       assert_failed
    874            
    875            if ((SDIO->STA & SDIO_FLAG) != (uint32_t)RESET)
   \                     ??SDIO_GetFlagStatus_0: (+1)
   \   00000090   0x....             LDR.N    R0,??DataTable25_25  ;; 0x40012c34
   \   00000092   0x6800             LDR      R0,[R0, #+0]
   \   00000094   0x4220             TST      R0,R4
   \   00000096   0xD002             BEQ.N    ??SDIO_GetFlagStatus_1
    876            {
    877              bitstatus = SET;
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0x0005             MOVS     R5,R0
   \   0000009C   0xE001             B.N      ??SDIO_GetFlagStatus_2
    878            }
    879            else
    880            {
    881              bitstatus = RESET;
   \                     ??SDIO_GetFlagStatus_1: (+1)
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x0005             MOVS     R5,R0
    882            }
    883            return bitstatus;
   \                     ??SDIO_GetFlagStatus_2: (+1)
   \   000000A2   0x0028             MOVS     R0,R5
   \   000000A4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A6   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    884          }
    885          
    886          /**
    887            * @brief  Clears the SDIO's pending flags.
    888            * @param  SDIO_FLAG: specifies the flag to clear.  
    889            *          This parameter can be one or a combination of the following values:
    890            *            @arg SDIO_FLAG_CCRCFAIL: Command response received (CRC check failed)
    891            *            @arg SDIO_FLAG_DCRCFAIL: Data block sent/received (CRC check failed)
    892            *            @arg SDIO_FLAG_CTIMEOUT: Command response timeout
    893            *            @arg SDIO_FLAG_DTIMEOUT: Data timeout
    894            *            @arg SDIO_FLAG_TXUNDERR: Transmit FIFO underrun error
    895            *            @arg SDIO_FLAG_RXOVERR:  Received FIFO overrun error
    896            *            @arg SDIO_FLAG_CMDREND:  Command response received (CRC check passed)
    897            *            @arg SDIO_FLAG_CMDSENT:  Command sent (no response required)
    898            *            @arg SDIO_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is zero)
    899            *            @arg SDIO_FLAG_STBITERR: Start bit not detected on all data signals in wide bus mode
    900            *            @arg SDIO_FLAG_DBCKEND:  Data block sent/received (CRC check passed)
    901            *            @arg SDIO_FLAG_SDIOIT:   SD I/O interrupt received
    902            *            @arg SDIO_FLAG_CEATAEND: CE-ATA command completion signal received for CMD61
    903            * @retval None
    904            */

   \                                 In section .text, align 2, keep-with-next
    905          void SDIO_ClearFlag(uint32_t SDIO_FLAG)
    906          { 
   \                     SDIO_ClearFlag: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    907            /* Check the parameters */
    908            assert_param(IS_SDIO_CLEAR_FLAG(SDIO_FLAG));
   \   00000004   0x....             LDR.N    R0,??DataTable25_26  ;; 0xff3ff800
   \   00000006   0x4204             TST      R4,R0
   \   00000008   0xD101             BNE.N    ??SDIO_ClearFlag_0
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD104             BNE.N    ??SDIO_ClearFlag_1
   \                     ??SDIO_ClearFlag_0: (+1)
   \   0000000E   0xF44F 0x7163      MOV      R1,#+908
   \   00000012   0x....             LDR.N    R0,??DataTable25
   \   00000014   0x.... 0x....      BL       assert_failed
    909             
    910            SDIO->ICR = SDIO_FLAG;
   \                     ??SDIO_ClearFlag_1: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable25_27  ;; 0x40012c38
   \   0000001A   0x6004             STR      R4,[R0, #+0]
    911          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    912          
    913          /**
    914            * @brief  Checks whether the specified SDIO interrupt has occurred or not.
    915            * @param  SDIO_IT: specifies the SDIO interrupt source to check. 
    916            *          This parameter can be one of the following values:
    917            *            @arg SDIO_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
    918            *            @arg SDIO_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
    919            *            @arg SDIO_IT_CTIMEOUT: Command response timeout interrupt
    920            *            @arg SDIO_IT_DTIMEOUT: Data timeout interrupt
    921            *            @arg SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt
    922            *            @arg SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt
    923            *            @arg SDIO_IT_CMDREND:  Command response received (CRC check passed) interrupt
    924            *            @arg SDIO_IT_CMDSENT:  Command sent (no response required) interrupt
    925            *            @arg SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt
    926            *            @arg SDIO_IT_STBITERR: Start bit not detected on all data signals in wide 
    927            *                                   bus mode interrupt
    928            *            @arg SDIO_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt
    929            *            @arg SDIO_IT_CMDACT:   Command transfer in progress interrupt
    930            *            @arg SDIO_IT_TXACT:    Data transmit in progress interrupt
    931            *            @arg SDIO_IT_RXACT:    Data receive in progress interrupt
    932            *            @arg SDIO_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt
    933            *            @arg SDIO_IT_RXFIFOHF: Receive FIFO Half Full interrupt
    934            *            @arg SDIO_IT_TXFIFOF:  Transmit FIFO full interrupt
    935            *            @arg SDIO_IT_RXFIFOF:  Receive FIFO full interrupt
    936            *            @arg SDIO_IT_TXFIFOE:  Transmit FIFO empty interrupt
    937            *            @arg SDIO_IT_RXFIFOE:  Receive FIFO empty interrupt
    938            *            @arg SDIO_IT_TXDAVL:   Data available in transmit FIFO interrupt
    939            *            @arg SDIO_IT_RXDAVL:   Data available in receive FIFO interrupt
    940            *            @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt
    941            *            @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61 interrupt
    942            * @retval The new state of SDIO_IT (SET or RESET).
    943            */

   \                                 In section .text, align 2, keep-with-next
    944          ITStatus SDIO_GetITStatus(uint32_t SDIO_IT)
    945          { 
   \                     SDIO_GetITStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    946            ITStatus bitstatus = RESET;
   \   00000004   0x2500             MOVS     R5,#+0
    947            
    948            /* Check the parameters */
    949            assert_param(IS_SDIO_GET_IT(SDIO_IT));
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD042             BEQ.N    ??SDIO_GetITStatus_0
   \   0000000A   0x2C02             CMP      R4,#+2
   \   0000000C   0xD040             BEQ.N    ??SDIO_GetITStatus_0
   \   0000000E   0x2C04             CMP      R4,#+4
   \   00000010   0xD03E             BEQ.N    ??SDIO_GetITStatus_0
   \   00000012   0x2C08             CMP      R4,#+8
   \   00000014   0xD03C             BEQ.N    ??SDIO_GetITStatus_0
   \   00000016   0x2C10             CMP      R4,#+16
   \   00000018   0xD03A             BEQ.N    ??SDIO_GetITStatus_0
   \   0000001A   0x2C20             CMP      R4,#+32
   \   0000001C   0xD038             BEQ.N    ??SDIO_GetITStatus_0
   \   0000001E   0x2C40             CMP      R4,#+64
   \   00000020   0xD036             BEQ.N    ??SDIO_GetITStatus_0
   \   00000022   0x2C80             CMP      R4,#+128
   \   00000024   0xD034             BEQ.N    ??SDIO_GetITStatus_0
   \   00000026   0xF5B4 0x7F80      CMP      R4,#+256
   \   0000002A   0xD031             BEQ.N    ??SDIO_GetITStatus_0
   \   0000002C   0xF5B4 0x7F00      CMP      R4,#+512
   \   00000030   0xD02E             BEQ.N    ??SDIO_GetITStatus_0
   \   00000032   0xF5B4 0x6F80      CMP      R4,#+1024
   \   00000036   0xD02B             BEQ.N    ??SDIO_GetITStatus_0
   \   00000038   0xF5B4 0x6F00      CMP      R4,#+2048
   \   0000003C   0xD028             BEQ.N    ??SDIO_GetITStatus_0
   \   0000003E   0xF5B4 0x5F80      CMP      R4,#+4096
   \   00000042   0xD025             BEQ.N    ??SDIO_GetITStatus_0
   \   00000044   0xF5B4 0x5F00      CMP      R4,#+8192
   \   00000048   0xD022             BEQ.N    ??SDIO_GetITStatus_0
   \   0000004A   0xF5B4 0x4F80      CMP      R4,#+16384
   \   0000004E   0xD01F             BEQ.N    ??SDIO_GetITStatus_0
   \   00000050   0xF5B4 0x4F00      CMP      R4,#+32768
   \   00000054   0xD01C             BEQ.N    ??SDIO_GetITStatus_0
   \   00000056   0xF5B4 0x3F80      CMP      R4,#+65536
   \   0000005A   0xD019             BEQ.N    ??SDIO_GetITStatus_0
   \   0000005C   0xF5B4 0x3F00      CMP      R4,#+131072
   \   00000060   0xD016             BEQ.N    ??SDIO_GetITStatus_0
   \   00000062   0xF5B4 0x2F80      CMP      R4,#+262144
   \   00000066   0xD013             BEQ.N    ??SDIO_GetITStatus_0
   \   00000068   0xF5B4 0x2F00      CMP      R4,#+524288
   \   0000006C   0xD010             BEQ.N    ??SDIO_GetITStatus_0
   \   0000006E   0xF5B4 0x1F80      CMP      R4,#+1048576
   \   00000072   0xD00D             BEQ.N    ??SDIO_GetITStatus_0
   \   00000074   0xF5B4 0x1F00      CMP      R4,#+2097152
   \   00000078   0xD00A             BEQ.N    ??SDIO_GetITStatus_0
   \   0000007A   0xF5B4 0x0F80      CMP      R4,#+4194304
   \   0000007E   0xD007             BEQ.N    ??SDIO_GetITStatus_0
   \   00000080   0xF5B4 0x0F00      CMP      R4,#+8388608
   \   00000084   0xD004             BEQ.N    ??SDIO_GetITStatus_0
   \   00000086   0xF240 0x31B5      MOVW     R1,#+949
   \   0000008A   0x....             LDR.N    R0,??DataTable25
   \   0000008C   0x.... 0x....      BL       assert_failed
    950            if ((SDIO->STA & SDIO_IT) != (uint32_t)RESET)  
   \                     ??SDIO_GetITStatus_0: (+1)
   \   00000090   0x....             LDR.N    R0,??DataTable25_25  ;; 0x40012c34
   \   00000092   0x6800             LDR      R0,[R0, #+0]
   \   00000094   0x4220             TST      R0,R4
   \   00000096   0xD002             BEQ.N    ??SDIO_GetITStatus_1
    951            {
    952              bitstatus = SET;
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0x0005             MOVS     R5,R0
   \   0000009C   0xE001             B.N      ??SDIO_GetITStatus_2
    953            }
    954            else
    955            {
    956              bitstatus = RESET;
   \                     ??SDIO_GetITStatus_1: (+1)
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x0005             MOVS     R5,R0
    957            }
    958            return bitstatus;
   \                     ??SDIO_GetITStatus_2: (+1)
   \   000000A2   0x0028             MOVS     R0,R5
   \   000000A4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A6   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    959          }
    960          
    961          /**
    962            * @brief  Clears the SDIO's interrupt pending bits.
    963            * @param  SDIO_IT: specifies the interrupt pending bit to clear. 
    964            *          This parameter can be one or a combination of the following values:
    965            *            @arg SDIO_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
    966            *            @arg SDIO_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
    967            *            @arg SDIO_IT_CTIMEOUT: Command response timeout interrupt
    968            *            @arg SDIO_IT_DTIMEOUT: Data timeout interrupt
    969            *            @arg SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt
    970            *            @arg SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt
    971            *            @arg SDIO_IT_CMDREND:  Command response received (CRC check passed) interrupt
    972            *            @arg SDIO_IT_CMDSENT:  Command sent (no response required) interrupt
    973            *            @arg SDIO_IT_DATAEND:  Data end (data counter, SDIO_DCOUNT, is zero) interrupt
    974            *            @arg SDIO_IT_STBITERR: Start bit not detected on all data signals in wide 
    975            *                                   bus mode interrupt
    976            *            @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt
    977            *            @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61
    978            * @retval None
    979            */

   \                                 In section .text, align 2, keep-with-next
    980          void SDIO_ClearITPendingBit(uint32_t SDIO_IT)
    981          { 
   \                     SDIO_ClearITPendingBit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    982            /* Check the parameters */
    983            assert_param(IS_SDIO_CLEAR_IT(SDIO_IT));
   \   00000004   0x....             LDR.N    R0,??DataTable25_26  ;; 0xff3ff800
   \   00000006   0x4204             TST      R4,R0
   \   00000008   0xD101             BNE.N    ??SDIO_ClearITPendingBit_0
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD104             BNE.N    ??SDIO_ClearITPendingBit_1
   \                     ??SDIO_ClearITPendingBit_0: (+1)
   \   0000000E   0xF240 0x31D7      MOVW     R1,#+983
   \   00000012   0x....             LDR.N    R0,??DataTable25
   \   00000014   0x.... 0x....      BL       assert_failed
    984             
    985            SDIO->ICR = SDIO_IT;
   \                     ??SDIO_ClearITPendingBit_1: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable25_27  ;; 0x40012c38
   \   0000001A   0x6004             STR      R4,[R0, #+0]
    986          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \   00000000   0x40012C04         DC32     0x40012c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_2:
   \   00000000   0xFFFF8100         DC32     0xffff8100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_3:
   \   00000000   0x422580A0         DC32     0x422580a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_4:
   \   00000000   0x40012C00         DC32     0x40012c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_5:
   \   00000000   0x40012C08         DC32     0x40012c08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_6:
   \   00000000   0x40012C0C         DC32     0x40012c0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_7:
   \   00000000   0x40012C10         DC32     0x40012c10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_8:
   \   00000000   0x40012C14         DC32     0x40012c14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_9:
   \   00000000   0x40012C24         DC32     0x40012c24

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_10:
   \   00000000   0x40012C28         DC32     0x40012c28

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_11:
   \   00000000   0x40012C2C         DC32     0x40012c2c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_12:
   \   00000000   0x40012C30         DC32     0x40012c30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_13:
   \   00000000   0x40012C80         DC32     0x40012c80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_14:
   \   00000000   0x40012C48         DC32     0x40012c48

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_15:
   \   00000000   0x422585A0         DC32     0x422585a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_16:
   \   00000000   0x422585A4         DC32     0x422585a4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_17:
   \   00000000   0x422585A8         DC32     0x422585a8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_18:
   \   00000000   0x422585AC         DC32     0x422585ac

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_19:
   \   00000000   0x422581AC         DC32     0x422581ac

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_20:
   \   00000000   0x422581B0         DC32     0x422581b0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_21:
   \   00000000   0x422581B4         DC32     0x422581b4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_22:
   \   00000000   0x422581B8         DC32     0x422581b8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_23:
   \   00000000   0x4225858C         DC32     0x4225858c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_24:
   \   00000000   0x40012C3C         DC32     0x40012c3c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_25:
   \   00000000   0x40012C34         DC32     0x40012c34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_26:
   \   00000000   0xFF3FF800         DC32     0xff3ff800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_27:
   \   00000000   0x40012C38         DC32     0x40012c38

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 49H, 41H, 52H, 20H, 57H
   \              0x5C 0x49    
   \              0x41 0x52    
   \              0x20 0x57    
   \   00000008   0x6F 0x72          DC8 6FH, 72H, 6BH, 73H, 70H, 61H, 63H, 65H
   \              0x6B 0x73    
   \              0x70 0x61    
   \              0x63 0x65    
   \   00000010   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 46H, 34H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x46 0x34    
   \   00000018   0x30 0x37          DC8 30H, 37H, 5CH, 53H, 54H, 4DH, 33H, 32H
   \              0x5C 0x53    
   \              0x54 0x4D    
   \              0x33 0x32    
   \   00000020   0x46 0x34          DC8 46H, 34H, 2DH, 44H, 69H, 73H, 63H, 6FH
   \              0x2D 0x44    
   \              0x69 0x73    
   \              0x63 0x6F    
   \   00000028   0x76 0x65          DC8 76H, 65H, 72H, 79H, 5FH, 46H, 57H, 5FH
   \              0x72 0x79    
   \              0x5F 0x46    
   \              0x57 0x5F    
   \   00000030   0x56 0x31          DC8 56H, 31H, 2EH, 31H, 2EH, 30H, 5CH, 4CH
   \              0x2E 0x31    
   \              0x2E 0x30    
   \              0x5C 0x4C    
   \   00000038   0x69 0x62          DC8 69H, 62H, 72H, 61H, 72H, 69H, 65H, 73H
   \              0x72 0x61    
   \              0x72 0x69    
   \              0x65 0x73    
   \   00000040   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 46H, 34H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x46 0x34    
   \   00000048   0x78 0x78          DC8 78H, 78H, 5FH, 53H, 74H, 64H, 50H, 65H
   \              0x5F 0x53    
   \              0x74 0x64    
   \              0x50 0x65    
   \   00000050   0x72 0x69          DC8 72H, 69H, 70H, 68H, 5FH, 44H, 72H, 69H
   \              0x70 0x68    
   \              0x5F 0x44    
   \              0x72 0x69    
   \   00000058   0x76 0x65          DC8 76H, 65H, 72H, 5CH, 73H, 72H, 63H, 5CH
   \              0x72 0x5C    
   \              0x73 0x72    
   \              0x63 0x5C    
   \   00000060   0x73 0x74          DC8 73H, 74H, 6DH, 33H, 32H, 66H, 34H, 78H
   \              0x6D 0x33    
   \              0x32 0x66    
   \              0x34 0x78    
   \   00000068   0x78 0x5F          DC8 78H, 5FH, 73H, 64H, 69H, 6FH, 2EH, 63H
   \              0x73 0x64    
   \              0x69 0x6F    
   \              0x2E 0x63    
   \   00000070   0x00               DC8 0
   \   00000071   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    987          
    988          /**
    989            * @}
    990            */
    991          
    992          /**
    993            * @}
    994            */
    995          
    996          /**
    997            * @}
    998            */
    999          
   1000          /**
   1001            * @}
   1002            */
   1003          
   1004          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   SDIO_CEATAITCmd
         8   -> assert_failed
       8   SDIO_ClearFlag
         8   -> assert_failed
       8   SDIO_ClearITPendingBit
         8   -> assert_failed
       8   SDIO_ClockCmd
         8   -> assert_failed
       0   SDIO_CmdStructInit
       8   SDIO_CommandCompletionCmd
         8   -> assert_failed
       8   SDIO_DMACmd
         8   -> assert_failed
      16   SDIO_DataConfig
        16   -> assert_failed
       0   SDIO_DataStructInit
       8   SDIO_DeInit
         8   -> RCC_APB2PeriphResetCmd
       0   SDIO_GetCommandResponse
       0   SDIO_GetDataCounter
       0   SDIO_GetFIFOCount
      16   SDIO_GetFlagStatus
        16   -> assert_failed
      16   SDIO_GetITStatus
        16   -> assert_failed
       0   SDIO_GetPowerState
      16   SDIO_GetResponse
        16   -> assert_failed
      16   SDIO_ITConfig
        16   -> assert_failed
      16   SDIO_Init
        16   -> assert_failed
       0   SDIO_ReadData
       8   SDIO_SendCEATACmd
         8   -> assert_failed
      16   SDIO_SendCommand
        16   -> assert_failed
       8   SDIO_SendSDIOSuspendCmd
         8   -> assert_failed
       8   SDIO_SetPowerState
         8   -> assert_failed
       8   SDIO_SetSDIOOperation
         8   -> assert_failed
       8   SDIO_SetSDIOReadWaitMode
         8   -> assert_failed
       8   SDIO_StartSDIOReadWait
         8   -> assert_failed
       8   SDIO_StopSDIOReadWait
         8   -> assert_failed
       0   SDIO_StructInit
       0   SDIO_WriteData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_10
       4  ??DataTable25_11
       4  ??DataTable25_12
       4  ??DataTable25_13
       4  ??DataTable25_14
       4  ??DataTable25_15
       4  ??DataTable25_16
       4  ??DataTable25_17
       4  ??DataTable25_18
       4  ??DataTable25_19
       4  ??DataTable25_2
       4  ??DataTable25_20
       4  ??DataTable25_21
       4  ??DataTable25_22
       4  ??DataTable25_23
       4  ??DataTable25_24
       4  ??DataTable25_25
       4  ??DataTable25_26
       4  ??DataTable25_27
       4  ??DataTable25_3
       4  ??DataTable25_4
       4  ??DataTable25_5
       4  ??DataTable25_6
       4  ??DataTable25_7
       4  ??DataTable25_8
       4  ??DataTable25_9
     116  ?_0
      40  SDIO_CEATAITCmd
      30  SDIO_ClearFlag
      30  SDIO_ClearITPendingBit
      38  SDIO_ClockCmd
      22  SDIO_CmdStructInit
      34  SDIO_CommandCompletionCmd
      34  SDIO_DMACmd
     252  SDIO_DataConfig
      28  SDIO_DataStructInit
      24  SDIO_DeInit
      10  SDIO_GetCommandResponse
       8  SDIO_GetDataCounter
       8  SDIO_GetFIFOCount
     168  SDIO_GetFlagStatus
     168  SDIO_GetITStatus
      12  SDIO_GetPowerState
      52  SDIO_GetResponse
      78  SDIO_ITConfig
     190  SDIO_Init
       8  SDIO_ReadData
      34  SDIO_SendCEATACmd
     158  SDIO_SendCommand
      34  SDIO_SendSDIOSuspendCmd
      32  SDIO_SetPowerState
      34  SDIO_SetSDIOOperation
      28  SDIO_SetSDIOReadWaitMode
      36  SDIO_StartSDIOReadWait
      36  SDIO_StopSDIOReadWait
      26  SDIO_StructInit
       8  SDIO_WriteData

 
   116 bytes in section .rodata
 1 772 bytes in section .text
 
 1 772 bytes of CODE  memory
   116 bytes of CONST memory

Errors: none
Warnings: none
