###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       06/May/2016  23:31:34
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\IAR
#        Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rcc.c
#    Command line =  
#        "D:\IAR
#        Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rcc.c"
#        -D USE_STDPERIPH_DRIVER -D STM32F4XX -D USE_FULL_ASSERT -lCN "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\List" -o "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\Obj" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\Include\" -I
#        "D:\IAR Workspace\STM32F407\VCP_ESP\..\Utilities\STM32F4-Discovery\"
#        -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\ST\STM32F4xx\Include\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_conf\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\cdc\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\otg\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\core\" -On --use_c++_inline -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    List file    =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\Debug\List\stm32f4xx_rcc.lst
#    Object file  =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\Debug\Obj\stm32f4xx_rcc.o
#
###############################################################################

D:\IAR Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rcc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_rcc.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    30-September-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Reset and clock control (RCC) peripheral:
      9            *           - Internal/external clocks, PLL, CSS and MCO configuration
     10            *           - System, AHB and APB busses clocks configuration
     11            *           - Peripheral clocks configuration
     12            *           - Interrupts and flags management
     13            *
     14            *  @verbatim
     15            *               
     16            *          ===================================================================
     17            *                               RCC specific features
     18            *          ===================================================================
     19            *    
     20            *          After reset the device is running from Internal High Speed oscillator 
     21            *          (HSI 16MHz) with Flash 0 wait state, Flash prefetch buffer, D-Cache 
     22            *          and I-Cache are disabled, and all peripherals are off except internal
     23            *          SRAM, Flash and JTAG.
     24            *           - There is no prescaler on High speed (AHB) and Low speed (APB) busses;
     25            *             all peripherals mapped on these busses are running at HSI speed.
     26            *       	  - The clock for all peripherals is switched off, except the SRAM and FLASH.
     27            *           - All GPIOs are in input floating state, except the JTAG pins which
     28            *             are assigned to be used for debug purpose.
     29            *        
     30            *          Once the device started from reset, the user application has to:        
     31            *           - Configure the clock source to be used to drive the System clock
     32            *             (if the application needs higher frequency/performance)
     33            *           - Configure the System clock frequency and Flash settings  
     34            *           - Configure the AHB and APB busses prescalers
     35            *           - Enable the clock for the peripheral(s) to be used
     36            *           - Configure the clock source(s) for peripherals which clocks are not
     37            *             derived from the System clock (I2S, RTC, ADC, USB OTG FS/SDIO/RNG)      
     38            *                        
     39            *  @endverbatim
     40            *    
     41            ******************************************************************************
     42            * @attention
     43            *
     44            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     45            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     46            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     47            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     48            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     49            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     50            *
     51            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     52            ******************************************************************************
     53            */
     54          
     55          /* Includes ------------------------------------------------------------------*/
     56          #include "stm32f4xx_rcc.h"
     57          
     58          /** @addtogroup STM32F4xx_StdPeriph_Driver
     59            * @{
     60            */
     61          
     62          /** @defgroup RCC 
     63            * @brief RCC driver modules
     64            * @{
     65            */ 
     66          
     67          /* Private typedef -----------------------------------------------------------*/
     68          /* Private define ------------------------------------------------------------*/
     69          /* ------------ RCC registers bit address in the alias region ----------- */
     70          #define RCC_OFFSET                (RCC_BASE - PERIPH_BASE)
     71          /* --- CR Register ---*/
     72          /* Alias word address of HSION bit */
     73          #define CR_OFFSET                 (RCC_OFFSET + 0x00)
     74          #define HSION_BitNumber           0x00
     75          #define CR_HSION_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (HSION_BitNumber * 4))
     76          /* Alias word address of CSSON bit */
     77          #define CSSON_BitNumber           0x13
     78          #define CR_CSSON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (CSSON_BitNumber * 4))
     79          /* Alias word address of PLLON bit */
     80          #define PLLON_BitNumber           0x18
     81          #define CR_PLLON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLON_BitNumber * 4))
     82          /* Alias word address of PLLI2SON bit */
     83          #define PLLI2SON_BitNumber        0x1A
     84          #define CR_PLLI2SON_BB            (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLI2SON_BitNumber * 4))
     85          
     86          /* --- CFGR Register ---*/
     87          /* Alias word address of I2SSRC bit */
     88          #define CFGR_OFFSET               (RCC_OFFSET + 0x08)
     89          #define I2SSRC_BitNumber          0x17
     90          #define CFGR_I2SSRC_BB            (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (I2SSRC_BitNumber * 4))
     91          
     92          /* --- BDCR Register ---*/
     93          /* Alias word address of RTCEN bit */
     94          #define BDCR_OFFSET               (RCC_OFFSET + 0x70)
     95          #define RTCEN_BitNumber           0x0F
     96          #define BDCR_RTCEN_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (RTCEN_BitNumber * 4))
     97          /* Alias word address of BDRST bit */
     98          #define BDRST_BitNumber           0x10
     99          #define BDCR_BDRST_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (BDRST_BitNumber * 4))
    100          /* --- CSR Register ---*/
    101          /* Alias word address of LSION bit */
    102          #define CSR_OFFSET                (RCC_OFFSET + 0x74)
    103          #define LSION_BitNumber           0x00
    104          #define CSR_LSION_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (LSION_BitNumber * 4))
    105          /* ---------------------- RCC registers bit mask ------------------------ */
    106          /* CFGR register bit mask */
    107          #define CFGR_MCO2_RESET_MASK      ((uint32_t)0x07FFFFFF)
    108          #define CFGR_MCO1_RESET_MASK      ((uint32_t)0xF89FFFFF)
    109          
    110          /* RCC Flag Mask */
    111          #define FLAG_MASK                 ((uint8_t)0x1F)
    112          
    113          /* CR register byte 3 (Bits[23:16]) base address */
    114          #define CR_BYTE3_ADDRESS          ((uint32_t)0x40023802)
    115          
    116          /* CIR register byte 2 (Bits[15:8]) base address */
    117          #define CIR_BYTE2_ADDRESS         ((uint32_t)(RCC_BASE + 0x0C + 0x01))
    118          
    119          /* CIR register byte 3 (Bits[23:16]) base address */
    120          #define CIR_BYTE3_ADDRESS         ((uint32_t)(RCC_BASE + 0x0C + 0x02))
    121          
    122          /* BDCR register base address */
    123          #define BDCR_ADDRESS              (PERIPH_BASE + BDCR_OFFSET)
    124          
    125          /* Private macro -------------------------------------------------------------*/
    126          /* Private variables ---------------------------------------------------------*/

   \                                 In section .data, align 4
    127          static __I uint8_t APBAHBPrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};
   \                     APBAHBPrescTable:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9
   \              0x00 0x00    
   \              0x01 0x02    
   \              0x03 0x04    
   \              0x01 0x02    
   \              0x03 0x04    
   \              0x06 0x07    
   \              0x08 0x09    
    128          
    129          /* Private function prototypes -----------------------------------------------*/
    130          /* Private functions ---------------------------------------------------------*/
    131          
    132          /** @defgroup RCC_Private_Functions
    133            * @{
    134            */ 
    135          
    136          /** @defgroup RCC_Group1 Internal and external clocks, PLL, CSS and MCO configuration functions
    137           *  @brief   Internal and external clocks, PLL, CSS and MCO configuration functions 
    138           *
    139          @verbatim   
    140           ===============================================================================
    141                Internal/external clocks, PLL, CSS and MCO configuration functions
    142           ===============================================================================  
    143          
    144            This section provide functions allowing to configure the internal/external clocks,
    145            PLLs, CSS and MCO pins.
    146            
    147            1. HSI (high-speed internal), 16 MHz factory-trimmed RC used directly or through
    148               the PLL as System clock source.
    149          
    150            2. LSI (low-speed internal), 32 KHz low consumption RC used as IWDG and/or RTC
    151               clock source.
    152          
    153            3. HSE (high-speed external), 4 to 26 MHz crystal oscillator used directly or
    154               through the PLL as System clock source. Can be used also as RTC clock source.
    155          
    156            4. LSE (low-speed external), 32 KHz oscillator used as RTC clock source.   
    157          
    158            5. PLL (clocked by HSI or HSE), featuring two different output clocks:
    159                - The first output is used to generate the high speed system clock (up to 168 MHz)
    160                - The second output is used to generate the clock for the USB OTG FS (48 MHz),
    161                  the random analog generator (<=48 MHz) and the SDIO (<= 48 MHz).
    162          
    163            6. PLLI2S (clocked by HSI or HSE), used to generate an accurate clock to achieve 
    164               high-quality audio performance on the I2S interface.
    165            
    166            7. CSS (Clock security system), once enable and if a HSE clock failure occurs 
    167               (HSE used directly or through PLL as System clock source), the System clock
    168               is automatically switched to HSI and an interrupt is generated if enabled. 
    169               The interrupt is linked to the Cortex-M4 NMI (Non-Maskable Interrupt) 
    170               exception vector.   
    171          
    172            8. MCO1 (microcontroller clock output), used to output HSI, LSE, HSE or PLL
    173               clock (through a configurable prescaler) on PA8 pin.
    174          
    175            9. MCO2 (microcontroller clock output), used to output HSE, PLL, SYSCLK or PLLI2S
    176               clock (through a configurable prescaler) on PC9 pin.
    177          
    178          @endverbatim
    179            * @{
    180            */
    181          
    182          /**
    183            * @brief  Resets the RCC clock configuration to the default reset state.
    184            * @note   The default reset state of the clock configuration is given below:
    185            *            - HSI ON and used as system clock source
    186            *            - HSE, PLL and PLLI2S OFF
    187            *            - AHB, APB1 and APB2 prescaler set to 1.
    188            *            - CSS, MCO1 and MCO2 OFF
    189            *            - All interrupts disabled
    190            * @note   This function doesn't modify the configuration of the
    191            *            - Peripheral clocks
    192            *            - LSI, LSE and RTC clocks 
    193            * @param  None
    194            * @retval None
    195            */

   \                                 In section .text, align 2, keep-with-next
    196          void RCC_DeInit(void)
    197          {
    198            /* Set HSION bit */
    199            RCC->CR |= (uint32_t)0x00000001;
   \                     RCC_DeInit: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable30  ;; 0x40023800
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable30  ;; 0x40023800
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    200          
    201            /* Reset CFGR register */
    202            RCC->CFGR = 0x00000000;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable30_1  ;; 0x40023808
   \   00000016   0x6008             STR      R0,[R1, #+0]
    203          
    204            /* Reset HSEON, CSSON and PLLON bits */
    205            RCC->CR &= (uint32_t)0xFEF6FFFF;
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable30  ;; 0x40023800
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable30_2  ;; 0xfef6ffff
   \   00000022   0x4008             ANDS     R0,R1,R0
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable30  ;; 0x40023800
   \   00000028   0x6008             STR      R0,[R1, #+0]
    206          
    207            /* Reset PLLCFGR register */
    208            RCC->PLLCFGR = 0x24003010;
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable30_3  ;; 0x24003010
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable30_4  ;; 0x40023804
   \   00000032   0x6008             STR      R0,[R1, #+0]
    209          
    210            /* Reset HSEBYP bit */
    211            RCC->CR &= (uint32_t)0xFFFBFFFF;
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable30  ;; 0x40023800
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable30  ;; 0x40023800
   \   00000042   0x6008             STR      R0,[R1, #+0]
    212          
    213            /* Disable all interrupts */
    214            RCC->CIR = 0x00000000;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable37  ;; 0x4002380c
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    215          }
   \   0000004C   0x4770             BX       LR               ;; return
    216          
    217          /**
    218            * @brief  Configures the External High Speed oscillator (HSE).
    219            * @note   After enabling the HSE (RCC_HSE_ON or RCC_HSE_Bypass), the application
    220            *         software should wait on HSERDY flag to be set indicating that HSE clock
    221            *         is stable and can be used to clock the PLL and/or system clock.
    222            * @note   HSE state can not be changed if it is used directly or through the
    223            *         PLL as system clock. In this case, you have to select another source
    224            *         of the system clock then change the HSE state (ex. disable it).
    225            * @note   The HSE is stopped by hardware when entering STOP and STANDBY modes.  
    226            * @note   This function reset the CSSON bit, so if the Clock security system(CSS)
    227            *         was previously enabled you have to enable it again after calling this
    228            *         function.    
    229            * @param  RCC_HSE: specifies the new state of the HSE.
    230            *          This parameter can be one of the following values:
    231            *            @arg RCC_HSE_OFF: turn OFF the HSE oscillator, HSERDY flag goes low after
    232            *                              6 HSE oscillator clock cycles.
    233            *            @arg RCC_HSE_ON: turn ON the HSE oscillator
    234            *            @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock
    235            * @retval None
    236            */

   \                                 In section .text, align 2, keep-with-next
    237          void RCC_HSEConfig(uint8_t RCC_HSE)
    238          {
   \                     RCC_HSEConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    239            /* Check the parameters */
    240            assert_param(IS_RCC_HSE(RCC_HSE));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00A             BEQ.N    ??RCC_HSEConfig_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD007             BEQ.N    ??RCC_HSEConfig_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C05             CMP      R4,#+5
   \   00000014   0xD004             BEQ.N    ??RCC_HSEConfig_0
   \   00000016   0x21F0             MOVS     R1,#+240
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable31
   \   0000001C   0x.... 0x....      BL       assert_failed
    241          
    242            /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
    243            *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
   \                     ??RCC_HSEConfig_0: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable37_1  ;; 0x40023802
   \   00000026   0x7008             STRB     R0,[R1, #+0]
    244          
    245            /* Set the new HSE configuration -------------------------------------------*/
    246            *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable37_1  ;; 0x40023802
   \   0000002C   0x7004             STRB     R4,[R0, #+0]
    247          }
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    248          
    249          /**
    250            * @brief  Waits for HSE start-up.
    251            * @note   This functions waits on HSERDY flag to be set and return SUCCESS if 
    252            *         this flag is set, otherwise returns ERROR if the timeout is reached 
    253            *         and this flag is not set. The timeout value is defined by the constant
    254            *         HSE_STARTUP_TIMEOUT in stm32f4xx.h file. You can tailor it depending
    255            *         on the HSE crystal used in your application. 
    256            * @param  None
    257            * @retval An ErrorStatus enumeration value:
    258            *          - SUCCESS: HSE oscillator is stable and ready to use
    259            *          - ERROR: HSE oscillator not yet ready
    260            */

   \                                 In section .text, align 2, keep-with-next
    261          ErrorStatus RCC_WaitForHSEStartUp(void)
    262          {
   \                     RCC_WaitForHSEStartUp: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    263            __IO uint32_t startupcounter = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9000             STR      R0,[SP, #+0]
    264            ErrorStatus status = ERROR;
   \   00000006   0x2400             MOVS     R4,#+0
    265            FlagStatus hsestatus = RESET;
   \   00000008   0x2500             MOVS     R5,#+0
    266            /* Wait till HSE is ready and if Time out is reached exit */
    267            do
    268            {
    269              hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
   \                     ??RCC_WaitForHSEStartUp_0: (+1)
   \   0000000A   0x2031             MOVS     R0,#+49
   \   0000000C   0x.... 0x....      BL       RCC_GetFlagStatus
   \   00000010   0x0005             MOVS     R5,R0
    270              startupcounter++;
   \   00000012   0x9800             LDR      R0,[SP, #+0]
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   \   00000016   0x9000             STR      R0,[SP, #+0]
    271            } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
   \   00000018   0x9800             LDR      R0,[SP, #+0]
   \   0000001A   0xF5B0 0x6FA0      CMP      R0,#+1280
   \   0000001E   0xD002             BEQ.N    ??RCC_WaitForHSEStartUp_1
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD0F1             BEQ.N    ??RCC_WaitForHSEStartUp_0
    272          
    273            if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
   \                     ??RCC_WaitForHSEStartUp_1: (+1)
   \   00000026   0x2031             MOVS     R0,#+49
   \   00000028   0x.... 0x....      BL       RCC_GetFlagStatus
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD002             BEQ.N    ??RCC_WaitForHSEStartUp_2
    274            {
    275              status = SUCCESS;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x0004             MOVS     R4,R0
   \   00000034   0xE001             B.N      ??RCC_WaitForHSEStartUp_3
    276            }
    277            else
    278            {
    279              status = ERROR;
   \                     ??RCC_WaitForHSEStartUp_2: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x0004             MOVS     R4,R0
    280            }
    281            return (status);
   \                     ??RCC_WaitForHSEStartUp_3: (+1)
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    282          }
    283          
    284          /**
    285            * @brief  Adjusts the Internal High Speed oscillator (HSI) calibration value.
    286            * @note   The calibration is used to compensate for the variations in voltage
    287            *         and temperature that influence the frequency of the internal HSI RC.
    288            * @param  HSICalibrationValue: specifies the calibration trimming value.
    289            *         This parameter must be a number between 0 and 0x1F.
    290            * @retval None
    291            */

   \                                 In section .text, align 2, keep-with-next
    292          void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
    293          {
   \                     RCC_AdjustHSICalibrationValue: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    294            uint32_t tmpreg = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    295            /* Check the parameters */
    296            assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C20             CMP      R4,#+32
   \   0000000A   0xDB05             BLT.N    ??RCC_AdjustHSICalibrationValue_0
   \   0000000C   0xF44F 0x7194      MOV      R1,#+296
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable31
   \   00000014   0x.... 0x....      BL       assert_failed
    297          
    298            tmpreg = RCC->CR;
   \                     ??RCC_AdjustHSICalibrationValue_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable30  ;; 0x40023800
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x0005             MOVS     R5,R0
    299          
    300            /* Clear HSITRIM[4:0] bits */
    301            tmpreg &= ~RCC_CR_HSITRIM;
   \   00000020   0xF035 0x05F8      BICS     R5,R5,#0xF8
    302          
    303            /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
    304            tmpreg |= (uint32_t)HSICalibrationValue << 3;
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0xEA55 0x05C4      ORRS     R5,R5,R4, LSL #+3
    305          
    306            /* Store the new value */
    307            RCC->CR = tmpreg;
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable30  ;; 0x40023800
   \   0000002E   0x6005             STR      R5,[R0, #+0]
    308          }
   \   00000030   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    309          
    310          /**
    311            * @brief  Enables or disables the Internal High Speed oscillator (HSI).
    312            * @note   The HSI is stopped by hardware when entering STOP and STANDBY modes.
    313            *         It is used (enabled by hardware) as system clock source after startup
    314            *         from Reset, wakeup from STOP and STANDBY mode, or in case of failure
    315            *         of the HSE used directly or indirectly as system clock (if the Clock
    316            *         Security System CSS is enabled).             
    317            * @note   HSI can not be stopped if it is used as system clock source. In this case,
    318            *         you have to select another source of the system clock then stop the HSI.  
    319            * @note   After enabling the HSI, the application software should wait on HSIRDY
    320            *         flag to be set indicating that HSI clock is stable and can be used as
    321            *         system clock source.  
    322            * @param  NewState: new state of the HSI.
    323            *          This parameter can be: ENABLE or DISABLE.
    324            * @note   When the HSI is stopped, HSIRDY flag goes low after 6 HSI oscillator
    325            *         clock cycles.  
    326            * @retval None
    327            */

   \                                 In section .text, align 2, keep-with-next
    328          void RCC_HSICmd(FunctionalState NewState)
    329          {
   \                     RCC_HSICmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    330            /* Check the parameters */
    331            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??RCC_HSICmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??RCC_HSICmd_0
   \   00000010   0xF240 0x114B      MOVW     R1,#+331
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable31
   \   00000018   0x.... 0x....      BL       assert_failed
    332          
    333            *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
   \                     ??RCC_HSICmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable38  ;; 0x42470000
   \   00000022   0x6004             STR      R4,[R0, #+0]
    334          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    335          
    336          /**
    337            * @brief  Configures the External Low Speed oscillator (LSE).
    338            * @note   As the LSE is in the Backup domain and write access is denied to
    339            *         this domain after reset, you have to enable write access using 
    340            *         PWR_BackupAccessCmd(ENABLE) function before to configure the LSE
    341            *         (to be done once after reset).  
    342            * @note   After enabling the LSE (RCC_LSE_ON or RCC_LSE_Bypass), the application
    343            *         software should wait on LSERDY flag to be set indicating that LSE clock
    344            *         is stable and can be used to clock the RTC.
    345            * @param  RCC_LSE: specifies the new state of the LSE.
    346            *          This parameter can be one of the following values:
    347            *            @arg RCC_LSE_OFF: turn OFF the LSE oscillator, LSERDY flag goes low after
    348            *                              6 LSE oscillator clock cycles.
    349            *            @arg RCC_LSE_ON: turn ON the LSE oscillator
    350            *            @arg RCC_LSE_Bypass: LSE oscillator bypassed with external clock
    351            * @retval None
    352            */

   \                                 In section .text, align 2, keep-with-next
    353          void RCC_LSEConfig(uint8_t RCC_LSE)
    354          {
   \                     RCC_LSEConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    355            /* Check the parameters */
    356            assert_param(IS_RCC_LSE(RCC_LSE));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00B             BEQ.N    ??RCC_LSEConfig_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD008             BEQ.N    ??RCC_LSEConfig_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C04             CMP      R4,#+4
   \   00000014   0xD005             BEQ.N    ??RCC_LSEConfig_0
   \   00000016   0xF44F 0x71B2      MOV      R1,#+356
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable31
   \   0000001E   0x.... 0x....      BL       assert_failed
    357          
    358            /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
    359            /* Reset LSEON bit */
    360            *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
   \                     ??RCC_LSEConfig_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable38_1  ;; 0x40023870
   \   00000028   0x7008             STRB     R0,[R1, #+0]
    361          
    362            /* Reset LSEBYP bit */
    363            *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable38_1  ;; 0x40023870
   \   00000030   0x7008             STRB     R0,[R1, #+0]
    364          
    365            /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
    366            switch (RCC_LSE)
   \   00000032   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD002             BEQ.N    ??RCC_LSEConfig_1
   \   0000003A   0x2804             CMP      R0,#+4
   \   0000003C   0xD005             BEQ.N    ??RCC_LSEConfig_2
   \   0000003E   0xE009             B.N      ??RCC_LSEConfig_3
    367            {
    368              case RCC_LSE_ON:
    369                /* Set LSEON bit */
    370                *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
   \                     ??RCC_LSEConfig_1: (+1)
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable38_1  ;; 0x40023870
   \   00000046   0x7008             STRB     R0,[R1, #+0]
    371                break;
   \   00000048   0xE004             B.N      ??RCC_LSEConfig_4
    372              case RCC_LSE_Bypass:
    373                /* Set LSEBYP and LSEON bits */
    374                *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
   \                     ??RCC_LSEConfig_2: (+1)
   \   0000004A   0x2005             MOVS     R0,#+5
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable38_1  ;; 0x40023870
   \   00000050   0x7008             STRB     R0,[R1, #+0]
    375                break;
   \   00000052   0xE7FF             B.N      ??RCC_LSEConfig_4
    376              default:
    377                break;
    378            }
    379          }
   \                     ??RCC_LSEConfig_3: (+1)
   \                     ??RCC_LSEConfig_4: (+1)
   \   00000054   0xBD10             POP      {R4,PC}          ;; return
    380          
    381          /**
    382            * @brief  Enables or disables the Internal Low Speed oscillator (LSI).
    383            * @note   After enabling the LSI, the application software should wait on 
    384            *         LSIRDY flag to be set indicating that LSI clock is stable and can
    385            *         be used to clock the IWDG and/or the RTC.
    386            * @note   LSI can not be disabled if the IWDG is running.  
    387            * @param  NewState: new state of the LSI.
    388            *          This parameter can be: ENABLE or DISABLE.
    389            * @note   When the LSI is stopped, LSIRDY flag goes low after 6 LSI oscillator
    390            *         clock cycles. 
    391            * @retval None
    392            */

   \                                 In section .text, align 2, keep-with-next
    393          void RCC_LSICmd(FunctionalState NewState)
    394          {
   \                     RCC_LSICmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    395            /* Check the parameters */
    396            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??RCC_LSICmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??RCC_LSICmd_0
   \   00000010   0xF44F 0x71C6      MOV      R1,#+396
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable31
   \   00000018   0x.... 0x....      BL       assert_failed
    397          
    398            *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
   \                     ??RCC_LSICmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable40  ;; 0x42470e80
   \   00000022   0x6004             STR      R4,[R0, #+0]
    399          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    400          
    401          /**
    402            * @brief  Configures the main PLL clock source, multiplication and division factors.
    403            * @note   This function must be used only when the main PLL is disabled.
    404            *  
    405            * @param  RCC_PLLSource: specifies the PLL entry clock source.
    406            *          This parameter can be one of the following values:
    407            *            @arg RCC_PLLSource_HSI: HSI oscillator clock selected as PLL clock entry
    408            *            @arg RCC_PLLSource_HSE: HSE oscillator clock selected as PLL clock entry
    409            * @note   This clock source (RCC_PLLSource) is common for the main PLL and PLLI2S.  
    410            *  
    411            * @param  PLLM: specifies the division factor for PLL VCO input clock
    412            *          This parameter must be a number between 0 and 63.
    413            * @note   You have to set the PLLM parameter correctly to ensure that the VCO input
    414            *         frequency ranges from 1 to 2 MHz. It is recommended to select a frequency
    415            *         of 2 MHz to limit PLL jitter.
    416            *  
    417            * @param  PLLN: specifies the multiplication factor for PLL VCO output clock
    418            *          This parameter must be a number between 192 and 432.
    419            * @note   You have to set the PLLN parameter correctly to ensure that the VCO
    420            *         output frequency is between 192 and 432 MHz.
    421            *   
    422            * @param  PLLP: specifies the division factor for main system clock (SYSCLK)
    423            *          This parameter must be a number in the range {2, 4, 6, or 8}.
    424            * @note   You have to set the PLLP parameter correctly to not exceed 168 MHz on
    425            *         the System clock frequency.
    426            *  
    427            * @param  PLLQ: specifies the division factor for OTG FS, SDIO and RNG clocks
    428            *          This parameter must be a number between 4 and 15.
    429            * @note   If the USB OTG FS is used in your application, you have to set the
    430            *         PLLQ parameter correctly to have 48 MHz clock for the USB. However,
    431            *         the SDIO and RNG need a frequency lower than or equal to 48 MHz to work
    432            *         correctly.
    433            *   
    434            * @retval None
    435            */

   \                                 In section .text, align 2, keep-with-next
    436          void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ)
    437          {
   \                     RCC_PLLConfig: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0xF8DD 0x8018      LDR      R8,[SP, #+24]
    438            /* Check the parameters */
    439            assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD008             BEQ.N    ??RCC_PLLConfig_0
   \   00000014   0xF5B4 0x0F80      CMP      R4,#+4194304
   \   00000018   0xD005             BEQ.N    ??RCC_PLLConfig_0
   \   0000001A   0xF240 0x11B7      MOVW     R1,#+439
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable31
   \   00000022   0x.... 0x....      BL       assert_failed
    440            assert_param(IS_RCC_PLLM_VALUE(PLLM));
   \                     ??RCC_PLLConfig_0: (+1)
   \   00000026   0x2D40             CMP      R5,#+64
   \   00000028   0xD305             BCC.N    ??RCC_PLLConfig_1
   \   0000002A   0xF44F 0x71DC      MOV      R1,#+440
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable31
   \   00000032   0x.... 0x....      BL       assert_failed
    441            assert_param(IS_RCC_PLLN_VALUE(PLLN));
   \                     ??RCC_PLLConfig_1: (+1)
   \   00000036   0x2EC0             CMP      R6,#+192
   \   00000038   0xD302             BCC.N    ??RCC_PLLConfig_2
   \   0000003A   0xF5B6 0x7FD8      CMP      R6,#+432
   \   0000003E   0xD905             BLS.N    ??RCC_PLLConfig_3
   \                     ??RCC_PLLConfig_2: (+1)
   \   00000040   0xF240 0x11B9      MOVW     R1,#+441
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable31
   \   00000048   0x.... 0x....      BL       assert_failed
    442            assert_param(IS_RCC_PLLP_VALUE(PLLP));
   \                     ??RCC_PLLConfig_3: (+1)
   \   0000004C   0x2F02             CMP      R7,#+2
   \   0000004E   0xD00B             BEQ.N    ??RCC_PLLConfig_4
   \   00000050   0x2F04             CMP      R7,#+4
   \   00000052   0xD009             BEQ.N    ??RCC_PLLConfig_4
   \   00000054   0x2F06             CMP      R7,#+6
   \   00000056   0xD007             BEQ.N    ??RCC_PLLConfig_4
   \   00000058   0x2F08             CMP      R7,#+8
   \   0000005A   0xD005             BEQ.N    ??RCC_PLLConfig_4
   \   0000005C   0xF44F 0x71DD      MOV      R1,#+442
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable31
   \   00000064   0x.... 0x....      BL       assert_failed
    443            assert_param(IS_RCC_PLLQ_VALUE(PLLQ));
   \                     ??RCC_PLLConfig_4: (+1)
   \   00000068   0xF1B8 0x0F04      CMP      R8,#+4
   \   0000006C   0xD302             BCC.N    ??RCC_PLLConfig_5
   \   0000006E   0xF1B8 0x0F10      CMP      R8,#+16
   \   00000072   0xD305             BCC.N    ??RCC_PLLConfig_6
   \                     ??RCC_PLLConfig_5: (+1)
   \   00000074   0xF240 0x11BB      MOVW     R1,#+443
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable31
   \   0000007C   0x.... 0x....      BL       assert_failed
    444          
    445            RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
    446                           (PLLQ << 24);
   \                     ??RCC_PLLConfig_6: (+1)
   \   00000080   0xEA55 0x1086      ORRS     R0,R5,R6, LSL #+6
   \   00000084   0x1EB9             SUBS     R1,R7,#+2
   \   00000086   0x03C9             LSLS     R1,R1,#+15
   \   00000088   0x0C09             LSRS     R1,R1,#+16
   \   0000008A   0x0409             LSLS     R1,R1,#+16
   \   0000008C   0x4308             ORRS     R0,R1,R0
   \   0000008E   0x4320             ORRS     R0,R4,R0
   \   00000090   0xEA50 0x6008      ORRS     R0,R0,R8, LSL #+24
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable30_4  ;; 0x40023804
   \   00000098   0x6008             STR      R0,[R1, #+0]
    447          }
   \   0000009A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    448          
    449          /**
    450            * @brief  Enables or disables the main PLL.
    451            * @note   After enabling the main PLL, the application software should wait on 
    452            *         PLLRDY flag to be set indicating that PLL clock is stable and can
    453            *         be used as system clock source.
    454            * @note   The main PLL can not be disabled if it is used as system clock source
    455            * @note   The main PLL is disabled by hardware when entering STOP and STANDBY modes.
    456            * @param  NewState: new state of the main PLL. This parameter can be: ENABLE or DISABLE.
    457            * @retval None
    458            */

   \                                 In section .text, align 2, keep-with-next
    459          void RCC_PLLCmd(FunctionalState NewState)
    460          {
   \                     RCC_PLLCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    461            /* Check the parameters */
    462            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??RCC_PLLCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??RCC_PLLCmd_0
   \   00000010   0xF44F 0x71E7      MOV      R1,#+462
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable31
   \   00000018   0x.... 0x....      BL       assert_failed
    463            *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
   \                     ??RCC_PLLCmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable41  ;; 0x42470060
   \   00000022   0x6004             STR      R4,[R0, #+0]
    464          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    465          
    466          /**
    467            * @brief  Configures the PLLI2S clock multiplication and division factors.
    468            *  
    469            * @note   This function must be used only when the PLLI2S is disabled.
    470            * @note   PLLI2S clock source is common with the main PLL (configured in 
    471            *         RCC_PLLConfig function )  
    472            *             
    473            * @param  PLLI2SN: specifies the multiplication factor for PLLI2S VCO output clock
    474            *          This parameter must be a number between 192 and 432.
    475            * @note   You have to set the PLLI2SN parameter correctly to ensure that the VCO 
    476            *         output frequency is between 192 and 432 MHz.
    477            *    
    478            * @param  PLLI2SR: specifies the division factor for I2S clock
    479            *          This parameter must be a number between 2 and 7.
    480            * @note   You have to set the PLLI2SR parameter correctly to not exceed 192 MHz
    481            *         on the I2S clock frequency.
    482            *   
    483            * @retval None
    484            */

   \                                 In section .text, align 2, keep-with-next
    485          void RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SR)
    486          {
   \                     RCC_PLLI2SConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    487            /* Check the parameters */
    488            assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
   \   00000006   0x2CC0             CMP      R4,#+192
   \   00000008   0xD302             BCC.N    ??RCC_PLLI2SConfig_0
   \   0000000A   0xF5B4 0x7FD8      CMP      R4,#+432
   \   0000000E   0xD905             BLS.N    ??RCC_PLLI2SConfig_1
   \                     ??RCC_PLLI2SConfig_0: (+1)
   \   00000010   0xF44F 0x71F4      MOV      R1,#+488
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable31
   \   00000018   0x.... 0x....      BL       assert_failed
    489            assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));
   \                     ??RCC_PLLI2SConfig_1: (+1)
   \   0000001C   0x2D02             CMP      R5,#+2
   \   0000001E   0xD301             BCC.N    ??RCC_PLLI2SConfig_2
   \   00000020   0x2D08             CMP      R5,#+8
   \   00000022   0xD305             BCC.N    ??RCC_PLLI2SConfig_3
   \                     ??RCC_PLLI2SConfig_2: (+1)
   \   00000024   0xF240 0x11E9      MOVW     R1,#+489
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable31
   \   0000002C   0x.... 0x....      BL       assert_failed
    490          
    491            RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
   \                     ??RCC_PLLI2SConfig_3: (+1)
   \   00000030   0x0728             LSLS     R0,R5,#+28
   \   00000032   0xEA50 0x1084      ORRS     R0,R0,R4, LSL #+6
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable42  ;; 0x40023884
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    492          }
   \   0000003C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    493          
    494          /**
    495            * @brief  Enables or disables the PLLI2S. 
    496            * @note   The PLLI2S is disabled by hardware when entering STOP and STANDBY modes.  
    497            * @param  NewState: new state of the PLLI2S. This parameter can be: ENABLE or DISABLE.
    498            * @retval None
    499            */

   \                                 In section .text, align 2, keep-with-next
    500          void RCC_PLLI2SCmd(FunctionalState NewState)
    501          {
   \                     RCC_PLLI2SCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    502            /* Check the parameters */
    503            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??RCC_PLLI2SCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??RCC_PLLI2SCmd_0
   \   00000010   0xF240 0x11F7      MOVW     R1,#+503
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable31
   \   00000018   0x.... 0x....      BL       assert_failed
    504            *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
   \                     ??RCC_PLLI2SCmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable42_1  ;; 0x42470068
   \   00000022   0x6004             STR      R4,[R0, #+0]
    505          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    506          
    507          /**
    508            * @brief  Enables or disables the Clock Security System.
    509            * @note   If a failure is detected on the HSE oscillator clock, this oscillator
    510            *         is automatically disabled and an interrupt is generated to inform the
    511            *         software about the failure (Clock Security System Interrupt, CSSI),
    512            *         allowing the MCU to perform rescue operations. The CSSI is linked to 
    513            *         the Cortex-M4 NMI (Non-Maskable Interrupt) exception vector.  
    514            * @param  NewState: new state of the Clock Security System.
    515            *         This parameter can be: ENABLE or DISABLE.
    516            * @retval None
    517            */

   \                                 In section .text, align 2, keep-with-next
    518          void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
    519          {
   \                     RCC_ClockSecuritySystemCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    520            /* Check the parameters */
    521            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??RCC_ClockSecuritySystemCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??RCC_ClockSecuritySystemCmd_0
   \   00000010   0xF240 0x2109      MOVW     R1,#+521
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable31
   \   00000018   0x.... 0x....      BL       assert_failed
    522            *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
   \                     ??RCC_ClockSecuritySystemCmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable42_2  ;; 0x4247004c
   \   00000022   0x6004             STR      R4,[R0, #+0]
    523          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    524          
    525          /**
    526            * @brief  Selects the clock source to output on MCO1 pin(PA8).
    527            * @note   PA8 should be configured in alternate function mode.
    528            * @param  RCC_MCO1Source: specifies the clock source to output.
    529            *          This parameter can be one of the following values:
    530            *            @arg RCC_MCO1Source_HSI: HSI clock selected as MCO1 source
    531            *            @arg RCC_MCO1Source_LSE: LSE clock selected as MCO1 source
    532            *            @arg RCC_MCO1Source_HSE: HSE clock selected as MCO1 source
    533            *            @arg RCC_MCO1Source_PLLCLK: main PLL clock selected as MCO1 source
    534            * @param  RCC_MCO1Div: specifies the MCO1 prescaler.
    535            *          This parameter can be one of the following values:
    536            *            @arg RCC_MCO1Div_1: no division applied to MCO1 clock
    537            *            @arg RCC_MCO1Div_2: division by 2 applied to MCO1 clock
    538            *            @arg RCC_MCO1Div_3: division by 3 applied to MCO1 clock
    539            *            @arg RCC_MCO1Div_4: division by 4 applied to MCO1 clock
    540            *            @arg RCC_MCO1Div_5: division by 5 applied to MCO1 clock
    541            * @retval None
    542            */

   \                                 In section .text, align 2, keep-with-next
    543          void RCC_MCO1Config(uint32_t RCC_MCO1Source, uint32_t RCC_MCO1Div)
    544          {
   \                     RCC_MCO1Config: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    545            uint32_t tmpreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    546            
    547            /* Check the parameters */
    548            assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD00E             BEQ.N    ??RCC_MCO1Config_0
   \   0000000C   0xF5B4 0x1F00      CMP      R4,#+2097152
   \   00000010   0xD00B             BEQ.N    ??RCC_MCO1Config_0
   \   00000012   0xF5B4 0x0F80      CMP      R4,#+4194304
   \   00000016   0xD008             BEQ.N    ??RCC_MCO1Config_0
   \   00000018   0xF5B4 0x0FC0      CMP      R4,#+6291456
   \   0000001C   0xD005             BEQ.N    ??RCC_MCO1Config_0
   \   0000001E   0xF44F 0x7109      MOV      R1,#+548
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable31
   \   00000026   0x.... 0x....      BL       assert_failed
    549            assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  
   \                     ??RCC_MCO1Config_0: (+1)
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD011             BEQ.N    ??RCC_MCO1Config_1
   \   0000002E   0xF1B5 0x6F80      CMP      R5,#+67108864
   \   00000032   0xD00E             BEQ.N    ??RCC_MCO1Config_1
   \   00000034   0xF1B5 0x6FA0      CMP      R5,#+83886080
   \   00000038   0xD00B             BEQ.N    ??RCC_MCO1Config_1
   \   0000003A   0xF1B5 0x6FC0      CMP      R5,#+100663296
   \   0000003E   0xD008             BEQ.N    ??RCC_MCO1Config_1
   \   00000040   0xF1B5 0x6FE0      CMP      R5,#+117440512
   \   00000044   0xD005             BEQ.N    ??RCC_MCO1Config_1
   \   00000046   0xF240 0x2125      MOVW     R1,#+549
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable31
   \   0000004E   0x.... 0x....      BL       assert_failed
    550          
    551            tmpreg = RCC->CFGR;
   \                     ??RCC_MCO1Config_1: (+1)
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable30_1  ;; 0x40023808
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x0006             MOVS     R6,R0
    552          
    553            /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
    554            tmpreg &= CFGR_MCO1_RESET_MASK;
   \   0000005A   0xF036 0x66EC      BICS     R6,R6,#0x7600000
    555          
    556            /* Select MCO1 clock source and prescaler */
    557            tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
   \   0000005E   0xEA55 0x0004      ORRS     R0,R5,R4
   \   00000062   0x4306             ORRS     R6,R0,R6
    558          
    559            /* Store the new value */
    560            RCC->CFGR = tmpreg;  
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable30_1  ;; 0x40023808
   \   00000068   0x6006             STR      R6,[R0, #+0]
    561          }
   \   0000006A   0xBD70             POP      {R4-R6,PC}       ;; return
    562          
    563          /**
    564            * @brief  Selects the clock source to output on MCO2 pin(PC9).
    565            * @note   PC9 should be configured in alternate function mode.
    566            * @param  RCC_MCO2Source: specifies the clock source to output.
    567            *          This parameter can be one of the following values:
    568            *            @arg RCC_MCO2Source_SYSCLK: System clock (SYSCLK) selected as MCO2 source
    569            *            @arg RCC_MCO2Source_PLLI2SCLK: PLLI2S clock selected as MCO2 source
    570            *            @arg RCC_MCO2Source_HSE: HSE clock selected as MCO2 source
    571            *            @arg RCC_MCO2Source_PLLCLK: main PLL clock selected as MCO2 source
    572            * @param  RCC_MCO2Div: specifies the MCO2 prescaler.
    573            *          This parameter can be one of the following values:
    574            *            @arg RCC_MCO2Div_1: no division applied to MCO2 clock
    575            *            @arg RCC_MCO2Div_2: division by 2 applied to MCO2 clock
    576            *            @arg RCC_MCO2Div_3: division by 3 applied to MCO2 clock
    577            *            @arg RCC_MCO2Div_4: division by 4 applied to MCO2 clock
    578            *            @arg RCC_MCO2Div_5: division by 5 applied to MCO2 clock
    579            * @retval None
    580            */

   \                                 In section .text, align 2, keep-with-next
    581          void RCC_MCO2Config(uint32_t RCC_MCO2Source, uint32_t RCC_MCO2Div)
    582          {
   \                     RCC_MCO2Config: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    583            uint32_t tmpreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    584            
    585            /* Check the parameters */
    586            assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD00E             BEQ.N    ??RCC_MCO2Config_0
   \   0000000C   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   00000010   0xD00B             BEQ.N    ??RCC_MCO2Config_0
   \   00000012   0xF1B4 0x4F00      CMP      R4,#-2147483648
   \   00000016   0xD008             BEQ.N    ??RCC_MCO2Config_0
   \   00000018   0xF114 0x4F80      CMN      R4,#+1073741824
   \   0000001C   0xD005             BEQ.N    ??RCC_MCO2Config_0
   \   0000001E   0xF240 0x214A      MOVW     R1,#+586
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable31
   \   00000026   0x.... 0x....      BL       assert_failed
    587            assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
   \                     ??RCC_MCO2Config_0: (+1)
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD011             BEQ.N    ??RCC_MCO2Config_1
   \   0000002E   0xF1B5 0x5F00      CMP      R5,#+536870912
   \   00000032   0xD00E             BEQ.N    ??RCC_MCO2Config_1
   \   00000034   0xF1B5 0x5F20      CMP      R5,#+671088640
   \   00000038   0xD00B             BEQ.N    ??RCC_MCO2Config_1
   \   0000003A   0xF1B5 0x5F40      CMP      R5,#+805306368
   \   0000003E   0xD008             BEQ.N    ??RCC_MCO2Config_1
   \   00000040   0xF1B5 0x5F60      CMP      R5,#+939524096
   \   00000044   0xD005             BEQ.N    ??RCC_MCO2Config_1
   \   00000046   0xF240 0x214B      MOVW     R1,#+587
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable31
   \   0000004E   0x.... 0x....      BL       assert_failed
    588            
    589            tmpreg = RCC->CFGR;
   \                     ??RCC_MCO2Config_1: (+1)
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable30_1  ;; 0x40023808
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x0006             MOVS     R6,R0
    590            
    591            /* Clear MCO2 and MCO2PRE[2:0] bits */
    592            tmpreg &= CFGR_MCO2_RESET_MASK;
   \   0000005A   0x0176             LSLS     R6,R6,#+5        ;; ZeroExtS R6,R6,#+5,#+5
   \   0000005C   0x0976             LSRS     R6,R6,#+5
    593          
    594            /* Select MCO2 clock source and prescaler */
    595            tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
   \   0000005E   0xEA55 0x0004      ORRS     R0,R5,R4
   \   00000062   0x4306             ORRS     R6,R0,R6
    596          
    597            /* Store the new value */
    598            RCC->CFGR = tmpreg;  
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable30_1  ;; 0x40023808
   \   00000068   0x6006             STR      R6,[R0, #+0]
    599          }
   \   0000006A   0xBD70             POP      {R4-R6,PC}       ;; return
    600          
    601          /**
    602            * @}
    603            */
    604          
    605          /** @defgroup RCC_Group2 System AHB and APB busses clocks configuration functions
    606           *  @brief   System, AHB and APB busses clocks configuration functions
    607           *
    608          @verbatim   
    609           ===============================================================================
    610                       System, AHB and APB busses clocks configuration functions
    611           ===============================================================================  
    612          
    613            This section provide functions allowing to configure the System, AHB, APB1 and 
    614            APB2 busses clocks.
    615            
    616            1. Several clock sources can be used to drive the System clock (SYSCLK): HSI,
    617               HSE and PLL.
    618               The AHB clock (HCLK) is derived from System clock through configurable prescaler
    619               and used to clock the CPU, memory and peripherals mapped on AHB bus (DMA, GPIO...).
    620               APB1 (PCLK1) and APB2 (PCLK2) clocks are derived from AHB clock through 
    621               configurable prescalers and used to clock the peripherals mapped on these busses.
    622               You can use "RCC_GetClocksFreq()" function to retrieve the frequencies of these clocks.  
    623          
    624          @note All the peripheral clocks are derived from the System clock (SYSCLK) except:
    625                 - I2S: the I2S clock can be derived either from a specific PLL (PLLI2S) or
    626                    from an external clock mapped on the I2S_CKIN pin. 
    627                    You have to use RCC_I2SCLKConfig() function to configure this clock. 
    628                 - RTC: the RTC clock can be derived either from the LSI, LSE or HSE clock
    629                    divided by 2 to 31. You have to use RCC_RTCCLKConfig() and RCC_RTCCLKCmd()
    630                    functions to configure this clock. 
    631                 - USB OTG FS, SDIO and RTC: USB OTG FS require a frequency equal to 48 MHz
    632                    to work correctly, while the SDIO require a frequency equal or lower than
    633                    to 48. This clock is derived of the main PLL through PLLQ divider.
    634                 - IWDG clock which is always the LSI clock.
    635                 
    636            2. The maximum frequency of the SYSCLK and HCLK is 168 MHz, PCLK2 82 MHz and PCLK1 42 MHz.
    637               Depending on the device voltage range, the maximum frequency should be 
    638               adapted accordingly:
    639           +-------------------------------------------------------------------------------------+     
    640           | Latency       |                HCLK clock frequency (MHz)                           |
    641           |               |---------------------------------------------------------------------|     
    642           |               | voltage range  | voltage range  | voltage range   | voltage range   |
    643           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
    644           |---------------|----------------|----------------|-----------------|-----------------|              
    645           |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 18   |0 < HCLK <= 16   |
    646           |---------------|----------------|----------------|-----------------|-----------------|   
    647           |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |18 < HCLK <= 36  |16 < HCLK <= 32  | 
    648           |---------------|----------------|----------------|-----------------|-----------------|   
    649           |2WS(3CPU cycle)|60 < HCLK <= 90 |48 < HCLK <= 72 |36 < HCLK <= 54  |32 < HCLK <= 48  |
    650           |---------------|----------------|----------------|-----------------|-----------------| 
    651           |3WS(4CPU cycle)|90 < HCLK <= 120|72 < HCLK <= 96 |54 < HCLK <= 72  |48 < HCLK <= 64  |
    652           |---------------|----------------|----------------|-----------------|-----------------| 
    653           |4WS(5CPU cycle)|120< HCLK <= 150|96 < HCLK <= 120|72 < HCLK <= 90  |64 < HCLK <= 80  |
    654           |---------------|----------------|----------------|-----------------|-----------------| 
    655           |5WS(6CPU cycle)|120< HCLK <= 168|120< HCLK <= 144|90 < HCLK <= 108 |80 < HCLK <= 96  | 
    656           |---------------|----------------|----------------|-----------------|-----------------| 
    657           |6WS(7CPU cycle)|      NA        |144< HCLK <= 168|108 < HCLK <= 120|96 < HCLK <= 112 | 
    658           |---------------|----------------|----------------|-----------------|-----------------| 
    659           |7WS(8CPU cycle)|      NA        |      NA        |120 < HCLK <= 138|112 < HCLK <= 120| 
    660           +-------------------------------------------------------------------------------------+    
    661             @note When VOS bit (in PWR_CR register) is reset to '0, the maximum value of HCLK is 144 MHz.
    662                   You can use PWR_MainRegulatorModeConfig() function to set or reset this bit.
    663          
    664          @endverbatim
    665            * @{
    666            */
    667          
    668          /**
    669            * @brief  Configures the system clock (SYSCLK).
    670            * @note   The HSI is used (enabled by hardware) as system clock source after
    671            *         startup from Reset, wake-up from STOP and STANDBY mode, or in case
    672            *         of failure of the HSE used directly or indirectly as system clock
    673            *         (if the Clock Security System CSS is enabled).
    674            * @note   A switch from one clock source to another occurs only if the target
    675            *         clock source is ready (clock stable after startup delay or PLL locked). 
    676            *         If a clock source which is not yet ready is selected, the switch will
    677            *         occur when the clock source will be ready. 
    678            *         You can use RCC_GetSYSCLKSource() function to know which clock is
    679            *         currently used as system clock source. 
    680            * @param  RCC_SYSCLKSource: specifies the clock source used as system clock.
    681            *          This parameter can be one of the following values:
    682            *            @arg RCC_SYSCLKSource_HSI:    HSI selected as system clock source
    683            *            @arg RCC_SYSCLKSource_HSE:    HSE selected as system clock source
    684            *            @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock source
    685            * @retval None
    686            */

   \                                 In section .text, align 2, keep-with-next
    687          void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
    688          {
   \                     RCC_SYSCLKConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    689            uint32_t tmpreg = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    690          
    691            /* Check the parameters */
    692            assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD009             BEQ.N    ??RCC_SYSCLKConfig_0
   \   0000000A   0x2C01             CMP      R4,#+1
   \   0000000C   0xD007             BEQ.N    ??RCC_SYSCLKConfig_0
   \   0000000E   0x2C02             CMP      R4,#+2
   \   00000010   0xD005             BEQ.N    ??RCC_SYSCLKConfig_0
   \   00000012   0xF44F 0x712D      MOV      R1,#+692
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable31
   \   0000001A   0x.... 0x....      BL       assert_failed
    693          
    694            tmpreg = RCC->CFGR;
   \                     ??RCC_SYSCLKConfig_0: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable30_1  ;; 0x40023808
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x0005             MOVS     R5,R0
    695          
    696            /* Clear SW[1:0] bits */
    697            tmpreg &= ~RCC_CFGR_SW;
   \   00000026   0x08AD             LSRS     R5,R5,#+2
   \   00000028   0x00AD             LSLS     R5,R5,#+2
    698          
    699            /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
    700            tmpreg |= RCC_SYSCLKSource;
   \   0000002A   0x4325             ORRS     R5,R4,R5
    701          
    702            /* Store the new value */
    703            RCC->CFGR = tmpreg;
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable30_1  ;; 0x40023808
   \   00000030   0x6005             STR      R5,[R0, #+0]
    704          }
   \   00000032   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    705          
    706          /**
    707            * @brief  Returns the clock source used as system clock.
    708            * @param  None
    709            * @retval The clock source used as system clock. The returned value can be one
    710            *         of the following:
    711            *              - 0x00: HSI used as system clock
    712            *              - 0x04: HSE used as system clock
    713            *              - 0x08: PLL used as system clock
    714            */

   \                                 In section .text, align 2, keep-with-next
    715          uint8_t RCC_GetSYSCLKSource(void)
    716          {
    717            return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
   \                     RCC_GetSYSCLKSource: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable30_1  ;; 0x40023808
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   0000000A   0x4770             BX       LR               ;; return
    718          }
    719          
    720          /**
    721            * @brief  Configures the AHB clock (HCLK).
    722            * @note   Depending on the device voltage range, the software has to set correctly
    723            *         these bits to ensure that HCLK not exceed the maximum allowed frequency
    724            *         (for more details refer to section above
    725            *           "CPU, AHB and APB busses clocks configuration functions")
    726            * @param  RCC_SYSCLK: defines the AHB clock divider. This clock is derived from 
    727            *         the system clock (SYSCLK).
    728            *          This parameter can be one of the following values:
    729            *            @arg RCC_SYSCLK_Div1: AHB clock = SYSCLK
    730            *            @arg RCC_SYSCLK_Div2: AHB clock = SYSCLK/2
    731            *            @arg RCC_SYSCLK_Div4: AHB clock = SYSCLK/4
    732            *            @arg RCC_SYSCLK_Div8: AHB clock = SYSCLK/8
    733            *            @arg RCC_SYSCLK_Div16: AHB clock = SYSCLK/16
    734            *            @arg RCC_SYSCLK_Div64: AHB clock = SYSCLK/64
    735            *            @arg RCC_SYSCLK_Div128: AHB clock = SYSCLK/128
    736            *            @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
    737            *            @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
    738            * @retval None
    739            */

   \                                 In section .text, align 2, keep-with-next
    740          void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
    741          {
   \                     RCC_HCLKConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    742            uint32_t tmpreg = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    743            
    744            /* Check the parameters */
    745            assert_param(IS_RCC_HCLK(RCC_SYSCLK));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD015             BEQ.N    ??RCC_HCLKConfig_0
   \   0000000A   0x2C80             CMP      R4,#+128
   \   0000000C   0xD013             BEQ.N    ??RCC_HCLKConfig_0
   \   0000000E   0x2C90             CMP      R4,#+144
   \   00000010   0xD011             BEQ.N    ??RCC_HCLKConfig_0
   \   00000012   0x2CA0             CMP      R4,#+160
   \   00000014   0xD00F             BEQ.N    ??RCC_HCLKConfig_0
   \   00000016   0x2CB0             CMP      R4,#+176
   \   00000018   0xD00D             BEQ.N    ??RCC_HCLKConfig_0
   \   0000001A   0x2CC0             CMP      R4,#+192
   \   0000001C   0xD00B             BEQ.N    ??RCC_HCLKConfig_0
   \   0000001E   0x2CD0             CMP      R4,#+208
   \   00000020   0xD009             BEQ.N    ??RCC_HCLKConfig_0
   \   00000022   0x2CE0             CMP      R4,#+224
   \   00000024   0xD007             BEQ.N    ??RCC_HCLKConfig_0
   \   00000026   0x2CF0             CMP      R4,#+240
   \   00000028   0xD005             BEQ.N    ??RCC_HCLKConfig_0
   \   0000002A   0xF240 0x21E9      MOVW     R1,#+745
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable31
   \   00000032   0x.... 0x....      BL       assert_failed
    746          
    747            tmpreg = RCC->CFGR;
   \                     ??RCC_HCLKConfig_0: (+1)
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable30_1  ;; 0x40023808
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x0005             MOVS     R5,R0
    748          
    749            /* Clear HPRE[3:0] bits */
    750            tmpreg &= ~RCC_CFGR_HPRE;
   \   0000003E   0xF035 0x05F0      BICS     R5,R5,#0xF0
    751          
    752            /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
    753            tmpreg |= RCC_SYSCLK;
   \   00000042   0x4325             ORRS     R5,R4,R5
    754          
    755            /* Store the new value */
    756            RCC->CFGR = tmpreg;
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable30_1  ;; 0x40023808
   \   00000048   0x6005             STR      R5,[R0, #+0]
    757          }
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    758          
    759          
    760          /**
    761            * @brief  Configures the Low Speed APB clock (PCLK1).
    762            * @param  RCC_HCLK: defines the APB1 clock divider. This clock is derived from 
    763            *         the AHB clock (HCLK).
    764            *          This parameter can be one of the following values:
    765            *            @arg RCC_HCLK_Div1:  APB1 clock = HCLK
    766            *            @arg RCC_HCLK_Div2:  APB1 clock = HCLK/2
    767            *            @arg RCC_HCLK_Div4:  APB1 clock = HCLK/4
    768            *            @arg RCC_HCLK_Div8:  APB1 clock = HCLK/8
    769            *            @arg RCC_HCLK_Div16: APB1 clock = HCLK/16
    770            * @retval None
    771            */

   \                                 In section .text, align 2, keep-with-next
    772          void RCC_PCLK1Config(uint32_t RCC_HCLK)
    773          {
   \                     RCC_PCLK1Config: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    774            uint32_t tmpreg = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    775          
    776            /* Check the parameters */
    777            assert_param(IS_RCC_PCLK(RCC_HCLK));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD011             BEQ.N    ??RCC_PCLK1Config_0
   \   0000000A   0xF5B4 0x5F80      CMP      R4,#+4096
   \   0000000E   0xD00E             BEQ.N    ??RCC_PCLK1Config_0
   \   00000010   0xF5B4 0x5FA0      CMP      R4,#+5120
   \   00000014   0xD00B             BEQ.N    ??RCC_PCLK1Config_0
   \   00000016   0xF5B4 0x5FC0      CMP      R4,#+6144
   \   0000001A   0xD008             BEQ.N    ??RCC_PCLK1Config_0
   \   0000001C   0xF5B4 0x5FE0      CMP      R4,#+7168
   \   00000020   0xD005             BEQ.N    ??RCC_PCLK1Config_0
   \   00000022   0xF240 0x3109      MOVW     R1,#+777
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable31
   \   0000002A   0x.... 0x....      BL       assert_failed
    778          
    779            tmpreg = RCC->CFGR;
   \                     ??RCC_PCLK1Config_0: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable30_1  ;; 0x40023808
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x0005             MOVS     R5,R0
    780          
    781            /* Clear PPRE1[2:0] bits */
    782            tmpreg &= ~RCC_CFGR_PPRE1;
   \   00000036   0xF435 0x55E0      BICS     R5,R5,#0x1C00
    783          
    784            /* Set PPRE1[2:0] bits according to RCC_HCLK value */
    785            tmpreg |= RCC_HCLK;
   \   0000003A   0x4325             ORRS     R5,R4,R5
    786          
    787            /* Store the new value */
    788            RCC->CFGR = tmpreg;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable30_1  ;; 0x40023808
   \   00000040   0x6005             STR      R5,[R0, #+0]
    789          }
   \   00000042   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    790          
    791          /**
    792            * @brief  Configures the High Speed APB clock (PCLK2).
    793            * @param  RCC_HCLK: defines the APB2 clock divider. This clock is derived from 
    794            *         the AHB clock (HCLK).
    795            *          This parameter can be one of the following values:
    796            *            @arg RCC_HCLK_Div1:  APB2 clock = HCLK
    797            *            @arg RCC_HCLK_Div2:  APB2 clock = HCLK/2
    798            *            @arg RCC_HCLK_Div4:  APB2 clock = HCLK/4
    799            *            @arg RCC_HCLK_Div8:  APB2 clock = HCLK/8
    800            *            @arg RCC_HCLK_Div16: APB2 clock = HCLK/16
    801            * @retval None
    802            */

   \                                 In section .text, align 2, keep-with-next
    803          void RCC_PCLK2Config(uint32_t RCC_HCLK)
    804          {
   \                     RCC_PCLK2Config: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    805            uint32_t tmpreg = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    806          
    807            /* Check the parameters */
    808            assert_param(IS_RCC_PCLK(RCC_HCLK));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD011             BEQ.N    ??RCC_PCLK2Config_0
   \   0000000A   0xF5B4 0x5F80      CMP      R4,#+4096
   \   0000000E   0xD00E             BEQ.N    ??RCC_PCLK2Config_0
   \   00000010   0xF5B4 0x5FA0      CMP      R4,#+5120
   \   00000014   0xD00B             BEQ.N    ??RCC_PCLK2Config_0
   \   00000016   0xF5B4 0x5FC0      CMP      R4,#+6144
   \   0000001A   0xD008             BEQ.N    ??RCC_PCLK2Config_0
   \   0000001C   0xF5B4 0x5FE0      CMP      R4,#+7168
   \   00000020   0xD005             BEQ.N    ??RCC_PCLK2Config_0
   \   00000022   0xF44F 0x714A      MOV      R1,#+808
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable31
   \   0000002A   0x.... 0x....      BL       assert_failed
    809          
    810            tmpreg = RCC->CFGR;
   \                     ??RCC_PCLK2Config_0: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable30_1  ;; 0x40023808
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x0005             MOVS     R5,R0
    811          
    812            /* Clear PPRE2[2:0] bits */
    813            tmpreg &= ~RCC_CFGR_PPRE2;
   \   00000036   0xF435 0x4560      BICS     R5,R5,#0xE000
    814          
    815            /* Set PPRE2[2:0] bits according to RCC_HCLK value */
    816            tmpreg |= RCC_HCLK << 3;
   \   0000003A   0xEA55 0x05C4      ORRS     R5,R5,R4, LSL #+3
    817          
    818            /* Store the new value */
    819            RCC->CFGR = tmpreg;
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable30_1  ;; 0x40023808
   \   00000042   0x6005             STR      R5,[R0, #+0]
    820          }
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    821          
    822          /**
    823            * @brief  Returns the frequencies of different on chip clocks; SYSCLK, HCLK, 
    824            *         PCLK1 and PCLK2.       
    825            * 
    826            * @note   The system frequency computed by this function is not the real 
    827            *         frequency in the chip. It is calculated based on the predefined 
    828            *         constant and the selected clock source:
    829            * @note     If SYSCLK source is HSI, function returns values based on HSI_VALUE(*)
    830            * @note     If SYSCLK source is HSE, function returns values based on HSE_VALUE(**)
    831            * @note     If SYSCLK source is PLL, function returns values based on HSE_VALUE(**) 
    832            *           or HSI_VALUE(*) multiplied/divided by the PLL factors.         
    833            * @note     (*) HSI_VALUE is a constant defined in stm32f4xx.h file (default value
    834            *               16 MHz) but the real value may vary depending on the variations
    835            *               in voltage and temperature.
    836            * @note     (**) HSE_VALUE is a constant defined in stm32f4xx.h file (default value
    837            *                25 MHz), user has to ensure that HSE_VALUE is same as the real
    838            *                frequency of the crystal used. Otherwise, this function may
    839            *                have wrong result.
    840            *                
    841            * @note   The result of this function could be not correct when using fractional
    842            *         value for HSE crystal.
    843            *   
    844            * @param  RCC_Clocks: pointer to a RCC_ClocksTypeDef structure which will hold
    845            *          the clocks frequencies.
    846            *     
    847            * @note   This function can be used by the user application to compute the 
    848            *         baudrate for the communication peripherals or configure other parameters.
    849            * @note   Each time SYSCLK, HCLK, PCLK1 and/or PCLK2 clock changes, this function
    850            *         must be called to update the structure's field. Otherwise, any
    851            *         configuration based on this function will be incorrect.
    852            *    
    853            * @retval None
    854            */

   \                                 In section .text, align 2, keep-with-next
    855          void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
    856          {
   \                     RCC_GetClocksFreq: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    857            uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x2402             MOVS     R4,#+2
   \   0000000A   0x2500             MOVS     R5,#+0
   \   0000000C   0x2602             MOVS     R6,#+2
    858          
    859            /* Get SYSCLK source -------------------------------------------------------*/
    860            tmp = RCC->CFGR & RCC_CFGR_SWS;
   \   0000000E   0x.... 0x....      LDR.W    R7,??DataTable30_1  ;; 0x40023808
   \   00000012   0x683F             LDR      R7,[R7, #+0]
   \   00000014   0xF017 0x070C      ANDS     R7,R7,#0xC
   \   00000018   0x0039             MOVS     R1,R7
    861          
    862            switch (tmp)
   \   0000001A   0x000F             MOVS     R7,R1
   \   0000001C   0x2F00             CMP      R7,#+0
   \   0000001E   0xD004             BEQ.N    ??RCC_GetClocksFreq_0
   \   00000020   0x2F04             CMP      R7,#+4
   \   00000022   0xD006             BEQ.N    ??RCC_GetClocksFreq_1
   \   00000024   0x2F08             CMP      R7,#+8
   \   00000026   0xD008             BEQ.N    ??RCC_GetClocksFreq_2
   \   00000028   0xE03C             B.N      ??RCC_GetClocksFreq_3
    863            {
    864              case 0x00:  /* HSI used as system clock source */
    865                RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
   \                     ??RCC_GetClocksFreq_0: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R7,??DataTable42_3  ;; 0xf42400
   \   0000002E   0x6007             STR      R7,[R0, #+0]
    866                break;
   \   00000030   0xE03B             B.N      ??RCC_GetClocksFreq_4
    867              case 0x04:  /* HSE used as system clock  source */
    868                RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
   \                     ??RCC_GetClocksFreq_1: (+1)
   \   00000032   0x.... 0x....      LDR.W    R7,??DataTable42_4  ;; 0x7a1200
   \   00000036   0x6007             STR      R7,[R0, #+0]
    869                break;
   \   00000038   0xE037             B.N      ??RCC_GetClocksFreq_4
    870              case 0x08:  /* PLL used as system clock  source */
    871          
    872                /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
    873                   SYSCLK = PLL_VCO / PLLP
    874                   */    
    875                pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
   \                     ??RCC_GetClocksFreq_2: (+1)
   \   0000003A   0x.... 0x....      LDR.W    R7,??DataTable30_4  ;; 0x40023804
   \   0000003E   0x683F             LDR      R7,[R7, #+0]
   \   00000040   0xF3C7 0x5780      UBFX     R7,R7,#+22,#+1
   \   00000044   0x003D             MOVS     R5,R7
    876                pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
   \   00000046   0x.... 0x....      LDR.W    R7,??DataTable30_4  ;; 0x40023804
   \   0000004A   0x683F             LDR      R7,[R7, #+0]
   \   0000004C   0xF017 0x073F      ANDS     R7,R7,#0x3F
   \   00000050   0x003E             MOVS     R6,R7
    877                
    878                if (pllsource != 0)
   \   00000052   0x2D00             CMP      R5,#+0
   \   00000054   0xD00D             BEQ.N    ??RCC_GetClocksFreq_5
    879                {
    880                  /* HSE used as PLL clock source */
    881                  pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
   \   00000056   0x.... 0x....      LDR.W    R7,??DataTable42_4  ;; 0x7a1200
   \   0000005A   0xFBB7 0xF7F6      UDIV     R7,R7,R6
   \   0000005E   0x.... 0x....      LDR.W    R12,??DataTable30_4  ;; 0x40023804
   \   00000062   0xF8DC 0xC000      LDR      R12,[R12, #+0]
   \   00000066   0xF3CC 0x1C88      UBFX     R12,R12,#+6,#+9
   \   0000006A   0xFB0C 0xF707      MUL      R7,R12,R7
   \   0000006E   0x003B             MOVS     R3,R7
   \   00000070   0xE00C             B.N      ??RCC_GetClocksFreq_6
    882                }
    883                else
    884                {
    885                  /* HSI used as PLL clock source */
    886                  pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
   \                     ??RCC_GetClocksFreq_5: (+1)
   \   00000072   0x.... 0x....      LDR.W    R7,??DataTable42_3  ;; 0xf42400
   \   00000076   0xFBB7 0xF7F6      UDIV     R7,R7,R6
   \   0000007A   0x.... 0x....      LDR.W    R12,??DataTable30_4  ;; 0x40023804
   \   0000007E   0xF8DC 0xC000      LDR      R12,[R12, #+0]
   \   00000082   0xF3CC 0x1C88      UBFX     R12,R12,#+6,#+9
   \   00000086   0xFB0C 0xF707      MUL      R7,R12,R7
   \   0000008A   0x003B             MOVS     R3,R7
    887                }
    888          
    889                pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
   \                     ??RCC_GetClocksFreq_6: (+1)
   \   0000008C   0x.... 0x....      LDR.W    R7,??DataTable30_4  ;; 0x40023804
   \   00000090   0x683F             LDR      R7,[R7, #+0]
   \   00000092   0xF3C7 0x4701      UBFX     R7,R7,#+16,#+2
   \   00000096   0x1C7F             ADDS     R7,R7,#+1
   \   00000098   0x007F             LSLS     R7,R7,#+1
   \   0000009A   0x003C             MOVS     R4,R7
    890                RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
   \   0000009C   0xFBB3 0xF7F4      UDIV     R7,R3,R4
   \   000000A0   0x6007             STR      R7,[R0, #+0]
    891                break;
   \   000000A2   0xE002             B.N      ??RCC_GetClocksFreq_4
    892              default:
    893                RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
   \                     ??RCC_GetClocksFreq_3: (+1)
   \   000000A4   0x.... 0x....      LDR.W    R7,??DataTable42_3  ;; 0xf42400
   \   000000A8   0x6007             STR      R7,[R0, #+0]
    894                break;
    895            }
    896            /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/
    897          
    898            /* Get HCLK prescaler */
    899            tmp = RCC->CFGR & RCC_CFGR_HPRE;
   \                     ??RCC_GetClocksFreq_4: (+1)
   \   000000AA   0x.... 0x....      LDR.W    R7,??DataTable30_1  ;; 0x40023808
   \   000000AE   0x683F             LDR      R7,[R7, #+0]
   \   000000B0   0xF017 0x07F0      ANDS     R7,R7,#0xF0
   \   000000B4   0x0039             MOVS     R1,R7
    900            tmp = tmp >> 4;
   \   000000B6   0x0909             LSRS     R1,R1,#+4
    901            presc = APBAHBPrescTable[tmp];
   \   000000B8   0x.... 0x....      LDR.W    R7,??DataTable42_5
   \   000000BC   0x5DCF             LDRB     R7,[R1, R7]
   \   000000BE   0x003A             MOVS     R2,R7
    902            /* HCLK clock frequency */
    903            RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
   \   000000C0   0x6807             LDR      R7,[R0, #+0]
   \   000000C2   0x40D7             LSRS     R7,R7,R2
   \   000000C4   0x6047             STR      R7,[R0, #+4]
    904          
    905            /* Get PCLK1 prescaler */
    906            tmp = RCC->CFGR & RCC_CFGR_PPRE1;
   \   000000C6   0x.... 0x....      LDR.W    R7,??DataTable30_1  ;; 0x40023808
   \   000000CA   0x683F             LDR      R7,[R7, #+0]
   \   000000CC   0xF417 0x57E0      ANDS     R7,R7,#0x1C00
   \   000000D0   0x0039             MOVS     R1,R7
    907            tmp = tmp >> 10;
   \   000000D2   0x0A89             LSRS     R1,R1,#+10
    908            presc = APBAHBPrescTable[tmp];
   \   000000D4   0x.... 0x....      LDR.W    R7,??DataTable42_5
   \   000000D8   0x5DCF             LDRB     R7,[R1, R7]
   \   000000DA   0x003A             MOVS     R2,R7
    909            /* PCLK1 clock frequency */
    910            RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
   \   000000DC   0x6847             LDR      R7,[R0, #+4]
   \   000000DE   0x40D7             LSRS     R7,R7,R2
   \   000000E0   0x6087             STR      R7,[R0, #+8]
    911          
    912            /* Get PCLK2 prescaler */
    913            tmp = RCC->CFGR & RCC_CFGR_PPRE2;
   \   000000E2   0x.... 0x....      LDR.W    R7,??DataTable30_1  ;; 0x40023808
   \   000000E6   0x683F             LDR      R7,[R7, #+0]
   \   000000E8   0xF417 0x4760      ANDS     R7,R7,#0xE000
   \   000000EC   0x0039             MOVS     R1,R7
    914            tmp = tmp >> 13;
   \   000000EE   0x0B49             LSRS     R1,R1,#+13
    915            presc = APBAHBPrescTable[tmp];
   \   000000F0   0x.... 0x....      LDR.W    R7,??DataTable42_5
   \   000000F4   0x5DCF             LDRB     R7,[R1, R7]
   \   000000F6   0x003A             MOVS     R2,R7
    916            /* PCLK2 clock frequency */
    917            RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
   \   000000F8   0x6847             LDR      R7,[R0, #+4]
   \   000000FA   0x40D7             LSRS     R7,R7,R2
   \   000000FC   0x60C7             STR      R7,[R0, #+12]
    918          }
   \   000000FE   0xBCF0             POP      {R4-R7}
   \   00000100   0x4770             BX       LR               ;; return
    919          
    920          /**
    921            * @}
    922            */
    923          
    924          /** @defgroup RCC_Group3 Peripheral clocks configuration functions
    925           *  @brief   Peripheral clocks configuration functions 
    926           *
    927          @verbatim   
    928           ===============================================================================
    929                             Peripheral clocks configuration functions
    930           ===============================================================================  
    931          
    932            This section provide functions allowing to configure the Peripheral clocks. 
    933            
    934            1. The RTC clock which is derived from the LSI, LSE or HSE clock divided by 2 to 31.
    935               
    936            2. After restart from Reset or wakeup from STANDBY, all peripherals are off
    937               except internal SRAM, Flash and JTAG. Before to start using a peripheral you
    938               have to enable its interface clock. You can do this using RCC_AHBPeriphClockCmd()
    939               , RCC_APB2PeriphClockCmd() and RCC_APB1PeriphClockCmd() functions.
    940          
    941            3. To reset the peripherals configuration (to the default state after device reset)
    942               you can use RCC_AHBPeriphResetCmd(), RCC_APB2PeriphResetCmd() and 
    943               RCC_APB1PeriphResetCmd() functions.
    944               
    945            4. To further reduce power consumption in SLEEP mode the peripheral clocks can
    946               be disabled prior to executing the WFI or WFE instructions. You can do this
    947               using RCC_AHBPeriphClockLPModeCmd(), RCC_APB2PeriphClockLPModeCmd() and
    948               RCC_APB1PeriphClockLPModeCmd() functions.  
    949          
    950          @endverbatim
    951            * @{
    952            */
    953          
    954          /**
    955            * @brief  Configures the RTC clock (RTCCLK).
    956            * @note   As the RTC clock configuration bits are in the Backup domain and write
    957            *         access is denied to this domain after reset, you have to enable write
    958            *         access using PWR_BackupAccessCmd(ENABLE) function before to configure
    959            *         the RTC clock source (to be done once after reset).    
    960            * @note   Once the RTC clock is configured it can't be changed unless the  
    961            *         Backup domain is reset using RCC_BackupResetCmd() function, or by
    962            *         a Power On Reset (POR).
    963            *    
    964            * @param  RCC_RTCCLKSource: specifies the RTC clock source.
    965            *          This parameter can be one of the following values:
    966            *            @arg RCC_RTCCLKSource_LSE: LSE selected as RTC clock
    967            *            @arg RCC_RTCCLKSource_LSI: LSI selected as RTC clock
    968            *            @arg RCC_RTCCLKSource_HSE_Divx: HSE clock divided by x selected
    969            *                                            as RTC clock, where x:[2,31]
    970            *  
    971            * @note   If the LSE or LSI is used as RTC clock source, the RTC continues to
    972            *         work in STOP and STANDBY modes, and can be used as wakeup source.
    973            *         However, when the HSE clock is used as RTC clock source, the RTC
    974            *         cannot be used in STOP and STANDBY modes.    
    975            * @note   The maximum input clock frequency for RTC is 1MHz (when using HSE as
    976            *         RTC clock source).
    977            *  
    978            * @retval None
    979            */

   \                                 In section .text, align 2, keep-with-next
    980          void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
    981          {
   \                     RCC_RTCCLKConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    982            uint32_t tmpreg = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    983          
    984            /* Check the parameters */
    985            assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
   \   00000006   0xF5B4 0x7F80      CMP      R4,#+256
   \   0000000A   0xF000 0x8081      BEQ.W    ??RCC_RTCCLKConfig_0
   \   0000000E   0xF5B4 0x7F00      CMP      R4,#+512
   \   00000012   0xD07D             BEQ.N    ??RCC_RTCCLKConfig_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable42_6  ;; 0x20300
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD079             BEQ.N    ??RCC_RTCCLKConfig_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable42_7  ;; 0x30300
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD075             BEQ.N    ??RCC_RTCCLKConfig_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable42_8  ;; 0x40300
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD071             BEQ.N    ??RCC_RTCCLKConfig_0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable42_9  ;; 0x50300
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD06D             BEQ.N    ??RCC_RTCCLKConfig_0
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable42_10  ;; 0x60300
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD069             BEQ.N    ??RCC_RTCCLKConfig_0
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable42_11  ;; 0x70300
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD065             BEQ.N    ??RCC_RTCCLKConfig_0
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable42_12  ;; 0x80300
   \   00000048   0x4284             CMP      R4,R0
   \   0000004A   0xD061             BEQ.N    ??RCC_RTCCLKConfig_0
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable42_13  ;; 0x90300
   \   00000050   0x4284             CMP      R4,R0
   \   00000052   0xD05D             BEQ.N    ??RCC_RTCCLKConfig_0
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable42_14  ;; 0xa0300
   \   00000058   0x4284             CMP      R4,R0
   \   0000005A   0xD059             BEQ.N    ??RCC_RTCCLKConfig_0
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable42_15  ;; 0xb0300
   \   00000060   0x4284             CMP      R4,R0
   \   00000062   0xD055             BEQ.N    ??RCC_RTCCLKConfig_0
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable42_16  ;; 0xc0300
   \   00000068   0x4284             CMP      R4,R0
   \   0000006A   0xD051             BEQ.N    ??RCC_RTCCLKConfig_0
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable42_17  ;; 0xd0300
   \   00000070   0x4284             CMP      R4,R0
   \   00000072   0xD04D             BEQ.N    ??RCC_RTCCLKConfig_0
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable42_18  ;; 0xe0300
   \   00000078   0x4284             CMP      R4,R0
   \   0000007A   0xD049             BEQ.N    ??RCC_RTCCLKConfig_0
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable42_19  ;; 0xf0300
   \   00000080   0x4284             CMP      R4,R0
   \   00000082   0xD045             BEQ.N    ??RCC_RTCCLKConfig_0
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable42_20  ;; 0x100300
   \   00000088   0x4284             CMP      R4,R0
   \   0000008A   0xD041             BEQ.N    ??RCC_RTCCLKConfig_0
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable42_21  ;; 0x110300
   \   00000090   0x4284             CMP      R4,R0
   \   00000092   0xD03D             BEQ.N    ??RCC_RTCCLKConfig_0
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable42_22  ;; 0x120300
   \   00000098   0x4284             CMP      R4,R0
   \   0000009A   0xD039             BEQ.N    ??RCC_RTCCLKConfig_0
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable42_23  ;; 0x130300
   \   000000A0   0x4284             CMP      R4,R0
   \   000000A2   0xD035             BEQ.N    ??RCC_RTCCLKConfig_0
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable42_24  ;; 0x140300
   \   000000A8   0x4284             CMP      R4,R0
   \   000000AA   0xD031             BEQ.N    ??RCC_RTCCLKConfig_0
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable42_25  ;; 0x150300
   \   000000B0   0x4284             CMP      R4,R0
   \   000000B2   0xD02D             BEQ.N    ??RCC_RTCCLKConfig_0
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable42_26  ;; 0x160300
   \   000000B8   0x4284             CMP      R4,R0
   \   000000BA   0xD029             BEQ.N    ??RCC_RTCCLKConfig_0
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable42_27  ;; 0x170300
   \   000000C0   0x4284             CMP      R4,R0
   \   000000C2   0xD025             BEQ.N    ??RCC_RTCCLKConfig_0
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable42_28  ;; 0x180300
   \   000000C8   0x4284             CMP      R4,R0
   \   000000CA   0xD021             BEQ.N    ??RCC_RTCCLKConfig_0
   \   000000CC   0x.... 0x....      LDR.W    R0,??DataTable42_29  ;; 0x190300
   \   000000D0   0x4284             CMP      R4,R0
   \   000000D2   0xD01D             BEQ.N    ??RCC_RTCCLKConfig_0
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable42_30  ;; 0x1a0300
   \   000000D8   0x4284             CMP      R4,R0
   \   000000DA   0xD019             BEQ.N    ??RCC_RTCCLKConfig_0
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable42_31  ;; 0x1b0300
   \   000000E0   0x4284             CMP      R4,R0
   \   000000E2   0xD015             BEQ.N    ??RCC_RTCCLKConfig_0
   \   000000E4   0x.... 0x....      LDR.W    R0,??DataTable42_32  ;; 0x1c0300
   \   000000E8   0x4284             CMP      R4,R0
   \   000000EA   0xD011             BEQ.N    ??RCC_RTCCLKConfig_0
   \   000000EC   0x.... 0x....      LDR.W    R0,??DataTable42_33  ;; 0x1d0300
   \   000000F0   0x4284             CMP      R4,R0
   \   000000F2   0xD00D             BEQ.N    ??RCC_RTCCLKConfig_0
   \   000000F4   0x.... 0x....      LDR.W    R0,??DataTable42_34  ;; 0x1e0300
   \   000000F8   0x4284             CMP      R4,R0
   \   000000FA   0xD009             BEQ.N    ??RCC_RTCCLKConfig_0
   \   000000FC   0x.... 0x....      LDR.W    R0,??DataTable42_35  ;; 0x1f0300
   \   00000100   0x4284             CMP      R4,R0
   \   00000102   0xD005             BEQ.N    ??RCC_RTCCLKConfig_0
   \   00000104   0xF240 0x31D9      MOVW     R1,#+985
   \   00000108   0x.... 0x....      LDR.W    R0,??DataTable31
   \   0000010C   0x.... 0x....      BL       assert_failed
    986          
    987            if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
   \                     ??RCC_RTCCLKConfig_0: (+1)
   \   00000110   0xF414 0x7040      ANDS     R0,R4,#0x300
   \   00000114   0xF5B0 0x7F40      CMP      R0,#+768
   \   00000118   0xD10B             BNE.N    ??RCC_RTCCLKConfig_1
    988            { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
    989              tmpreg = RCC->CFGR;
   \   0000011A   0x.... 0x....      LDR.W    R0,??DataTable30_1  ;; 0x40023808
   \   0000011E   0x6800             LDR      R0,[R0, #+0]
   \   00000120   0x0005             MOVS     R5,R0
    990          
    991              /* Clear RTCPRE[4:0] bits */
    992              tmpreg &= ~RCC_CFGR_RTCPRE;
   \   00000122   0xF435 0x15F8      BICS     R5,R5,#0x1F0000
    993          
    994              /* Configure HSE division factor for RTC clock */
    995              tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
   \   00000126   0x.... 0x....      LDR.W    R0,??DataTable42_36  ;; 0xffffcff
   \   0000012A   0x4020             ANDS     R0,R0,R4
   \   0000012C   0x4305             ORRS     R5,R0,R5
    996          
    997              /* Store the new value */
    998              RCC->CFGR = tmpreg;
   \   0000012E   0x....             LDR.N    R0,??DataTable30_1  ;; 0x40023808
   \   00000130   0x6005             STR      R5,[R0, #+0]
    999            }
   1000              
   1001            /* Select the RTC clock source */
   1002            RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
   \                     ??RCC_RTCCLKConfig_1: (+1)
   \   00000132   0x.... 0x....      LDR.W    R0,??DataTable42_37  ;; 0x40023870
   \   00000136   0x6800             LDR      R0,[R0, #+0]
   \   00000138   0x0521             LSLS     R1,R4,#+20       ;; ZeroExtS R1,R4,#+20,#+20
   \   0000013A   0x0D09             LSRS     R1,R1,#+20
   \   0000013C   0x4308             ORRS     R0,R1,R0
   \   0000013E   0x.... 0x....      LDR.W    R1,??DataTable42_37  ;; 0x40023870
   \   00000142   0x6008             STR      R0,[R1, #+0]
   1003          }
   \   00000144   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1004          
   1005          /**
   1006            * @brief  Enables or disables the RTC clock.
   1007            * @note   This function must be used only after the RTC clock source was selected
   1008            *         using the RCC_RTCCLKConfig function.
   1009            * @param  NewState: new state of the RTC clock. This parameter can be: ENABLE or DISABLE.
   1010            * @retval None
   1011            */

   \                                 In section .text, align 2, keep-with-next
   1012          void RCC_RTCCLKCmd(FunctionalState NewState)
   1013          {
   \                     RCC_RTCCLKCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1014            /* Check the parameters */
   1015            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??RCC_RTCCLKCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??RCC_RTCCLKCmd_0
   \   00000010   0xF240 0x31F7      MOVW     R1,#+1015
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable31
   \   00000018   0x.... 0x....      BL       assert_failed
   1016          
   1017            *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
   \                     ??RCC_RTCCLKCmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable42_38  ;; 0x42470e3c
   \   00000022   0x6004             STR      R4,[R0, #+0]
   1018          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
   1019          
   1020          /**
   1021            * @brief  Forces or releases the Backup domain reset.
   1022            * @note   This function resets the RTC peripheral (including the backup registers)
   1023            *         and the RTC clock source selection in RCC_CSR register.
   1024            * @note   The BKPSRAM is not affected by this reset.    
   1025            * @param  NewState: new state of the Backup domain reset.
   1026            *          This parameter can be: ENABLE or DISABLE.
   1027            * @retval None
   1028            */

   \                                 In section .text, align 2, keep-with-next
   1029          void RCC_BackupResetCmd(FunctionalState NewState)
   1030          {
   \                     RCC_BackupResetCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1031            /* Check the parameters */
   1032            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??RCC_BackupResetCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??RCC_BackupResetCmd_0
   \   00000010   0xF44F 0x6181      MOV      R1,#+1032
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable31
   \   00000018   0x.... 0x....      BL       assert_failed
   1033            *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
   \                     ??RCC_BackupResetCmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable42_39  ;; 0x42470e40
   \   00000022   0x6004             STR      R4,[R0, #+0]
   1034          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
   1035          
   1036          /**
   1037            * @brief  Configures the I2S clock source (I2SCLK).
   1038            * @note   This function must be called before enabling the I2S APB clock.
   1039            * @param  RCC_I2SCLKSource: specifies the I2S clock source.
   1040            *          This parameter can be one of the following values:
   1041            *            @arg RCC_I2S2CLKSource_PLLI2S: PLLI2S clock used as I2S clock source
   1042            *            @arg RCC_I2S2CLKSource_Ext: External clock mapped on the I2S_CKIN pin
   1043            *                                        used as I2S clock source
   1044            * @retval None
   1045            */

   \                                 In section .text, align 2, keep-with-next
   1046          void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
   1047          {
   \                     RCC_I2SCLKConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1048            /* Check the parameters */
   1049            assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD006             BEQ.N    ??RCC_I2SCLKConfig_0
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD004             BEQ.N    ??RCC_I2SCLKConfig_0
   \   0000000C   0xF240 0x4119      MOVW     R1,#+1049
   \   00000010   0x....             LDR.N    R0,??DataTable31
   \   00000012   0x.... 0x....      BL       assert_failed
   1050          
   1051            *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
   \                     ??RCC_I2SCLKConfig_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable42_40  ;; 0x4247015c
   \   0000001A   0x6004             STR      R4,[R0, #+0]
   1052          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
   1053          
   1054          /**
   1055            * @brief  Enables or disables the AHB1 peripheral clock.
   1056            * @note   After reset, the peripheral clock (used for registers read/write access)
   1057            *         is disabled and the application software has to enable this clock before 
   1058            *         using it.   
   1059            * @param  RCC_AHBPeriph: specifies the AHB1 peripheral to gates its clock.
   1060            *          This parameter can be any combination of the following values:
   1061            *            @arg RCC_AHB1Periph_GPIOA:       GPIOA clock
   1062            *            @arg RCC_AHB1Periph_GPIOB:       GPIOB clock 
   1063            *            @arg RCC_AHB1Periph_GPIOC:       GPIOC clock
   1064            *            @arg RCC_AHB1Periph_GPIOD:       GPIOD clock
   1065            *            @arg RCC_AHB1Periph_GPIOE:       GPIOE clock
   1066            *            @arg RCC_AHB1Periph_GPIOF:       GPIOF clock
   1067            *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
   1068            *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
   1069            *            @arg RCC_AHB1Periph_GPIOI:       GPIOI clock
   1070            *            @arg RCC_AHB1Periph_CRC:         CRC clock
   1071            *            @arg RCC_AHB1Periph_BKPSRAM:     BKPSRAM interface clock
   1072            *            @arg RCC_AHB1Periph_CCMDATARAMEN CCM data RAM interface clock
   1073            *            @arg RCC_AHB1Periph_DMA1:        DMA1 clock
   1074            *            @arg RCC_AHB1Periph_DMA2:        DMA2 clock
   1075            *            @arg RCC_AHB1Periph_ETH_MAC:     Ethernet MAC clock
   1076            *            @arg RCC_AHB1Periph_ETH_MAC_Tx:  Ethernet Transmission clock
   1077            *            @arg RCC_AHB1Periph_ETH_MAC_Rx:  Ethernet Reception clock
   1078            *            @arg RCC_AHB1Periph_ETH_MAC_PTP: Ethernet PTP clock
   1079            *            @arg RCC_AHB1Periph_OTG_HS:      USB OTG HS clock
   1080            *            @arg RCC_AHB1Periph_OTG_HS_ULPI: USB OTG HS ULPI clock
   1081            * @param  NewState: new state of the specified peripheral clock.
   1082            *          This parameter can be: ENABLE or DISABLE.
   1083            * @retval None
   1084            */

   \                                 In section .text, align 2, keep-with-next
   1085          void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
   1086          {
   \                     RCC_AHB1PeriphClockCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1087            /* Check the parameters */
   1088            assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable42_41  ;; 0x818bee00
   \   0000000A   0x4204             TST      R4,R0
   \   0000000C   0xD101             BNE.N    ??RCC_AHB1PeriphClockCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD104             BNE.N    ??RCC_AHB1PeriphClockCmd_1
   \                     ??RCC_AHB1PeriphClockCmd_0: (+1)
   \   00000012   0xF44F 0x6188      MOV      R1,#+1088
   \   00000016   0x....             LDR.N    R0,??DataTable31
   \   00000018   0x.... 0x....      BL       assert_failed
   1089          
   1090            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_AHB1PeriphClockCmd_1: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??RCC_AHB1PeriphClockCmd_2
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD004             BEQ.N    ??RCC_AHB1PeriphClockCmd_2
   \   00000028   0xF240 0x4142      MOVW     R1,#+1090
   \   0000002C   0x....             LDR.N    R0,??DataTable31
   \   0000002E   0x.... 0x....      BL       assert_failed
   1091            if (NewState != DISABLE)
   \                     ??RCC_AHB1PeriphClockCmd_2: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD007             BEQ.N    ??RCC_AHB1PeriphClockCmd_3
   1092            {
   1093              RCC->AHB1ENR |= RCC_AHB1Periph;
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable42_42  ;; 0x40023830
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x4320             ORRS     R0,R4,R0
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable42_42  ;; 0x40023830
   \   00000044   0x6008             STR      R0,[R1, #+0]
   \   00000046   0xE006             B.N      ??RCC_AHB1PeriphClockCmd_4
   1094            }
   1095            else
   1096            {
   1097              RCC->AHB1ENR &= ~RCC_AHB1Periph;
   \                     ??RCC_AHB1PeriphClockCmd_3: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable42_42  ;; 0x40023830
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x43A0             BICS     R0,R0,R4
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable42_42  ;; 0x40023830
   \   00000054   0x6008             STR      R0,[R1, #+0]
   1098            }
   1099          }
   \                     ??RCC_AHB1PeriphClockCmd_4: (+1)
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1100          
   1101          /**
   1102            * @brief  Enables or disables the AHB2 peripheral clock.
   1103            * @note   After reset, the peripheral clock (used for registers read/write access)
   1104            *         is disabled and the application software has to enable this clock before 
   1105            *         using it. 
   1106            * @param  RCC_AHBPeriph: specifies the AHB2 peripheral to gates its clock.
   1107            *          This parameter can be any combination of the following values:
   1108            *            @arg RCC_AHB2Periph_DCMI:   DCMI clock
   1109            *            @arg RCC_AHB2Periph_CRYP:   CRYP clock
   1110            *            @arg RCC_AHB2Periph_HASH:   HASH clock
   1111            *            @arg RCC_AHB2Periph_RNG:    RNG clock
   1112            *            @arg RCC_AHB2Periph_OTG_FS: USB OTG FS clock
   1113            * @param  NewState: new state of the specified peripheral clock.
   1114            *          This parameter can be: ENABLE or DISABLE.
   1115            * @retval None
   1116            */

   \                                 In section .text, align 2, keep-with-next
   1117          void RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
   1118          {
   \                     RCC_AHB2PeriphClockCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1119            /* Check the parameters */
   1120            assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
   \   00000006   0xF034 0x00F1      BICS     R0,R4,#0xF1
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??RCC_AHB2PeriphClockCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD104             BNE.N    ??RCC_AHB2PeriphClockCmd_1
   \                     ??RCC_AHB2PeriphClockCmd_0: (+1)
   \   00000012   0xF44F 0x618C      MOV      R1,#+1120
   \   00000016   0x....             LDR.N    R0,??DataTable31
   \   00000018   0x.... 0x....      BL       assert_failed
   1121            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_AHB2PeriphClockCmd_1: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??RCC_AHB2PeriphClockCmd_2
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD004             BEQ.N    ??RCC_AHB2PeriphClockCmd_2
   \   00000028   0xF240 0x4161      MOVW     R1,#+1121
   \   0000002C   0x....             LDR.N    R0,??DataTable31
   \   0000002E   0x.... 0x....      BL       assert_failed
   1122          
   1123            if (NewState != DISABLE)
   \                     ??RCC_AHB2PeriphClockCmd_2: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD007             BEQ.N    ??RCC_AHB2PeriphClockCmd_3
   1124            {
   1125              RCC->AHB2ENR |= RCC_AHB2Periph;
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable42_43  ;; 0x40023834
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x4320             ORRS     R0,R4,R0
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable42_43  ;; 0x40023834
   \   00000044   0x6008             STR      R0,[R1, #+0]
   \   00000046   0xE006             B.N      ??RCC_AHB2PeriphClockCmd_4
   1126            }
   1127            else
   1128            {
   1129              RCC->AHB2ENR &= ~RCC_AHB2Periph;
   \                     ??RCC_AHB2PeriphClockCmd_3: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable42_43  ;; 0x40023834
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x43A0             BICS     R0,R0,R4
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable42_43  ;; 0x40023834
   \   00000054   0x6008             STR      R0,[R1, #+0]
   1130            }
   1131          }
   \                     ??RCC_AHB2PeriphClockCmd_4: (+1)
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1132          
   1133          /**
   1134            * @brief  Enables or disables the AHB3 peripheral clock.
   1135            * @note   After reset, the peripheral clock (used for registers read/write access)
   1136            *         is disabled and the application software has to enable this clock before 
   1137            *         using it. 
   1138            * @param  RCC_AHBPeriph: specifies the AHB3 peripheral to gates its clock.
   1139            *          This parameter must be: RCC_AHB3Periph_FSMC
   1140            * @param  NewState: new state of the specified peripheral clock.
   1141            *          This parameter can be: ENABLE or DISABLE.
   1142            * @retval None
   1143            */

   \                                 In section .text, align 2, keep-with-next
   1144          void RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
   1145          {
   \                     RCC_AHB3PeriphClockCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1146            /* Check the parameters */
   1147            assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
   \   00000006   0x0860             LSRS     R0,R4,#+1
   \   00000008   0x0040             LSLS     R0,R0,#+1
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??RCC_AHB3PeriphClockCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD104             BNE.N    ??RCC_AHB3PeriphClockCmd_1
   \                     ??RCC_AHB3PeriphClockCmd_0: (+1)
   \   00000012   0xF240 0x417B      MOVW     R1,#+1147
   \   00000016   0x....             LDR.N    R0,??DataTable31
   \   00000018   0x.... 0x....      BL       assert_failed
   1148            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_AHB3PeriphClockCmd_1: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??RCC_AHB3PeriphClockCmd_2
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD004             BEQ.N    ??RCC_AHB3PeriphClockCmd_2
   \   00000028   0xF240 0x417C      MOVW     R1,#+1148
   \   0000002C   0x....             LDR.N    R0,??DataTable31
   \   0000002E   0x.... 0x....      BL       assert_failed
   1149          
   1150            if (NewState != DISABLE)
   \                     ??RCC_AHB3PeriphClockCmd_2: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD007             BEQ.N    ??RCC_AHB3PeriphClockCmd_3
   1151            {
   1152              RCC->AHB3ENR |= RCC_AHB3Periph;
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable42_44  ;; 0x40023838
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x4320             ORRS     R0,R4,R0
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable42_44  ;; 0x40023838
   \   00000044   0x6008             STR      R0,[R1, #+0]
   \   00000046   0xE006             B.N      ??RCC_AHB3PeriphClockCmd_4
   1153            }
   1154            else
   1155            {
   1156              RCC->AHB3ENR &= ~RCC_AHB3Periph;
   \                     ??RCC_AHB3PeriphClockCmd_3: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable42_44  ;; 0x40023838
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x43A0             BICS     R0,R0,R4
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable42_44  ;; 0x40023838
   \   00000054   0x6008             STR      R0,[R1, #+0]
   1157            }
   1158          }
   \                     ??RCC_AHB3PeriphClockCmd_4: (+1)
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1159          
   1160          /**
   1161            * @brief  Enables or disables the Low Speed APB (APB1) peripheral clock.
   1162            * @note   After reset, the peripheral clock (used for registers read/write access)
   1163            *         is disabled and the application software has to enable this clock before 
   1164            *         using it. 
   1165            * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
   1166            *          This parameter can be any combination of the following values:
   1167            *            @arg RCC_APB1Periph_TIM2:   TIM2 clock
   1168            *            @arg RCC_APB1Periph_TIM3:   TIM3 clock
   1169            *            @arg RCC_APB1Periph_TIM4:   TIM4 clock
   1170            *            @arg RCC_APB1Periph_TIM5:   TIM5 clock
   1171            *            @arg RCC_APB1Periph_TIM6:   TIM6 clock
   1172            *            @arg RCC_APB1Periph_TIM7:   TIM7 clock
   1173            *            @arg RCC_APB1Periph_TIM12:  TIM12 clock
   1174            *            @arg RCC_APB1Periph_TIM13:  TIM13 clock
   1175            *            @arg RCC_APB1Periph_TIM14:  TIM14 clock
   1176            *            @arg RCC_APB1Periph_WWDG:   WWDG clock
   1177            *            @arg RCC_APB1Periph_SPI2:   SPI2 clock
   1178            *            @arg RCC_APB1Periph_SPI3:   SPI3 clock
   1179            *            @arg RCC_APB1Periph_USART2: USART2 clock
   1180            *            @arg RCC_APB1Periph_USART3: USART3 clock
   1181            *            @arg RCC_APB1Periph_UART4:  UART4 clock
   1182            *            @arg RCC_APB1Periph_UART5:  UART5 clock
   1183            *            @arg RCC_APB1Periph_I2C1:   I2C1 clock
   1184            *            @arg RCC_APB1Periph_I2C2:   I2C2 clock
   1185            *            @arg RCC_APB1Periph_I2C3:   I2C3 clock
   1186            *            @arg RCC_APB1Periph_CAN1:   CAN1 clock
   1187            *            @arg RCC_APB1Periph_CAN2:   CAN2 clock
   1188            *            @arg RCC_APB1Periph_PWR:    PWR clock
   1189            *            @arg RCC_APB1Periph_DAC:    DAC clock
   1190            * @param  NewState: new state of the specified peripheral clock.
   1191            *          This parameter can be: ENABLE or DISABLE.
   1192            * @retval None
   1193            */

   \                                 In section .text, align 2, keep-with-next
   1194          void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
   1195          {
   \                     RCC_APB1PeriphClockCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1196            /* Check the parameters */
   1197            assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable42_45  ;; 0xc9013600
   \   0000000A   0x4204             TST      R4,R0
   \   0000000C   0xD101             BNE.N    ??RCC_APB1PeriphClockCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD104             BNE.N    ??RCC_APB1PeriphClockCmd_1
   \                     ??RCC_APB1PeriphClockCmd_0: (+1)
   \   00000012   0xF240 0x41AD      MOVW     R1,#+1197
   \   00000016   0x....             LDR.N    R0,??DataTable31
   \   00000018   0x.... 0x....      BL       assert_failed
   1198            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_APB1PeriphClockCmd_1: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??RCC_APB1PeriphClockCmd_2
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD004             BEQ.N    ??RCC_APB1PeriphClockCmd_2
   \   00000028   0xF240 0x41AE      MOVW     R1,#+1198
   \   0000002C   0x....             LDR.N    R0,??DataTable31
   \   0000002E   0x.... 0x....      BL       assert_failed
   1199          
   1200            if (NewState != DISABLE)
   \                     ??RCC_APB1PeriphClockCmd_2: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD007             BEQ.N    ??RCC_APB1PeriphClockCmd_3
   1201            {
   1202              RCC->APB1ENR |= RCC_APB1Periph;
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable42_46  ;; 0x40023840
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x4320             ORRS     R0,R4,R0
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable42_46  ;; 0x40023840
   \   00000044   0x6008             STR      R0,[R1, #+0]
   \   00000046   0xE006             B.N      ??RCC_APB1PeriphClockCmd_4
   1203            }
   1204            else
   1205            {
   1206              RCC->APB1ENR &= ~RCC_APB1Periph;
   \                     ??RCC_APB1PeriphClockCmd_3: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable42_46  ;; 0x40023840
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x43A0             BICS     R0,R0,R4
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable42_46  ;; 0x40023840
   \   00000054   0x6008             STR      R0,[R1, #+0]
   1207            }
   1208          }
   \                     ??RCC_APB1PeriphClockCmd_4: (+1)
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1209          
   1210          /**
   1211            * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.
   1212            * @note   After reset, the peripheral clock (used for registers read/write access)
   1213            *         is disabled and the application software has to enable this clock before 
   1214            *         using it.
   1215            * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
   1216            *          This parameter can be any combination of the following values:
   1217            *            @arg RCC_APB2Periph_TIM1:   TIM1 clock
   1218            *            @arg RCC_APB2Periph_TIM8:   TIM8 clock
   1219            *            @arg RCC_APB2Periph_USART1: USART1 clock
   1220            *            @arg RCC_APB2Periph_USART6: USART6 clock
   1221            *            @arg RCC_APB2Periph_ADC1:   ADC1 clock
   1222            *            @arg RCC_APB2Periph_ADC2:   ADC2 clock
   1223            *            @arg RCC_APB2Periph_ADC3:   ADC3 clock
   1224            *            @arg RCC_APB2Periph_SDIO:   SDIO clock
   1225            *            @arg RCC_APB2Periph_SPI1:   SPI1 clock
   1226            *            @arg RCC_APB2Periph_SYSCFG: SYSCFG clock
   1227            *            @arg RCC_APB2Periph_TIM9:   TIM9 clock
   1228            *            @arg RCC_APB2Periph_TIM10:  TIM10 clock
   1229            *            @arg RCC_APB2Periph_TIM11:  TIM11 clock
   1230            * @param  NewState: new state of the specified peripheral clock.
   1231            *          This parameter can be: ENABLE or DISABLE.
   1232            * @retval None
   1233            */

   \                                 In section .text, align 2, keep-with-next
   1234          void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
   1235          {
   \                     RCC_APB2PeriphClockCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1236            /* Check the parameters */
   1237            assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable42_47  ;; 0xfff8a0cc
   \   0000000A   0x4204             TST      R4,R0
   \   0000000C   0xD101             BNE.N    ??RCC_APB2PeriphClockCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD104             BNE.N    ??RCC_APB2PeriphClockCmd_1
   \                     ??RCC_APB2PeriphClockCmd_0: (+1)
   \   00000012   0xF240 0x41D5      MOVW     R1,#+1237
   \   00000016   0x....             LDR.N    R0,??DataTable31
   \   00000018   0x.... 0x....      BL       assert_failed
   1238            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_APB2PeriphClockCmd_1: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??RCC_APB2PeriphClockCmd_2
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD004             BEQ.N    ??RCC_APB2PeriphClockCmd_2
   \   00000028   0xF240 0x41D6      MOVW     R1,#+1238
   \   0000002C   0x....             LDR.N    R0,??DataTable31
   \   0000002E   0x.... 0x....      BL       assert_failed
   1239          
   1240            if (NewState != DISABLE)
   \                     ??RCC_APB2PeriphClockCmd_2: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD007             BEQ.N    ??RCC_APB2PeriphClockCmd_3
   1241            {
   1242              RCC->APB2ENR |= RCC_APB2Periph;
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable42_48  ;; 0x40023844
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x4320             ORRS     R0,R4,R0
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable42_48  ;; 0x40023844
   \   00000044   0x6008             STR      R0,[R1, #+0]
   \   00000046   0xE006             B.N      ??RCC_APB2PeriphClockCmd_4
   1243            }
   1244            else
   1245            {
   1246              RCC->APB2ENR &= ~RCC_APB2Periph;
   \                     ??RCC_APB2PeriphClockCmd_3: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable42_48  ;; 0x40023844
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x43A0             BICS     R0,R0,R4
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable42_48  ;; 0x40023844
   \   00000054   0x6008             STR      R0,[R1, #+0]
   1247            }
   1248          }
   \                     ??RCC_APB2PeriphClockCmd_4: (+1)
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1249          
   1250          /**
   1251            * @brief  Forces or releases AHB1 peripheral reset.
   1252            * @param  RCC_AHB1Periph: specifies the AHB1 peripheral to reset.
   1253            *          This parameter can be any combination of the following values:
   1254            *            @arg RCC_AHB1Periph_GPIOA:   GPIOA clock
   1255            *            @arg RCC_AHB1Periph_GPIOB:   GPIOB clock 
   1256            *            @arg RCC_AHB1Periph_GPIOC:   GPIOC clock
   1257            *            @arg RCC_AHB1Periph_GPIOD:   GPIOD clock
   1258            *            @arg RCC_AHB1Periph_GPIOE:   GPIOE clock
   1259            *            @arg RCC_AHB1Periph_GPIOF:   GPIOF clock
   1260            *            @arg RCC_AHB1Periph_GPIOG:   GPIOG clock
   1261            *            @arg RCC_AHB1Periph_GPIOG:   GPIOG clock
   1262            *            @arg RCC_AHB1Periph_GPIOI:   GPIOI clock
   1263            *            @arg RCC_AHB1Periph_CRC:     CRC clock
   1264            *            @arg RCC_AHB1Periph_DMA1:    DMA1 clock
   1265            *            @arg RCC_AHB1Periph_DMA2:    DMA2 clock
   1266            *            @arg RCC_AHB1Periph_ETH_MAC: Ethernet MAC clock
   1267            *            @arg RCC_AHB1Periph_OTG_HS:  USB OTG HS clock
   1268            *                  
   1269            * @param  NewState: new state of the specified peripheral reset.
   1270            *          This parameter can be: ENABLE or DISABLE.
   1271            * @retval None
   1272            */

   \                                 In section .text, align 2, keep-with-next
   1273          void RCC_AHB1PeriphResetCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
   1274          {
   \                     RCC_AHB1PeriphResetCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1275            /* Check the parameters */
   1276            assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable42_49  ;; 0xdd9fee00
   \   0000000A   0x4204             TST      R4,R0
   \   0000000C   0xD101             BNE.N    ??RCC_AHB1PeriphResetCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD104             BNE.N    ??RCC_AHB1PeriphResetCmd_1
   \                     ??RCC_AHB1PeriphResetCmd_0: (+1)
   \   00000012   0xF240 0x41FC      MOVW     R1,#+1276
   \   00000016   0x....             LDR.N    R0,??DataTable31
   \   00000018   0x.... 0x....      BL       assert_failed
   1277            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_AHB1PeriphResetCmd_1: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??RCC_AHB1PeriphResetCmd_2
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD004             BEQ.N    ??RCC_AHB1PeriphResetCmd_2
   \   00000028   0xF240 0x41FD      MOVW     R1,#+1277
   \   0000002C   0x....             LDR.N    R0,??DataTable31
   \   0000002E   0x.... 0x....      BL       assert_failed
   1278          
   1279            if (NewState != DISABLE)
   \                     ??RCC_AHB1PeriphResetCmd_2: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD007             BEQ.N    ??RCC_AHB1PeriphResetCmd_3
   1280            {
   1281              RCC->AHB1RSTR |= RCC_AHB1Periph;
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable42_50  ;; 0x40023810
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x4320             ORRS     R0,R4,R0
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable42_50  ;; 0x40023810
   \   00000044   0x6008             STR      R0,[R1, #+0]
   \   00000046   0xE006             B.N      ??RCC_AHB1PeriphResetCmd_4
   1282            }
   1283            else
   1284            {
   1285              RCC->AHB1RSTR &= ~RCC_AHB1Periph;
   \                     ??RCC_AHB1PeriphResetCmd_3: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable42_50  ;; 0x40023810
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x43A0             BICS     R0,R0,R4
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable42_50  ;; 0x40023810
   \   00000054   0x6008             STR      R0,[R1, #+0]
   1286            }
   1287          }
   \                     ??RCC_AHB1PeriphResetCmd_4: (+1)
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1288          
   1289          /**
   1290            * @brief  Forces or releases AHB2 peripheral reset.
   1291            * @param  RCC_AHB2Periph: specifies the AHB2 peripheral to reset.
   1292            *          This parameter can be any combination of the following values:
   1293            *            @arg RCC_AHB2Periph_DCMI:   DCMI clock
   1294            *            @arg RCC_AHB2Periph_CRYP:   CRYP clock
   1295            *            @arg RCC_AHB2Periph_HASH:   HASH clock
   1296            *            @arg RCC_AHB2Periph_RNG:    RNG clock
   1297            *            @arg RCC_AHB2Periph_OTG_FS: USB OTG FS clock
   1298            * @param  NewState: new state of the specified peripheral reset.
   1299            *          This parameter can be: ENABLE or DISABLE.
   1300            * @retval None
   1301            */

   \                                 In section .text, align 2, keep-with-next
   1302          void RCC_AHB2PeriphResetCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
   1303          {
   \                     RCC_AHB2PeriphResetCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1304            /* Check the parameters */
   1305            assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
   \   00000006   0xF034 0x00F1      BICS     R0,R4,#0xF1
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??RCC_AHB2PeriphResetCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD104             BNE.N    ??RCC_AHB2PeriphResetCmd_1
   \                     ??RCC_AHB2PeriphResetCmd_0: (+1)
   \   00000012   0xF240 0x5119      MOVW     R1,#+1305
   \   00000016   0x....             LDR.N    R0,??DataTable31
   \   00000018   0x.... 0x....      BL       assert_failed
   1306            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_AHB2PeriphResetCmd_1: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??RCC_AHB2PeriphResetCmd_2
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD004             BEQ.N    ??RCC_AHB2PeriphResetCmd_2
   \   00000028   0xF240 0x511A      MOVW     R1,#+1306
   \   0000002C   0x....             LDR.N    R0,??DataTable31
   \   0000002E   0x.... 0x....      BL       assert_failed
   1307          
   1308            if (NewState != DISABLE)
   \                     ??RCC_AHB2PeriphResetCmd_2: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD007             BEQ.N    ??RCC_AHB2PeriphResetCmd_3
   1309            {
   1310              RCC->AHB2RSTR |= RCC_AHB2Periph;
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable42_51  ;; 0x40023814
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x4320             ORRS     R0,R4,R0
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable42_51  ;; 0x40023814
   \   00000044   0x6008             STR      R0,[R1, #+0]
   \   00000046   0xE006             B.N      ??RCC_AHB2PeriphResetCmd_4
   1311            }
   1312            else
   1313            {
   1314              RCC->AHB2RSTR &= ~RCC_AHB2Periph;
   \                     ??RCC_AHB2PeriphResetCmd_3: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable42_51  ;; 0x40023814
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x43A0             BICS     R0,R0,R4
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable42_51  ;; 0x40023814
   \   00000054   0x6008             STR      R0,[R1, #+0]
   1315            }
   1316          }
   \                     ??RCC_AHB2PeriphResetCmd_4: (+1)
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1317          
   1318          /**
   1319            * @brief  Forces or releases AHB3 peripheral reset.
   1320            * @param  RCC_AHB3Periph: specifies the AHB3 peripheral to reset.
   1321            *          This parameter must be: RCC_AHB3Periph_FSMC
   1322            * @param  NewState: new state of the specified peripheral reset.
   1323            *          This parameter can be: ENABLE or DISABLE.
   1324            * @retval None
   1325            */

   \                                 In section .text, align 2, keep-with-next
   1326          void RCC_AHB3PeriphResetCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
   1327          {
   \                     RCC_AHB3PeriphResetCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1328            /* Check the parameters */
   1329            assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
   \   00000006   0x0860             LSRS     R0,R4,#+1
   \   00000008   0x0040             LSLS     R0,R0,#+1
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??RCC_AHB3PeriphResetCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD104             BNE.N    ??RCC_AHB3PeriphResetCmd_1
   \                     ??RCC_AHB3PeriphResetCmd_0: (+1)
   \   00000012   0xF240 0x5131      MOVW     R1,#+1329
   \   00000016   0x....             LDR.N    R0,??DataTable31
   \   00000018   0x.... 0x....      BL       assert_failed
   1330            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_AHB3PeriphResetCmd_1: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??RCC_AHB3PeriphResetCmd_2
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD004             BEQ.N    ??RCC_AHB3PeriphResetCmd_2
   \   00000028   0xF240 0x5132      MOVW     R1,#+1330
   \   0000002C   0x....             LDR.N    R0,??DataTable31
   \   0000002E   0x.... 0x....      BL       assert_failed
   1331          
   1332            if (NewState != DISABLE)
   \                     ??RCC_AHB3PeriphResetCmd_2: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD007             BEQ.N    ??RCC_AHB3PeriphResetCmd_3
   1333            {
   1334              RCC->AHB3RSTR |= RCC_AHB3Periph;
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable42_52  ;; 0x40023818
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x4320             ORRS     R0,R4,R0
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable42_52  ;; 0x40023818
   \   00000044   0x6008             STR      R0,[R1, #+0]
   \   00000046   0xE006             B.N      ??RCC_AHB3PeriphResetCmd_4
   1335            }
   1336            else
   1337            {
   1338              RCC->AHB3RSTR &= ~RCC_AHB3Periph;
   \                     ??RCC_AHB3PeriphResetCmd_3: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable42_52  ;; 0x40023818
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x43A0             BICS     R0,R0,R4
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable42_52  ;; 0x40023818
   \   00000054   0x6008             STR      R0,[R1, #+0]
   1339            }
   1340          }
   \                     ??RCC_AHB3PeriphResetCmd_4: (+1)
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1341          
   1342          /**
   1343            * @brief  Forces or releases Low Speed APB (APB1) peripheral reset.
   1344            * @param  RCC_APB1Periph: specifies the APB1 peripheral to reset.
   1345            *          This parameter can be any combination of the following values:
   1346            *            @arg RCC_APB1Periph_TIM2:   TIM2 clock
   1347            *            @arg RCC_APB1Periph_TIM3:   TIM3 clock
   1348            *            @arg RCC_APB1Periph_TIM4:   TIM4 clock
   1349            *            @arg RCC_APB1Periph_TIM5:   TIM5 clock
   1350            *            @arg RCC_APB1Periph_TIM6:   TIM6 clock
   1351            *            @arg RCC_APB1Periph_TIM7:   TIM7 clock
   1352            *            @arg RCC_APB1Periph_TIM12:  TIM12 clock
   1353            *            @arg RCC_APB1Periph_TIM13:  TIM13 clock
   1354            *            @arg RCC_APB1Periph_TIM14:  TIM14 clock
   1355            *            @arg RCC_APB1Periph_WWDG:   WWDG clock
   1356            *            @arg RCC_APB1Periph_SPI2:   SPI2 clock
   1357            *            @arg RCC_APB1Periph_SPI3:   SPI3 clock
   1358            *            @arg RCC_APB1Periph_USART2: USART2 clock
   1359            *            @arg RCC_APB1Periph_USART3: USART3 clock
   1360            *            @arg RCC_APB1Periph_UART4:  UART4 clock
   1361            *            @arg RCC_APB1Periph_UART5:  UART5 clock
   1362            *            @arg RCC_APB1Periph_I2C1:   I2C1 clock
   1363            *            @arg RCC_APB1Periph_I2C2:   I2C2 clock
   1364            *            @arg RCC_APB1Periph_I2C3:   I2C3 clock
   1365            *            @arg RCC_APB1Periph_CAN1:   CAN1 clock
   1366            *            @arg RCC_APB1Periph_CAN2:   CAN2 clock
   1367            *            @arg RCC_APB1Periph_PWR:    PWR clock
   1368            *            @arg RCC_APB1Periph_DAC:    DAC clock
   1369            * @param  NewState: new state of the specified peripheral reset.
   1370            *          This parameter can be: ENABLE or DISABLE.
   1371            * @retval None
   1372            */

   \                                 In section .text, align 2, keep-with-next
   1373          void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
   1374          {
   \                     RCC_APB1PeriphResetCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1375            /* Check the parameters */
   1376            assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable42_45  ;; 0xc9013600
   \   0000000A   0x4204             TST      R4,R0
   \   0000000C   0xD101             BNE.N    ??RCC_APB1PeriphResetCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD104             BNE.N    ??RCC_APB1PeriphResetCmd_1
   \                     ??RCC_APB1PeriphResetCmd_0: (+1)
   \   00000012   0xF44F 0x61AC      MOV      R1,#+1376
   \   00000016   0x....             LDR.N    R0,??DataTable31
   \   00000018   0x.... 0x....      BL       assert_failed
   1377            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_APB1PeriphResetCmd_1: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??RCC_APB1PeriphResetCmd_2
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD004             BEQ.N    ??RCC_APB1PeriphResetCmd_2
   \   00000028   0xF240 0x5161      MOVW     R1,#+1377
   \   0000002C   0x....             LDR.N    R0,??DataTable31
   \   0000002E   0x.... 0x....      BL       assert_failed
   1378            if (NewState != DISABLE)
   \                     ??RCC_APB1PeriphResetCmd_2: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD007             BEQ.N    ??RCC_APB1PeriphResetCmd_3
   1379            {
   1380              RCC->APB1RSTR |= RCC_APB1Periph;
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable42_53  ;; 0x40023820
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x4320             ORRS     R0,R4,R0
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable42_53  ;; 0x40023820
   \   00000044   0x6008             STR      R0,[R1, #+0]
   \   00000046   0xE006             B.N      ??RCC_APB1PeriphResetCmd_4
   1381            }
   1382            else
   1383            {
   1384              RCC->APB1RSTR &= ~RCC_APB1Periph;
   \                     ??RCC_APB1PeriphResetCmd_3: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable42_53  ;; 0x40023820
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x43A0             BICS     R0,R0,R4
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable42_53  ;; 0x40023820
   \   00000054   0x6008             STR      R0,[R1, #+0]
   1385            }
   1386          }
   \                     ??RCC_APB1PeriphResetCmd_4: (+1)
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1387          
   1388          /**
   1389            * @brief  Forces or releases High Speed APB (APB2) peripheral reset.
   1390            * @param  RCC_APB2Periph: specifies the APB2 peripheral to reset.
   1391            *          This parameter can be any combination of the following values:
   1392            *            @arg RCC_APB2Periph_TIM1:   TIM1 clock
   1393            *            @arg RCC_APB2Periph_TIM8:   TIM8 clock
   1394            *            @arg RCC_APB2Periph_USART1: USART1 clock
   1395            *            @arg RCC_APB2Periph_USART6: USART6 clock
   1396            *            @arg RCC_APB2Periph_ADC1:   ADC1 clock
   1397            *            @arg RCC_APB2Periph_ADC2:   ADC2 clock
   1398            *            @arg RCC_APB2Periph_ADC3:   ADC3 clock
   1399            *            @arg RCC_APB2Periph_SDIO:   SDIO clock
   1400            *            @arg RCC_APB2Periph_SPI1:   SPI1 clock
   1401            *            @arg RCC_APB2Periph_SYSCFG: SYSCFG clock
   1402            *            @arg RCC_APB2Periph_TIM9:   TIM9 clock
   1403            *            @arg RCC_APB2Periph_TIM10:  TIM10 clock
   1404            *            @arg RCC_APB2Periph_TIM11:  TIM11 clock
   1405            * @param  NewState: new state of the specified peripheral reset.
   1406            *          This parameter can be: ENABLE or DISABLE.
   1407            * @retval None
   1408            */

   \                                 In section .text, align 2, keep-with-next
   1409          void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
   1410          {
   \                     RCC_APB2PeriphResetCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1411            /* Check the parameters */
   1412            assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable42_54  ;; 0xfff8a6cc
   \   0000000A   0x4204             TST      R4,R0
   \   0000000C   0xD101             BNE.N    ??RCC_APB2PeriphResetCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD105             BNE.N    ??RCC_APB2PeriphResetCmd_1
   \                     ??RCC_APB2PeriphResetCmd_0: (+1)
   \   00000012   0xF240 0x5184      MOVW     R1,#+1412
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable42_55
   \   0000001A   0x.... 0x....      BL       assert_failed
   1413            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_APB2PeriphResetCmd_1: (+1)
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD008             BEQ.N    ??RCC_APB2PeriphResetCmd_2
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D01             CMP      R5,#+1
   \   00000028   0xD005             BEQ.N    ??RCC_APB2PeriphResetCmd_2
   \   0000002A   0xF240 0x5185      MOVW     R1,#+1413
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable42_55
   \   00000032   0x.... 0x....      BL       assert_failed
   1414            if (NewState != DISABLE)
   \                     ??RCC_APB2PeriphResetCmd_2: (+1)
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD007             BEQ.N    ??RCC_APB2PeriphResetCmd_3
   1415            {
   1416              RCC->APB2RSTR |= RCC_APB2Periph;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable42_56  ;; 0x40023824
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x4320             ORRS     R0,R4,R0
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable42_56  ;; 0x40023824
   \   00000048   0x6008             STR      R0,[R1, #+0]
   \   0000004A   0xE006             B.N      ??RCC_APB2PeriphResetCmd_4
   1417            }
   1418            else
   1419            {
   1420              RCC->APB2RSTR &= ~RCC_APB2Periph;
   \                     ??RCC_APB2PeriphResetCmd_3: (+1)
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable42_56  ;; 0x40023824
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x43A0             BICS     R0,R0,R4
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable42_56  ;; 0x40023824
   \   00000058   0x6008             STR      R0,[R1, #+0]
   1421            }
   1422          }
   \                     ??RCC_APB2PeriphResetCmd_4: (+1)
   \   0000005A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1423          
   1424          /**
   1425            * @brief  Enables or disables the AHB1 peripheral clock during Low Power (Sleep) mode.
   1426            * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
   1427            *         power consumption.
   1428            * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
   1429            * @note   By default, all peripheral clocks are enabled during SLEEP mode.
   1430            * @param  RCC_AHBPeriph: specifies the AHB1 peripheral to gates its clock.
   1431            *          This parameter can be any combination of the following values:
   1432            *            @arg RCC_AHB1Periph_GPIOA:       GPIOA clock
   1433            *            @arg RCC_AHB1Periph_GPIOB:       GPIOB clock 
   1434            *            @arg RCC_AHB1Periph_GPIOC:       GPIOC clock
   1435            *            @arg RCC_AHB1Periph_GPIOD:       GPIOD clock
   1436            *            @arg RCC_AHB1Periph_GPIOE:       GPIOE clock
   1437            *            @arg RCC_AHB1Periph_GPIOF:       GPIOF clock
   1438            *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
   1439            *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
   1440            *            @arg RCC_AHB1Periph_GPIOI:       GPIOI clock
   1441            *            @arg RCC_AHB1Periph_CRC:         CRC clock
   1442            *            @arg RCC_AHB1Periph_BKPSRAM:     BKPSRAM interface clock
   1443            *            @arg RCC_AHB1Periph_DMA1:        DMA1 clock
   1444            *            @arg RCC_AHB1Periph_DMA2:        DMA2 clock
   1445            *            @arg RCC_AHB1Periph_ETH_MAC:     Ethernet MAC clock
   1446            *            @arg RCC_AHB1Periph_ETH_MAC_Tx:  Ethernet Transmission clock
   1447            *            @arg RCC_AHB1Periph_ETH_MAC_Rx:  Ethernet Reception clock
   1448            *            @arg RCC_AHB1Periph_ETH_MAC_PTP: Ethernet PTP clock
   1449            *            @arg RCC_AHB1Periph_OTG_HS:      USB OTG HS clock
   1450            *            @arg RCC_AHB1Periph_OTG_HS_ULPI: USB OTG HS ULPI clock
   1451            * @param  NewState: new state of the specified peripheral clock.
   1452            *          This parameter can be: ENABLE or DISABLE.
   1453            * @retval None
   1454            */

   \                                 In section .text, align 2, keep-with-next
   1455          void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
   1456          {
   \                     RCC_AHB1PeriphClockLPModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1457            /* Check the parameters */
   1458            assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable42_57  ;; 0x81986e00
   \   0000000A   0x4204             TST      R4,R0
   \   0000000C   0xD101             BNE.N    ??RCC_AHB1PeriphClockLPModeCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD105             BNE.N    ??RCC_AHB1PeriphClockLPModeCmd_1
   \                     ??RCC_AHB1PeriphClockLPModeCmd_0: (+1)
   \   00000012   0xF240 0x51B2      MOVW     R1,#+1458
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable42_55
   \   0000001A   0x.... 0x....      BL       assert_failed
   1459            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_AHB1PeriphClockLPModeCmd_1: (+1)
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD008             BEQ.N    ??RCC_AHB1PeriphClockLPModeCmd_2
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D01             CMP      R5,#+1
   \   00000028   0xD005             BEQ.N    ??RCC_AHB1PeriphClockLPModeCmd_2
   \   0000002A   0xF240 0x51B3      MOVW     R1,#+1459
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable42_55
   \   00000032   0x.... 0x....      BL       assert_failed
   1460            if (NewState != DISABLE)
   \                     ??RCC_AHB1PeriphClockLPModeCmd_2: (+1)
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD007             BEQ.N    ??RCC_AHB1PeriphClockLPModeCmd_3
   1461            {
   1462              RCC->AHB1LPENR |= RCC_AHB1Periph;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable42_58  ;; 0x40023850
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x4320             ORRS     R0,R4,R0
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable42_58  ;; 0x40023850
   \   00000048   0x6008             STR      R0,[R1, #+0]
   \   0000004A   0xE006             B.N      ??RCC_AHB1PeriphClockLPModeCmd_4
   1463            }
   1464            else
   1465            {
   1466              RCC->AHB1LPENR &= ~RCC_AHB1Periph;
   \                     ??RCC_AHB1PeriphClockLPModeCmd_3: (+1)
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable42_58  ;; 0x40023850
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x43A0             BICS     R0,R0,R4
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable42_58  ;; 0x40023850
   \   00000058   0x6008             STR      R0,[R1, #+0]
   1467            }
   1468          }
   \                     ??RCC_AHB1PeriphClockLPModeCmd_4: (+1)
   \   0000005A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1469          
   1470          /**
   1471            * @brief  Enables or disables the AHB2 peripheral clock during Low Power (Sleep) mode.
   1472            * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
   1473            *           power consumption.
   1474            * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
   1475            * @note   By default, all peripheral clocks are enabled during SLEEP mode.
   1476            * @param  RCC_AHBPeriph: specifies the AHB2 peripheral to gates its clock.
   1477            *          This parameter can be any combination of the following values:
   1478            *            @arg RCC_AHB2Periph_DCMI:   DCMI clock
   1479            *            @arg RCC_AHB2Periph_CRYP:   CRYP clock
   1480            *            @arg RCC_AHB2Periph_HASH:   HASH clock
   1481            *            @arg RCC_AHB2Periph_RNG:    RNG clock
   1482            *            @arg RCC_AHB2Periph_OTG_FS: USB OTG FS clock  
   1483            * @param  NewState: new state of the specified peripheral clock.
   1484            *          This parameter can be: ENABLE or DISABLE.
   1485            * @retval None
   1486            */

   \                                 In section .text, align 2, keep-with-next
   1487          void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
   1488          {
   \                     RCC_AHB2PeriphClockLPModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1489            /* Check the parameters */
   1490            assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
   \   00000006   0xF034 0x00F1      BICS     R0,R4,#0xF1
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??RCC_AHB2PeriphClockLPModeCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD105             BNE.N    ??RCC_AHB2PeriphClockLPModeCmd_1
   \                     ??RCC_AHB2PeriphClockLPModeCmd_0: (+1)
   \   00000012   0xF240 0x51D2      MOVW     R1,#+1490
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable42_55
   \   0000001A   0x.... 0x....      BL       assert_failed
   1491            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_AHB2PeriphClockLPModeCmd_1: (+1)
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD008             BEQ.N    ??RCC_AHB2PeriphClockLPModeCmd_2
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D01             CMP      R5,#+1
   \   00000028   0xD005             BEQ.N    ??RCC_AHB2PeriphClockLPModeCmd_2
   \   0000002A   0xF240 0x51D3      MOVW     R1,#+1491
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable42_55
   \   00000032   0x.... 0x....      BL       assert_failed
   1492            if (NewState != DISABLE)
   \                     ??RCC_AHB2PeriphClockLPModeCmd_2: (+1)
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD007             BEQ.N    ??RCC_AHB2PeriphClockLPModeCmd_3
   1493            {
   1494              RCC->AHB2LPENR |= RCC_AHB2Periph;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable42_59  ;; 0x40023854
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x4320             ORRS     R0,R4,R0
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable42_59  ;; 0x40023854
   \   00000048   0x6008             STR      R0,[R1, #+0]
   \   0000004A   0xE006             B.N      ??RCC_AHB2PeriphClockLPModeCmd_4
   1495            }
   1496            else
   1497            {
   1498              RCC->AHB2LPENR &= ~RCC_AHB2Periph;
   \                     ??RCC_AHB2PeriphClockLPModeCmd_3: (+1)
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable42_59  ;; 0x40023854
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x43A0             BICS     R0,R0,R4
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable42_59  ;; 0x40023854
   \   00000058   0x6008             STR      R0,[R1, #+0]
   1499            }
   1500          }
   \                     ??RCC_AHB2PeriphClockLPModeCmd_4: (+1)
   \   0000005A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1501          
   1502          /**
   1503            * @brief  Enables or disables the AHB3 peripheral clock during Low Power (Sleep) mode.
   1504            * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
   1505            *         power consumption.
   1506            * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
   1507            * @note   By default, all peripheral clocks are enabled during SLEEP mode.
   1508            * @param  RCC_AHBPeriph: specifies the AHB3 peripheral to gates its clock.
   1509            *          This parameter must be: RCC_AHB3Periph_FSMC
   1510            * @param  NewState: new state of the specified peripheral clock.
   1511            *          This parameter can be: ENABLE or DISABLE.
   1512            * @retval None
   1513            */

   \                                 In section .text, align 2, keep-with-next
   1514          void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
   1515          {
   \                     RCC_AHB3PeriphClockLPModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1516            /* Check the parameters */
   1517            assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
   \   00000006   0x0860             LSRS     R0,R4,#+1
   \   00000008   0x0040             LSLS     R0,R0,#+1
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??RCC_AHB3PeriphClockLPModeCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD105             BNE.N    ??RCC_AHB3PeriphClockLPModeCmd_1
   \                     ??RCC_AHB3PeriphClockLPModeCmd_0: (+1)
   \   00000012   0xF240 0x51ED      MOVW     R1,#+1517
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable42_55
   \   0000001A   0x.... 0x....      BL       assert_failed
   1518            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_AHB3PeriphClockLPModeCmd_1: (+1)
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD007             BEQ.N    ??RCC_AHB3PeriphClockLPModeCmd_2
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D01             CMP      R5,#+1
   \   00000028   0xD004             BEQ.N    ??RCC_AHB3PeriphClockLPModeCmd_2
   \   0000002A   0xF240 0x51EE      MOVW     R1,#+1518
   \   0000002E   0x....             LDR.N    R0,??DataTable42_55
   \   00000030   0x.... 0x....      BL       assert_failed
   1519            if (NewState != DISABLE)
   \                     ??RCC_AHB3PeriphClockLPModeCmd_2: (+1)
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0xD005             BEQ.N    ??RCC_AHB3PeriphClockLPModeCmd_3
   1520            {
   1521              RCC->AHB3LPENR |= RCC_AHB3Periph;
   \   0000003A   0x....             LDR.N    R0,??DataTable42_60  ;; 0x40023858
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x4320             ORRS     R0,R4,R0
   \   00000040   0x....             LDR.N    R1,??DataTable42_60  ;; 0x40023858
   \   00000042   0x6008             STR      R0,[R1, #+0]
   \   00000044   0xE004             B.N      ??RCC_AHB3PeriphClockLPModeCmd_4
   1522            }
   1523            else
   1524            {
   1525              RCC->AHB3LPENR &= ~RCC_AHB3Periph;
   \                     ??RCC_AHB3PeriphClockLPModeCmd_3: (+1)
   \   00000046   0x....             LDR.N    R0,??DataTable42_60  ;; 0x40023858
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x43A0             BICS     R0,R0,R4
   \   0000004C   0x....             LDR.N    R1,??DataTable42_60  ;; 0x40023858
   \   0000004E   0x6008             STR      R0,[R1, #+0]
   1526            }
   1527          }
   \                     ??RCC_AHB3PeriphClockLPModeCmd_4: (+1)
   \   00000050   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1528          
   1529          /**
   1530            * @brief  Enables or disables the APB1 peripheral clock during Low Power (Sleep) mode.
   1531            * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
   1532            *         power consumption.
   1533            * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
   1534            * @note   By default, all peripheral clocks are enabled during SLEEP mode.
   1535            * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
   1536            *          This parameter can be any combination of the following values:
   1537            *            @arg RCC_APB1Periph_TIM2:   TIM2 clock
   1538            *            @arg RCC_APB1Periph_TIM3:   TIM3 clock
   1539            *            @arg RCC_APB1Periph_TIM4:   TIM4 clock
   1540            *            @arg RCC_APB1Periph_TIM5:   TIM5 clock
   1541            *            @arg RCC_APB1Periph_TIM6:   TIM6 clock
   1542            *            @arg RCC_APB1Periph_TIM7:   TIM7 clock
   1543            *            @arg RCC_APB1Periph_TIM12:  TIM12 clock
   1544            *            @arg RCC_APB1Periph_TIM13:  TIM13 clock
   1545            *            @arg RCC_APB1Periph_TIM14:  TIM14 clock
   1546            *            @arg RCC_APB1Periph_WWDG:   WWDG clock
   1547            *            @arg RCC_APB1Periph_SPI2:   SPI2 clock
   1548            *            @arg RCC_APB1Periph_SPI3:   SPI3 clock
   1549            *            @arg RCC_APB1Periph_USART2: USART2 clock
   1550            *            @arg RCC_APB1Periph_USART3: USART3 clock
   1551            *            @arg RCC_APB1Periph_UART4:  UART4 clock
   1552            *            @arg RCC_APB1Periph_UART5:  UART5 clock
   1553            *            @arg RCC_APB1Periph_I2C1:   I2C1 clock
   1554            *            @arg RCC_APB1Periph_I2C2:   I2C2 clock
   1555            *            @arg RCC_APB1Periph_I2C3:   I2C3 clock
   1556            *            @arg RCC_APB1Periph_CAN1:   CAN1 clock
   1557            *            @arg RCC_APB1Periph_CAN2:   CAN2 clock
   1558            *            @arg RCC_APB1Periph_PWR:    PWR clock
   1559            *            @arg RCC_APB1Periph_DAC:    DAC clock
   1560            * @param  NewState: new state of the specified peripheral clock.
   1561            *          This parameter can be: ENABLE or DISABLE.
   1562            * @retval None
   1563            */

   \                                 In section .text, align 2, keep-with-next
   1564          void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
   1565          {
   \                     RCC_APB1PeriphClockLPModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1566            /* Check the parameters */
   1567            assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
   \   00000006   0x....             LDR.N    R0,??DataTable42_45  ;; 0xc9013600
   \   00000008   0x4204             TST      R4,R0
   \   0000000A   0xD101             BNE.N    ??RCC_APB1PeriphClockLPModeCmd_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD104             BNE.N    ??RCC_APB1PeriphClockLPModeCmd_1
   \                     ??RCC_APB1PeriphClockLPModeCmd_0: (+1)
   \   00000010   0xF240 0x611F      MOVW     R1,#+1567
   \   00000014   0x....             LDR.N    R0,??DataTable42_55
   \   00000016   0x.... 0x....      BL       assert_failed
   1568            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_APB1PeriphClockLPModeCmd_1: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD007             BEQ.N    ??RCC_APB1PeriphClockLPModeCmd_2
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD004             BEQ.N    ??RCC_APB1PeriphClockLPModeCmd_2
   \   00000026   0xF44F 0x61C4      MOV      R1,#+1568
   \   0000002A   0x....             LDR.N    R0,??DataTable42_55
   \   0000002C   0x.... 0x....      BL       assert_failed
   1569            if (NewState != DISABLE)
   \                     ??RCC_APB1PeriphClockLPModeCmd_2: (+1)
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD005             BEQ.N    ??RCC_APB1PeriphClockLPModeCmd_3
   1570            {
   1571              RCC->APB1LPENR |= RCC_APB1Periph;
   \   00000036   0x....             LDR.N    R0,??DataTable42_61  ;; 0x40023860
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x4320             ORRS     R0,R4,R0
   \   0000003C   0x....             LDR.N    R1,??DataTable42_61  ;; 0x40023860
   \   0000003E   0x6008             STR      R0,[R1, #+0]
   \   00000040   0xE004             B.N      ??RCC_APB1PeriphClockLPModeCmd_4
   1572            }
   1573            else
   1574            {
   1575              RCC->APB1LPENR &= ~RCC_APB1Periph;
   \                     ??RCC_APB1PeriphClockLPModeCmd_3: (+1)
   \   00000042   0x....             LDR.N    R0,??DataTable42_61  ;; 0x40023860
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x43A0             BICS     R0,R0,R4
   \   00000048   0x....             LDR.N    R1,??DataTable42_61  ;; 0x40023860
   \   0000004A   0x6008             STR      R0,[R1, #+0]
   1576            }
   1577          }
   \                     ??RCC_APB1PeriphClockLPModeCmd_4: (+1)
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1578          
   1579          /**
   1580            * @brief  Enables or disables the APB2 peripheral clock during Low Power (Sleep) mode.
   1581            * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
   1582            *         power consumption.
   1583            * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
   1584            * @note   By default, all peripheral clocks are enabled during SLEEP mode.
   1585            * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
   1586            *          This parameter can be any combination of the following values:
   1587            *            @arg RCC_APB2Periph_TIM1:   TIM1 clock
   1588            *            @arg RCC_APB2Periph_TIM8:   TIM8 clock
   1589            *            @arg RCC_APB2Periph_USART1: USART1 clock
   1590            *            @arg RCC_APB2Periph_USART6: USART6 clock
   1591            *            @arg RCC_APB2Periph_ADC1:   ADC1 clock
   1592            *            @arg RCC_APB2Periph_ADC2:   ADC2 clock
   1593            *            @arg RCC_APB2Periph_ADC3:   ADC3 clock
   1594            *            @arg RCC_APB2Periph_SDIO:   SDIO clock
   1595            *            @arg RCC_APB2Periph_SPI1:   SPI1 clock
   1596            *            @arg RCC_APB2Periph_SYSCFG: SYSCFG clock
   1597            *            @arg RCC_APB2Periph_TIM9:   TIM9 clock
   1598            *            @arg RCC_APB2Periph_TIM10:  TIM10 clock
   1599            *            @arg RCC_APB2Periph_TIM11:  TIM11 clock
   1600            * @param  NewState: new state of the specified peripheral clock.
   1601            *          This parameter can be: ENABLE or DISABLE.
   1602            * @retval None
   1603            */

   \                                 In section .text, align 2, keep-with-next
   1604          void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
   1605          {
   \                     RCC_APB2PeriphClockLPModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1606            /* Check the parameters */
   1607            assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
   \   00000006   0x....             LDR.N    R0,??DataTable42_47  ;; 0xfff8a0cc
   \   00000008   0x4204             TST      R4,R0
   \   0000000A   0xD101             BNE.N    ??RCC_APB2PeriphClockLPModeCmd_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD104             BNE.N    ??RCC_APB2PeriphClockLPModeCmd_1
   \                     ??RCC_APB2PeriphClockLPModeCmd_0: (+1)
   \   00000010   0xF240 0x6147      MOVW     R1,#+1607
   \   00000014   0x....             LDR.N    R0,??DataTable42_55
   \   00000016   0x.... 0x....      BL       assert_failed
   1608            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_APB2PeriphClockLPModeCmd_1: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD007             BEQ.N    ??RCC_APB2PeriphClockLPModeCmd_2
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD004             BEQ.N    ??RCC_APB2PeriphClockLPModeCmd_2
   \   00000026   0xF44F 0x61C9      MOV      R1,#+1608
   \   0000002A   0x....             LDR.N    R0,??DataTable42_55
   \   0000002C   0x.... 0x....      BL       assert_failed
   1609            if (NewState != DISABLE)
   \                     ??RCC_APB2PeriphClockLPModeCmd_2: (+1)
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD005             BEQ.N    ??RCC_APB2PeriphClockLPModeCmd_3
   1610            {
   1611              RCC->APB2LPENR |= RCC_APB2Periph;
   \   00000036   0x....             LDR.N    R0,??DataTable42_62  ;; 0x40023864
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x4320             ORRS     R0,R4,R0
   \   0000003C   0x....             LDR.N    R1,??DataTable42_62  ;; 0x40023864
   \   0000003E   0x6008             STR      R0,[R1, #+0]
   \   00000040   0xE004             B.N      ??RCC_APB2PeriphClockLPModeCmd_4
   1612            }
   1613            else
   1614            {
   1615              RCC->APB2LPENR &= ~RCC_APB2Periph;
   \                     ??RCC_APB2PeriphClockLPModeCmd_3: (+1)
   \   00000042   0x....             LDR.N    R0,??DataTable42_62  ;; 0x40023864
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x43A0             BICS     R0,R0,R4
   \   00000048   0x....             LDR.N    R1,??DataTable42_62  ;; 0x40023864
   \   0000004A   0x6008             STR      R0,[R1, #+0]
   1616            }
   1617          }
   \                     ??RCC_APB2PeriphClockLPModeCmd_4: (+1)
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1618          
   1619          /**
   1620            * @}
   1621            */
   1622          
   1623          /** @defgroup RCC_Group4 Interrupts and flags management functions
   1624           *  @brief   Interrupts and flags management functions 
   1625           *
   1626          @verbatim   
   1627           ===============================================================================
   1628                             Interrupts and flags management functions
   1629           ===============================================================================  
   1630          
   1631          @endverbatim
   1632            * @{
   1633            */
   1634          
   1635          /**
   1636            * @brief  Enables or disables the specified RCC interrupts.
   1637            * @param  RCC_IT: specifies the RCC interrupt sources to be enabled or disabled.
   1638            *          This parameter can be any combination of the following values:
   1639            *            @arg RCC_IT_LSIRDY: LSI ready interrupt
   1640            *            @arg RCC_IT_LSERDY: LSE ready interrupt
   1641            *            @arg RCC_IT_HSIRDY: HSI ready interrupt
   1642            *            @arg RCC_IT_HSERDY: HSE ready interrupt
   1643            *            @arg RCC_IT_PLLRDY: main PLL ready interrupt
   1644            *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt  
   1645            * @param  NewState: new state of the specified RCC interrupts.
   1646            *          This parameter can be: ENABLE or DISABLE.
   1647            * @retval None
   1648            */

   \                                 In section .text, align 2, keep-with-next
   1649          void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
   1650          {
   \                     RCC_ITConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1651            /* Check the parameters */
   1652            assert_param(IS_RCC_IT(RCC_IT));
   \   00000006   0x20C0             MOVS     R0,#+192
   \   00000008   0x4204             TST      R4,R0
   \   0000000A   0xD102             BNE.N    ??RCC_ITConfig_0
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD104             BNE.N    ??RCC_ITConfig_1
   \                     ??RCC_ITConfig_0: (+1)
   \   00000012   0xF240 0x6174      MOVW     R1,#+1652
   \   00000016   0x....             LDR.N    R0,??DataTable42_55
   \   00000018   0x.... 0x....      BL       assert_failed
   1653            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_ITConfig_1: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??RCC_ITConfig_2
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD004             BEQ.N    ??RCC_ITConfig_2
   \   00000028   0xF240 0x6175      MOVW     R1,#+1653
   \   0000002C   0x....             LDR.N    R0,??DataTable42_55
   \   0000002E   0x.... 0x....      BL       assert_failed
   1654            if (NewState != DISABLE)
   \                     ??RCC_ITConfig_2: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD005             BEQ.N    ??RCC_ITConfig_3
   1655            {
   1656              /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
   1657              *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
   \   00000038   0x....             LDR.N    R0,??DataTable42_63  ;; 0x4002380d
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x4320             ORRS     R0,R4,R0
   \   0000003E   0x....             LDR.N    R1,??DataTable42_63  ;; 0x4002380d
   \   00000040   0x7008             STRB     R0,[R1, #+0]
   \   00000042   0xE004             B.N      ??RCC_ITConfig_4
   1658            }
   1659            else
   1660            {
   1661              /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
   1662              *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
   \                     ??RCC_ITConfig_3: (+1)
   \   00000044   0x....             LDR.N    R0,??DataTable42_63  ;; 0x4002380d
   \   00000046   0x7800             LDRB     R0,[R0, #+0]
   \   00000048   0x43A0             BICS     R0,R0,R4
   \   0000004A   0x....             LDR.N    R1,??DataTable42_63  ;; 0x4002380d
   \   0000004C   0x7008             STRB     R0,[R1, #+0]
   1663            }
   1664          }
   \                     ??RCC_ITConfig_4: (+1)
   \   0000004E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1665          
   1666          /**
   1667            * @brief  Checks whether the specified RCC flag is set or not.
   1668            * @param  RCC_FLAG: specifies the flag to check.
   1669            *          This parameter can be one of the following values:
   1670            *            @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready
   1671            *            @arg RCC_FLAG_HSERDY: HSE oscillator clock ready
   1672            *            @arg RCC_FLAG_PLLRDY: main PLL clock ready
   1673            *            @arg RCC_FLAG_PLLI2SRDY: PLLI2S clock ready
   1674            *            @arg RCC_FLAG_LSERDY: LSE oscillator clock ready
   1675            *            @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready
   1676            *            @arg RCC_FLAG_BORRST: POR/PDR or BOR reset
   1677            *            @arg RCC_FLAG_PINRST: Pin reset
   1678            *            @arg RCC_FLAG_PORRST: POR/PDR reset
   1679            *            @arg RCC_FLAG_SFTRST: Software reset
   1680            *            @arg RCC_FLAG_IWDGRST: Independent Watchdog reset
   1681            *            @arg RCC_FLAG_WWDGRST: Window Watchdog reset
   1682            *            @arg RCC_FLAG_LPWRRST: Low Power reset
   1683            * @retval The new state of RCC_FLAG (SET or RESET).
   1684            */

   \                                 In section .text, align 2, keep-with-next
   1685          FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
   1686          {
   \                     RCC_GetFlagStatus: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1687            uint32_t tmp = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   1688            uint32_t statusreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1689            FlagStatus bitstatus = RESET;
   \   00000008   0x2700             MOVS     R7,#+0
   1690          
   1691            /* Check the parameters */
   1692            assert_param(IS_RCC_FLAG(RCC_FLAG));
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C21             CMP      R4,#+33
   \   0000000E   0xD028             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C31             CMP      R4,#+49
   \   00000014   0xD025             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x2C39             CMP      R4,#+57
   \   0000001A   0xD022             BEQ.N    ??RCC_GetFlagStatus_0
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C41             CMP      R4,#+65
   \   00000020   0xD01F             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0x2C61             CMP      R4,#+97
   \   00000026   0xD01C             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0x2C79             CMP      R4,#+121
   \   0000002C   0xD019             BEQ.N    ??RCC_GetFlagStatus_0
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x2C7A             CMP      R4,#+122
   \   00000032   0xD016             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000034   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000036   0x2C7B             CMP      R4,#+123
   \   00000038   0xD013             BEQ.N    ??RCC_GetFlagStatus_0
   \   0000003A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003C   0x2C7C             CMP      R4,#+124
   \   0000003E   0xD010             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000040   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000042   0x2C7D             CMP      R4,#+125
   \   00000044   0xD00D             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000046   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000048   0x2C7E             CMP      R4,#+126
   \   0000004A   0xD00A             BEQ.N    ??RCC_GetFlagStatus_0
   \   0000004C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004E   0x2C7F             CMP      R4,#+127
   \   00000050   0xD007             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000052   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000054   0x2C3B             CMP      R4,#+59
   \   00000056   0xD004             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000058   0xF240 0x619C      MOVW     R1,#+1692
   \   0000005C   0x....             LDR.N    R0,??DataTable42_55
   \   0000005E   0x.... 0x....      BL       assert_failed
   1693          
   1694            /* Get the RCC register index */
   1695            tmp = RCC_FLAG >> 5;
   \                     ??RCC_GetFlagStatus_0: (+1)
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000066   0x0940             LSRS     R0,R0,#+5
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0x0005             MOVS     R5,R0
   1696            if (tmp == 1)               /* The flag to check is in CR register */
   \   0000006C   0x2D01             CMP      R5,#+1
   \   0000006E   0xD103             BNE.N    ??RCC_GetFlagStatus_1
   1697            {
   1698              statusreg = RCC->CR;
   \   00000070   0x....             LDR.N    R0,??DataTable42_64  ;; 0x40023800
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x0006             MOVS     R6,R0
   \   00000076   0xE008             B.N      ??RCC_GetFlagStatus_2
   1699            }
   1700            else if (tmp == 2)          /* The flag to check is in BDCR register */
   \                     ??RCC_GetFlagStatus_1: (+1)
   \   00000078   0x2D02             CMP      R5,#+2
   \   0000007A   0xD103             BNE.N    ??RCC_GetFlagStatus_3
   1701            {
   1702              statusreg = RCC->BDCR;
   \   0000007C   0x....             LDR.N    R0,??DataTable42_37  ;; 0x40023870
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x0006             MOVS     R6,R0
   \   00000082   0xE002             B.N      ??RCC_GetFlagStatus_2
   1703            }
   1704            else                       /* The flag to check is in CSR register */
   1705            {
   1706              statusreg = RCC->CSR;
   \                     ??RCC_GetFlagStatus_3: (+1)
   \   00000084   0x....             LDR.N    R0,??DataTable42_65  ;; 0x40023874
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x0006             MOVS     R6,R0
   1707            }
   1708          
   1709            /* Get the flag position */
   1710            tmp = RCC_FLAG & FLAG_MASK;
   \                     ??RCC_GetFlagStatus_2: (+1)
   \   0000008A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000008C   0xF014 0x001F      ANDS     R0,R4,#0x1F
   \   00000090   0x0005             MOVS     R5,R0
   1711            if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
   \   00000092   0x0030             MOVS     R0,R6
   \   00000094   0x40E8             LSRS     R0,R0,R5
   \   00000096   0x07C0             LSLS     R0,R0,#+31
   \   00000098   0xD502             BPL.N    ??RCC_GetFlagStatus_4
   1712            {
   1713              bitstatus = SET;
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0x0007             MOVS     R7,R0
   \   0000009E   0xE001             B.N      ??RCC_GetFlagStatus_5
   1714            }
   1715            else
   1716            {
   1717              bitstatus = RESET;
   \                     ??RCC_GetFlagStatus_4: (+1)
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x0007             MOVS     R7,R0
   1718            }
   1719            /* Return the flag status */
   1720            return bitstatus;
   \                     ??RCC_GetFlagStatus_5: (+1)
   \   000000A4   0x0038             MOVS     R0,R7
   \   000000A6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A8   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1721          }
   1722          
   1723          /**
   1724            * @brief  Clears the RCC reset flags.
   1725            *         The reset flags are: RCC_FLAG_PINRST, RCC_FLAG_PORRST,  RCC_FLAG_SFTRST,
   1726            *         RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST
   1727            * @param  None
   1728            * @retval None
   1729            */

   \                                 In section .text, align 2, keep-with-next
   1730          void RCC_ClearFlag(void)
   1731          {
   1732            /* Set RMVF bit to clear the reset flags */
   1733            RCC->CSR |= RCC_CSR_RMVF;
   \                     RCC_ClearFlag: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable42_65  ;; 0x40023874
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \   00000008   0x....             LDR.N    R1,??DataTable42_65  ;; 0x40023874
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   1734          }
   \   0000000C   0x4770             BX       LR               ;; return
   1735          
   1736          /**
   1737            * @brief  Checks whether the specified RCC interrupt has occurred or not.
   1738            * @param  RCC_IT: specifies the RCC interrupt source to check.
   1739            *          This parameter can be one of the following values:
   1740            *            @arg RCC_IT_LSIRDY: LSI ready interrupt
   1741            *            @arg RCC_IT_LSERDY: LSE ready interrupt
   1742            *            @arg RCC_IT_HSIRDY: HSI ready interrupt
   1743            *            @arg RCC_IT_HSERDY: HSE ready interrupt
   1744            *            @arg RCC_IT_PLLRDY: main PLL ready interrupt
   1745            *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt  
   1746            *            @arg RCC_IT_CSS: Clock Security System interrupt
   1747            * @retval The new state of RCC_IT (SET or RESET).
   1748            */

   \                                 In section .text, align 2, keep-with-next
   1749          ITStatus RCC_GetITStatus(uint8_t RCC_IT)
   1750          {
   \                     RCC_GetITStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1751            ITStatus bitstatus = RESET;
   \   00000004   0x2500             MOVS     R5,#+0
   1752          
   1753            /* Check the parameters */
   1754            assert_param(IS_RCC_GET_IT(RCC_IT));
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD016             BEQ.N    ??RCC_GetITStatus_0
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C02             CMP      R4,#+2
   \   00000010   0xD013             BEQ.N    ??RCC_GetITStatus_0
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2C04             CMP      R4,#+4
   \   00000016   0xD010             BEQ.N    ??RCC_GetITStatus_0
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0x2C08             CMP      R4,#+8
   \   0000001C   0xD00D             BEQ.N    ??RCC_GetITStatus_0
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x2C10             CMP      R4,#+16
   \   00000022   0xD00A             BEQ.N    ??RCC_GetITStatus_0
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x2C80             CMP      R4,#+128
   \   00000028   0xD007             BEQ.N    ??RCC_GetITStatus_0
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x2C20             CMP      R4,#+32
   \   0000002E   0xD004             BEQ.N    ??RCC_GetITStatus_0
   \   00000030   0xF240 0x61DA      MOVW     R1,#+1754
   \   00000034   0x....             LDR.N    R0,??DataTable42_55
   \   00000036   0x.... 0x....      BL       assert_failed
   1755          
   1756            /* Check the status of the specified RCC interrupt */
   1757            if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
   \                     ??RCC_GetITStatus_0: (+1)
   \   0000003A   0x....             LDR.N    R0,??DataTable42_66  ;; 0x4002380c
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000040   0x4220             TST      R0,R4
   \   00000042   0xD002             BEQ.N    ??RCC_GetITStatus_1
   1758            {
   1759              bitstatus = SET;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x0005             MOVS     R5,R0
   \   00000048   0xE001             B.N      ??RCC_GetITStatus_2
   1760            }
   1761            else
   1762            {
   1763              bitstatus = RESET;
   \                     ??RCC_GetITStatus_1: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x0005             MOVS     R5,R0
   1764            }
   1765            /* Return the RCC_IT status */
   1766            return  bitstatus;
   \                     ??RCC_GetITStatus_2: (+1)
   \   0000004E   0x0028             MOVS     R0,R5
   \   00000050   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1767          }
   1768          
   1769          /**
   1770            * @brief  Clears the RCC's interrupt pending bits.
   1771            * @param  RCC_IT: specifies the interrupt pending bit to clear.
   1772            *          This parameter can be any combination of the following values:
   1773            *            @arg RCC_IT_LSIRDY: LSI ready interrupt
   1774            *            @arg RCC_IT_LSERDY: LSE ready interrupt
   1775            *            @arg RCC_IT_HSIRDY: HSI ready interrupt
   1776            *            @arg RCC_IT_HSERDY: HSE ready interrupt
   1777            *            @arg RCC_IT_PLLRDY: main PLL ready interrupt
   1778            *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt  
   1779            *            @arg RCC_IT_CSS: Clock Security System interrupt
   1780            * @retval None
   1781            */

   \                                 In section .text, align 2, keep-with-next
   1782          void RCC_ClearITPendingBit(uint8_t RCC_IT)
   1783          {
   \                     RCC_ClearITPendingBit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1784            /* Check the parameters */
   1785            assert_param(IS_RCC_CLEAR_IT(RCC_IT));
   \   00000004   0x0660             LSLS     R0,R4,#+25
   \   00000006   0xD402             BMI.N    ??RCC_ClearITPendingBit_0
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD104             BNE.N    ??RCC_ClearITPendingBit_1
   \                     ??RCC_ClearITPendingBit_0: (+1)
   \   0000000E   0xF240 0x61F9      MOVW     R1,#+1785
   \   00000012   0x....             LDR.N    R0,??DataTable42_55
   \   00000014   0x.... 0x....      BL       assert_failed
   1786          
   1787            /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
   1788               pending bits */
   1789            *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
   \                     ??RCC_ClearITPendingBit_1: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable42_67  ;; 0x4002380e
   \   0000001A   0x7004             STRB     R4,[R0, #+0]
   1790          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0x40023800         DC32     0x40023800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_1:
   \   00000000   0x40023808         DC32     0x40023808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_2:
   \   00000000   0xFEF6FFFF         DC32     0xfef6ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_3:
   \   00000000   0x24003010         DC32     0x24003010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_4:
   \   00000000   0x40023804         DC32     0x40023804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37:
   \   00000000   0x4002380C         DC32     0x4002380c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_1:
   \   00000000   0x40023802         DC32     0x40023802

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38:
   \   00000000   0x42470000         DC32     0x42470000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_1:
   \   00000000   0x40023870         DC32     0x40023870

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40:
   \   00000000   0x42470E80         DC32     0x42470e80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41:
   \   00000000   0x42470060         DC32     0x42470060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42:
   \   00000000   0x40023884         DC32     0x40023884

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_1:
   \   00000000   0x42470068         DC32     0x42470068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_2:
   \   00000000   0x4247004C         DC32     0x4247004c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_3:
   \   00000000   0x00F42400         DC32     0xf42400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_4:
   \   00000000   0x007A1200         DC32     0x7a1200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_5:
   \   00000000   0x........         DC32     APBAHBPrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_6:
   \   00000000   0x00020300         DC32     0x20300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_7:
   \   00000000   0x00030300         DC32     0x30300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_8:
   \   00000000   0x00040300         DC32     0x40300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_9:
   \   00000000   0x00050300         DC32     0x50300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_10:
   \   00000000   0x00060300         DC32     0x60300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_11:
   \   00000000   0x00070300         DC32     0x70300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_12:
   \   00000000   0x00080300         DC32     0x80300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_13:
   \   00000000   0x00090300         DC32     0x90300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_14:
   \   00000000   0x000A0300         DC32     0xa0300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_15:
   \   00000000   0x000B0300         DC32     0xb0300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_16:
   \   00000000   0x000C0300         DC32     0xc0300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_17:
   \   00000000   0x000D0300         DC32     0xd0300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_18:
   \   00000000   0x000E0300         DC32     0xe0300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_19:
   \   00000000   0x000F0300         DC32     0xf0300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_20:
   \   00000000   0x00100300         DC32     0x100300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_21:
   \   00000000   0x00110300         DC32     0x110300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_22:
   \   00000000   0x00120300         DC32     0x120300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_23:
   \   00000000   0x00130300         DC32     0x130300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_24:
   \   00000000   0x00140300         DC32     0x140300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_25:
   \   00000000   0x00150300         DC32     0x150300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_26:
   \   00000000   0x00160300         DC32     0x160300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_27:
   \   00000000   0x00170300         DC32     0x170300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_28:
   \   00000000   0x00180300         DC32     0x180300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_29:
   \   00000000   0x00190300         DC32     0x190300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_30:
   \   00000000   0x001A0300         DC32     0x1a0300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_31:
   \   00000000   0x001B0300         DC32     0x1b0300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_32:
   \   00000000   0x001C0300         DC32     0x1c0300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_33:
   \   00000000   0x001D0300         DC32     0x1d0300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_34:
   \   00000000   0x001E0300         DC32     0x1e0300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_35:
   \   00000000   0x001F0300         DC32     0x1f0300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_36:
   \   00000000   0x0FFFFCFF         DC32     0xffffcff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_37:
   \   00000000   0x40023870         DC32     0x40023870

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_38:
   \   00000000   0x42470E3C         DC32     0x42470e3c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_39:
   \   00000000   0x42470E40         DC32     0x42470e40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_40:
   \   00000000   0x4247015C         DC32     0x4247015c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_41:
   \   00000000   0x818BEE00         DC32     0x818bee00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_42:
   \   00000000   0x40023830         DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_43:
   \   00000000   0x40023834         DC32     0x40023834

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_44:
   \   00000000   0x40023838         DC32     0x40023838

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_45:
   \   00000000   0xC9013600         DC32     0xc9013600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_46:
   \   00000000   0x40023840         DC32     0x40023840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_47:
   \   00000000   0xFFF8A0CC         DC32     0xfff8a0cc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_48:
   \   00000000   0x40023844         DC32     0x40023844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_49:
   \   00000000   0xDD9FEE00         DC32     0xdd9fee00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_50:
   \   00000000   0x40023810         DC32     0x40023810

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_51:
   \   00000000   0x40023814         DC32     0x40023814

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_52:
   \   00000000   0x40023818         DC32     0x40023818

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_53:
   \   00000000   0x40023820         DC32     0x40023820

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_54:
   \   00000000   0xFFF8A6CC         DC32     0xfff8a6cc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_55:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_56:
   \   00000000   0x40023824         DC32     0x40023824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_57:
   \   00000000   0x81986E00         DC32     0x81986e00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_58:
   \   00000000   0x40023850         DC32     0x40023850

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_59:
   \   00000000   0x40023854         DC32     0x40023854

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_60:
   \   00000000   0x40023858         DC32     0x40023858

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_61:
   \   00000000   0x40023860         DC32     0x40023860

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_62:
   \   00000000   0x40023864         DC32     0x40023864

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_63:
   \   00000000   0x4002380D         DC32     0x4002380d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_64:
   \   00000000   0x40023800         DC32     0x40023800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_65:
   \   00000000   0x40023874         DC32     0x40023874

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_66:
   \   00000000   0x4002380C         DC32     0x4002380c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_67:
   \   00000000   0x4002380E         DC32     0x4002380e

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 49H, 41H, 52H, 20H, 57H
   \              0x5C 0x49    
   \              0x41 0x52    
   \              0x20 0x57    
   \   00000008   0x6F 0x72          DC8 6FH, 72H, 6BH, 73H, 70H, 61H, 63H, 65H
   \              0x6B 0x73    
   \              0x70 0x61    
   \              0x63 0x65    
   \   00000010   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 46H, 34H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x46 0x34    
   \   00000018   0x30 0x37          DC8 30H, 37H, 5CH, 53H, 54H, 4DH, 33H, 32H
   \              0x5C 0x53    
   \              0x54 0x4D    
   \              0x33 0x32    
   \   00000020   0x46 0x34          DC8 46H, 34H, 2DH, 44H, 69H, 73H, 63H, 6FH
   \              0x2D 0x44    
   \              0x69 0x73    
   \              0x63 0x6F    
   \   00000028   0x76 0x65          DC8 76H, 65H, 72H, 79H, 5FH, 46H, 57H, 5FH
   \              0x72 0x79    
   \              0x5F 0x46    
   \              0x57 0x5F    
   \   00000030   0x56 0x31          DC8 56H, 31H, 2EH, 31H, 2EH, 30H, 5CH, 4CH
   \              0x2E 0x31    
   \              0x2E 0x30    
   \              0x5C 0x4C    
   \   00000038   0x69 0x62          DC8 69H, 62H, 72H, 61H, 72H, 69H, 65H, 73H
   \              0x72 0x61    
   \              0x72 0x69    
   \              0x65 0x73    
   \   00000040   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 46H, 34H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x46 0x34    
   \   00000048   0x78 0x78          DC8 78H, 78H, 5FH, 53H, 74H, 64H, 50H, 65H
   \              0x5F 0x53    
   \              0x74 0x64    
   \              0x50 0x65    
   \   00000050   0x72 0x69          DC8 72H, 69H, 70H, 68H, 5FH, 44H, 72H, 69H
   \              0x70 0x68    
   \              0x5F 0x44    
   \              0x72 0x69    
   \   00000058   0x76 0x65          DC8 76H, 65H, 72H, 5CH, 73H, 72H, 63H, 5CH
   \              0x72 0x5C    
   \              0x73 0x72    
   \              0x63 0x5C    
   \   00000060   0x73 0x74          DC8 73H, 74H, 6DH, 33H, 32H, 66H, 34H, 78H
   \              0x6D 0x33    
   \              0x32 0x66    
   \              0x34 0x78    
   \   00000068   0x78 0x5F          DC8 78H, 5FH, 72H, 63H, 63H, 2EH, 63H, 0
   \              0x72 0x63    
   \              0x63 0x2E    
   \              0x63 0x00    
   1791          
   1792          /**
   1793            * @}
   1794            */ 
   1795          
   1796          /**
   1797            * @}
   1798            */ 
   1799          
   1800          /**
   1801            * @}
   1802            */ 
   1803          
   1804          /**
   1805            * @}
   1806            */ 
   1807          
   1808          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   RCC_AHB1PeriphClockCmd
        16   -> assert_failed
      16   RCC_AHB1PeriphClockLPModeCmd
        16   -> assert_failed
      16   RCC_AHB1PeriphResetCmd
        16   -> assert_failed
      16   RCC_AHB2PeriphClockCmd
        16   -> assert_failed
      16   RCC_AHB2PeriphClockLPModeCmd
        16   -> assert_failed
      16   RCC_AHB2PeriphResetCmd
        16   -> assert_failed
      16   RCC_AHB3PeriphClockCmd
        16   -> assert_failed
      16   RCC_AHB3PeriphClockLPModeCmd
        16   -> assert_failed
      16   RCC_AHB3PeriphResetCmd
        16   -> assert_failed
      16   RCC_APB1PeriphClockCmd
        16   -> assert_failed
      16   RCC_APB1PeriphClockLPModeCmd
        16   -> assert_failed
      16   RCC_APB1PeriphResetCmd
        16   -> assert_failed
      16   RCC_APB2PeriphClockCmd
        16   -> assert_failed
      16   RCC_APB2PeriphClockLPModeCmd
        16   -> assert_failed
      16   RCC_APB2PeriphResetCmd
        16   -> assert_failed
      16   RCC_AdjustHSICalibrationValue
        16   -> assert_failed
       8   RCC_BackupResetCmd
         8   -> assert_failed
       0   RCC_ClearFlag
       8   RCC_ClearITPendingBit
         8   -> assert_failed
       8   RCC_ClockSecuritySystemCmd
         8   -> assert_failed
       0   RCC_DeInit
      16   RCC_GetClocksFreq
      24   RCC_GetFlagStatus
        24   -> assert_failed
      16   RCC_GetITStatus
        16   -> assert_failed
       0   RCC_GetSYSCLKSource
      16   RCC_HCLKConfig
        16   -> assert_failed
       8   RCC_HSEConfig
         8   -> assert_failed
       8   RCC_HSICmd
         8   -> assert_failed
       8   RCC_I2SCLKConfig
         8   -> assert_failed
      16   RCC_ITConfig
        16   -> assert_failed
       8   RCC_LSEConfig
         8   -> assert_failed
       8   RCC_LSICmd
         8   -> assert_failed
      16   RCC_MCO1Config
        16   -> assert_failed
      16   RCC_MCO2Config
        16   -> assert_failed
      16   RCC_PCLK1Config
        16   -> assert_failed
      16   RCC_PCLK2Config
        16   -> assert_failed
       8   RCC_PLLCmd
         8   -> assert_failed
      24   RCC_PLLConfig
        24   -> assert_failed
       8   RCC_PLLI2SCmd
         8   -> assert_failed
      16   RCC_PLLI2SConfig
        16   -> assert_failed
       8   RCC_RTCCLKCmd
         8   -> assert_failed
      16   RCC_RTCCLKConfig
        16   -> assert_failed
      16   RCC_SYSCLKConfig
        16   -> assert_failed
      16   RCC_WaitForHSEStartUp
        16   -> RCC_GetFlagStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable30_2
       4  ??DataTable30_3
       4  ??DataTable30_4
       4  ??DataTable31
       4  ??DataTable37
       4  ??DataTable37_1
       4  ??DataTable38
       4  ??DataTable38_1
       4  ??DataTable40
       4  ??DataTable41
       4  ??DataTable42
       4  ??DataTable42_1
       4  ??DataTable42_10
       4  ??DataTable42_11
       4  ??DataTable42_12
       4  ??DataTable42_13
       4  ??DataTable42_14
       4  ??DataTable42_15
       4  ??DataTable42_16
       4  ??DataTable42_17
       4  ??DataTable42_18
       4  ??DataTable42_19
       4  ??DataTable42_2
       4  ??DataTable42_20
       4  ??DataTable42_21
       4  ??DataTable42_22
       4  ??DataTable42_23
       4  ??DataTable42_24
       4  ??DataTable42_25
       4  ??DataTable42_26
       4  ??DataTable42_27
       4  ??DataTable42_28
       4  ??DataTable42_29
       4  ??DataTable42_3
       4  ??DataTable42_30
       4  ??DataTable42_31
       4  ??DataTable42_32
       4  ??DataTable42_33
       4  ??DataTable42_34
       4  ??DataTable42_35
       4  ??DataTable42_36
       4  ??DataTable42_37
       4  ??DataTable42_38
       4  ??DataTable42_39
       4  ??DataTable42_4
       4  ??DataTable42_40
       4  ??DataTable42_41
       4  ??DataTable42_42
       4  ??DataTable42_43
       4  ??DataTable42_44
       4  ??DataTable42_45
       4  ??DataTable42_46
       4  ??DataTable42_47
       4  ??DataTable42_48
       4  ??DataTable42_49
       4  ??DataTable42_5
       4  ??DataTable42_50
       4  ??DataTable42_51
       4  ??DataTable42_52
       4  ??DataTable42_53
       4  ??DataTable42_54
       4  ??DataTable42_55
       4  ??DataTable42_56
       4  ??DataTable42_57
       4  ??DataTable42_58
       4  ??DataTable42_59
       4  ??DataTable42_6
       4  ??DataTable42_60
       4  ??DataTable42_61
       4  ??DataTable42_62
       4  ??DataTable42_63
       4  ??DataTable42_64
       4  ??DataTable42_65
       4  ??DataTable42_66
       4  ??DataTable42_67
       4  ??DataTable42_7
       4  ??DataTable42_8
       4  ??DataTable42_9
     112  ?_0
      16  APBAHBPrescTable
      88  RCC_AHB1PeriphClockCmd
      92  RCC_AHB1PeriphClockLPModeCmd
      88  RCC_AHB1PeriphResetCmd
      88  RCC_AHB2PeriphClockCmd
      92  RCC_AHB2PeriphClockLPModeCmd
      88  RCC_AHB2PeriphResetCmd
      88  RCC_AHB3PeriphClockCmd
      82  RCC_AHB3PeriphClockLPModeCmd
      88  RCC_AHB3PeriphResetCmd
      88  RCC_APB1PeriphClockCmd
      78  RCC_APB1PeriphClockLPModeCmd
      88  RCC_APB1PeriphResetCmd
      88  RCC_APB2PeriphClockCmd
      78  RCC_APB2PeriphClockLPModeCmd
      92  RCC_APB2PeriphResetCmd
      50  RCC_AdjustHSICalibrationValue
      38  RCC_BackupResetCmd
      14  RCC_ClearFlag
      30  RCC_ClearITPendingBit
      38  RCC_ClockSecuritySystemCmd
      78  RCC_DeInit
     258  RCC_GetClocksFreq
     170  RCC_GetFlagStatus
      84  RCC_GetITStatus
      12  RCC_GetSYSCLKSource
      76  RCC_HCLKConfig
      48  RCC_HSEConfig
      38  RCC_HSICmd
      30  RCC_I2SCLKConfig
      80  RCC_ITConfig
      86  RCC_LSEConfig
      38  RCC_LSICmd
     108  RCC_MCO1Config
     108  RCC_MCO2Config
      68  RCC_PCLK1Config
      70  RCC_PCLK2Config
      38  RCC_PLLCmd
     158  RCC_PLLConfig
      38  RCC_PLLI2SCmd
      62  RCC_PLLI2SConfig
      38  RCC_RTCCLKCmd
     326  RCC_RTCCLKConfig
      52  RCC_SYSCLKConfig
      64  RCC_WaitForHSEStartUp

 
    16 bytes in section .data
   112 bytes in section .rodata
 3 924 bytes in section .text
 
 3 924 bytes of CODE  memory
   112 bytes of CONST memory
    16 bytes of DATA  memory

Errors: none
Warnings: none
