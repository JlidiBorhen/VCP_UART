###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       06/May/2016  23:31:33
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\IAR
#        Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_flash.c
#    Command line =  
#        "D:\IAR
#        Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_flash.c"
#        -D USE_STDPERIPH_DRIVER -D STM32F4XX -D USE_FULL_ASSERT -lCN "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\List" -o "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\Obj" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\Include\" -I
#        "D:\IAR Workspace\STM32F407\VCP_ESP\..\Utilities\STM32F4-Discovery\"
#        -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\ST\STM32F4xx\Include\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_conf\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\cdc\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\otg\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\core\" -On --use_c++_inline -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    List file    =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\Debug\List\stm32f4xx_flash.lst
#    Object file  =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\Debug\Obj\stm32f4xx_flash.o
#
###############################################################################

D:\IAR Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_flash.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    30-September-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the FLASH peripheral:
      9            *            - FLASH Interface configuration
     10            *            - FLASH Memory Programming
     11            *            - Option Bytes Programming
     12            *            - Interrupts and flags management
     13            *  
     14            *  @verbatim
     15            *  
     16            *          ===================================================================
     17            *                                 How to use this driver
     18            *          ===================================================================
     19            *                           
     20            *          This driver provides functions to configure and program the FLASH 
     21            *          memory of all STM32F4xx devices.
     22            *          These functions are split in 4 groups:
     23            * 
     24            *           1. FLASH Interface configuration functions: this group includes the
     25            *              management of the following features:
     26            *                    - Set the latency
     27            *                    - Enable/Disable the prefetch buffer
     28            *                    - Enable/Disable the Instruction cache and the Data cache
     29            *                    - Reset the Instruction cache and the Data cache
     30            *  
     31            *           2. FLASH Memory Programming functions: this group includes all needed
     32            *              functions to erase and program the main memory:
     33            *                    - Lock and Unlock the FLASH interface
     34            *                    - Erase function: Erase sector, erase all sectors
     35            *                    - Program functions: byte, half word, word and double word
     36            *  
     37            *           3. Option Bytes Programming functions: this group includes all needed
     38            *              functions to manage the Option Bytes:
     39            *                    - Set/Reset the write protection
     40            *                    - Set the Read protection Level
     41            *                    - Set the BOR level
     42            *                    - Program the user Option Bytes
     43            *                    - Launch the Option Bytes loader
     44            *  
     45            *           4. Interrupts and flags management functions: this group 
     46            *              includes all needed functions to:
     47            *                    - Enable/Disable the FLASH interrupt sources
     48            *                    - Get flags status
     49            *                    - Clear flags
     50            *                    - Get FLASH operation status
     51            *                    - Wait for last FLASH operation
     52            * 
     53            *  @endverbatim
     54            *                      
     55            ******************************************************************************
     56            * @attention
     57            *
     58            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     59            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     60            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     61            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     62            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     63            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     64            *
     65            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     66            ******************************************************************************
     67            */
     68          
     69          /* Includes ------------------------------------------------------------------*/
     70          #include "stm32f4xx_flash.h"
     71          
     72          /** @addtogroup STM32F4xx_StdPeriph_Driver
     73            * @{
     74            */
     75          
     76          /** @defgroup FLASH 
     77            * @brief FLASH driver modules
     78            * @{
     79            */ 
     80          
     81          /* Private typedef -----------------------------------------------------------*/
     82          /* Private define ------------------------------------------------------------*/ 
     83          #define SECTOR_MASK               ((uint32_t)0xFFFFFF07)
     84          
     85          /* Private macro -------------------------------------------------------------*/
     86          /* Private variables ---------------------------------------------------------*/
     87          /* Private function prototypes -----------------------------------------------*/
     88          /* Private functions ---------------------------------------------------------*/
     89          
     90          /** @defgroup FLASH_Private_Functions
     91            * @{
     92            */ 
     93          
     94          /** @defgroup FLASH_Group1 FLASH Interface configuration functions
     95            *  @brief   FLASH Interface configuration functions 
     96           *
     97          
     98          @verbatim   
     99           ===============================================================================
    100                                 FLASH Interface configuration functions
    101           ===============================================================================
    102          
    103             This group includes the following functions:
    104              - void FLASH_SetLatency(uint32_t FLASH_Latency)
    105                 To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    106                 must be correctly programmed according to the frequency of the CPU clock 
    107                (HCLK) and the supply voltage of the device.
    108           +-------------------------------------------------------------------------------------+     
    109           | Latency       |                HCLK clock frequency (MHz)                           |
    110           |               |---------------------------------------------------------------------|     
    111           |               | voltage range  | voltage range  | voltage range   | voltage range   |
    112           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
    113           |---------------|----------------|----------------|-----------------|-----------------|              
    114           |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 18   |0 < HCLK <= 16   |
    115           |---------------|----------------|----------------|-----------------|-----------------|   
    116           |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |18 < HCLK <= 36  |16 < HCLK <= 32  | 
    117           |---------------|----------------|----------------|-----------------|-----------------|   
    118           |2WS(3CPU cycle)|60 < HCLK <= 90 |48 < HCLK <= 72 |36 < HCLK <= 54  |32 < HCLK <= 48  |
    119           |---------------|----------------|----------------|-----------------|-----------------| 
    120           |3WS(4CPU cycle)|90 < HCLK <= 120|72 < HCLK <= 96 |54 < HCLK <= 72  |48 < HCLK <= 64  |
    121           |---------------|----------------|----------------|-----------------|-----------------| 
    122           |4WS(5CPU cycle)|120< HCLK <= 150|96 < HCLK <= 120|72 < HCLK <= 90  |64 < HCLK <= 80  |
    123           |---------------|----------------|----------------|-----------------|-----------------| 
    124           |5WS(6CPU cycle)|120< HCLK <= 168|120< HCLK <= 144|90 < HCLK <= 108 |80 < HCLK <= 96  | 
    125           |---------------|----------------|----------------|-----------------|-----------------| 
    126           |6WS(7CPU cycle)|      NA        |144< HCLK <= 168|108 < HCLK <= 120|96 < HCLK <= 112 | 
    127           |---------------|----------------|----------------|-----------------|-----------------| 
    128           |7WS(8CPU cycle)|      NA        |      NA        |120 < HCLK <= 138|112 < HCLK <= 120| 
    129           |***************|****************|****************|*****************|*****************|*****************************+
    130           |               | voltage range  | voltage range  | voltage range   | voltage range   | voltage range 2.7 V - 3.6 V |
    131           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   | with External Vpp = 9V      |
    132           |---------------|----------------|----------------|-----------------|-----------------|-----------------------------| 
    133           |Max Parallelism|      x32       |               x16                |       x8        |          x64                |              
    134           |---------------|----------------|----------------|-----------------|-----------------|-----------------------------|   
    135           |PSIZE[1:0]     |      10        |               01                 |       00        |           11                |
    136           +-------------------------------------------------------------------------------------------------------------------+  
    137             @note When VOS bit (in PWR_CR register) is reset to '0’, the maximum value of HCLK is 144 MHz.
    138                   You can use PWR_MainRegulatorModeConfig() function to set or reset this bit.
    139                       
    140              - void FLASH_PrefetchBufferCmd(FunctionalState NewState)
    141              - void FLASH_InstructionCacheCmd(FunctionalState NewState)
    142              - void FLASH_DataCacheCmd(FunctionalState NewState)
    143              - void FLASH_InstructionCacheReset(void)
    144              - void FLASH_DataCacheReset(void)
    145             
    146             The unlock sequence is not needed for these functions.
    147           
    148          @endverbatim
    149            * @{
    150            */
    151           
    152          /**
    153            * @brief  Sets the code latency value.
    154            * @param  FLASH_Latency: specifies the FLASH Latency value.
    155            *          This parameter can be one of the following values:
    156            *            @arg FLASH_Latency_0: FLASH Zero Latency cycle
    157            *            @arg FLASH_Latency_1: FLASH One Latency cycle
    158            *            @arg FLASH_Latency_2: FLASH Two Latency cycles
    159            *            @arg FLASH_Latency_3: FLASH Three Latency cycles
    160            *            @arg FLASH_Latency_4: FLASH Four Latency cycles 
    161            *            @arg FLASH_Latency_5: FLASH Five Latency cycles 
    162            *            @arg FLASH_Latency_6: FLASH Six Latency cycles
    163            *            @arg FLASH_Latency_7: FLASH Seven Latency cycles      
    164            * @retval None
    165            */

   \                                 In section .text, align 2, keep-with-next
    166          void FLASH_SetLatency(uint32_t FLASH_Latency)
    167          {
   \                     FLASH_SetLatency: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    168            /* Check the parameters */
    169            assert_param(IS_FLASH_LATENCY(FLASH_Latency));
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD012             BEQ.N    ??FLASH_SetLatency_0
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD010             BEQ.N    ??FLASH_SetLatency_0
   \   0000000C   0x2C02             CMP      R4,#+2
   \   0000000E   0xD00E             BEQ.N    ??FLASH_SetLatency_0
   \   00000010   0x2C03             CMP      R4,#+3
   \   00000012   0xD00C             BEQ.N    ??FLASH_SetLatency_0
   \   00000014   0x2C04             CMP      R4,#+4
   \   00000016   0xD00A             BEQ.N    ??FLASH_SetLatency_0
   \   00000018   0x2C05             CMP      R4,#+5
   \   0000001A   0xD008             BEQ.N    ??FLASH_SetLatency_0
   \   0000001C   0x2C06             CMP      R4,#+6
   \   0000001E   0xD006             BEQ.N    ??FLASH_SetLatency_0
   \   00000020   0x2C07             CMP      R4,#+7
   \   00000022   0xD004             BEQ.N    ??FLASH_SetLatency_0
   \   00000024   0x21A9             MOVS     R1,#+169
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable28
   \   0000002A   0x.... 0x....      BL       assert_failed
    170            
    171            /* Perform Byte access to FLASH_ACR[8:0] to set the Latency value */
    172            *(__IO uint8_t *)ACR_BYTE0_ADDRESS = (uint8_t)FLASH_Latency;
   \                     ??FLASH_SetLatency_0: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40023c00
   \   00000032   0x7004             STRB     R4,[R0, #+0]
    173          }
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    174          
    175          /**
    176            * @brief  Enables or disables the Prefetch Buffer.
    177            * @param  NewState: new state of the Prefetch Buffer.
    178            *          This parameter  can be: ENABLE or DISABLE.
    179            * @retval None
    180            */

   \                                 In section .text, align 2, keep-with-next
    181          void FLASH_PrefetchBufferCmd(FunctionalState NewState)
    182          {
   \                     FLASH_PrefetchBufferCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    183            /* Check the parameters */
    184            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??FLASH_PrefetchBufferCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??FLASH_PrefetchBufferCmd_0
   \   00000010   0x21B8             MOVS     R1,#+184
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable28
   \   00000016   0x.... 0x....      BL       assert_failed
    185            
    186            /* Enable or disable the Prefetch Buffer */
    187            if(NewState != DISABLE)
   \                     ??FLASH_PrefetchBufferCmd_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD008             BEQ.N    ??FLASH_PrefetchBufferCmd_1
    188            {
    189              FLASH->ACR |= FLASH_ACR_PRFTEN;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40023c00
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable28_1  ;; 0x40023c00
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   \   00000030   0xE007             B.N      ??FLASH_PrefetchBufferCmd_2
    190            }
    191            else
    192            {
    193              FLASH->ACR &= (~FLASH_ACR_PRFTEN);
   \                     ??FLASH_PrefetchBufferCmd_1: (+1)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40023c00
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable28_1  ;; 0x40023c00
   \   00000040   0x6008             STR      R0,[R1, #+0]
    194            }
    195          }
   \                     ??FLASH_PrefetchBufferCmd_2: (+1)
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
    196          
    197          /**
    198            * @brief  Enables or disables the Instruction Cache feature.
    199            * @param  NewState: new state of the Instruction Cache.
    200            *          This parameter  can be: ENABLE or DISABLE.
    201            * @retval None
    202            */

   \                                 In section .text, align 2, keep-with-next
    203          void FLASH_InstructionCacheCmd(FunctionalState NewState)
    204          {
   \                     FLASH_InstructionCacheCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    205            /* Check the parameters */
    206            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??FLASH_InstructionCacheCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??FLASH_InstructionCacheCmd_0
   \   00000010   0x21CE             MOVS     R1,#+206
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable28
   \   00000016   0x.... 0x....      BL       assert_failed
    207            
    208            if(NewState != DISABLE)
   \                     ??FLASH_InstructionCacheCmd_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD008             BEQ.N    ??FLASH_InstructionCacheCmd_1
    209            {
    210              FLASH->ACR |= FLASH_ACR_ICEN;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40023c00
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable28_1  ;; 0x40023c00
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   \   00000030   0xE007             B.N      ??FLASH_InstructionCacheCmd_2
    211            }
    212            else
    213            {
    214              FLASH->ACR &= (~FLASH_ACR_ICEN);
   \                     ??FLASH_InstructionCacheCmd_1: (+1)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40023c00
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF430 0x7000      BICS     R0,R0,#0x200
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable28_1  ;; 0x40023c00
   \   00000040   0x6008             STR      R0,[R1, #+0]
    215            }
    216          }
   \                     ??FLASH_InstructionCacheCmd_2: (+1)
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
    217          
    218          /**
    219            * @brief  Enables or disables the Data Cache feature.
    220            * @param  NewState: new state of the Data Cache.
    221            *          This parameter  can be: ENABLE or DISABLE.
    222            * @retval None
    223            */

   \                                 In section .text, align 2, keep-with-next
    224          void FLASH_DataCacheCmd(FunctionalState NewState)
    225          {
   \                     FLASH_DataCacheCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    226            /* Check the parameters */
    227            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??FLASH_DataCacheCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??FLASH_DataCacheCmd_0
   \   00000010   0x21E3             MOVS     R1,#+227
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable28
   \   00000016   0x.... 0x....      BL       assert_failed
    228            
    229            if(NewState != DISABLE)
   \                     ??FLASH_DataCacheCmd_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD008             BEQ.N    ??FLASH_DataCacheCmd_1
    230            {
    231              FLASH->ACR |= FLASH_ACR_DCEN;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40023c00
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable28_1  ;; 0x40023c00
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   \   00000030   0xE007             B.N      ??FLASH_DataCacheCmd_2
    232            }
    233            else
    234            {
    235              FLASH->ACR &= (~FLASH_ACR_DCEN);
   \                     ??FLASH_DataCacheCmd_1: (+1)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40023c00
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF430 0x6080      BICS     R0,R0,#0x400
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable28_1  ;; 0x40023c00
   \   00000040   0x6008             STR      R0,[R1, #+0]
    236            }
    237          }
   \                     ??FLASH_DataCacheCmd_2: (+1)
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
    238          
    239          /**
    240            * @brief  Resets the Instruction Cache.
    241            * @note   This function must be used only when the Instruction Cache is disabled.  
    242            * @param  None
    243            * @retval None
    244            */

   \                                 In section .text, align 2, keep-with-next
    245          void FLASH_InstructionCacheReset(void)
    246          {
    247            FLASH->ACR |= FLASH_ACR_ICRST;
   \                     FLASH_InstructionCacheReset: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40023c00
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable28_1  ;; 0x40023c00
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    248          }
   \   00000010   0x4770             BX       LR               ;; return
    249          
    250          /**
    251            * @brief  Resets the Data Cache.
    252            * @note   This function must be used only when the Data Cache is disabled.  
    253            * @param  None
    254            * @retval None
    255            */

   \                                 In section .text, align 2, keep-with-next
    256          void FLASH_DataCacheReset(void)
    257          {
    258            FLASH->ACR |= FLASH_ACR_DCRST;
   \                     FLASH_DataCacheReset: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40023c00
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable28_1  ;; 0x40023c00
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    259          }
   \   00000010   0x4770             BX       LR               ;; return
    260          
    261          /**
    262            * @}
    263            */
    264          
    265          /** @defgroup FLASH_Group2 FLASH Memory Programming functions
    266           *  @brief   FLASH Memory Programming functions
    267           *
    268          @verbatim   
    269           ===============================================================================
    270                                FLASH Memory Programming functions
    271           ===============================================================================   
    272          
    273             This group includes the following functions:
    274              - void FLASH_Unlock(void)
    275              - void FLASH_Lock(void)
    276              - FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
    277              - FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange)
    278              - FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data)
    279              - FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
    280              - FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
    281              - FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data)
    282             
    283             Any operation of erase or program should follow these steps:
    284             1. Call the FLASH_Unlock() function to enable the FLASH control register access
    285          
    286             2. Call the desired function to erase sector(s) or program data
    287          
    288             3. Call the FLASH_Lock() function to disable the FLASH control register access
    289                (recommended to protect the FLASH memory against possible unwanted operation)
    290              
    291          @endverbatim
    292            * @{
    293            */
    294          
    295          /**
    296            * @brief  Unlocks the FLASH control register access
    297            * @param  None
    298            * @retval None
    299            */

   \                                 In section .text, align 2, keep-with-next
    300          void FLASH_Unlock(void)
    301          {
    302            if((FLASH->CR & FLASH_CR_LOCK) != RESET)
   \                     FLASH_Unlock: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40023c10
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD509             BPL.N    ??FLASH_Unlock_0
    303            {
    304              /* Authorize the FLASH Registers access */
    305              FLASH->KEYR = FLASH_KEY1;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable28_3  ;; 0x45670123
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable28_4  ;; 0x40023c04
   \   00000012   0x6008             STR      R0,[R1, #+0]
    306              FLASH->KEYR = FLASH_KEY2;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable28_5  ;; 0xcdef89ab
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable28_4  ;; 0x40023c04
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    307            }  
    308          }
   \                     ??FLASH_Unlock_0: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
    309          
    310          /**
    311            * @brief  Locks the FLASH control register access
    312            * @param  None
    313            * @retval None
    314            */

   \                                 In section .text, align 2, keep-with-next
    315          void FLASH_Lock(void)
    316          {
    317            /* Set the LOCK Bit to lock the FLASH Registers access */
    318            FLASH->CR |= FLASH_CR_LOCK;
   \                     FLASH_Lock: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40023c10
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0x40023c10
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    319          }
   \   00000010   0x4770             BX       LR               ;; return
    320          
    321          /**
    322            * @brief  Erases a specified FLASH Sector.
    323            *   
    324            * @param  FLASH_Sector: The Sector number to be erased.
    325            *          This parameter can be a value between FLASH_Sector_0 and FLASH_Sector_11
    326            *    
    327            * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
    328            *          This parameter can be one of the following values:
    329            *            @arg VoltageRange_1: when the device voltage range is 1.8V to 2.1V, 
    330            *                                  the operation will be done by byte (8-bit) 
    331            *            @arg VoltageRange_2: when the device voltage range is 2.1V to 2.7V,
    332            *                                  the operation will be done by half word (16-bit)
    333            *            @arg VoltageRange_3: when the device voltage range is 2.7V to 3.6V,
    334            *                                  the operation will be done by word (32-bit)
    335            *            @arg VoltageRange_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
    336            *                                  the operation will be done by double word (64-bit)
    337            *       
    338            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    339            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    340            */

   \                                 In section .text, align 2, keep-with-next
    341          FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
    342          {
   \                     FLASH_EraseSector: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    343            uint32_t tmp_psize = 0x0;
   \   00000006   0x2600             MOVS     R6,#+0
    344            FLASH_Status status = FLASH_COMPLETE;
   \   00000008   0x2708             MOVS     R7,#+8
    345          
    346            /* Check the parameters */
    347            assert_param(IS_FLASH_SECTOR(FLASH_Sector));
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD01B             BEQ.N    ??FLASH_EraseSector_0
   \   0000000E   0x2C08             CMP      R4,#+8
   \   00000010   0xD019             BEQ.N    ??FLASH_EraseSector_0
   \   00000012   0x2C10             CMP      R4,#+16
   \   00000014   0xD017             BEQ.N    ??FLASH_EraseSector_0
   \   00000016   0x2C18             CMP      R4,#+24
   \   00000018   0xD015             BEQ.N    ??FLASH_EraseSector_0
   \   0000001A   0x2C20             CMP      R4,#+32
   \   0000001C   0xD013             BEQ.N    ??FLASH_EraseSector_0
   \   0000001E   0x2C28             CMP      R4,#+40
   \   00000020   0xD011             BEQ.N    ??FLASH_EraseSector_0
   \   00000022   0x2C30             CMP      R4,#+48
   \   00000024   0xD00F             BEQ.N    ??FLASH_EraseSector_0
   \   00000026   0x2C38             CMP      R4,#+56
   \   00000028   0xD00D             BEQ.N    ??FLASH_EraseSector_0
   \   0000002A   0x2C40             CMP      R4,#+64
   \   0000002C   0xD00B             BEQ.N    ??FLASH_EraseSector_0
   \   0000002E   0x2C48             CMP      R4,#+72
   \   00000030   0xD009             BEQ.N    ??FLASH_EraseSector_0
   \   00000032   0x2C50             CMP      R4,#+80
   \   00000034   0xD007             BEQ.N    ??FLASH_EraseSector_0
   \   00000036   0x2C58             CMP      R4,#+88
   \   00000038   0xD005             BEQ.N    ??FLASH_EraseSector_0
   \   0000003A   0xF240 0x115B      MOVW     R1,#+347
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable28
   \   00000042   0x.... 0x....      BL       assert_failed
    348            assert_param(IS_VOLTAGERANGE(VoltageRange));
   \                     ??FLASH_EraseSector_0: (+1)
   \   00000046   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   0x2D00             CMP      R5,#+0
   \   0000004A   0xD00E             BEQ.N    ??FLASH_EraseSector_1
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x2D01             CMP      R5,#+1
   \   00000050   0xD00B             BEQ.N    ??FLASH_EraseSector_1
   \   00000052   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000054   0x2D02             CMP      R5,#+2
   \   00000056   0xD008             BEQ.N    ??FLASH_EraseSector_1
   \   00000058   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005A   0x2D03             CMP      R5,#+3
   \   0000005C   0xD005             BEQ.N    ??FLASH_EraseSector_1
   \   0000005E   0xF44F 0x71AE      MOV      R1,#+348
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable28
   \   00000066   0x.... 0x....      BL       assert_failed
    349            
    350            if(VoltageRange == VoltageRange_1)
   \                     ??FLASH_EraseSector_1: (+1)
   \   0000006A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000006C   0x2D00             CMP      R5,#+0
   \   0000006E   0xD102             BNE.N    ??FLASH_EraseSector_2
    351            {
    352               tmp_psize = FLASH_PSIZE_BYTE;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x0006             MOVS     R6,R0
   \   00000074   0xE010             B.N      ??FLASH_EraseSector_3
    353            }
    354            else if(VoltageRange == VoltageRange_2)
   \                     ??FLASH_EraseSector_2: (+1)
   \   00000076   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000078   0x2D01             CMP      R5,#+1
   \   0000007A   0xD103             BNE.N    ??FLASH_EraseSector_4
    355            {
    356              tmp_psize = FLASH_PSIZE_HALF_WORD;
   \   0000007C   0xF44F 0x7080      MOV      R0,#+256
   \   00000080   0x0006             MOVS     R6,R0
   \   00000082   0xE009             B.N      ??FLASH_EraseSector_3
    357            }
    358            else if(VoltageRange == VoltageRange_3)
   \                     ??FLASH_EraseSector_4: (+1)
   \   00000084   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000086   0x2D02             CMP      R5,#+2
   \   00000088   0xD103             BNE.N    ??FLASH_EraseSector_5
    359            {
    360              tmp_psize = FLASH_PSIZE_WORD;
   \   0000008A   0xF44F 0x7000      MOV      R0,#+512
   \   0000008E   0x0006             MOVS     R6,R0
   \   00000090   0xE002             B.N      ??FLASH_EraseSector_3
    361            }
    362            else
    363            {
    364              tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
   \                     ??FLASH_EraseSector_5: (+1)
   \   00000092   0xF44F 0x7040      MOV      R0,#+768
   \   00000096   0x0006             MOVS     R6,R0
    365            }
    366            /* Wait for last operation to be completed */
    367            status = FLASH_WaitForLastOperation();
   \                     ??FLASH_EraseSector_3: (+1)
   \   00000098   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000009C   0x0007             MOVS     R7,R0
    368            
    369            if(status == FLASH_COMPLETE)
   \   0000009E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000A0   0x2F08             CMP      R7,#+8
   \   000000A2   0xD13A             BNE.N    ??FLASH_EraseSector_6
    370            { 
    371              /* if the previous operation is completed, proceed to erase the sector */
    372              FLASH->CR &= CR_PSIZE_MASK;
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40023c10
   \   000000A8   0x6800             LDR      R0,[R0, #+0]
   \   000000AA   0xF430 0x7040      BICS     R0,R0,#0x300
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0x40023c10
   \   000000B2   0x6008             STR      R0,[R1, #+0]
    373              FLASH->CR |= tmp_psize;
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40023c10
   \   000000B8   0x6800             LDR      R0,[R0, #+0]
   \   000000BA   0x4330             ORRS     R0,R6,R0
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0x40023c10
   \   000000C0   0x6008             STR      R0,[R1, #+0]
    374              FLASH->CR &= SECTOR_MASK;
   \   000000C2   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40023c10
   \   000000C6   0x6800             LDR      R0,[R0, #+0]
   \   000000C8   0xF030 0x00F8      BICS     R0,R0,#0xF8
   \   000000CC   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0x40023c10
   \   000000D0   0x6008             STR      R0,[R1, #+0]
    375              FLASH->CR |= FLASH_CR_SER | FLASH_Sector;
   \   000000D2   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40023c10
   \   000000D6   0x6800             LDR      R0,[R0, #+0]
   \   000000D8   0xF054 0x0102      ORRS     R1,R4,#0x2
   \   000000DC   0x4308             ORRS     R0,R1,R0
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0x40023c10
   \   000000E2   0x6008             STR      R0,[R1, #+0]
    376              FLASH->CR |= FLASH_CR_STRT;
   \   000000E4   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40023c10
   \   000000E8   0x6800             LDR      R0,[R0, #+0]
   \   000000EA   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   000000EE   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0x40023c10
   \   000000F2   0x6008             STR      R0,[R1, #+0]
    377              
    378              /* Wait for last operation to be completed */
    379              status = FLASH_WaitForLastOperation();
   \   000000F4   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   000000F8   0x0007             MOVS     R7,R0
    380              
    381              /* if the erase operation is completed, disable the SER Bit */
    382              FLASH->CR &= (~FLASH_CR_SER);
   \   000000FA   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40023c10
   \   000000FE   0x6800             LDR      R0,[R0, #+0]
   \   00000100   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000104   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0x40023c10
   \   00000108   0x6008             STR      R0,[R1, #+0]
    383              FLASH->CR &= SECTOR_MASK; 
   \   0000010A   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40023c10
   \   0000010E   0x6800             LDR      R0,[R0, #+0]
   \   00000110   0xF030 0x00F8      BICS     R0,R0,#0xF8
   \   00000114   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0x40023c10
   \   00000118   0x6008             STR      R0,[R1, #+0]
    384            }
    385            /* Return the Erase Status */
    386            return status;
   \                     ??FLASH_EraseSector_6: (+1)
   \   0000011A   0x0038             MOVS     R0,R7
   \   0000011C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000011E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    387          }
    388          
    389          /**
    390            * @brief  Erases all FLASH Sectors.
    391            *    
    392            * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
    393            *          This parameter can be one of the following values:
    394            *            @arg VoltageRange_1: when the device voltage range is 1.8V to 2.1V, 
    395            *                                  the operation will be done by byte (8-bit) 
    396            *            @arg VoltageRange_2: when the device voltage range is 2.1V to 2.7V,
    397            *                                  the operation will be done by half word (16-bit)
    398            *            @arg VoltageRange_3: when the device voltage range is 2.7V to 3.6V,
    399            *                                  the operation will be done by word (32-bit)
    400            *            @arg VoltageRange_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
    401            *                                  the operation will be done by double word (64-bit)
    402            *       
    403            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    404            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    405            */

   \                                 In section .text, align 2, keep-with-next
    406          FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange)
    407          {
   \                     FLASH_EraseAllSectors: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    408            uint32_t tmp_psize = 0x0;
   \   00000004   0x2500             MOVS     R5,#+0
    409            FLASH_Status status = FLASH_COMPLETE;
   \   00000006   0x2608             MOVS     R6,#+8
    410            
    411            /* Wait for last operation to be completed */
    412            status = FLASH_WaitForLastOperation();
   \   00000008   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000000C   0x0006             MOVS     R6,R0
    413            assert_param(IS_VOLTAGERANGE(VoltageRange));
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD00E             BEQ.N    ??FLASH_EraseAllSectors_0
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0x2C01             CMP      R4,#+1
   \   00000018   0xD00B             BEQ.N    ??FLASH_EraseAllSectors_0
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C02             CMP      R4,#+2
   \   0000001E   0xD008             BEQ.N    ??FLASH_EraseAllSectors_0
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x2C03             CMP      R4,#+3
   \   00000024   0xD005             BEQ.N    ??FLASH_EraseAllSectors_0
   \   00000026   0xF240 0x119D      MOVW     R1,#+413
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable28
   \   0000002E   0x.... 0x....      BL       assert_failed
    414            
    415            if(VoltageRange == VoltageRange_1)
   \                     ??FLASH_EraseAllSectors_0: (+1)
   \   00000032   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000034   0x2C00             CMP      R4,#+0
   \   00000036   0xD102             BNE.N    ??FLASH_EraseAllSectors_1
    416            {
    417               tmp_psize = FLASH_PSIZE_BYTE;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x0005             MOVS     R5,R0
   \   0000003C   0xE010             B.N      ??FLASH_EraseAllSectors_2
    418            }
    419            else if(VoltageRange == VoltageRange_2)
   \                     ??FLASH_EraseAllSectors_1: (+1)
   \   0000003E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000040   0x2C01             CMP      R4,#+1
   \   00000042   0xD103             BNE.N    ??FLASH_EraseAllSectors_3
    420            {
    421              tmp_psize = FLASH_PSIZE_HALF_WORD;
   \   00000044   0xF44F 0x7080      MOV      R0,#+256
   \   00000048   0x0005             MOVS     R5,R0
   \   0000004A   0xE009             B.N      ??FLASH_EraseAllSectors_2
    422            }
    423            else if(VoltageRange == VoltageRange_3)
   \                     ??FLASH_EraseAllSectors_3: (+1)
   \   0000004C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004E   0x2C02             CMP      R4,#+2
   \   00000050   0xD103             BNE.N    ??FLASH_EraseAllSectors_4
    424            {
    425              tmp_psize = FLASH_PSIZE_WORD;
   \   00000052   0xF44F 0x7000      MOV      R0,#+512
   \   00000056   0x0005             MOVS     R5,R0
   \   00000058   0xE002             B.N      ??FLASH_EraseAllSectors_2
    426            }
    427            else
    428            {
    429              tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
   \                     ??FLASH_EraseAllSectors_4: (+1)
   \   0000005A   0xF44F 0x7040      MOV      R0,#+768
   \   0000005E   0x0005             MOVS     R5,R0
    430            }  
    431            if(status == FLASH_COMPLETE)
   \                     ??FLASH_EraseAllSectors_2: (+1)
   \   00000060   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000062   0x2E08             CMP      R6,#+8
   \   00000064   0xD129             BNE.N    ??FLASH_EraseAllSectors_5
    432            {
    433              /* if the previous operation is completed, proceed to erase all sectors */
    434               FLASH->CR &= CR_PSIZE_MASK;
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40023c10
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xF430 0x7040      BICS     R0,R0,#0x300
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0x40023c10
   \   00000074   0x6008             STR      R0,[R1, #+0]
    435               FLASH->CR |= tmp_psize;
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40023c10
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x4328             ORRS     R0,R5,R0
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0x40023c10
   \   00000082   0x6008             STR      R0,[R1, #+0]
    436               FLASH->CR |= FLASH_CR_MER;
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40023c10
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0x40023c10
   \   00000092   0x6008             STR      R0,[R1, #+0]
    437               FLASH->CR |= FLASH_CR_STRT;
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40023c10
   \   00000098   0x6800             LDR      R0,[R0, #+0]
   \   0000009A   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   0000009E   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0x40023c10
   \   000000A2   0x6008             STR      R0,[R1, #+0]
    438              
    439              /* Wait for last operation to be completed */
    440              status = FLASH_WaitForLastOperation();
   \   000000A4   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   000000A8   0x0006             MOVS     R6,R0
    441          
    442              /* if the erase operation is completed, disable the MER Bit */
    443              FLASH->CR &= (~FLASH_CR_MER);
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40023c10
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0xF030 0x0004      BICS     R0,R0,#0x4
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0x40023c10
   \   000000B8   0x6008             STR      R0,[R1, #+0]
    444          
    445            }   
    446            /* Return the Erase Status */
    447            return status;
   \                     ??FLASH_EraseAllSectors_5: (+1)
   \   000000BA   0x0030             MOVS     R0,R6
   \   000000BC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BE   0xBD70             POP      {R4-R6,PC}       ;; return
    448          }
    449          
    450          /**
    451            * @brief  Programs a double word (64-bit) at a specified address.
    452            * @note   This function must be used when the device voltage range is from
    453            *         2.7V to 3.6V and an External Vpp is present.           
    454            * @param  Address: specifies the address to be programmed.
    455            * @param  Data: specifies the data to be programmed.
    456            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    457            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    458            */

   \                                 In section .text, align 2, keep-with-next
    459          FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data)
    460          {
   \                     FLASH_ProgramDoubleWord: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x0014             MOVS     R4,R2
   \   00000006   0x001D             MOVS     R5,R3
    461            FLASH_Status status = FLASH_COMPLETE;
   \   00000008   0x2708             MOVS     R7,#+8
    462          
    463            /* Check the parameters */
    464            assert_param(IS_FLASH_ADDRESS(Address));
   \   0000000A   0xF1B6 0x6F00      CMP      R6,#+134217728
   \   0000000E   0xD303             BCC.N    ??FLASH_ProgramDoubleWord_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable28_6  ;; 0x80fffff
   \   00000014   0x4286             CMP      R6,R0
   \   00000016   0xD30D             BCC.N    ??FLASH_ProgramDoubleWord_1
   \                     ??FLASH_ProgramDoubleWord_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable28_7  ;; 0x1fff7800
   \   0000001C   0x4286             CMP      R6,R0
   \   0000001E   0xD303             BCC.N    ??FLASH_ProgramDoubleWord_2
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable28_8  ;; 0x1fff7a0f
   \   00000024   0x4286             CMP      R6,R0
   \   00000026   0xD305             BCC.N    ??FLASH_ProgramDoubleWord_1
   \                     ??FLASH_ProgramDoubleWord_2: (+1)
   \   00000028   0xF44F 0x71E8      MOV      R1,#+464
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable28
   \   00000030   0x.... 0x....      BL       assert_failed
    465          
    466            /* Wait for last operation to be completed */
    467            status = FLASH_WaitForLastOperation();
   \                     ??FLASH_ProgramDoubleWord_1: (+1)
   \   00000034   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000038   0x0007             MOVS     R7,R0
    468            
    469            if(status == FLASH_COMPLETE)
   \   0000003A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003C   0x2F08             CMP      R7,#+8
   \   0000003E   0xD124             BNE.N    ??FLASH_ProgramDoubleWord_3
    470            {
    471              /* if the previous operation is completed, proceed to program the new data */
    472              FLASH->CR &= CR_PSIZE_MASK;
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40023c10
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF430 0x7040      BICS     R0,R0,#0x300
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0x40023c10
   \   0000004E   0x6008             STR      R0,[R1, #+0]
    473              FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40023c10
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0xF450 0x7040      ORRS     R0,R0,#0x300
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0x40023c10
   \   0000005E   0x6008             STR      R0,[R1, #+0]
    474              FLASH->CR |= FLASH_CR_PG;
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40023c10
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0x40023c10
   \   0000006E   0x6008             STR      R0,[R1, #+0]
    475            
    476              *(__IO uint64_t*)Address = Data;
   \   00000070   0xE9C6 0x4500      STRD     R4,R5,[R6, #+0]
    477                  
    478              /* Wait for last operation to be completed */
    479              status = FLASH_WaitForLastOperation();
   \   00000074   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000078   0x0007             MOVS     R7,R0
    480          
    481              /* if the program operation is completed, disable the PG Bit */
    482              FLASH->CR &= (~FLASH_CR_PG);
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40023c10
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x0840             LSRS     R0,R0,#+1
   \   00000082   0x0040             LSLS     R0,R0,#+1
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0x40023c10
   \   00000088   0x6008             STR      R0,[R1, #+0]
    483            } 
    484            /* Return the Program Status */
    485            return status;
   \                     ??FLASH_ProgramDoubleWord_3: (+1)
   \   0000008A   0x0038             MOVS     R0,R7
   \   0000008C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    486          }
    487          
    488          /**
    489            * @brief  Programs a word (32-bit) at a specified address.
    490            * @param  Address: specifies the address to be programmed.
    491            *         This parameter can be any address in Program memory zone or in OTP zone.  
    492            * @note   This function must be used when the device voltage range is from 2.7V to 3.6V. 
    493            * @param  Data: specifies the data to be programmed.
    494            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    495            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    496            */

   \                                 In section .text, align 2, keep-with-next
    497          FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
    498          {
   \                     FLASH_ProgramWord: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    499            FLASH_Status status = FLASH_COMPLETE;
   \   00000006   0x2608             MOVS     R6,#+8
    500          
    501            /* Check the parameters */
    502            assert_param(IS_FLASH_ADDRESS(Address));
   \   00000008   0xF1B4 0x6F00      CMP      R4,#+134217728
   \   0000000C   0xD303             BCC.N    ??FLASH_ProgramWord_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable28_6  ;; 0x80fffff
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD30D             BCC.N    ??FLASH_ProgramWord_1
   \                     ??FLASH_ProgramWord_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable28_7  ;; 0x1fff7800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD303             BCC.N    ??FLASH_ProgramWord_2
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable28_8  ;; 0x1fff7a0f
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD305             BCC.N    ??FLASH_ProgramWord_1
   \                     ??FLASH_ProgramWord_2: (+1)
   \   00000026   0xF44F 0x71FB      MOV      R1,#+502
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable28
   \   0000002E   0x.... 0x....      BL       assert_failed
    503          
    504            /* Wait for last operation to be completed */
    505            status = FLASH_WaitForLastOperation();
   \                     ??FLASH_ProgramWord_1: (+1)
   \   00000032   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000036   0x0006             MOVS     R6,R0
    506            
    507            if(status == FLASH_COMPLETE)
   \   00000038   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003A   0x2E08             CMP      R6,#+8
   \   0000003C   0xD123             BNE.N    ??FLASH_ProgramWord_3
    508            {
    509              /* if the previous operation is completed, proceed to program the new data */
    510              FLASH->CR &= CR_PSIZE_MASK;
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40023c10
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0xF430 0x7040      BICS     R0,R0,#0x300
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0x40023c10
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    511              FLASH->CR |= FLASH_PSIZE_WORD;
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40023c10
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0x40023c10
   \   0000005C   0x6008             STR      R0,[R1, #+0]
    512              FLASH->CR |= FLASH_CR_PG;
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40023c10
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0x40023c10
   \   0000006C   0x6008             STR      R0,[R1, #+0]
    513            
    514              *(__IO uint32_t*)Address = Data;
   \   0000006E   0x6025             STR      R5,[R4, #+0]
    515                  
    516              /* Wait for last operation to be completed */
    517              status = FLASH_WaitForLastOperation();
   \   00000070   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000074   0x0006             MOVS     R6,R0
    518          
    519              /* if the program operation is completed, disable the PG Bit */
    520              FLASH->CR &= (~FLASH_CR_PG);
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40023c10
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x0840             LSRS     R0,R0,#+1
   \   0000007E   0x0040             LSLS     R0,R0,#+1
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0x40023c10
   \   00000084   0x6008             STR      R0,[R1, #+0]
    521            } 
    522            /* Return the Program Status */
    523            return status;
   \                     ??FLASH_ProgramWord_3: (+1)
   \   00000086   0x0030             MOVS     R0,R6
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0xBD70             POP      {R4-R6,PC}       ;; return
    524          }
    525          
    526          /**
    527            * @brief  Programs a half word (16-bit) at a specified address. 
    528            * @note   This function must be used when the device voltage range is from 2.1V to 3.6V.               
    529            * @param  Address: specifies the address to be programmed.
    530            *         This parameter can be any address in Program memory zone or in OTP zone.  
    531            * @param  Data: specifies the data to be programmed.
    532            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    533            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    534            */

   \                                 In section .text, align 2, keep-with-next
    535          FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
    536          {
   \                     FLASH_ProgramHalfWord: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    537            FLASH_Status status = FLASH_COMPLETE;
   \   00000006   0x2608             MOVS     R6,#+8
    538          
    539            /* Check the parameters */
    540            assert_param(IS_FLASH_ADDRESS(Address));
   \   00000008   0xF1B4 0x6F00      CMP      R4,#+134217728
   \   0000000C   0xD303             BCC.N    ??FLASH_ProgramHalfWord_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable28_6  ;; 0x80fffff
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD30D             BCC.N    ??FLASH_ProgramHalfWord_1
   \                     ??FLASH_ProgramHalfWord_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable28_7  ;; 0x1fff7800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD303             BCC.N    ??FLASH_ProgramHalfWord_2
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable28_8  ;; 0x1fff7a0f
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD305             BCC.N    ??FLASH_ProgramHalfWord_1
   \                     ??FLASH_ProgramHalfWord_2: (+1)
   \   00000026   0xF44F 0x7107      MOV      R1,#+540
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable28
   \   0000002E   0x.... 0x....      BL       assert_failed
    541          
    542            /* Wait for last operation to be completed */
    543            status = FLASH_WaitForLastOperation();
   \                     ??FLASH_ProgramHalfWord_1: (+1)
   \   00000032   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000036   0x0006             MOVS     R6,R0
    544            
    545            if(status == FLASH_COMPLETE)
   \   00000038   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003A   0x2E08             CMP      R6,#+8
   \   0000003C   0xD123             BNE.N    ??FLASH_ProgramHalfWord_3
    546            {
    547              /* if the previous operation is completed, proceed to program the new data */
    548              FLASH->CR &= CR_PSIZE_MASK;
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40023c10
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0xF430 0x7040      BICS     R0,R0,#0x300
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0x40023c10
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    549              FLASH->CR |= FLASH_PSIZE_HALF_WORD;
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40023c10
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0x40023c10
   \   0000005C   0x6008             STR      R0,[R1, #+0]
    550              FLASH->CR |= FLASH_CR_PG;
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40023c10
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0x40023c10
   \   0000006C   0x6008             STR      R0,[R1, #+0]
    551            
    552              *(__IO uint16_t*)Address = Data;
   \   0000006E   0x8025             STRH     R5,[R4, #+0]
    553                  
    554              /* Wait for last operation to be completed */
    555              status = FLASH_WaitForLastOperation();
   \   00000070   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000074   0x0006             MOVS     R6,R0
    556          
    557              /* if the program operation is completed, disable the PG Bit */
    558              FLASH->CR &= (~FLASH_CR_PG);
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40023c10
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x0840             LSRS     R0,R0,#+1
   \   0000007E   0x0040             LSLS     R0,R0,#+1
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0x40023c10
   \   00000084   0x6008             STR      R0,[R1, #+0]
    559            } 
    560            /* Return the Program Status */
    561            return status;
   \                     ??FLASH_ProgramHalfWord_3: (+1)
   \   00000086   0x0030             MOVS     R0,R6
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0xBD70             POP      {R4-R6,PC}       ;; return
    562          }
    563          
    564          /**
    565            * @brief  Programs a byte (8-bit) at a specified address.
    566            * @note   This function can be used within all the device supply voltage ranges.               
    567            * @param  Address: specifies the address to be programmed.
    568            *         This parameter can be any address in Program memory zone or in OTP zone.  
    569            * @param  Data: specifies the data to be programmed.
    570            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    571            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    572            */

   \                                 In section .text, align 2, keep-with-next
    573          FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data)
    574          {
   \                     FLASH_ProgramByte: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    575            FLASH_Status status = FLASH_COMPLETE;
   \   00000006   0x2608             MOVS     R6,#+8
    576          
    577            /* Check the parameters */
    578            assert_param(IS_FLASH_ADDRESS(Address));
   \   00000008   0xF1B4 0x6F00      CMP      R4,#+134217728
   \   0000000C   0xD303             BCC.N    ??FLASH_ProgramByte_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable28_6  ;; 0x80fffff
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD30C             BCC.N    ??FLASH_ProgramByte_1
   \                     ??FLASH_ProgramByte_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable28_7  ;; 0x1fff7800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD303             BCC.N    ??FLASH_ProgramByte_2
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable28_8  ;; 0x1fff7a0f
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD304             BCC.N    ??FLASH_ProgramByte_1
   \                     ??FLASH_ProgramByte_2: (+1)
   \   00000026   0xF240 0x2142      MOVW     R1,#+578
   \   0000002A   0x....             LDR.N    R0,??DataTable28
   \   0000002C   0x.... 0x....      BL       assert_failed
    579          
    580            /* Wait for last operation to be completed */
    581            status = FLASH_WaitForLastOperation();
   \                     ??FLASH_ProgramByte_1: (+1)
   \   00000030   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000034   0x0006             MOVS     R6,R0
    582            
    583            if(status == FLASH_COMPLETE)
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x2E08             CMP      R6,#+8
   \   0000003A   0xD119             BNE.N    ??FLASH_ProgramByte_3
    584            {
    585              /* if the previous operation is completed, proceed to program the new data */
    586              FLASH->CR &= CR_PSIZE_MASK;
   \   0000003C   0x....             LDR.N    R0,??DataTable28_2  ;; 0x40023c10
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0xF430 0x7040      BICS     R0,R0,#0x300
   \   00000044   0x....             LDR.N    R1,??DataTable28_2  ;; 0x40023c10
   \   00000046   0x6008             STR      R0,[R1, #+0]
    587              FLASH->CR |= FLASH_PSIZE_BYTE;
   \   00000048   0x....             LDR.N    R0,??DataTable28_2  ;; 0x40023c10
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x....             LDR.N    R1,??DataTable28_2  ;; 0x40023c10
   \   0000004E   0x6008             STR      R0,[R1, #+0]
    588              FLASH->CR |= FLASH_CR_PG;
   \   00000050   0x....             LDR.N    R0,??DataTable28_2  ;; 0x40023c10
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000058   0x....             LDR.N    R1,??DataTable28_2  ;; 0x40023c10
   \   0000005A   0x6008             STR      R0,[R1, #+0]
    589            
    590              *(__IO uint8_t*)Address = Data;
   \   0000005C   0x7025             STRB     R5,[R4, #+0]
    591                  
    592              /* Wait for last operation to be completed */
    593              status = FLASH_WaitForLastOperation();
   \   0000005E   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000062   0x0006             MOVS     R6,R0
    594          
    595              /* if the program operation is completed, disable the PG Bit */
    596              FLASH->CR &= (~FLASH_CR_PG);
   \   00000064   0x....             LDR.N    R0,??DataTable28_2  ;; 0x40023c10
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0x0840             LSRS     R0,R0,#+1
   \   0000006A   0x0040             LSLS     R0,R0,#+1
   \   0000006C   0x....             LDR.N    R1,??DataTable28_2  ;; 0x40023c10
   \   0000006E   0x6008             STR      R0,[R1, #+0]
    597            } 
    598          
    599            /* Return the Program Status */
    600            return status;
   \                     ??FLASH_ProgramByte_3: (+1)
   \   00000070   0x0030             MOVS     R0,R6
   \   00000072   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000074   0xBD70             POP      {R4-R6,PC}       ;; return
    601          }
    602          
    603          /**
    604            * @}
    605            */
    606          
    607          /** @defgroup FLASH_Group3 Option Bytes Programming functions
    608           *  @brief   Option Bytes Programming functions 
    609           *
    610          @verbatim   
    611           ===============================================================================
    612                                  Option Bytes Programming functions
    613           ===============================================================================  
    614           
    615             This group includes the following functions:
    616             - void FLASH_OB_Unlock(void)
    617             - void FLASH_OB_Lock(void)
    618             - void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
    619             - void FLASH_OB_RDPConfig(uint8_t OB_RDP)
    620             - void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
    621             - void FLASH_OB_BORConfig(uint8_t OB_BOR)
    622             - FLASH_Status FLASH_ProgramOTP(uint32_t Address, uint32_t Data)							
    623             - FLASH_Status FLASH_OB_Launch(void)
    624             - uint32_t FLASH_OB_GetUser(void)						
    625             - uint8_t FLASH_OB_GetWRP(void)						
    626             - uint8_t FLASH_OB_GetRDP(void)							
    627             - uint8_t FLASH_OB_GetBOR(void)
    628             
    629             Any operation of erase or program should follow these steps:
    630             1. Call the FLASH_OB_Unlock() function to enable the FLASH option control register access
    631          
    632             2. Call one or several functions to program the desired Option Bytes:
    633                - void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState) => to Enable/Disable 
    634                  the desired sector write protection
    635                - void FLASH_OB_RDPConfig(uint8_t OB_RDP) => to set the desired read Protection Level
    636                - void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY) => to configure 
    637                  the user Option Bytes.
    638                - void FLASH_OB_BORConfig(uint8_t OB_BOR) => to set the BOR Level 			 
    639          
    640             3. Once all needed Option Bytes to be programmed are correctly written, call the
    641                FLASH_OB_Launch() function to launch the Option Bytes programming process.
    642               
    643               @note When changing the IWDG mode from HW to SW or from SW to HW, a system 
    644                     reset is needed to make the change effective.  
    645          
    646             4. Call the FLASH_OB_Lock() function to disable the FLASH option control register
    647                access (recommended to protect the Option Bytes against possible unwanted operations)
    648              
    649          @endverbatim
    650            * @{
    651            */
    652          
    653          /**
    654            * @brief  Unlocks the FLASH Option Control Registers access.
    655            * @param  None
    656            * @retval None
    657            */

   \                                 In section .text, align 2, keep-with-next
    658          void FLASH_OB_Unlock(void)
    659          {
    660            if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
   \                     FLASH_OB_Unlock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable28_9  ;; 0x40023c14
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x07C0             LSLS     R0,R0,#+31
   \   00000006   0xD505             BPL.N    ??FLASH_OB_Unlock_0
    661            {
    662              /* Authorizes the Option Byte register programming */
    663              FLASH->OPTKEYR = FLASH_OPT_KEY1;
   \   00000008   0x....             LDR.N    R0,??DataTable28_10  ;; 0x8192a3b
   \   0000000A   0x....             LDR.N    R1,??DataTable28_11  ;; 0x40023c08
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    664              FLASH->OPTKEYR = FLASH_OPT_KEY2;
   \   0000000E   0x....             LDR.N    R0,??DataTable28_12  ;; 0x4c5d6e7f
   \   00000010   0x....             LDR.N    R1,??DataTable28_11  ;; 0x40023c08
   \   00000012   0x6008             STR      R0,[R1, #+0]
    665            }  
    666          }
   \                     ??FLASH_OB_Unlock_0: (+1)
   \   00000014   0x4770             BX       LR               ;; return
    667          
    668          /**
    669            * @brief  Locks the FLASH Option Control Registers access.
    670            * @param  None
    671            * @retval None
    672            */

   \                                 In section .text, align 2, keep-with-next
    673          void FLASH_OB_Lock(void)
    674          {
    675            /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
    676            FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
   \                     FLASH_OB_Lock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable28_9  ;; 0x40023c14
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000008   0x....             LDR.N    R1,??DataTable28_9  ;; 0x40023c14
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    677          }
   \   0000000C   0x4770             BX       LR               ;; return
    678          
    679          /**
    680            * @brief  Enables or disables the write protection of the desired sectors
    681            * @param  OB_WRP: specifies the sector(s) to be write protected or unprotected.
    682            *          This parameter can be one of the following values:
    683            *            @arg OB_WRP: A value between OB_WRP_Sector0 and OB_WRP_Sector11                      
    684            *            @arg OB_WRP_Sector_All
    685            * @param  Newstate: new state of the Write Protection.
    686            *          This parameter can be: ENABLE or DISABLE.
    687            * @retval None  
    688            */

   \                                 In section .text, align 2, keep-with-next
    689          void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
    690          { 
   \                     FLASH_OB_WRPConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    691            FLASH_Status status = FLASH_COMPLETE;
   \   00000006   0x2608             MOVS     R6,#+8
    692            
    693            /* Check the parameters */
    694            assert_param(IS_OB_WRP(OB_WRP));
   \   00000008   0x0B20             LSRS     R0,R4,#+12
   \   0000000A   0x0300             LSLS     R0,R0,#+12
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD101             BNE.N    ??FLASH_OB_WRPConfig_0
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD104             BNE.N    ??FLASH_OB_WRPConfig_1
   \                     ??FLASH_OB_WRPConfig_0: (+1)
   \   00000014   0xF240 0x21B6      MOVW     R1,#+694
   \   00000018   0x....             LDR.N    R0,??DataTable28
   \   0000001A   0x.... 0x....      BL       assert_failed
    695            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??FLASH_OB_WRPConfig_1: (+1)
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD007             BEQ.N    ??FLASH_OB_WRPConfig_2
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D01             CMP      R5,#+1
   \   00000028   0xD004             BEQ.N    ??FLASH_OB_WRPConfig_2
   \   0000002A   0xF240 0x21B7      MOVW     R1,#+695
   \   0000002E   0x....             LDR.N    R0,??DataTable28
   \   00000030   0x.... 0x....      BL       assert_failed
    696              
    697            status = FLASH_WaitForLastOperation();
   \                     ??FLASH_OB_WRPConfig_2: (+1)
   \   00000034   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000038   0x0006             MOVS     R6,R0
    698          
    699            if(status == FLASH_COMPLETE)
   \   0000003A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003C   0x2E08             CMP      R6,#+8
   \   0000003E   0xD10D             BNE.N    ??FLASH_OB_WRPConfig_3
    700            { 
    701              if(NewState != DISABLE)
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x2D00             CMP      R5,#+0
   \   00000044   0xD005             BEQ.N    ??FLASH_OB_WRPConfig_4
    702              {
    703                *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_WRP);
   \   00000046   0x....             LDR.N    R0,??DataTable28_13  ;; 0x40023c16
   \   00000048   0x8800             LDRH     R0,[R0, #+0]
   \   0000004A   0x43A0             BICS     R0,R0,R4
   \   0000004C   0x....             LDR.N    R1,??DataTable28_13  ;; 0x40023c16
   \   0000004E   0x8008             STRH     R0,[R1, #+0]
   \   00000050   0xE004             B.N      ??FLASH_OB_WRPConfig_3
    704              }
    705              else
    706              {
    707                *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
   \                     ??FLASH_OB_WRPConfig_4: (+1)
   \   00000052   0x....             LDR.N    R0,??DataTable28_13  ;; 0x40023c16
   \   00000054   0x8800             LDRH     R0,[R0, #+0]
   \   00000056   0x4320             ORRS     R0,R4,R0
   \   00000058   0x....             LDR.N    R1,??DataTable28_13  ;; 0x40023c16
   \   0000005A   0x8008             STRH     R0,[R1, #+0]
    708              }
    709            }
    710          }
   \                     ??FLASH_OB_WRPConfig_3: (+1)
   \   0000005C   0xBD70             POP      {R4-R6,PC}       ;; return
    711          
    712          /**
    713            * @brief  Sets the read protection level.
    714            * @param  OB_RDP: specifies the read protection level.
    715            *          This parameter can be one of the following values:
    716            *            @arg OB_RDP_Level_0: No protection
    717            *            @arg OB_RDP_Level_1: Read protection of the memory
    718            *            @arg OB_RDP_Level_2: Full chip protection
    719            *   
    720            * !!!Warning!!! When enabling OB_RDP level 2 it's no more possible to go back to level 1 or 0
    721            *    
    722            * @retval None
    723            */

   \                                 In section .text, align 2, keep-with-next
    724          void FLASH_OB_RDPConfig(uint8_t OB_RDP)
    725          {
   \                     FLASH_OB_RDPConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    726            FLASH_Status status = FLASH_COMPLETE;
   \   00000004   0x2508             MOVS     R5,#+8
    727          
    728            /* Check the parameters */
    729            assert_param(IS_OB_RDP(OB_RDP));
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2CAA             CMP      R4,#+170
   \   0000000A   0xD007             BEQ.N    ??FLASH_OB_RDPConfig_0
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C55             CMP      R4,#+85
   \   00000010   0xD004             BEQ.N    ??FLASH_OB_RDPConfig_0
   \   00000012   0xF240 0x21D9      MOVW     R1,#+729
   \   00000016   0x....             LDR.N    R0,??DataTable28
   \   00000018   0x.... 0x....      BL       assert_failed
    730          
    731            status = FLASH_WaitForLastOperation();
   \                     ??FLASH_OB_RDPConfig_0: (+1)
   \   0000001C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000020   0x0005             MOVS     R5,R0
    732          
    733            if(status == FLASH_COMPLETE)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D08             CMP      R5,#+8
   \   00000026   0xD101             BNE.N    ??FLASH_OB_RDPConfig_1
    734            {
    735              *(__IO uint8_t*)OPTCR_BYTE1_ADDRESS = OB_RDP;
   \   00000028   0x....             LDR.N    R0,??DataTable28_14  ;; 0x40023c15
   \   0000002A   0x7004             STRB     R4,[R0, #+0]
    736          
    737            }
    738          }
   \                     ??FLASH_OB_RDPConfig_1: (+1)
   \   0000002C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    739          
    740          /**
    741            * @brief  Programs the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.    
    742            * @param  OB_IWDG: Selects the IWDG mode
    743            *          This parameter can be one of the following values:
    744            *            @arg OB_IWDG_SW: Software IWDG selected
    745            *            @arg OB_IWDG_HW: Hardware IWDG selected
    746            * @param  OB_STOP: Reset event when entering STOP mode.
    747            *          This parameter  can be one of the following values:
    748            *            @arg OB_STOP_NoRST: No reset generated when entering in STOP
    749            *            @arg OB_STOP_RST: Reset generated when entering in STOP
    750            * @param  OB_STDBY: Reset event when entering Standby mode.
    751            *          This parameter  can be one of the following values:
    752            *            @arg OB_STDBY_NoRST: No reset generated when entering in STANDBY
    753            *            @arg OB_STDBY_RST: Reset generated when entering in STANDBY
    754            * @retval None
    755            */

   \                                 In section .text, align 2, keep-with-next
    756          void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
    757          {
   \                     FLASH_OB_UserConfig: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    758            uint8_t optiontmp = 0xFF;
   \   0000000A   0x27FF             MOVS     R7,#+255
    759            FLASH_Status status = FLASH_COMPLETE; 
   \   0000000C   0xF05F 0x0808      MOVS     R8,#+8
    760          
    761            /* Check the parameters */
    762            assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C20             CMP      R4,#+32
   \   00000014   0xD007             BEQ.N    ??FLASH_OB_UserConfig_0
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD004             BEQ.N    ??FLASH_OB_UserConfig_0
   \   0000001C   0xF240 0x21FA      MOVW     R1,#+762
   \   00000020   0x....             LDR.N    R0,??DataTable28
   \   00000022   0x.... 0x....      BL       assert_failed
    763            assert_param(IS_OB_STOP_SOURCE(OB_STOP));
   \                     ??FLASH_OB_UserConfig_0: (+1)
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0x2D40             CMP      R5,#+64
   \   0000002A   0xD007             BEQ.N    ??FLASH_OB_UserConfig_1
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD004             BEQ.N    ??FLASH_OB_UserConfig_1
   \   00000032   0xF240 0x21FB      MOVW     R1,#+763
   \   00000036   0x....             LDR.N    R0,??DataTable28
   \   00000038   0x.... 0x....      BL       assert_failed
    764            assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
   \                     ??FLASH_OB_UserConfig_1: (+1)
   \   0000003C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003E   0x2E80             CMP      R6,#+128
   \   00000040   0xD007             BEQ.N    ??FLASH_OB_UserConfig_2
   \   00000042   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000044   0x2E00             CMP      R6,#+0
   \   00000046   0xD004             BEQ.N    ??FLASH_OB_UserConfig_2
   \   00000048   0xF44F 0x713F      MOV      R1,#+764
   \   0000004C   0x....             LDR.N    R0,??DataTable28
   \   0000004E   0x.... 0x....      BL       assert_failed
    765          
    766            /* Wait for last operation to be completed */
    767            status = FLASH_WaitForLastOperation();
   \                     ??FLASH_OB_UserConfig_2: (+1)
   \   00000052   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000056   0x4680             MOV      R8,R0
    768            
    769            if(status == FLASH_COMPLETE)
   \   00000058   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000005C   0xF1B8 0x0F08      CMP      R8,#+8
   \   00000060   0xD10A             BNE.N    ??FLASH_OB_UserConfig_3
    770            { 
    771              /* Mask OPTLOCK, OPTSTRT and BOR_LEV bits */
    772              optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0F); 
   \   00000062   0x....             LDR.N    R0,??DataTable28_9  ;; 0x40023c14
   \   00000064   0x7800             LDRB     R0,[R0, #+0]
   \   00000066   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000006A   0x0007             MOVS     R7,R0
    773          
    774              /* Update User Option Byte */
    775              *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS = OB_IWDG | (uint8_t)(OB_STDBY | (uint8_t)(OB_STOP | ((uint8_t)optiontmp))); 
   \   0000006C   0xEA57 0x0005      ORRS     R0,R7,R5
   \   00000070   0x4330             ORRS     R0,R0,R6
   \   00000072   0x4320             ORRS     R0,R0,R4
   \   00000074   0x....             LDR.N    R1,??DataTable28_9  ;; 0x40023c14
   \   00000076   0x7008             STRB     R0,[R1, #+0]
    776            }  
    777          }
   \                     ??FLASH_OB_UserConfig_3: (+1)
   \   00000078   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    778          
    779          /**
    780            * @brief  Sets the BOR Level. 
    781            * @param  OB_BOR: specifies the Option Bytes BOR Reset Level.
    782            *          This parameter can be one of the following values:
    783            *            @arg OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V
    784            *            @arg OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V
    785            *            @arg OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
    786            *            @arg OB_BOR_OFF: Supply voltage ranges from 1.62 to 2.1 V
    787            * @retval None
    788            */

   \                                 In section .text, align 2, keep-with-next
    789          void FLASH_OB_BORConfig(uint8_t OB_BOR)
    790          {
   \                     FLASH_OB_BORConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    791            /* Check the parameters */
    792            assert_param(IS_OB_BOR(OB_BOR));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C08             CMP      R4,#+8
   \   00000008   0xD00D             BEQ.N    ??FLASH_OB_BORConfig_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C04             CMP      R4,#+4
   \   0000000E   0xD00A             BEQ.N    ??FLASH_OB_BORConfig_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD007             BEQ.N    ??FLASH_OB_BORConfig_0
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x2C0C             CMP      R4,#+12
   \   0000001A   0xD004             BEQ.N    ??FLASH_OB_BORConfig_0
   \   0000001C   0xF44F 0x7146      MOV      R1,#+792
   \   00000020   0x....             LDR.N    R0,??DataTable28
   \   00000022   0x.... 0x....      BL       assert_failed
    793          
    794            /* Set the BOR Level */
    795            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BOR_LEV);
   \                     ??FLASH_OB_BORConfig_0: (+1)
   \   00000026   0x....             LDR.N    R0,??DataTable28_9  ;; 0x40023c14
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0xF010 0x00F3      ANDS     R0,R0,#0xF3
   \   0000002E   0x....             LDR.N    R1,??DataTable28_9  ;; 0x40023c14
   \   00000030   0x7008             STRB     R0,[R1, #+0]
    796            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOR;
   \   00000032   0x....             LDR.N    R0,??DataTable28_9  ;; 0x40023c14
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0x4320             ORRS     R0,R4,R0
   \   00000038   0x....             LDR.N    R1,??DataTable28_9  ;; 0x40023c14
   \   0000003A   0x7008             STRB     R0,[R1, #+0]
    797          
    798          }
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
    799          
    800          /**
    801            * @brief  Launch the option byte loading.
    802            * @param  None
    803            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    804            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    805            */

   \                                 In section .text, align 2, keep-with-next
    806          FLASH_Status FLASH_OB_Launch(void)
    807          {
   \                     FLASH_OB_Launch: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    808            FLASH_Status status = FLASH_COMPLETE;
   \   00000002   0x2408             MOVS     R4,#+8
    809          
    810            /* Set the OPTSTRT bit in OPTCR register */
    811            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= FLASH_OPTCR_OPTSTRT;
   \   00000004   0x....             LDR.N    R0,??DataTable28_9  ;; 0x40023c14
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000000C   0x....             LDR.N    R1,??DataTable28_9  ;; 0x40023c14
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
    812          
    813            /* Wait for last operation to be completed */
    814            status = FLASH_WaitForLastOperation();
   \   00000010   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000014   0x0004             MOVS     R4,R0
    815          
    816            return status;
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    817          }
    818          
    819          /**
    820            * @brief  Returns the FLASH User Option Bytes values.
    821            * @param  None
    822            * @retval The FLASH User Option Bytes values: IWDG_SW(Bit0), RST_STOP(Bit1)
    823            *         and RST_STDBY(Bit2).
    824            */

   \                                 In section .text, align 2, keep-with-next
    825          uint8_t FLASH_OB_GetUser(void)
    826          {
    827            /* Return the User Option Byte */
    828            return (uint8_t)(FLASH->OPTCR >> 5);
   \                     FLASH_OB_GetUser: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable28_9  ;; 0x40023c14
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0940             LSRS     R0,R0,#+5
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x4770             BX       LR               ;; return
    829          }
    830          
    831          /**
    832            * @brief  Returns the FLASH Write Protection Option Bytes value.
    833            * @param  None
    834            * @retval The FLASH Write Protection  Option Bytes value
    835            */

   \                                 In section .text, align 2, keep-with-next
    836          uint16_t FLASH_OB_GetWRP(void)
    837          {
    838            /* Return the FLASH write protection Register value */
    839            return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
   \                     FLASH_OB_GetWRP: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable28_13  ;; 0x40023c16
   \   00000002   0x8800             LDRH     R0,[R0, #+0]
   \   00000004   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000006   0x4770             BX       LR               ;; return
    840          }
    841          
    842          /**
    843            * @brief  Returns the FLASH Read Protection level.
    844            * @param  None
    845            * @retval FLASH ReadOut Protection Status:
    846            *           - SET, when OB_RDP_Level_1 or OB_RDP_Level_2 is set
    847            *           - RESET, when OB_RDP_Level_0 is set
    848            */

   \                                 In section .text, align 2, keep-with-next
    849          FlagStatus FLASH_OB_GetRDP(void)
    850          {
    851            FlagStatus readstatus = RESET;
   \                     FLASH_OB_GetRDP: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
    852          
    853            if ((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS) != (uint8_t)OB_RDP_Level_0))
   \   00000002   0x....             LDR.N    R1,??DataTable28_14  ;; 0x40023c15
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0x29AA             CMP      R1,#+170
   \   0000000A   0xD002             BEQ.N    ??FLASH_OB_GetRDP_0
    854            {
    855              readstatus = SET;
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x0008             MOVS     R0,R1
   \   00000010   0xE001             B.N      ??FLASH_OB_GetRDP_1
    856            }
    857            else
    858            {
    859              readstatus = RESET;
   \                     ??FLASH_OB_GetRDP_0: (+1)
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x0008             MOVS     R0,R1
    860            }
    861            return readstatus;
   \                     ??FLASH_OB_GetRDP_1: (+1)
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x4770             BX       LR               ;; return
    862          }
    863          
    864          /**
    865            * @brief  Returns the FLASH BOR level.
    866            * @param  None
    867            * @retval The FLASH BOR level:
    868            *           - OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V
    869            *           - OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V
    870            *           - OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
    871            *           - OB_BOR_OFF   : Supply voltage ranges from 1.62 to 2.1 V  
    872            */

   \                                 In section .text, align 2, keep-with-next
    873          uint8_t FLASH_OB_GetBOR(void)
    874          {
    875            /* Return the FLASH BOR level */
    876            return (uint8_t)(*(__IO uint8_t *)(OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0C);
   \                     FLASH_OB_GetBOR: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable28_9  ;; 0x40023c14
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   00000008   0x4770             BX       LR               ;; return
    877          }
    878          
    879          /**
    880            * @}
    881            */
    882          
    883          /** @defgroup FLASH_Group4 Interrupts and flags management functions
    884           *  @brief   Interrupts and flags management functions
    885           *
    886          @verbatim   
    887           ===============================================================================
    888                            Interrupts and flags management functions
    889           ===============================================================================  
    890          
    891          @endverbatim
    892            * @{
    893            */
    894          
    895          /**
    896            * @brief  Enables or disables the specified FLASH interrupts.
    897            * @param  FLASH_IT: specifies the FLASH interrupt sources to be enabled or disabled.
    898            *          This parameter can be any combination of the following values:
    899            *            @arg FLASH_IT_ERR: FLASH Error Interrupt
    900            *            @arg FLASH_IT_EOP: FLASH end of operation Interrupt
    901            * @retval None 
    902            */

   \                                 In section .text, align 2, keep-with-next
    903          void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
    904          {
   \                     FLASH_ITConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    905            /* Check the parameters */
    906            assert_param(IS_FLASH_IT(FLASH_IT)); 
   \   00000006   0xF034 0x7040      BICS     R0,R4,#0x3000000
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??FLASH_ITConfig_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD104             BNE.N    ??FLASH_ITConfig_1
   \                     ??FLASH_ITConfig_0: (+1)
   \   00000012   0xF240 0x318A      MOVW     R1,#+906
   \   00000016   0x....             LDR.N    R0,??DataTable28
   \   00000018   0x.... 0x....      BL       assert_failed
    907            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??FLASH_ITConfig_1: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??FLASH_ITConfig_2
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD004             BEQ.N    ??FLASH_ITConfig_2
   \   00000028   0xF240 0x318B      MOVW     R1,#+907
   \   0000002C   0x....             LDR.N    R0,??DataTable28
   \   0000002E   0x.... 0x....      BL       assert_failed
    908          
    909            if(NewState != DISABLE)
   \                     ??FLASH_ITConfig_2: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD005             BEQ.N    ??FLASH_ITConfig_3
    910            {
    911              /* Enable the interrupt sources */
    912              FLASH->CR |= FLASH_IT;
   \   00000038   0x....             LDR.N    R0,??DataTable28_2  ;; 0x40023c10
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x4320             ORRS     R0,R4,R0
   \   0000003E   0x....             LDR.N    R1,??DataTable28_2  ;; 0x40023c10
   \   00000040   0x6008             STR      R0,[R1, #+0]
   \   00000042   0xE004             B.N      ??FLASH_ITConfig_4
    913            }
    914            else
    915            {
    916              /* Disable the interrupt sources */
    917              FLASH->CR &= ~(uint32_t)FLASH_IT;
   \                     ??FLASH_ITConfig_3: (+1)
   \   00000044   0x....             LDR.N    R0,??DataTable28_2  ;; 0x40023c10
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x43A0             BICS     R0,R0,R4
   \   0000004A   0x....             LDR.N    R1,??DataTable28_2  ;; 0x40023c10
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    918            }
    919          }
   \                     ??FLASH_ITConfig_4: (+1)
   \   0000004E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    920          
    921          /**
    922            * @brief  Checks whether the specified FLASH flag is set or not.
    923            * @param  FLASH_FLAG: specifies the FLASH flag to check.
    924            *          This parameter can be one of the following values:
    925            *            @arg FLASH_FLAG_EOP: FLASH End of Operation flag 
    926            *            @arg FLASH_FLAG_OPERR: FLASH operation Error flag 
    927            *            @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
    928            *            @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag
    929            *            @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
    930            *            @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
    931            *            @arg FLASH_FLAG_BSY: FLASH Busy flag
    932            * @retval The new state of FLASH_FLAG (SET or RESET).
    933            */

   \                                 In section .text, align 2, keep-with-next
    934          FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
    935          {
   \                     FLASH_GetFlagStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    936            FlagStatus bitstatus = RESET;
   \   00000004   0x2500             MOVS     R5,#+0
    937            /* Check the parameters */
    938            assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG));
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD011             BEQ.N    ??FLASH_GetFlagStatus_0
   \   0000000A   0x2C02             CMP      R4,#+2
   \   0000000C   0xD00F             BEQ.N    ??FLASH_GetFlagStatus_0
   \   0000000E   0x2C10             CMP      R4,#+16
   \   00000010   0xD00D             BEQ.N    ??FLASH_GetFlagStatus_0
   \   00000012   0x2C20             CMP      R4,#+32
   \   00000014   0xD00B             BEQ.N    ??FLASH_GetFlagStatus_0
   \   00000016   0x2C40             CMP      R4,#+64
   \   00000018   0xD009             BEQ.N    ??FLASH_GetFlagStatus_0
   \   0000001A   0x2C80             CMP      R4,#+128
   \   0000001C   0xD007             BEQ.N    ??FLASH_GetFlagStatus_0
   \   0000001E   0xF5B4 0x3F80      CMP      R4,#+65536
   \   00000022   0xD004             BEQ.N    ??FLASH_GetFlagStatus_0
   \   00000024   0xF240 0x31AA      MOVW     R1,#+938
   \   00000028   0x....             LDR.N    R0,??DataTable28
   \   0000002A   0x.... 0x....      BL       assert_failed
    939          
    940            if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
   \                     ??FLASH_GetFlagStatus_0: (+1)
   \   0000002E   0x....             LDR.N    R0,??DataTable28_15  ;; 0x40023c0c
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x4220             TST      R0,R4
   \   00000034   0xD002             BEQ.N    ??FLASH_GetFlagStatus_1
    941            {
    942              bitstatus = SET;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x0005             MOVS     R5,R0
   \   0000003A   0xE001             B.N      ??FLASH_GetFlagStatus_2
    943            }
    944            else
    945            {
    946              bitstatus = RESET;
   \                     ??FLASH_GetFlagStatus_1: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x0005             MOVS     R5,R0
    947            }
    948            /* Return the new state of FLASH_FLAG (SET or RESET) */
    949            return bitstatus; 
   \                     ??FLASH_GetFlagStatus_2: (+1)
   \   00000040   0x0028             MOVS     R0,R5
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    950          }
    951          
    952          /**
    953            * @brief  Clears the FLASH's pending flags.
    954            * @param  FLASH_FLAG: specifies the FLASH flags to clear.
    955            *          This parameter can be any combination of the following values:
    956            *            @arg FLASH_FLAG_EOP: FLASH End of Operation flag 
    957            *            @arg FLASH_FLAG_OPERR: FLASH operation Error flag 
    958            *            @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
    959            *            @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag 
    960            *            @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
    961            *            @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
    962            * @retval None
    963            */

   \                                 In section .text, align 2, keep-with-next
    964          void FLASH_ClearFlag(uint32_t FLASH_FLAG)
    965          {
   \                     FLASH_ClearFlag: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    966            /* Check the parameters */
    967            assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
   \   00000004   0xF034 0x00F3      BICS     R0,R4,#0xF3
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD101             BNE.N    ??FLASH_ClearFlag_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD104             BNE.N    ??FLASH_ClearFlag_1
   \                     ??FLASH_ClearFlag_0: (+1)
   \   00000010   0xF240 0x31C7      MOVW     R1,#+967
   \   00000014   0x....             LDR.N    R0,??DataTable28
   \   00000016   0x.... 0x....      BL       assert_failed
    968            
    969            /* Clear the flags */
    970            FLASH->SR = FLASH_FLAG;
   \                     ??FLASH_ClearFlag_1: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable28_15  ;; 0x40023c0c
   \   0000001C   0x6004             STR      R4,[R0, #+0]
    971          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    972          
    973          /**
    974            * @brief  Returns the FLASH Status.
    975            * @param  None
    976            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    977            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    978            */

   \                                 In section .text, align 2, keep-with-next
    979          FLASH_Status FLASH_GetStatus(void)
    980          {
    981            FLASH_Status flashstatus = FLASH_COMPLETE;
   \                     FLASH_GetStatus: (+1)
   \   00000000   0x2008             MOVS     R0,#+8
    982            
    983            if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
   \   00000002   0x....             LDR.N    R1,??DataTable28_15  ;; 0x40023c0c
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x03C9             LSLS     R1,R1,#+15
   \   00000008   0xD502             BPL.N    ??FLASH_GetStatus_0
    984            {
    985              flashstatus = FLASH_BUSY;
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x0008             MOVS     R0,R1
   \   0000000E   0xE017             B.N      ??FLASH_GetStatus_1
    986            }
    987            else 
    988            {  
    989              if((FLASH->SR & FLASH_FLAG_WRPERR) != (uint32_t)0x00)
   \                     ??FLASH_GetStatus_0: (+1)
   \   00000010   0x....             LDR.N    R1,??DataTable28_15  ;; 0x40023c0c
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0x06C9             LSLS     R1,R1,#+27
   \   00000016   0xD502             BPL.N    ??FLASH_GetStatus_2
    990              { 
    991                flashstatus = FLASH_ERROR_WRP;
   \   00000018   0x2105             MOVS     R1,#+5
   \   0000001A   0x0008             MOVS     R0,R1
   \   0000001C   0xE010             B.N      ??FLASH_GetStatus_1
    992              }
    993              else 
    994              {
    995                if((FLASH->SR & (uint32_t)0xEF) != (uint32_t)0x00)
   \                     ??FLASH_GetStatus_2: (+1)
   \   0000001E   0x....             LDR.N    R1,??DataTable28_15  ;; 0x40023c0c
   \   00000020   0x6809             LDR      R1,[R1, #+0]
   \   00000022   0xF011 0x0FEF      TST      R1,#0xEF
   \   00000026   0xD002             BEQ.N    ??FLASH_GetStatus_3
    996                {
    997                  flashstatus = FLASH_ERROR_PROGRAM; 
   \   00000028   0x2106             MOVS     R1,#+6
   \   0000002A   0x0008             MOVS     R0,R1
   \   0000002C   0xE008             B.N      ??FLASH_GetStatus_1
    998                }
    999                else
   1000                {
   1001                  if((FLASH->SR & FLASH_FLAG_OPERR) != (uint32_t)0x00)
   \                     ??FLASH_GetStatus_3: (+1)
   \   0000002E   0x....             LDR.N    R1,??DataTable28_15  ;; 0x40023c0c
   \   00000030   0x6809             LDR      R1,[R1, #+0]
   \   00000032   0x0789             LSLS     R1,R1,#+30
   \   00000034   0xD502             BPL.N    ??FLASH_GetStatus_4
   1002                  {
   1003                    flashstatus = FLASH_ERROR_OPERATION;
   \   00000036   0x2107             MOVS     R1,#+7
   \   00000038   0x0008             MOVS     R0,R1
   \   0000003A   0xE001             B.N      ??FLASH_GetStatus_1
   1004                  }
   1005                  else
   1006                  {
   1007                    flashstatus = FLASH_COMPLETE;
   \                     ??FLASH_GetStatus_4: (+1)
   \   0000003C   0x2108             MOVS     R1,#+8
   \   0000003E   0x0008             MOVS     R0,R1
   1008                  }
   1009                }
   1010              }
   1011            }
   1012            /* Return the FLASH Status */
   1013            return flashstatus;
   \                     ??FLASH_GetStatus_1: (+1)
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0x4770             BX       LR               ;; return
   1014          }
   1015          
   1016          /**
   1017            * @brief  Waits for a FLASH operation to complete.
   1018            * @param  None
   1019            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
   1020            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
   1021            */

   \                                 In section .text, align 2, keep-with-next
   1022          FLASH_Status FLASH_WaitForLastOperation(void)
   1023          { 
   \                     FLASH_WaitForLastOperation: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1024            __IO FLASH_Status status = FLASH_COMPLETE;
   \   00000002   0x2008             MOVS     R0,#+8
   \   00000004   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1025             
   1026            /* Check for the FLASH Status */
   1027            status = FLASH_GetStatus();
   \   00000008   0x.... 0x....      BL       FLASH_GetStatus
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1028          
   1029            /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
   1030               Even if the FLASH operation fails, the BUSY flag will be reset and an error
   1031               flag will be set */
   1032            while(status == FLASH_BUSY)
   \                     ??FLASH_WaitForLastOperation_0: (+1)
   \   00000010   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD104             BNE.N    ??FLASH_WaitForLastOperation_1
   1033            {
   1034              status = FLASH_GetStatus();
   \   00000018   0x.... 0x....      BL       FLASH_GetStatus
   \   0000001C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000020   0xE7F6             B.N      ??FLASH_WaitForLastOperation_0
   1035            }
   1036            /* Return the operation status */
   1037            return status;
   \                     ??FLASH_WaitForLastOperation_1: (+1)
   \   00000022   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000026   0xBD02             POP      {R1,PC}          ;; return
   1038          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \   00000000   0x40023C00         DC32     0x40023c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_2:
   \   00000000   0x40023C10         DC32     0x40023c10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_3:
   \   00000000   0x45670123         DC32     0x45670123

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_4:
   \   00000000   0x40023C04         DC32     0x40023c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_5:
   \   00000000   0xCDEF89AB         DC32     0xcdef89ab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_6:
   \   00000000   0x080FFFFF         DC32     0x80fffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_7:
   \   00000000   0x1FFF7800         DC32     0x1fff7800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_8:
   \   00000000   0x1FFF7A0F         DC32     0x1fff7a0f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_9:
   \   00000000   0x40023C14         DC32     0x40023c14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_10:
   \   00000000   0x08192A3B         DC32     0x8192a3b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_11:
   \   00000000   0x40023C08         DC32     0x40023c08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_12:
   \   00000000   0x4C5D6E7F         DC32     0x4c5d6e7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_13:
   \   00000000   0x40023C16         DC32     0x40023c16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_14:
   \   00000000   0x40023C15         DC32     0x40023c15

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_15:
   \   00000000   0x40023C0C         DC32     0x40023c0c

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 49H, 41H, 52H, 20H, 57H
   \              0x5C 0x49    
   \              0x41 0x52    
   \              0x20 0x57    
   \   00000008   0x6F 0x72          DC8 6FH, 72H, 6BH, 73H, 70H, 61H, 63H, 65H
   \              0x6B 0x73    
   \              0x70 0x61    
   \              0x63 0x65    
   \   00000010   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 46H, 34H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x46 0x34    
   \   00000018   0x30 0x37          DC8 30H, 37H, 5CH, 53H, 54H, 4DH, 33H, 32H
   \              0x5C 0x53    
   \              0x54 0x4D    
   \              0x33 0x32    
   \   00000020   0x46 0x34          DC8 46H, 34H, 2DH, 44H, 69H, 73H, 63H, 6FH
   \              0x2D 0x44    
   \              0x69 0x73    
   \              0x63 0x6F    
   \   00000028   0x76 0x65          DC8 76H, 65H, 72H, 79H, 5FH, 46H, 57H, 5FH
   \              0x72 0x79    
   \              0x5F 0x46    
   \              0x57 0x5F    
   \   00000030   0x56 0x31          DC8 56H, 31H, 2EH, 31H, 2EH, 30H, 5CH, 4CH
   \              0x2E 0x31    
   \              0x2E 0x30    
   \              0x5C 0x4C    
   \   00000038   0x69 0x62          DC8 69H, 62H, 72H, 61H, 72H, 69H, 65H, 73H
   \              0x72 0x61    
   \              0x72 0x69    
   \              0x65 0x73    
   \   00000040   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 46H, 34H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x46 0x34    
   \   00000048   0x78 0x78          DC8 78H, 78H, 5FH, 53H, 74H, 64H, 50H, 65H
   \              0x5F 0x53    
   \              0x74 0x64    
   \              0x50 0x65    
   \   00000050   0x72 0x69          DC8 72H, 69H, 70H, 68H, 5FH, 44H, 72H, 69H
   \              0x70 0x68    
   \              0x5F 0x44    
   \              0x72 0x69    
   \   00000058   0x76 0x65          DC8 76H, 65H, 72H, 5CH, 73H, 72H, 63H, 5CH
   \              0x72 0x5C    
   \              0x73 0x72    
   \              0x63 0x5C    
   \   00000060   0x73 0x74          DC8 73H, 74H, 6DH, 33H, 32H, 66H, 34H, 78H
   \              0x6D 0x33    
   \              0x32 0x66    
   \              0x34 0x78    
   \   00000068   0x78 0x5F          DC8 78H, 5FH, 66H, 6CH, 61H, 73H, 68H, 2EH
   \              0x66 0x6C    
   \              0x61 0x73    
   \              0x68 0x2E    
   \   00000070   0x63 0x00          DC8 63H, 0
   \   00000072   0x00 0x00          DC8 0, 0
   1039          
   1040          /**
   1041            * @}
   1042            */ 
   1043          
   1044          /**
   1045            * @}
   1046            */ 
   1047          
   1048          /**
   1049            * @}
   1050            */ 
   1051          
   1052          /**
   1053            * @}
   1054            */
   1055          
   1056          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   FLASH_ClearFlag
         8   -> assert_failed
       8   FLASH_DataCacheCmd
         8   -> assert_failed
       0   FLASH_DataCacheReset
      16   FLASH_EraseAllSectors
        16   -> FLASH_WaitForLastOperation
        16   -> assert_failed
      24   FLASH_EraseSector
        24   -> FLASH_WaitForLastOperation
        24   -> assert_failed
      16   FLASH_GetFlagStatus
        16   -> assert_failed
       0   FLASH_GetStatus
      16   FLASH_ITConfig
        16   -> assert_failed
       8   FLASH_InstructionCacheCmd
         8   -> assert_failed
       0   FLASH_InstructionCacheReset
       0   FLASH_Lock
       8   FLASH_OB_BORConfig
         8   -> assert_failed
       0   FLASH_OB_GetBOR
       0   FLASH_OB_GetRDP
       0   FLASH_OB_GetUser
       0   FLASH_OB_GetWRP
       8   FLASH_OB_Launch
         8   -> FLASH_WaitForLastOperation
       0   FLASH_OB_Lock
      16   FLASH_OB_RDPConfig
        16   -> FLASH_WaitForLastOperation
        16   -> assert_failed
       0   FLASH_OB_Unlock
      24   FLASH_OB_UserConfig
        24   -> FLASH_WaitForLastOperation
        24   -> assert_failed
      16   FLASH_OB_WRPConfig
        16   -> FLASH_WaitForLastOperation
        16   -> assert_failed
       8   FLASH_PrefetchBufferCmd
         8   -> assert_failed
      16   FLASH_ProgramByte
        16   -> FLASH_WaitForLastOperation
        16   -> assert_failed
      24   FLASH_ProgramDoubleWord
        24   -> FLASH_WaitForLastOperation
        24   -> assert_failed
      16   FLASH_ProgramHalfWord
        16   -> FLASH_WaitForLastOperation
        16   -> assert_failed
      16   FLASH_ProgramWord
        16   -> FLASH_WaitForLastOperation
        16   -> assert_failed
       8   FLASH_SetLatency
         8   -> assert_failed
       0   FLASH_Unlock
       8   FLASH_WaitForLastOperation
         8   -> FLASH_GetStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_10
       4  ??DataTable28_11
       4  ??DataTable28_12
       4  ??DataTable28_13
       4  ??DataTable28_14
       4  ??DataTable28_15
       4  ??DataTable28_2
       4  ??DataTable28_3
       4  ??DataTable28_4
       4  ??DataTable28_5
       4  ??DataTable28_6
       4  ??DataTable28_7
       4  ??DataTable28_8
       4  ??DataTable28_9
     116  ?_0
      32  FLASH_ClearFlag
      68  FLASH_DataCacheCmd
      18  FLASH_DataCacheReset
     192  FLASH_EraseAllSectors
     288  FLASH_EraseSector
      70  FLASH_GetFlagStatus
      68  FLASH_GetStatus
      80  FLASH_ITConfig
      68  FLASH_InstructionCacheCmd
      18  FLASH_InstructionCacheReset
      18  FLASH_Lock
      62  FLASH_OB_BORConfig
      10  FLASH_OB_GetBOR
      26  FLASH_OB_GetRDP
      10  FLASH_OB_GetUser
       8  FLASH_OB_GetWRP
      28  FLASH_OB_Launch
      14  FLASH_OB_Lock
      46  FLASH_OB_RDPConfig
      22  FLASH_OB_Unlock
     124  FLASH_OB_UserConfig
      94  FLASH_OB_WRPConfig
      68  FLASH_PrefetchBufferCmd
     118  FLASH_ProgramByte
     144  FLASH_ProgramDoubleWord
     140  FLASH_ProgramHalfWord
     140  FLASH_ProgramWord
      54  FLASH_SetLatency
      32  FLASH_Unlock
      40  FLASH_WaitForLastOperation

 
   116 bytes in section .rodata
 2 164 bytes in section .text
 
 2 164 bytes of CODE  memory
   116 bytes of CONST memory

Errors: none
Warnings: none
