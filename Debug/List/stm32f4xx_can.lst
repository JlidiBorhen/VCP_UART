###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       06/May/2016  23:31:30
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\IAR
#        Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_can.c
#    Command line =  
#        "D:\IAR
#        Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_can.c"
#        -D USE_STDPERIPH_DRIVER -D STM32F4XX -D USE_FULL_ASSERT -lCN "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\List" -o "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\Obj" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\Include\" -I
#        "D:\IAR Workspace\STM32F407\VCP_ESP\..\Utilities\STM32F4-Discovery\"
#        -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\ST\STM32F4xx\Include\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_conf\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\cdc\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\otg\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\core\" -On --use_c++_inline -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    List file    =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\Debug\List\stm32f4xx_can.lst
#    Object file  =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\Debug\Obj\stm32f4xx_can.o
#
###############################################################################

D:\IAR Workspace\STM32F407\STM32F4-Discovery_FW_V1.1.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_can.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_can.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    30-September-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Controller area network (CAN) peripheral:           
      9            *           - Initialization and Configuration 
     10            *           - CAN Frames Transmission 
     11            *           - CAN Frames Reception    
     12            *           - Operation modes switch  
     13            *           - Error management          
     14            *           - Interrupts and flags        
     15            *         
     16            *  @verbatim
     17            *                               
     18            *          ===================================================================      
     19            *                                   How to use this driver
     20            *          ===================================================================
     21                          
     22            *          1.  Enable the CAN controller interface clock using 
     23            *                  RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1, ENABLE); for CAN1 
     24            *              and RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN2, ENABLE); for CAN2
     25            *  @note   In case you are using CAN2 only, you have to enable the CAN1 clock.
     26            *     
     27            *          2. CAN pins configuration
     28            *               - Enable the clock for the CAN GPIOs using the following function:
     29            *                   RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);   
     30            *               - Connect the involved CAN pins to AF9 using the following function 
     31            *                   GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_CANx); 
     32            *                - Configure these CAN pins in alternate function mode by calling
     33            *                  the function  GPIO_Init();
     34            *    
     35            *          3.  Initialise and configure the CAN using CAN_Init() and 
     36            *               CAN_FilterInit() functions.   
     37            *               
     38            *          4.  Transmit the desired CAN frame using CAN_Transmit() function.
     39            *         
     40            *          5.  Check the transmission of a CAN frame using CAN_TransmitStatus()
     41            *              function.
     42            *               
     43            *          6.  Cancel the transmission of a CAN frame using CAN_CancelTransmit()
     44            *              function.  
     45            *            
     46            *          7.  Receive a CAN frame using CAN_Recieve() function.
     47            *         
     48            *          8.  Release the receive FIFOs using CAN_FIFORelease() function.
     49            *               
     50            *          9. Return the number of pending received frames using 
     51            *              CAN_MessagePending() function.            
     52            *                   
     53            *          10. To control CAN events you can use one of the following two methods:
     54            *               - Check on CAN flags using the CAN_GetFlagStatus() function.  
     55            *               - Use CAN interrupts through the function CAN_ITConfig() at 
     56            *                 initialization phase and CAN_GetITStatus() function into 
     57            *                 interrupt routines to check if the event has occurred or not.
     58            *             After checking on a flag you should clear it using CAN_ClearFlag()
     59            *             function. And after checking on an interrupt event you should 
     60            *             clear it using CAN_ClearITPendingBit() function.            
     61            *               
     62            *              
     63            *  @endverbatim
     64            *         
     65            ******************************************************************************
     66            * @attention
     67            *
     68            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     69            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     70            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     71            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     72            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     73            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     74            *
     75            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     76            ******************************************************************************  
     77            */
     78          
     79          /* Includes ------------------------------------------------------------------*/
     80          #include "stm32f4xx_can.h"
     81          #include "stm32f4xx_rcc.h"
     82          
     83          /** @addtogroup STM32F4xx_StdPeriph_Driver
     84            * @{
     85            */
     86          
     87          /** @defgroup CAN 
     88            * @brief CAN driver modules
     89            * @{
     90            */ 
     91          /* Private typedef -----------------------------------------------------------*/
     92          /* Private define ------------------------------------------------------------*/
     93          
     94          /* CAN Master Control Register bits */
     95          #define MCR_DBF           ((uint32_t)0x00010000) /* software master reset */
     96          
     97          /* CAN Mailbox Transmit Request */
     98          #define TMIDxR_TXRQ       ((uint32_t)0x00000001) /* Transmit mailbox request */
     99          
    100          /* CAN Filter Master Register bits */
    101          #define FMR_FINIT         ((uint32_t)0x00000001) /* Filter init mode */
    102          
    103          /* Time out for INAK bit */
    104          #define INAK_TIMEOUT      ((uint32_t)0x0000FFFF)
    105          /* Time out for SLAK bit */
    106          #define SLAK_TIMEOUT      ((uint32_t)0x0000FFFF)
    107          
    108          /* Flags in TSR register */
    109          #define CAN_FLAGS_TSR     ((uint32_t)0x08000000) 
    110          /* Flags in RF1R register */
    111          #define CAN_FLAGS_RF1R    ((uint32_t)0x04000000) 
    112          /* Flags in RF0R register */
    113          #define CAN_FLAGS_RF0R    ((uint32_t)0x02000000) 
    114          /* Flags in MSR register */
    115          #define CAN_FLAGS_MSR     ((uint32_t)0x01000000) 
    116          /* Flags in ESR register */
    117          #define CAN_FLAGS_ESR     ((uint32_t)0x00F00000) 
    118          
    119          /* Mailboxes definition */
    120          #define CAN_TXMAILBOX_0   ((uint8_t)0x00)
    121          #define CAN_TXMAILBOX_1   ((uint8_t)0x01)
    122          #define CAN_TXMAILBOX_2   ((uint8_t)0x02) 
    123          
    124          #define CAN_MODE_MASK     ((uint32_t) 0x00000003)
    125          
    126          /* Private macro -------------------------------------------------------------*/
    127          /* Private variables ---------------------------------------------------------*/
    128          /* Private function prototypes -----------------------------------------------*/
    129          /* Private functions ---------------------------------------------------------*/
    130          static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit);
    131          
    132          /** @defgroup CAN_Private_Functions
    133            * @{
    134            */
    135          
    136          /** @defgroup CAN_Group1 Initialization and Configuration functions
    137           *  @brief    Initialization and Configuration functions 
    138           *
    139          @verbatim    
    140           ===============================================================================
    141                                Initialization and Configuration functions
    142           ===============================================================================  
    143            This section provides functions allowing to 
    144             - Initialize the CAN peripherals : Prescaler, operating mode, the maximum number 
    145               of time quanta to perform resynchronization, the number of time quanta in
    146               Bit Segment 1 and 2 and many other modes. 
    147               Refer to  @ref CAN_InitTypeDef  for more details.
    148             - Configures the CAN reception filter.                                      
    149             - Select the start bank filter for slave CAN.
    150             - Enables or disables the Debug Freeze mode for CAN
    151             - Enables or disables the CAN Time Trigger Operation communication mode
    152             
    153          @endverbatim
    154            * @{
    155            */
    156            
    157          /**
    158            * @brief  Deinitializes the CAN peripheral registers to their default reset values.
    159            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    160            * @retval None.
    161            */

   \                                 In section .text, align 2, keep-with-next
    162          void CAN_DeInit(CAN_TypeDef* CANx)
    163          {
   \                     CAN_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    164            /* Check the parameters */
    165            assert_param(IS_CAN_ALL_PERIPH(CANx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40006400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD008             BEQ.N    ??CAN_DeInit_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40006800
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD004             BEQ.N    ??CAN_DeInit_0
   \   00000014   0x21A5             MOVS     R1,#+165
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   0000001A   0x.... 0x....      BL       assert_failed
    166           
    167            if (CANx == CAN1)
   \                     ??CAN_DeInit_0: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40006400
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD10A             BNE.N    ??CAN_DeInit_1
    168            {
    169              /* Enable CAN1 reset state */
    170              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0xF05F 0x7000      MOVS     R0,#+33554432
   \   0000002C   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    171              /* Release CAN1 from reset state */
    172              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0xF05F 0x7000      MOVS     R0,#+33554432
   \   00000036   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \   0000003A   0xE009             B.N      ??CAN_DeInit_2
    173            }
    174            else
    175            {  
    176              /* Enable CAN2 reset state */
    177              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
   \                     ??CAN_DeInit_1: (+1)
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0xF05F 0x6080      MOVS     R0,#+67108864
   \   00000042   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    178              /* Release CAN2 from reset state */
    179              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0xF05F 0x6080      MOVS     R0,#+67108864
   \   0000004C   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    180            }
    181          }
   \                     ??CAN_DeInit_2: (+1)
   \   00000050   0xBD10             POP      {R4,PC}          ;; return
    182          
    183          /**
    184            * @brief  Initializes the CAN peripheral according to the specified
    185            *         parameters in the CAN_InitStruct.
    186            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    187            * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure that contains
    188            *         the configuration information for the CAN peripheral.
    189            * @retval Constant indicates initialization succeed which will be 
    190            *         CAN_InitStatus_Failed or CAN_InitStatus_Success.
    191            */

   \                                 In section .text, align 2, keep-with-next
    192          uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
    193          {
   \                     CAN_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    194            uint8_t InitStatus = CAN_InitStatus_Failed;
   \   00000006   0x2600             MOVS     R6,#+0
    195            uint32_t wait_ack = 0x00000000;
   \   00000008   0x2700             MOVS     R7,#+0
    196            /* Check the parameters */
    197            assert_param(IS_CAN_ALL_PERIPH(CANx));
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40006400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD008             BEQ.N    ??CAN_Init_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40006800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD004             BEQ.N    ??CAN_Init_0
   \   0000001A   0x21C5             MOVS     R1,#+197
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000020   0x.... 0x....      BL       assert_failed
    198            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
   \                     ??CAN_Init_0: (+1)
   \   00000024   0x79A8             LDRB     R0,[R5, #+6]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD007             BEQ.N    ??CAN_Init_1
   \   0000002A   0x79A8             LDRB     R0,[R5, #+6]
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD004             BEQ.N    ??CAN_Init_1
   \   00000030   0x21C6             MOVS     R1,#+198
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000036   0x.... 0x....      BL       assert_failed
    199            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
   \                     ??CAN_Init_1: (+1)
   \   0000003A   0x79E8             LDRB     R0,[R5, #+7]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD007             BEQ.N    ??CAN_Init_2
   \   00000040   0x79E8             LDRB     R0,[R5, #+7]
   \   00000042   0x2801             CMP      R0,#+1
   \   00000044   0xD004             BEQ.N    ??CAN_Init_2
   \   00000046   0x21C7             MOVS     R1,#+199
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   0000004C   0x.... 0x....      BL       assert_failed
    200            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
   \                     ??CAN_Init_2: (+1)
   \   00000050   0x7A28             LDRB     R0,[R5, #+8]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD007             BEQ.N    ??CAN_Init_3
   \   00000056   0x7A28             LDRB     R0,[R5, #+8]
   \   00000058   0x2801             CMP      R0,#+1
   \   0000005A   0xD004             BEQ.N    ??CAN_Init_3
   \   0000005C   0x21C8             MOVS     R1,#+200
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000062   0x.... 0x....      BL       assert_failed
    201            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
   \                     ??CAN_Init_3: (+1)
   \   00000066   0x7A68             LDRB     R0,[R5, #+9]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD007             BEQ.N    ??CAN_Init_4
   \   0000006C   0x7A68             LDRB     R0,[R5, #+9]
   \   0000006E   0x2801             CMP      R0,#+1
   \   00000070   0xD004             BEQ.N    ??CAN_Init_4
   \   00000072   0x21C9             MOVS     R1,#+201
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000078   0x.... 0x....      BL       assert_failed
    202            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
   \                     ??CAN_Init_4: (+1)
   \   0000007C   0x7AA8             LDRB     R0,[R5, #+10]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD007             BEQ.N    ??CAN_Init_5
   \   00000082   0x7AA8             LDRB     R0,[R5, #+10]
   \   00000084   0x2801             CMP      R0,#+1
   \   00000086   0xD004             BEQ.N    ??CAN_Init_5
   \   00000088   0x21CA             MOVS     R1,#+202
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   0000008E   0x.... 0x....      BL       assert_failed
    203            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
   \                     ??CAN_Init_5: (+1)
   \   00000092   0x7AE8             LDRB     R0,[R5, #+11]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD007             BEQ.N    ??CAN_Init_6
   \   00000098   0x7AE8             LDRB     R0,[R5, #+11]
   \   0000009A   0x2801             CMP      R0,#+1
   \   0000009C   0xD004             BEQ.N    ??CAN_Init_6
   \   0000009E   0x21CB             MOVS     R1,#+203
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   000000A4   0x.... 0x....      BL       assert_failed
    204            assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
   \                     ??CAN_Init_6: (+1)
   \   000000A8   0x78A8             LDRB     R0,[R5, #+2]
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD00D             BEQ.N    ??CAN_Init_7
   \   000000AE   0x78A8             LDRB     R0,[R5, #+2]
   \   000000B0   0x2801             CMP      R0,#+1
   \   000000B2   0xD00A             BEQ.N    ??CAN_Init_7
   \   000000B4   0x78A8             LDRB     R0,[R5, #+2]
   \   000000B6   0x2802             CMP      R0,#+2
   \   000000B8   0xD007             BEQ.N    ??CAN_Init_7
   \   000000BA   0x78A8             LDRB     R0,[R5, #+2]
   \   000000BC   0x2803             CMP      R0,#+3
   \   000000BE   0xD004             BEQ.N    ??CAN_Init_7
   \   000000C0   0x21CC             MOVS     R1,#+204
   \   000000C2   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   000000C6   0x.... 0x....      BL       assert_failed
    205            assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
   \                     ??CAN_Init_7: (+1)
   \   000000CA   0x78E8             LDRB     R0,[R5, #+3]
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD00D             BEQ.N    ??CAN_Init_8
   \   000000D0   0x78E8             LDRB     R0,[R5, #+3]
   \   000000D2   0x2801             CMP      R0,#+1
   \   000000D4   0xD00A             BEQ.N    ??CAN_Init_8
   \   000000D6   0x78E8             LDRB     R0,[R5, #+3]
   \   000000D8   0x2802             CMP      R0,#+2
   \   000000DA   0xD007             BEQ.N    ??CAN_Init_8
   \   000000DC   0x78E8             LDRB     R0,[R5, #+3]
   \   000000DE   0x2803             CMP      R0,#+3
   \   000000E0   0xD004             BEQ.N    ??CAN_Init_8
   \   000000E2   0x21CD             MOVS     R1,#+205
   \   000000E4   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   000000E8   0x.... 0x....      BL       assert_failed
    206            assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
   \                     ??CAN_Init_8: (+1)
   \   000000EC   0x7928             LDRB     R0,[R5, #+4]
   \   000000EE   0x2810             CMP      R0,#+16
   \   000000F0   0xDB04             BLT.N    ??CAN_Init_9
   \   000000F2   0x21CE             MOVS     R1,#+206
   \   000000F4   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   000000F8   0x.... 0x....      BL       assert_failed
    207            assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
   \                     ??CAN_Init_9: (+1)
   \   000000FC   0x7968             LDRB     R0,[R5, #+5]
   \   000000FE   0x2808             CMP      R0,#+8
   \   00000100   0xDB04             BLT.N    ??CAN_Init_10
   \   00000102   0x21CF             MOVS     R1,#+207
   \   00000104   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000108   0x.... 0x....      BL       assert_failed
    208            assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
   \                     ??CAN_Init_10: (+1)
   \   0000010C   0x8828             LDRH     R0,[R5, #+0]
   \   0000010E   0x2800             CMP      R0,#+0
   \   00000110   0xD003             BEQ.N    ??CAN_Init_11
   \   00000112   0x8828             LDRH     R0,[R5, #+0]
   \   00000114   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000118   0xDD04             BLE.N    ??CAN_Init_12
   \                     ??CAN_Init_11: (+1)
   \   0000011A   0x21D0             MOVS     R1,#+208
   \   0000011C   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000120   0x.... 0x....      BL       assert_failed
    209          
    210            /* Exit from sleep mode */
    211            CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
   \                     ??CAN_Init_12: (+1)
   \   00000124   0x6820             LDR      R0,[R4, #+0]
   \   00000126   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000012A   0x6020             STR      R0,[R4, #+0]
    212          
    213            /* Request initialisation */
    214            CANx->MCR |= CAN_MCR_INRQ ;
   \   0000012C   0x6820             LDR      R0,[R4, #+0]
   \   0000012E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000132   0x6020             STR      R0,[R4, #+0]
    215          
    216            /* Wait the acknowledge */
    217            while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
   \                     ??CAN_Init_13: (+1)
   \   00000134   0x6860             LDR      R0,[R4, #+4]
   \   00000136   0x07C0             LSLS     R0,R0,#+31
   \   00000138   0xD405             BMI.N    ??CAN_Init_14
   \   0000013A   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000013E   0x4287             CMP      R7,R0
   \   00000140   0xD001             BEQ.N    ??CAN_Init_14
    218            {
    219              wait_ack++;
   \   00000142   0x1C7F             ADDS     R7,R7,#+1
   \   00000144   0xE7F6             B.N      ??CAN_Init_13
    220            }
    221          
    222            /* Check acknowledge */
    223            if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
   \                     ??CAN_Init_14: (+1)
   \   00000146   0x6860             LDR      R0,[R4, #+4]
   \   00000148   0x07C0             LSLS     R0,R0,#+31
   \   0000014A   0xD402             BMI.N    ??CAN_Init_15
    224            {
    225              InitStatus = CAN_InitStatus_Failed;
   \   0000014C   0x2000             MOVS     R0,#+0
   \   0000014E   0x0006             MOVS     R6,R0
   \   00000150   0xE06D             B.N      ??CAN_Init_16
    226            }
    227            else 
    228            {
    229              /* Set the time triggered communication mode */
    230              if (CAN_InitStruct->CAN_TTCM == ENABLE)
   \                     ??CAN_Init_15: (+1)
   \   00000152   0x79A8             LDRB     R0,[R5, #+6]
   \   00000154   0x2801             CMP      R0,#+1
   \   00000156   0xD104             BNE.N    ??CAN_Init_17
    231              {
    232                CANx->MCR |= CAN_MCR_TTCM;
   \   00000158   0x6820             LDR      R0,[R4, #+0]
   \   0000015A   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000015E   0x6020             STR      R0,[R4, #+0]
   \   00000160   0xE003             B.N      ??CAN_Init_18
    233              }
    234              else
    235              {
    236                CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
   \                     ??CAN_Init_17: (+1)
   \   00000162   0x6820             LDR      R0,[R4, #+0]
   \   00000164   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000168   0x6020             STR      R0,[R4, #+0]
    237              }
    238          
    239              /* Set the automatic bus-off management */
    240              if (CAN_InitStruct->CAN_ABOM == ENABLE)
   \                     ??CAN_Init_18: (+1)
   \   0000016A   0x79E8             LDRB     R0,[R5, #+7]
   \   0000016C   0x2801             CMP      R0,#+1
   \   0000016E   0xD104             BNE.N    ??CAN_Init_19
    241              {
    242                CANx->MCR |= CAN_MCR_ABOM;
   \   00000170   0x6820             LDR      R0,[R4, #+0]
   \   00000172   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000176   0x6020             STR      R0,[R4, #+0]
   \   00000178   0xE003             B.N      ??CAN_Init_20
    243              }
    244              else
    245              {
    246                CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
   \                     ??CAN_Init_19: (+1)
   \   0000017A   0x6820             LDR      R0,[R4, #+0]
   \   0000017C   0xF030 0x0040      BICS     R0,R0,#0x40
   \   00000180   0x6020             STR      R0,[R4, #+0]
    247              }
    248          
    249              /* Set the automatic wake-up mode */
    250              if (CAN_InitStruct->CAN_AWUM == ENABLE)
   \                     ??CAN_Init_20: (+1)
   \   00000182   0x7A28             LDRB     R0,[R5, #+8]
   \   00000184   0x2801             CMP      R0,#+1
   \   00000186   0xD104             BNE.N    ??CAN_Init_21
    251              {
    252                CANx->MCR |= CAN_MCR_AWUM;
   \   00000188   0x6820             LDR      R0,[R4, #+0]
   \   0000018A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000018E   0x6020             STR      R0,[R4, #+0]
   \   00000190   0xE003             B.N      ??CAN_Init_22
    253              }
    254              else
    255              {
    256                CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
   \                     ??CAN_Init_21: (+1)
   \   00000192   0x6820             LDR      R0,[R4, #+0]
   \   00000194   0xF030 0x0020      BICS     R0,R0,#0x20
   \   00000198   0x6020             STR      R0,[R4, #+0]
    257              }
    258          
    259              /* Set the no automatic retransmission */
    260              if (CAN_InitStruct->CAN_NART == ENABLE)
   \                     ??CAN_Init_22: (+1)
   \   0000019A   0x7A68             LDRB     R0,[R5, #+9]
   \   0000019C   0x2801             CMP      R0,#+1
   \   0000019E   0xD104             BNE.N    ??CAN_Init_23
    261              {
    262                CANx->MCR |= CAN_MCR_NART;
   \   000001A0   0x6820             LDR      R0,[R4, #+0]
   \   000001A2   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   000001A6   0x6020             STR      R0,[R4, #+0]
   \   000001A8   0xE003             B.N      ??CAN_Init_24
    263              }
    264              else
    265              {
    266                CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
   \                     ??CAN_Init_23: (+1)
   \   000001AA   0x6820             LDR      R0,[R4, #+0]
   \   000001AC   0xF030 0x0010      BICS     R0,R0,#0x10
   \   000001B0   0x6020             STR      R0,[R4, #+0]
    267              }
    268          
    269              /* Set the receive FIFO locked mode */
    270              if (CAN_InitStruct->CAN_RFLM == ENABLE)
   \                     ??CAN_Init_24: (+1)
   \   000001B2   0x7AA8             LDRB     R0,[R5, #+10]
   \   000001B4   0x2801             CMP      R0,#+1
   \   000001B6   0xD104             BNE.N    ??CAN_Init_25
    271              {
    272                CANx->MCR |= CAN_MCR_RFLM;
   \   000001B8   0x6820             LDR      R0,[R4, #+0]
   \   000001BA   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   000001BE   0x6020             STR      R0,[R4, #+0]
   \   000001C0   0xE003             B.N      ??CAN_Init_26
    273              }
    274              else
    275              {
    276                CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
   \                     ??CAN_Init_25: (+1)
   \   000001C2   0x6820             LDR      R0,[R4, #+0]
   \   000001C4   0xF030 0x0008      BICS     R0,R0,#0x8
   \   000001C8   0x6020             STR      R0,[R4, #+0]
    277              }
    278          
    279              /* Set the transmit FIFO priority */
    280              if (CAN_InitStruct->CAN_TXFP == ENABLE)
   \                     ??CAN_Init_26: (+1)
   \   000001CA   0x7AE8             LDRB     R0,[R5, #+11]
   \   000001CC   0x2801             CMP      R0,#+1
   \   000001CE   0xD104             BNE.N    ??CAN_Init_27
    281              {
    282                CANx->MCR |= CAN_MCR_TXFP;
   \   000001D0   0x6820             LDR      R0,[R4, #+0]
   \   000001D2   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   000001D6   0x6020             STR      R0,[R4, #+0]
   \   000001D8   0xE003             B.N      ??CAN_Init_28
    283              }
    284              else
    285              {
    286                CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
   \                     ??CAN_Init_27: (+1)
   \   000001DA   0x6820             LDR      R0,[R4, #+0]
   \   000001DC   0xF030 0x0004      BICS     R0,R0,#0x4
   \   000001E0   0x6020             STR      R0,[R4, #+0]
    287              }
    288          
    289              /* Set the bit timing register */
    290              CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
    291                          ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
    292                          ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
    293                          ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
    294                         ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
   \                     ??CAN_Init_28: (+1)
   \   000001E2   0x78A8             LDRB     R0,[R5, #+2]
   \   000001E4   0x78E9             LDRB     R1,[R5, #+3]
   \   000001E6   0x0609             LSLS     R1,R1,#+24
   \   000001E8   0xEA51 0x7080      ORRS     R0,R1,R0, LSL #+30
   \   000001EC   0x7929             LDRB     R1,[R5, #+4]
   \   000001EE   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   000001F2   0x7969             LDRB     R1,[R5, #+5]
   \   000001F4   0xEA50 0x5001      ORRS     R0,R0,R1, LSL #+20
   \   000001F8   0x8829             LDRH     R1,[R5, #+0]
   \   000001FA   0x1E49             SUBS     R1,R1,#+1
   \   000001FC   0x4308             ORRS     R0,R1,R0
   \   000001FE   0x61E0             STR      R0,[R4, #+28]
    295          
    296              /* Request leave initialisation */
    297              CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
   \   00000200   0x6820             LDR      R0,[R4, #+0]
   \   00000202   0x0840             LSRS     R0,R0,#+1
   \   00000204   0x0040             LSLS     R0,R0,#+1
   \   00000206   0x6020             STR      R0,[R4, #+0]
    298          
    299             /* Wait the acknowledge */
    300             wait_ack = 0;
   \   00000208   0x2000             MOVS     R0,#+0
   \   0000020A   0x0007             MOVS     R7,R0
    301          
    302             while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
   \                     ??CAN_Init_29: (+1)
   \   0000020C   0x6860             LDR      R0,[R4, #+4]
   \   0000020E   0x07C0             LSLS     R0,R0,#+31
   \   00000210   0xD505             BPL.N    ??CAN_Init_30
   \   00000212   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000216   0x4287             CMP      R7,R0
   \   00000218   0xD001             BEQ.N    ??CAN_Init_30
    303             {
    304               wait_ack++;
   \   0000021A   0x1C7F             ADDS     R7,R7,#+1
   \   0000021C   0xE7F6             B.N      ??CAN_Init_29
    305             }
    306          
    307              /* ...and check acknowledged */
    308              if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
   \                     ??CAN_Init_30: (+1)
   \   0000021E   0x6860             LDR      R0,[R4, #+4]
   \   00000220   0x07C0             LSLS     R0,R0,#+31
   \   00000222   0xD502             BPL.N    ??CAN_Init_31
    309              {
    310                InitStatus = CAN_InitStatus_Failed;
   \   00000224   0x2000             MOVS     R0,#+0
   \   00000226   0x0006             MOVS     R6,R0
   \   00000228   0xE001             B.N      ??CAN_Init_16
    311              }
    312              else
    313              {
    314                InitStatus = CAN_InitStatus_Success ;
   \                     ??CAN_Init_31: (+1)
   \   0000022A   0x2001             MOVS     R0,#+1
   \   0000022C   0x0006             MOVS     R6,R0
    315              }
    316            }
    317          
    318            /* At this step, return the status of initialization */
    319            return InitStatus;
   \                     ??CAN_Init_16: (+1)
   \   0000022E   0x0030             MOVS     R0,R6
   \   00000230   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000232   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    320          }
    321          
    322          /**
    323            * @brief  Configures the CAN reception filter according to the specified
    324            *         parameters in the CAN_FilterInitStruct.
    325            * @param  CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef structure that
    326            *         contains the configuration information.
    327            * @retval None
    328            */

   \                                 In section .text, align 2, keep-with-next
    329          void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
    330          {
   \                     CAN_FilterInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    331            uint32_t filter_number_bit_pos = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    332            /* Check the parameters */
    333            assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
   \   00000006   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000008   0x281C             CMP      R0,#+28
   \   0000000A   0xDB05             BLT.N    ??CAN_FilterInit_0
   \   0000000C   0xF240 0x114D      MOVW     R1,#+333
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000014   0x.... 0x....      BL       assert_failed
    334            assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
   \                     ??CAN_FilterInit_0: (+1)
   \   00000018   0x7AE0             LDRB     R0,[R4, #+11]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD008             BEQ.N    ??CAN_FilterInit_1
   \   0000001E   0x7AE0             LDRB     R0,[R4, #+11]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD005             BEQ.N    ??CAN_FilterInit_1
   \   00000024   0xF44F 0x71A7      MOV      R1,#+334
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   0000002C   0x.... 0x....      BL       assert_failed
    335            assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
   \                     ??CAN_FilterInit_1: (+1)
   \   00000030   0x7B20             LDRB     R0,[R4, #+12]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD008             BEQ.N    ??CAN_FilterInit_2
   \   00000036   0x7B20             LDRB     R0,[R4, #+12]
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xD005             BEQ.N    ??CAN_FilterInit_2
   \   0000003C   0xF240 0x114F      MOVW     R1,#+335
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000044   0x.... 0x....      BL       assert_failed
    336            assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
   \                     ??CAN_FilterInit_2: (+1)
   \   00000048   0x8920             LDRH     R0,[R4, #+8]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD008             BEQ.N    ??CAN_FilterInit_3
   \   0000004E   0x8920             LDRH     R0,[R4, #+8]
   \   00000050   0x2801             CMP      R0,#+1
   \   00000052   0xD005             BEQ.N    ??CAN_FilterInit_3
   \   00000054   0xF44F 0x71A8      MOV      R1,#+336
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   0000005C   0x.... 0x....      BL       assert_failed
    337            assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
   \                     ??CAN_FilterInit_3: (+1)
   \   00000060   0x7B60             LDRB     R0,[R4, #+13]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD008             BEQ.N    ??CAN_FilterInit_4
   \   00000066   0x7B60             LDRB     R0,[R4, #+13]
   \   00000068   0x2801             CMP      R0,#+1
   \   0000006A   0xD005             BEQ.N    ??CAN_FilterInit_4
   \   0000006C   0xF240 0x1151      MOVW     R1,#+337
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000074   0x.... 0x....      BL       assert_failed
    338          
    339            filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
   \                     ??CAN_FilterInit_4: (+1)
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0x7AA1             LDRB     R1,[R4, #+10]
   \   0000007C   0x4088             LSLS     R0,R0,R1
   \   0000007E   0x0005             MOVS     R5,R0
    340          
    341            /* Initialisation mode for the filter */
    342            CAN1->FMR |= FMR_FINIT;
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable20  ;; 0x40006600
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable20  ;; 0x40006600
   \   0000008E   0x6008             STR      R0,[R1, #+0]
    343          
    344            /* Filter Deactivation */
    345            CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x4000661c
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0x43A8             BICS     R0,R0,R5
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable19  ;; 0x4000661c
   \   0000009C   0x6008             STR      R0,[R1, #+0]
    346          
    347            /* Filter Scale */
    348            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
   \   0000009E   0x7B20             LDRB     R0,[R4, #+12]
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD119             BNE.N    ??CAN_FilterInit_5
    349            {
    350              /* 16-bit scale for the filter */
    351              CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x4000660c
   \   000000A8   0x6800             LDR      R0,[R0, #+0]
   \   000000AA   0x43A8             BICS     R0,R0,R5
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable19_1  ;; 0x4000660c
   \   000000B0   0x6008             STR      R0,[R1, #+0]
    352          
    353              /* First 16-bit identifier and First 16-bit mask */
    354              /* Or First 16-bit identifier and Second 16-bit identifier */
    355              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    356                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
    357                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
   \   000000B2   0x88E0             LDRH     R0,[R4, #+6]
   \   000000B4   0x8861             LDRH     R1,[R4, #+2]
   \   000000B6   0xEA51 0x4000      ORRS     R0,R1,R0, LSL #+16
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable19_2  ;; 0x40006640
   \   000000BE   0x7AA2             LDRB     R2,[R4, #+10]
   \   000000C0   0xF841 0x0032      STR      R0,[R1, R2, LSL #+3]
    358          
    359              /* Second 16-bit identifier and Second 16-bit mask */
    360              /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    361              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    362                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    363                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable19_2  ;; 0x40006640
   \   000000C8   0x7AA1             LDRB     R1,[R4, #+10]
   \   000000CA   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   000000CE   0x88A1             LDRH     R1,[R4, #+4]
   \   000000D0   0x8822             LDRH     R2,[R4, #+0]
   \   000000D2   0xEA52 0x4101      ORRS     R1,R2,R1, LSL #+16
   \   000000D6   0x6041             STR      R1,[R0, #+4]
    364            }
    365          
    366            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
   \                     ??CAN_FilterInit_5: (+1)
   \   000000D8   0x7B20             LDRB     R0,[R4, #+12]
   \   000000DA   0x2801             CMP      R0,#+1
   \   000000DC   0xD119             BNE.N    ??CAN_FilterInit_6
    367            {
    368              /* 32-bit scale for the filter */
    369              CAN1->FS1R |= filter_number_bit_pos;
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x4000660c
   \   000000E2   0x6800             LDR      R0,[R0, #+0]
   \   000000E4   0x4328             ORRS     R0,R5,R0
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable19_1  ;; 0x4000660c
   \   000000EA   0x6008             STR      R0,[R1, #+0]
    370              /* 32-bit identifier or First 32-bit identifier */
    371              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    372                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
    373                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
   \   000000EC   0x8820             LDRH     R0,[R4, #+0]
   \   000000EE   0x8861             LDRH     R1,[R4, #+2]
   \   000000F0   0xEA51 0x4000      ORRS     R0,R1,R0, LSL #+16
   \   000000F4   0x.... 0x....      LDR.W    R1,??DataTable19_2  ;; 0x40006640
   \   000000F8   0x7AA2             LDRB     R2,[R4, #+10]
   \   000000FA   0xF841 0x0032      STR      R0,[R1, R2, LSL #+3]
    374              /* 32-bit mask or Second 32-bit identifier */
    375              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    376                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    377                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable19_2  ;; 0x40006640
   \   00000102   0x7AA1             LDRB     R1,[R4, #+10]
   \   00000104   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   00000108   0x88A1             LDRH     R1,[R4, #+4]
   \   0000010A   0x88E2             LDRH     R2,[R4, #+6]
   \   0000010C   0xEA52 0x4101      ORRS     R1,R2,R1, LSL #+16
   \   00000110   0x6041             STR      R1,[R0, #+4]
    378            }
    379          
    380            /* Filter Mode */
    381            if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
   \                     ??CAN_FilterInit_6: (+1)
   \   00000112   0x7AE0             LDRB     R0,[R4, #+11]
   \   00000114   0x2800             CMP      R0,#+0
   \   00000116   0xD107             BNE.N    ??CAN_FilterInit_7
    382            {
    383              /*Id/Mask mode for the filter*/
    384              CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
   \   00000118   0x.... 0x....      LDR.W    R0,??DataTable19_3  ;; 0x40006604
   \   0000011C   0x6800             LDR      R0,[R0, #+0]
   \   0000011E   0x43A8             BICS     R0,R0,R5
   \   00000120   0x.... 0x....      LDR.W    R1,??DataTable19_3  ;; 0x40006604
   \   00000124   0x6008             STR      R0,[R1, #+0]
   \   00000126   0xE006             B.N      ??CAN_FilterInit_8
    385            }
    386            else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
    387            {
    388              /*Identifier list mode for the filter*/
    389              CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
   \                     ??CAN_FilterInit_7: (+1)
   \   00000128   0x.... 0x....      LDR.W    R0,??DataTable19_3  ;; 0x40006604
   \   0000012C   0x6800             LDR      R0,[R0, #+0]
   \   0000012E   0x4328             ORRS     R0,R5,R0
   \   00000130   0x.... 0x....      LDR.W    R1,??DataTable19_3  ;; 0x40006604
   \   00000134   0x6008             STR      R0,[R1, #+0]
    390            }
    391          
    392            /* Filter FIFO assignment */
    393            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
   \                     ??CAN_FilterInit_8: (+1)
   \   00000136   0x8920             LDRH     R0,[R4, #+8]
   \   00000138   0x2800             CMP      R0,#+0
   \   0000013A   0xD106             BNE.N    ??CAN_FilterInit_9
    394            {
    395              /* FIFO 0 assignation for the filter */
    396              CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
   \   0000013C   0x.... 0x....      LDR.W    R0,??DataTable19_4  ;; 0x40006614
   \   00000140   0x6800             LDR      R0,[R0, #+0]
   \   00000142   0x43A8             BICS     R0,R0,R5
   \   00000144   0x.... 0x....      LDR.W    R1,??DataTable19_4  ;; 0x40006614
   \   00000148   0x6008             STR      R0,[R1, #+0]
    397            }
    398          
    399            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
   \                     ??CAN_FilterInit_9: (+1)
   \   0000014A   0x8920             LDRH     R0,[R4, #+8]
   \   0000014C   0x2801             CMP      R0,#+1
   \   0000014E   0xD106             BNE.N    ??CAN_FilterInit_10
    400            {
    401              /* FIFO 1 assignation for the filter */
    402              CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
   \   00000150   0x.... 0x....      LDR.W    R0,??DataTable19_4  ;; 0x40006614
   \   00000154   0x6800             LDR      R0,[R0, #+0]
   \   00000156   0x4328             ORRS     R0,R5,R0
   \   00000158   0x.... 0x....      LDR.W    R1,??DataTable19_4  ;; 0x40006614
   \   0000015C   0x6008             STR      R0,[R1, #+0]
    403            }
    404            
    405            /* Filter activation */
    406            if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
   \                     ??CAN_FilterInit_10: (+1)
   \   0000015E   0x7B60             LDRB     R0,[R4, #+13]
   \   00000160   0x2801             CMP      R0,#+1
   \   00000162   0xD106             BNE.N    ??CAN_FilterInit_11
    407            {
    408              CAN1->FA1R |= filter_number_bit_pos;
   \   00000164   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x4000661c
   \   00000168   0x6800             LDR      R0,[R0, #+0]
   \   0000016A   0x4328             ORRS     R0,R5,R0
   \   0000016C   0x.... 0x....      LDR.W    R1,??DataTable19  ;; 0x4000661c
   \   00000170   0x6008             STR      R0,[R1, #+0]
    409            }
    410          
    411            /* Leave the initialisation mode for the filter */
    412            CAN1->FMR &= ~FMR_FINIT;
   \                     ??CAN_FilterInit_11: (+1)
   \   00000172   0x.... 0x....      LDR.W    R0,??DataTable20  ;; 0x40006600
   \   00000176   0x6800             LDR      R0,[R0, #+0]
   \   00000178   0x0840             LSRS     R0,R0,#+1
   \   0000017A   0x0040             LSLS     R0,R0,#+1
   \   0000017C   0x.... 0x....      LDR.W    R1,??DataTable20  ;; 0x40006600
   \   00000180   0x6008             STR      R0,[R1, #+0]
    413          }
   \   00000182   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    414          
    415          /**
    416            * @brief  Fills each CAN_InitStruct member with its default value.
    417            * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure which ill be initialized.
    418            * @retval None
    419            */

   \                                 In section .text, align 2, keep-with-next
    420          void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
    421          {
    422            /* Reset CAN init structure parameters values */
    423            
    424            /* Initialize the time triggered communication mode */
    425            CAN_InitStruct->CAN_TTCM = DISABLE;
   \                     CAN_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7181             STRB     R1,[R0, #+6]
    426            
    427            /* Initialize the automatic bus-off management */
    428            CAN_InitStruct->CAN_ABOM = DISABLE;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x71C1             STRB     R1,[R0, #+7]
    429            
    430            /* Initialize the automatic wake-up mode */
    431            CAN_InitStruct->CAN_AWUM = DISABLE;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7201             STRB     R1,[R0, #+8]
    432            
    433            /* Initialize the no automatic retransmission */
    434            CAN_InitStruct->CAN_NART = DISABLE;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x7241             STRB     R1,[R0, #+9]
    435            
    436            /* Initialize the receive FIFO locked mode */
    437            CAN_InitStruct->CAN_RFLM = DISABLE;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x7281             STRB     R1,[R0, #+10]
    438            
    439            /* Initialize the transmit FIFO priority */
    440            CAN_InitStruct->CAN_TXFP = DISABLE;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x72C1             STRB     R1,[R0, #+11]
    441            
    442            /* Initialize the CAN_Mode member */
    443            CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x7081             STRB     R1,[R0, #+2]
    444            
    445            /* Initialize the CAN_SJW member */
    446            CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x70C1             STRB     R1,[R0, #+3]
    447            
    448            /* Initialize the CAN_BS1 member */
    449            CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
   \   00000020   0x2103             MOVS     R1,#+3
   \   00000022   0x7101             STRB     R1,[R0, #+4]
    450            
    451            /* Initialize the CAN_BS2 member */
    452            CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
   \   00000024   0x2102             MOVS     R1,#+2
   \   00000026   0x7141             STRB     R1,[R0, #+5]
    453            
    454            /* Initialize the CAN_Prescaler member */
    455            CAN_InitStruct->CAN_Prescaler = 1;
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0x8001             STRH     R1,[R0, #+0]
    456          }
   \   0000002C   0x4770             BX       LR               ;; return
    457          
    458          /**
    459            * @brief  Select the start bank filter for slave CAN.
    460            * @param  CAN_BankNumber: Select the start slave bank filter from 1..27.
    461            * @retval None
    462            */

   \                                 In section .text, align 2, keep-with-next
    463          void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
    464          {
   \                     CAN_SlaveStartBank: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    465            /* Check the parameters */
    466            assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD002             BEQ.N    ??CAN_SlaveStartBank_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C1C             CMP      R4,#+28
   \   0000000E   0xDB05             BLT.N    ??CAN_SlaveStartBank_1
   \                     ??CAN_SlaveStartBank_0: (+1)
   \   00000010   0xF44F 0x71E9      MOV      R1,#+466
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000018   0x.... 0x....      BL       assert_failed
    467            
    468            /* Enter Initialisation mode for the filter */
    469            CAN1->FMR |= FMR_FINIT;
   \                     ??CAN_SlaveStartBank_1: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable20  ;; 0x40006600
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable20  ;; 0x40006600
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    470            
    471            /* Select the start slave bank */
    472            CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable20  ;; 0x40006600
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable20_1  ;; 0xffffc0f1
   \   00000036   0x4008             ANDS     R0,R1,R0
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable20  ;; 0x40006600
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    473            CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable20  ;; 0x40006600
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000046   0xEA50 0x2004      ORRS     R0,R0,R4, LSL #+8
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable20  ;; 0x40006600
   \   0000004E   0x6008             STR      R0,[R1, #+0]
    474            
    475            /* Leave Initialisation mode for the filter */
    476            CAN1->FMR &= ~FMR_FINIT;
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable20  ;; 0x40006600
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x0840             LSRS     R0,R0,#+1
   \   00000058   0x0040             LSLS     R0,R0,#+1
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable20  ;; 0x40006600
   \   0000005E   0x6008             STR      R0,[R1, #+0]
    477          }
   \   00000060   0xBD10             POP      {R4,PC}          ;; return
    478          
    479          /**
    480            * @brief  Enables or disables the DBG Freeze for CAN.
    481            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    482            * @param  NewState: new state of the CAN peripheral. 
    483            *          This parameter can be: ENABLE (CAN reception/transmission is frozen
    484            *          during debug. Reception FIFOs can still be accessed/controlled normally) 
    485            *          or DISABLE (CAN is working during debug).
    486            * @retval None
    487            */

   \                                 In section .text, align 2, keep-with-next
    488          void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
    489          {
   \                     CAN_DBGFreeze: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    490            /* Check the parameters */
    491            assert_param(IS_CAN_ALL_PERIPH(CANx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40006400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??CAN_DBGFreeze_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40006800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??CAN_DBGFreeze_0
   \   00000016   0xF240 0x11EB      MOVW     R1,#+491
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   0000001E   0x.... 0x....      BL       assert_failed
    492            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??CAN_DBGFreeze_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD008             BEQ.N    ??CAN_DBGFreeze_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD005             BEQ.N    ??CAN_DBGFreeze_1
   \   0000002E   0xF44F 0x71F6      MOV      R1,#+492
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000036   0x.... 0x....      BL       assert_failed
    493            
    494            if (NewState != DISABLE)
   \                     ??CAN_DBGFreeze_1: (+1)
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xD004             BEQ.N    ??CAN_DBGFreeze_2
    495            {
    496              /* Enable Debug Freeze  */
    497              CANx->MCR |= MCR_DBF;
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000046   0x6020             STR      R0,[R4, #+0]
   \   00000048   0xE003             B.N      ??CAN_DBGFreeze_3
    498            }
    499            else
    500            {
    501              /* Disable Debug Freeze */
    502              CANx->MCR &= ~MCR_DBF;
   \                     ??CAN_DBGFreeze_2: (+1)
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   00000050   0x6020             STR      R0,[R4, #+0]
    503            }
    504          }
   \                     ??CAN_DBGFreeze_3: (+1)
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    505          
    506          
    507          /**
    508            * @brief  Enables or disables the CAN Time TriggerOperation communication mode.
    509            * @note   DLC must be programmed as 8 in order Time Stamp (2 bytes) to be 
    510            *         sent over the CAN bus.  
    511            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    512            * @param  NewState: Mode new state. This parameter can be: ENABLE or DISABLE.
    513            *         When enabled, Time stamp (TIME[15:0]) value is  sent in the last two
    514            *         data bytes of the 8-byte message: TIME[7:0] in data byte 6 and TIME[15:8] 
    515            *         in data byte 7. 
    516            * @retval None
    517            */

   \                                 In section .text, align 2, keep-with-next
    518          void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
    519          {
   \                     CAN_TTComModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    520            /* Check the parameters */
    521            assert_param(IS_CAN_ALL_PERIPH(CANx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40006400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??CAN_TTComModeCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40006800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??CAN_TTComModeCmd_0
   \   00000016   0xF240 0x2109      MOVW     R1,#+521
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable22
   \   0000001E   0x.... 0x....      BL       assert_failed
    522            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??CAN_TTComModeCmd_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD008             BEQ.N    ??CAN_TTComModeCmd_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD005             BEQ.N    ??CAN_TTComModeCmd_1
   \   0000002E   0xF240 0x210A      MOVW     R1,#+522
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000036   0x.... 0x....      BL       assert_failed
    523            if (NewState != DISABLE)
   \                     ??CAN_TTComModeCmd_1: (+1)
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xD016             BEQ.N    ??CAN_TTComModeCmd_2
    524            {
    525              /* Enable the TTCM mode */
    526              CANx->MCR |= CAN_MCR_TTCM;
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000046   0x6020             STR      R0,[R4, #+0]
    527          
    528              /* Set TGT bits */
    529              CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
   \   00000048   0xF8D4 0x0184      LDR      R0,[R4, #+388]
   \   0000004C   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000050   0xF8C4 0x0184      STR      R0,[R4, #+388]
    530              CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
   \   00000054   0xF8D4 0x0194      LDR      R0,[R4, #+404]
   \   00000058   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000005C   0xF8C4 0x0194      STR      R0,[R4, #+404]
    531              CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
   \   00000060   0xF8D4 0x01A4      LDR      R0,[R4, #+420]
   \   00000064   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000068   0xF8C4 0x01A4      STR      R0,[R4, #+420]
   \   0000006C   0xE015             B.N      ??CAN_TTComModeCmd_3
    532            }
    533            else
    534            {
    535              /* Disable the TTCM mode */
    536              CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
   \                     ??CAN_TTComModeCmd_2: (+1)
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000074   0x6020             STR      R0,[R4, #+0]
    537          
    538              /* Reset TGT bits */
    539              CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
   \   00000076   0xF8D4 0x0184      LDR      R0,[R4, #+388]
   \   0000007A   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000007E   0xF8C4 0x0184      STR      R0,[R4, #+388]
    540              CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
   \   00000082   0xF8D4 0x0194      LDR      R0,[R4, #+404]
   \   00000086   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000008A   0xF8C4 0x0194      STR      R0,[R4, #+404]
    541              CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
   \   0000008E   0xF8D4 0x01A4      LDR      R0,[R4, #+420]
   \   00000092   0xF430 0x7080      BICS     R0,R0,#0x100
   \   00000096   0xF8C4 0x01A4      STR      R0,[R4, #+420]
    542            }
    543          }
   \                     ??CAN_TTComModeCmd_3: (+1)
   \   0000009A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    544          /**
    545            * @}
    546            */
    547          
    548          
    549          /** @defgroup CAN_Group2 CAN Frames Transmission functions
    550           *  @brief    CAN Frames Transmission functions 
    551           *
    552          @verbatim    
    553           ===============================================================================
    554                                CAN Frames Transmission functions
    555           ===============================================================================  
    556            This section provides functions allowing to 
    557             - Initiate and transmit a CAN frame message (if there is an empty mailbox).
    558             - Check the transmission status of a CAN Frame
    559             - Cancel a transmit request
    560             
    561          @endverbatim
    562            * @{
    563            */
    564          
    565          /**
    566            * @brief  Initiates and transmits a CAN frame message.
    567            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    568            * @param  TxMessage: pointer to a structure which contains CAN Id, CAN DLC and CAN data.
    569            * @retval The number of the mailbox that is used for transmission or
    570            *         CAN_TxStatus_NoMailBox if there is no empty mailbox.
    571            */

   \                                 In section .text, align 2, keep-with-next
    572          uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
    573          {
   \                     CAN_Transmit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    574            uint8_t transmit_mailbox = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    575            /* Check the parameters */
    576            assert_param(IS_CAN_ALL_PERIPH(CANx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40006400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD009             BEQ.N    ??CAN_Transmit_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40006800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD005             BEQ.N    ??CAN_Transmit_0
   \   00000018   0xF44F 0x7110      MOV      R1,#+576
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000020   0x.... 0x....      BL       assert_failed
    577            assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
   \                     ??CAN_Transmit_0: (+1)
   \   00000024   0x7A28             LDRB     R0,[R5, #+8]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD008             BEQ.N    ??CAN_Transmit_1
   \   0000002A   0x7A28             LDRB     R0,[R5, #+8]
   \   0000002C   0x2804             CMP      R0,#+4
   \   0000002E   0xD005             BEQ.N    ??CAN_Transmit_1
   \   00000030   0xF240 0x2141      MOVW     R1,#+577
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000038   0x.... 0x....      BL       assert_failed
    578            assert_param(IS_CAN_RTR(TxMessage->RTR));
   \                     ??CAN_Transmit_1: (+1)
   \   0000003C   0x7A68             LDRB     R0,[R5, #+9]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD008             BEQ.N    ??CAN_Transmit_2
   \   00000042   0x7A68             LDRB     R0,[R5, #+9]
   \   00000044   0x2802             CMP      R0,#+2
   \   00000046   0xD005             BEQ.N    ??CAN_Transmit_2
   \   00000048   0xF240 0x2142      MOVW     R1,#+578
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000050   0x.... 0x....      BL       assert_failed
    579            assert_param(IS_CAN_DLC(TxMessage->DLC));
   \                     ??CAN_Transmit_2: (+1)
   \   00000054   0x7AA8             LDRB     R0,[R5, #+10]
   \   00000056   0x2809             CMP      R0,#+9
   \   00000058   0xDB05             BLT.N    ??CAN_Transmit_3
   \   0000005A   0xF240 0x2143      MOVW     R1,#+579
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000062   0x.... 0x....      BL       assert_failed
    580          
    581            /* Select one empty transmit mailbox */
    582            if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
   \                     ??CAN_Transmit_3: (+1)
   \   00000066   0x68A0             LDR      R0,[R4, #+8]
   \   00000068   0x0140             LSLS     R0,R0,#+5
   \   0000006A   0xD502             BPL.N    ??CAN_Transmit_4
    583            {
    584              transmit_mailbox = 0;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x0006             MOVS     R6,R0
   \   00000070   0xE00D             B.N      ??CAN_Transmit_5
    585            }
    586            else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
   \                     ??CAN_Transmit_4: (+1)
   \   00000072   0x68A0             LDR      R0,[R4, #+8]
   \   00000074   0x0100             LSLS     R0,R0,#+4
   \   00000076   0xD502             BPL.N    ??CAN_Transmit_6
    587            {
    588              transmit_mailbox = 1;
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0x0006             MOVS     R6,R0
   \   0000007C   0xE007             B.N      ??CAN_Transmit_5
    589            }
    590            else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
   \                     ??CAN_Transmit_6: (+1)
   \   0000007E   0x68A0             LDR      R0,[R4, #+8]
   \   00000080   0x00C0             LSLS     R0,R0,#+3
   \   00000082   0xD502             BPL.N    ??CAN_Transmit_7
    591            {
    592              transmit_mailbox = 2;
   \   00000084   0x2002             MOVS     R0,#+2
   \   00000086   0x0006             MOVS     R6,R0
   \   00000088   0xE001             B.N      ??CAN_Transmit_5
    593            }
    594            else
    595            {
    596              transmit_mailbox = CAN_TxStatus_NoMailBox;
   \                     ??CAN_Transmit_7: (+1)
   \   0000008A   0x2004             MOVS     R0,#+4
   \   0000008C   0x0006             MOVS     R6,R0
    597            }
    598          
    599            if (transmit_mailbox != CAN_TxStatus_NoMailBox)
   \                     ??CAN_Transmit_5: (+1)
   \   0000008E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000090   0x2E04             CMP      R6,#+4
   \   00000092   0xF000 0x808A      BEQ.W    ??CAN_Transmit_8
    600            {
    601              /* Set up the Id */
    602              CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
   \   00000096   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000098   0xEB14 0x1006      ADDS     R0,R4,R6, LSL #+4
   \   0000009C   0xF8D0 0x0180      LDR      R0,[R0, #+384]
   \   000000A0   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000A4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000A6   0xEB14 0x1106      ADDS     R1,R4,R6, LSL #+4
   \   000000AA   0xF8C1 0x0180      STR      R0,[R1, #+384]
    603              if (TxMessage->IDE == CAN_Id_Standard)
   \   000000AE   0x7A28             LDRB     R0,[R5, #+8]
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD119             BNE.N    ??CAN_Transmit_9
    604              {
    605                assert_param(IS_CAN_STDID(TxMessage->StdId));  
   \   000000B4   0x6828             LDR      R0,[R5, #+0]
   \   000000B6   0xF5B0 0x6F00      CMP      R0,#+2048
   \   000000BA   0xD305             BCC.N    ??CAN_Transmit_10
   \   000000BC   0xF240 0x215D      MOVW     R1,#+605
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable22
   \   000000C4   0x.... 0x....      BL       assert_failed
    606                CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
    607                                                            TxMessage->RTR);
   \                     ??CAN_Transmit_10: (+1)
   \   000000C8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000CA   0xEB14 0x1006      ADDS     R0,R4,R6, LSL #+4
   \   000000CE   0xF8D0 0x0180      LDR      R0,[R0, #+384]
   \   000000D2   0x6829             LDR      R1,[R5, #+0]
   \   000000D4   0x7A6A             LDRB     R2,[R5, #+9]
   \   000000D6   0xEA52 0x5141      ORRS     R1,R2,R1, LSL #+21
   \   000000DA   0x4308             ORRS     R0,R1,R0
   \   000000DC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000DE   0xEB14 0x1106      ADDS     R1,R4,R6, LSL #+4
   \   000000E2   0xF8C1 0x0180      STR      R0,[R1, #+384]
   \   000000E6   0xE01A             B.N      ??CAN_Transmit_11
    608              }
    609              else
    610              {
    611                assert_param(IS_CAN_EXTID(TxMessage->ExtId));
   \                     ??CAN_Transmit_9: (+1)
   \   000000E8   0x6868             LDR      R0,[R5, #+4]
   \   000000EA   0xF1B0 0x5F00      CMP      R0,#+536870912
   \   000000EE   0xD305             BCC.N    ??CAN_Transmit_12
   \   000000F0   0xF240 0x2163      MOVW     R1,#+611
   \   000000F4   0x.... 0x....      LDR.W    R0,??DataTable22
   \   000000F8   0x.... 0x....      BL       assert_failed
    612                CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
    613                                                            TxMessage->IDE | \
    614                                                            TxMessage->RTR);
   \                     ??CAN_Transmit_12: (+1)
   \   000000FC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000FE   0xEB14 0x1006      ADDS     R0,R4,R6, LSL #+4
   \   00000102   0xF8D0 0x0180      LDR      R0,[R0, #+384]
   \   00000106   0x6869             LDR      R1,[R5, #+4]
   \   00000108   0x7A2A             LDRB     R2,[R5, #+8]
   \   0000010A   0xEA52 0x01C1      ORRS     R1,R2,R1, LSL #+3
   \   0000010E   0x7A6A             LDRB     R2,[R5, #+9]
   \   00000110   0x4311             ORRS     R1,R2,R1
   \   00000112   0x4308             ORRS     R0,R1,R0
   \   00000114   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000116   0xEB14 0x1106      ADDS     R1,R4,R6, LSL #+4
   \   0000011A   0xF8C1 0x0180      STR      R0,[R1, #+384]
    615              }
    616              
    617              /* Set up the DLC */
    618              TxMessage->DLC &= (uint8_t)0x0000000F;
   \                     ??CAN_Transmit_11: (+1)
   \   0000011E   0x7AA8             LDRB     R0,[R5, #+10]
   \   00000120   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000124   0x72A8             STRB     R0,[R5, #+10]
    619              CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
   \   00000126   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000128   0xEB14 0x1006      ADDS     R0,R4,R6, LSL #+4
   \   0000012C   0xF8D0 0x0184      LDR      R0,[R0, #+388]
   \   00000130   0x0900             LSRS     R0,R0,#+4
   \   00000132   0x0100             LSLS     R0,R0,#+4
   \   00000134   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000136   0xEB14 0x1106      ADDS     R1,R4,R6, LSL #+4
   \   0000013A   0xF8C1 0x0184      STR      R0,[R1, #+388]
    620              CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
   \   0000013E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000140   0xEB14 0x1006      ADDS     R0,R4,R6, LSL #+4
   \   00000144   0xF8D0 0x0184      LDR      R0,[R0, #+388]
   \   00000148   0x7AA9             LDRB     R1,[R5, #+10]
   \   0000014A   0x4308             ORRS     R0,R1,R0
   \   0000014C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000014E   0xEB14 0x1106      ADDS     R1,R4,R6, LSL #+4
   \   00000152   0xF8C1 0x0184      STR      R0,[R1, #+388]
    621          
    622              /* Set up the data field */
    623              CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
    624                                                       ((uint32_t)TxMessage->Data[2] << 16) |
    625                                                       ((uint32_t)TxMessage->Data[1] << 8) | 
    626                                                       ((uint32_t)TxMessage->Data[0]));
   \   00000156   0x7BA8             LDRB     R0,[R5, #+14]
   \   00000158   0x7B69             LDRB     R1,[R5, #+13]
   \   0000015A   0x0409             LSLS     R1,R1,#+16
   \   0000015C   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   00000160   0x7B29             LDRB     R1,[R5, #+12]
   \   00000162   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000166   0x7AE9             LDRB     R1,[R5, #+11]
   \   00000168   0x4308             ORRS     R0,R1,R0
   \   0000016A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000016C   0xEB14 0x1106      ADDS     R1,R4,R6, LSL #+4
   \   00000170   0xF8C1 0x0188      STR      R0,[R1, #+392]
    627              CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
    628                                                       ((uint32_t)TxMessage->Data[6] << 16) |
    629                                                       ((uint32_t)TxMessage->Data[5] << 8) |
    630                                                       ((uint32_t)TxMessage->Data[4]));
   \   00000174   0x7CA8             LDRB     R0,[R5, #+18]
   \   00000176   0x7C69             LDRB     R1,[R5, #+17]
   \   00000178   0x0409             LSLS     R1,R1,#+16
   \   0000017A   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   0000017E   0x7C29             LDRB     R1,[R5, #+16]
   \   00000180   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000184   0x7BE9             LDRB     R1,[R5, #+15]
   \   00000186   0x4308             ORRS     R0,R1,R0
   \   00000188   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000018A   0xEB14 0x1106      ADDS     R1,R4,R6, LSL #+4
   \   0000018E   0xF8C1 0x018C      STR      R0,[R1, #+396]
    631              /* Request transmission */
    632              CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
   \   00000192   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000194   0xEB14 0x1006      ADDS     R0,R4,R6, LSL #+4
   \   00000198   0xF8D0 0x0180      LDR      R0,[R0, #+384]
   \   0000019C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000001A0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001A2   0xEB14 0x1106      ADDS     R1,R4,R6, LSL #+4
   \   000001A6   0xF8C1 0x0180      STR      R0,[R1, #+384]
    633            }
    634            return transmit_mailbox;
   \                     ??CAN_Transmit_8: (+1)
   \   000001AA   0x0030             MOVS     R0,R6
   \   000001AC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001AE   0xBD70             POP      {R4-R6,PC}       ;; return
    635          }
    636          
    637          /**
    638            * @brief  Checks the transmission status of a CAN Frame.
    639            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    640            * @param  TransmitMailbox: the number of the mailbox that is used for transmission.
    641            * @retval CAN_TxStatus_Ok if the CAN driver transmits the message, 
    642            *         CAN_TxStatus_Failed in an other case.
    643            */

   \                                 In section .text, align 2, keep-with-next
    644          uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
    645          {
   \                     CAN_TransmitStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    646            uint32_t state = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    647          
    648            /* Check the parameters */
    649            assert_param(IS_CAN_ALL_PERIPH(CANx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40006400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD009             BEQ.N    ??CAN_TransmitStatus_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40006800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD005             BEQ.N    ??CAN_TransmitStatus_0
   \   00000018   0xF240 0x2189      MOVW     R1,#+649
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000020   0x.... 0x....      BL       assert_failed
    650            assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
   \                     ??CAN_TransmitStatus_0: (+1)
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D03             CMP      R5,#+3
   \   00000028   0xDB05             BLT.N    ??CAN_TransmitStatus_1
   \   0000002A   0xF240 0x218A      MOVW     R1,#+650
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000032   0x.... 0x....      BL       assert_failed
    651           
    652            switch (TransmitMailbox)
   \                     ??CAN_TransmitStatus_1: (+1)
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD003             BEQ.N    ??CAN_TransmitStatus_2
   \   0000003C   0x2D02             CMP      R5,#+2
   \   0000003E   0xD00D             BEQ.N    ??CAN_TransmitStatus_3
   \   00000040   0xD306             BCC.N    ??CAN_TransmitStatus_4
   \   00000042   0xE011             B.N      ??CAN_TransmitStatus_5
    653            {
    654              case (CAN_TXMAILBOX_0): 
    655                state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
   \                     ??CAN_TransmitStatus_2: (+1)
   \   00000044   0x68A0             LDR      R0,[R4, #+8]
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable22_1  ;; 0x4000003
   \   0000004A   0x4008             ANDS     R0,R1,R0
   \   0000004C   0x0006             MOVS     R6,R0
    656                break;
   \   0000004E   0xE00D             B.N      ??CAN_TransmitStatus_6
    657              case (CAN_TXMAILBOX_1): 
    658                state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
   \                     ??CAN_TransmitStatus_4: (+1)
   \   00000050   0x68A0             LDR      R0,[R4, #+8]
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable22_2  ;; 0x8000300
   \   00000056   0x4008             ANDS     R0,R1,R0
   \   00000058   0x0006             MOVS     R6,R0
    659                break;
   \   0000005A   0xE007             B.N      ??CAN_TransmitStatus_6
    660              case (CAN_TXMAILBOX_2): 
    661                state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
   \                     ??CAN_TransmitStatus_3: (+1)
   \   0000005C   0x68A0             LDR      R0,[R4, #+8]
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable22_3  ;; 0x10030000
   \   00000062   0x4008             ANDS     R0,R1,R0
   \   00000064   0x0006             MOVS     R6,R0
    662                break;
   \   00000066   0xE001             B.N      ??CAN_TransmitStatus_6
    663              default:
    664                state = CAN_TxStatus_Failed;
   \                     ??CAN_TransmitStatus_5: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x0006             MOVS     R6,R0
    665                break;
    666            }
    667            switch (state)
   \                     ??CAN_TransmitStatus_6: (+1)
   \   0000006C   0x0030             MOVS     R0,R6
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD016             BEQ.N    ??CAN_TransmitStatus_7
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable22_4  ;; 0x4000001
   \   00000076   0x1A40             SUBS     R0,R0,R1
   \   00000078   0xD015             BEQ.N    ??CAN_TransmitStatus_8
   \   0000007A   0x1E80             SUBS     R0,R0,#+2
   \   0000007C   0xD01C             BEQ.N    ??CAN_TransmitStatus_9
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable22_5  ;; 0x40000fd
   \   00000082   0x1A40             SUBS     R0,R0,R1
   \   00000084   0xD012             BEQ.N    ??CAN_TransmitStatus_10
   \   00000086   0xF44F 0x7100      MOV      R1,#+512
   \   0000008A   0x1A40             SUBS     R0,R0,R1
   \   0000008C   0xD017             BEQ.N    ??CAN_TransmitStatus_11
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable22_6  ;; 0x800fd00
   \   00000092   0x1A40             SUBS     R0,R0,R1
   \   00000094   0xD00D             BEQ.N    ??CAN_TransmitStatus_12
   \   00000096   0xF45F 0x3100      MOVS     R1,#+131072
   \   0000009A   0x1A40             SUBS     R0,R0,R1
   \   0000009C   0xD012             BEQ.N    ??CAN_TransmitStatus_13
   \   0000009E   0xE014             B.N      ??CAN_TransmitStatus_14
    668            {
    669                /* transmit pending  */
    670              case (0x0): state = CAN_TxStatus_Pending;
   \                     ??CAN_TransmitStatus_7: (+1)
   \   000000A0   0x2002             MOVS     R0,#+2
   \   000000A2   0x0006             MOVS     R6,R0
    671                break;
   \   000000A4   0xE013             B.N      ??CAN_TransmitStatus_15
    672                /* transmit failed  */
    673               case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
   \                     ??CAN_TransmitStatus_8: (+1)
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x0006             MOVS     R6,R0
    674                break;
   \   000000AA   0xE010             B.N      ??CAN_TransmitStatus_15
    675               case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
   \                     ??CAN_TransmitStatus_10: (+1)
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x0006             MOVS     R6,R0
    676                break;
   \   000000B0   0xE00D             B.N      ??CAN_TransmitStatus_15
    677               case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
   \                     ??CAN_TransmitStatus_12: (+1)
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x0006             MOVS     R6,R0
    678                break;
   \   000000B6   0xE00A             B.N      ??CAN_TransmitStatus_15
    679                /* transmit succeeded  */
    680              case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
   \                     ??CAN_TransmitStatus_9: (+1)
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0x0006             MOVS     R6,R0
    681                break;
   \   000000BC   0xE007             B.N      ??CAN_TransmitStatus_15
    682              case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
   \                     ??CAN_TransmitStatus_11: (+1)
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0x0006             MOVS     R6,R0
    683                break;
   \   000000C2   0xE004             B.N      ??CAN_TransmitStatus_15
    684              case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
   \                     ??CAN_TransmitStatus_13: (+1)
   \   000000C4   0x2001             MOVS     R0,#+1
   \   000000C6   0x0006             MOVS     R6,R0
    685                break;
   \   000000C8   0xE001             B.N      ??CAN_TransmitStatus_15
    686              default: state = CAN_TxStatus_Failed;
   \                     ??CAN_TransmitStatus_14: (+1)
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x0006             MOVS     R6,R0
    687                break;
    688            }
    689            return (uint8_t) state;
   \                     ??CAN_TransmitStatus_15: (+1)
   \   000000CE   0x0030             MOVS     R0,R6
   \   000000D0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D2   0xBD70             POP      {R4-R6,PC}       ;; return
    690          }
    691          
    692          /**
    693            * @brief  Cancels a transmit request.
    694            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    695            * @param  Mailbox: Mailbox number.
    696            * @retval None
    697            */

   \                                 In section .text, align 2, keep-with-next
    698          void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
    699          {
   \                     CAN_CancelTransmit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    700            /* Check the parameters */
    701            assert_param(IS_CAN_ALL_PERIPH(CANx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40006400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??CAN_CancelTransmit_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40006800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??CAN_CancelTransmit_0
   \   00000016   0xF240 0x21BD      MOVW     R1,#+701
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable22
   \   0000001E   0x.... 0x....      BL       assert_failed
    702            assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
   \                     ??CAN_CancelTransmit_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D03             CMP      R5,#+3
   \   00000026   0xDB05             BLT.N    ??CAN_CancelTransmit_1
   \   00000028   0xF240 0x21BE      MOVW     R1,#+702
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000030   0x.... 0x....      BL       assert_failed
    703            /* abort transmission */
    704            switch (Mailbox)
   \                     ??CAN_CancelTransmit_1: (+1)
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0xD003             BEQ.N    ??CAN_CancelTransmit_2
   \   0000003A   0x2D02             CMP      R5,#+2
   \   0000003C   0xD00B             BEQ.N    ??CAN_CancelTransmit_3
   \   0000003E   0xD305             BCC.N    ??CAN_CancelTransmit_4
   \   00000040   0xE00E             B.N      ??CAN_CancelTransmit_5
    705            {
    706              case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
   \                     ??CAN_CancelTransmit_2: (+1)
   \   00000042   0x68A0             LDR      R0,[R4, #+8]
   \   00000044   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000048   0x60A0             STR      R0,[R4, #+8]
    707                break;
   \   0000004A   0xE009             B.N      ??CAN_CancelTransmit_6
    708              case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
   \                     ??CAN_CancelTransmit_4: (+1)
   \   0000004C   0x68A0             LDR      R0,[R4, #+8]
   \   0000004E   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000052   0x60A0             STR      R0,[R4, #+8]
    709                break;
   \   00000054   0xE004             B.N      ??CAN_CancelTransmit_6
    710              case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
   \                     ??CAN_CancelTransmit_3: (+1)
   \   00000056   0x68A0             LDR      R0,[R4, #+8]
   \   00000058   0xF450 0x0000      ORRS     R0,R0,#0x800000
   \   0000005C   0x60A0             STR      R0,[R4, #+8]
    711                break;
   \   0000005E   0xE7FF             B.N      ??CAN_CancelTransmit_6
    712              default:
    713                break;
    714            }
    715          }
   \                     ??CAN_CancelTransmit_5: (+1)
   \                     ??CAN_CancelTransmit_6: (+1)
   \   00000060   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    716          /**
    717            * @}
    718            */
    719          
    720          
    721          /** @defgroup CAN_Group3 CAN Frames Reception functions
    722           *  @brief    CAN Frames Reception functions 
    723           *
    724          @verbatim    
    725           ===============================================================================
    726                                CAN Frames Reception functions
    727           ===============================================================================  
    728            This section provides functions allowing to 
    729             -  Receive a correct CAN frame
    730             -  Release a specified receive FIFO (2 FIFOs are available)
    731             -  Return the number of the pending received CAN frames
    732             
    733          @endverbatim
    734            * @{
    735            */
    736          
    737          /**
    738            * @brief  Receives a correct CAN frame.
    739            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    740            * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    741            * @param  RxMessage: pointer to a structure receive frame which contains CAN Id,
    742            *         CAN DLC, CAN data and FMI number.
    743            * @retval None
    744            */

   \                                 In section .text, align 2, keep-with-next
    745          void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
    746          {
   \                     CAN_Receive: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    747            /* Check the parameters */
    748            assert_param(IS_CAN_ALL_PERIPH(CANx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40006400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD009             BEQ.N    ??CAN_Receive_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40006800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD005             BEQ.N    ??CAN_Receive_0
   \   00000018   0xF44F 0x713B      MOV      R1,#+748
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000020   0x.... 0x....      BL       assert_failed
    749            assert_param(IS_CAN_FIFO(FIFONumber));
   \                     ??CAN_Receive_0: (+1)
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD008             BEQ.N    ??CAN_Receive_1
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x2D01             CMP      R5,#+1
   \   0000002E   0xD005             BEQ.N    ??CAN_Receive_1
   \   00000030   0xF240 0x21ED      MOVW     R1,#+749
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000038   0x.... 0x....      BL       assert_failed
    750            /* Get the Id */
    751            RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
   \                     ??CAN_Receive_1: (+1)
   \   0000003C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003E   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   00000042   0xF8D0 0x01B0      LDR      R0,[R0, #+432]
   \   00000046   0xF010 0x0004      ANDS     R0,R0,#0x4
   \   0000004A   0x7230             STRB     R0,[R6, #+8]
    752            if (RxMessage->IDE == CAN_Id_Standard)
   \   0000004C   0x7A30             LDRB     R0,[R6, #+8]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD107             BNE.N    ??CAN_Receive_2
    753            {
    754              RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
   \   00000052   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000054   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   00000058   0xF8D0 0x01B0      LDR      R0,[R0, #+432]
   \   0000005C   0x0D40             LSRS     R0,R0,#+21
   \   0000005E   0x6030             STR      R0,[R6, #+0]
   \   00000060   0xE006             B.N      ??CAN_Receive_3
    755            }
    756            else
    757            {
    758              RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
   \                     ??CAN_Receive_2: (+1)
   \   00000062   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000064   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   00000068   0xF8D0 0x01B0      LDR      R0,[R0, #+432]
   \   0000006C   0x08C0             LSRS     R0,R0,#+3
   \   0000006E   0x6070             STR      R0,[R6, #+4]
    759            }
    760            
    761            RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
   \                     ??CAN_Receive_3: (+1)
   \   00000070   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000072   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   00000076   0xF8D0 0x01B0      LDR      R0,[R0, #+432]
   \   0000007A   0xF010 0x0002      ANDS     R0,R0,#0x2
   \   0000007E   0x7270             STRB     R0,[R6, #+9]
    762            /* Get the DLC */
    763            RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
   \   00000080   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000082   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   00000086   0xF8D0 0x01B4      LDR      R0,[R0, #+436]
   \   0000008A   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000008E   0x72B0             STRB     R0,[R6, #+10]
    764            /* Get the FMI */
    765            RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
   \   00000090   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000092   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   00000096   0xF8D0 0x01B4      LDR      R0,[R0, #+436]
   \   0000009A   0x0A00             LSRS     R0,R0,#+8
   \   0000009C   0x74F0             STRB     R0,[R6, #+19]
    766            /* Get the data field */
    767            RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
   \   0000009E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A0   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   000000A4   0xF8D0 0x01B8      LDR      R0,[R0, #+440]
   \   000000A8   0x72F0             STRB     R0,[R6, #+11]
    768            RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
   \   000000AA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000AC   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   000000B0   0xF8D0 0x01B8      LDR      R0,[R0, #+440]
   \   000000B4   0x0A00             LSRS     R0,R0,#+8
   \   000000B6   0x7330             STRB     R0,[R6, #+12]
    769            RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
   \   000000B8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000BA   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   000000BE   0xF8D0 0x01B8      LDR      R0,[R0, #+440]
   \   000000C2   0x0C00             LSRS     R0,R0,#+16
   \   000000C4   0x7370             STRB     R0,[R6, #+13]
    770            RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
   \   000000C6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000C8   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   000000CC   0xF8D0 0x01B8      LDR      R0,[R0, #+440]
   \   000000D0   0x0E00             LSRS     R0,R0,#+24
   \   000000D2   0x73B0             STRB     R0,[R6, #+14]
    771            RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
   \   000000D4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000D6   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   000000DA   0xF8D0 0x01BC      LDR      R0,[R0, #+444]
   \   000000DE   0x73F0             STRB     R0,[R6, #+15]
    772            RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
   \   000000E0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E2   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   000000E6   0xF8D0 0x01BC      LDR      R0,[R0, #+444]
   \   000000EA   0x0A00             LSRS     R0,R0,#+8
   \   000000EC   0x7430             STRB     R0,[R6, #+16]
    773            RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
   \   000000EE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000F0   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   000000F4   0xF8D0 0x01BC      LDR      R0,[R0, #+444]
   \   000000F8   0x0C00             LSRS     R0,R0,#+16
   \   000000FA   0x7470             STRB     R0,[R6, #+17]
    774            RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
   \   000000FC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000FE   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   00000102   0xF8D0 0x01BC      LDR      R0,[R0, #+444]
   \   00000106   0x0E00             LSRS     R0,R0,#+24
   \   00000108   0x74B0             STRB     R0,[R6, #+18]
    775            /* Release the FIFO */
    776            /* Release FIFO0 */
    777            if (FIFONumber == CAN_FIFO0)
   \   0000010A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000010C   0x2D00             CMP      R5,#+0
   \   0000010E   0xD104             BNE.N    ??CAN_Receive_4
    778            {
    779              CANx->RF0R |= CAN_RF0R_RFOM0;
   \   00000110   0x68E0             LDR      R0,[R4, #+12]
   \   00000112   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000116   0x60E0             STR      R0,[R4, #+12]
   \   00000118   0xE003             B.N      ??CAN_Receive_5
    780            }
    781            /* Release FIFO1 */
    782            else /* FIFONumber == CAN_FIFO1 */
    783            {
    784              CANx->RF1R |= CAN_RF1R_RFOM1;
   \                     ??CAN_Receive_4: (+1)
   \   0000011A   0x6920             LDR      R0,[R4, #+16]
   \   0000011C   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000120   0x6120             STR      R0,[R4, #+16]
    785            }
    786          }
   \                     ??CAN_Receive_5: (+1)
   \   00000122   0xBD70             POP      {R4-R6,PC}       ;; return
    787          
    788          /**
    789            * @brief  Releases the specified receive FIFO.
    790            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    791            * @param  FIFONumber: FIFO to release, CAN_FIFO0 or CAN_FIFO1.
    792            * @retval None
    793            */

   \                                 In section .text, align 2, keep-with-next
    794          void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
    795          {
   \                     CAN_FIFORelease: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    796            /* Check the parameters */
    797            assert_param(IS_CAN_ALL_PERIPH(CANx));
   \   00000006   0x....             LDR.N    R0,??DataTable16  ;; 0x40006400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD008             BEQ.N    ??CAN_FIFORelease_0
   \   0000000C   0x....             LDR.N    R0,??DataTable15  ;; 0x40006800
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD005             BEQ.N    ??CAN_FIFORelease_0
   \   00000012   0xF240 0x311D      MOVW     R1,#+797
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable22
   \   0000001A   0x.... 0x....      BL       assert_failed
    798            assert_param(IS_CAN_FIFO(FIFONumber));
   \                     ??CAN_FIFORelease_0: (+1)
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD008             BEQ.N    ??CAN_FIFORelease_1
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D01             CMP      R5,#+1
   \   00000028   0xD005             BEQ.N    ??CAN_FIFORelease_1
   \   0000002A   0xF240 0x311E      MOVW     R1,#+798
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000032   0x.... 0x....      BL       assert_failed
    799            /* Release FIFO0 */
    800            if (FIFONumber == CAN_FIFO0)
   \                     ??CAN_FIFORelease_1: (+1)
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD104             BNE.N    ??CAN_FIFORelease_2
    801            {
    802              CANx->RF0R |= CAN_RF0R_RFOM0;
   \   0000003C   0x68E0             LDR      R0,[R4, #+12]
   \   0000003E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000042   0x60E0             STR      R0,[R4, #+12]
   \   00000044   0xE003             B.N      ??CAN_FIFORelease_3
    803            }
    804            /* Release FIFO1 */
    805            else /* FIFONumber == CAN_FIFO1 */
    806            {
    807              CANx->RF1R |= CAN_RF1R_RFOM1;
   \                     ??CAN_FIFORelease_2: (+1)
   \   00000046   0x6920             LDR      R0,[R4, #+16]
   \   00000048   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000004C   0x6120             STR      R0,[R4, #+16]
    808            }
    809          }
   \                     ??CAN_FIFORelease_3: (+1)
   \   0000004E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    810          
    811          /**
    812            * @brief  Returns the number of pending received messages.
    813            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    814            * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    815            * @retval NbMessage : which is the number of pending message.
    816            */

   \                                 In section .text, align 2, keep-with-next
    817          uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
    818          {
   \                     CAN_MessagePending: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    819            uint8_t message_pending=0;
   \   00000006   0x2600             MOVS     R6,#+0
    820            /* Check the parameters */
    821            assert_param(IS_CAN_ALL_PERIPH(CANx));
   \   00000008   0x....             LDR.N    R0,??DataTable16  ;; 0x40006400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD008             BEQ.N    ??CAN_MessagePending_0
   \   0000000E   0x....             LDR.N    R0,??DataTable15  ;; 0x40006800
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD005             BEQ.N    ??CAN_MessagePending_0
   \   00000014   0xF240 0x3135      MOVW     R1,#+821
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable22
   \   0000001C   0x.... 0x....      BL       assert_failed
    822            assert_param(IS_CAN_FIFO(FIFONumber));
   \                     ??CAN_MessagePending_0: (+1)
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD008             BEQ.N    ??CAN_MessagePending_1
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0x2D01             CMP      R5,#+1
   \   0000002A   0xD005             BEQ.N    ??CAN_MessagePending_1
   \   0000002C   0xF240 0x3136      MOVW     R1,#+822
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000034   0x.... 0x....      BL       assert_failed
    823            if (FIFONumber == CAN_FIFO0)
   \                     ??CAN_MessagePending_1: (+1)
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD104             BNE.N    ??CAN_MessagePending_2
    824            {
    825              message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
   \   0000003E   0x68E0             LDR      R0,[R4, #+12]
   \   00000040   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   00000044   0x0006             MOVS     R6,R0
   \   00000046   0xE009             B.N      ??CAN_MessagePending_3
    826            }
    827            else if (FIFONumber == CAN_FIFO1)
   \                     ??CAN_MessagePending_2: (+1)
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x2D01             CMP      R5,#+1
   \   0000004C   0xD104             BNE.N    ??CAN_MessagePending_4
    828            {
    829              message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
   \   0000004E   0x6920             LDR      R0,[R4, #+16]
   \   00000050   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   00000054   0x0006             MOVS     R6,R0
   \   00000056   0xE001             B.N      ??CAN_MessagePending_3
    830            }
    831            else
    832            {
    833              message_pending = 0;
   \                     ??CAN_MessagePending_4: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x0006             MOVS     R6,R0
    834            }
    835            return message_pending;
   \                     ??CAN_MessagePending_3: (+1)
   \   0000005C   0x0030             MOVS     R0,R6
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
    836          }
    837          /**
    838            * @}
    839            */
    840          
    841          
    842          /** @defgroup CAN_Group4 CAN Operation modes functions
    843           *  @brief    CAN Operation modes functions 
    844           *
    845          @verbatim    
    846           ===============================================================================
    847                                CAN Operation modes functions
    848           ===============================================================================  
    849            This section provides functions allowing to select the CAN Operation modes
    850            - sleep mode
    851            - normal mode 
    852            - initialization mode
    853             
    854          @endverbatim
    855            * @{
    856            */
    857            
    858            
    859          /**
    860            * @brief  Selects the CAN Operation mode.
    861            * @param  CAN_OperatingMode: CAN Operating Mode.
    862            *         This parameter can be one of @ref CAN_OperatingMode_TypeDef enumeration.
    863            * @retval status of the requested mode which can be 
    864            *         - CAN_ModeStatus_Failed:  CAN failed entering the specific mode 
    865            *         - CAN_ModeStatus_Success: CAN Succeed entering the specific mode 
    866            */

   \                                 In section .text, align 2, keep-with-next
    867          uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)
    868          {
   \                     CAN_OperatingModeRequest: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    869            uint8_t status = CAN_ModeStatus_Failed;
   \   00000006   0x2600             MOVS     R6,#+0
    870            
    871            /* Timeout for INAK or also for SLAK bits*/
    872            uint32_t timeout = INAK_TIMEOUT; 
   \   00000008   0xF64F 0x77FF      MOVW     R7,#+65535
    873          
    874            /* Check the parameters */
    875            assert_param(IS_CAN_ALL_PERIPH(CANx));
   \   0000000C   0x....             LDR.N    R0,??DataTable16  ;; 0x40006400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD008             BEQ.N    ??CAN_OperatingModeRequest_0
   \   00000012   0x....             LDR.N    R0,??DataTable15  ;; 0x40006800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD005             BEQ.N    ??CAN_OperatingModeRequest_0
   \   00000018   0xF240 0x316B      MOVW     R1,#+875
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000020   0x.... 0x....      BL       assert_failed
    876            assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));
   \                     ??CAN_OperatingModeRequest_0: (+1)
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD00B             BEQ.N    ??CAN_OperatingModeRequest_1
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x2D01             CMP      R5,#+1
   \   0000002E   0xD008             BEQ.N    ??CAN_OperatingModeRequest_1
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D02             CMP      R5,#+2
   \   00000034   0xD005             BEQ.N    ??CAN_OperatingModeRequest_1
   \   00000036   0xF44F 0x715B      MOV      R1,#+876
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable22
   \   0000003E   0x.... 0x....      BL       assert_failed
    877          
    878            if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
   \                     ??CAN_OperatingModeRequest_1: (+1)
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD119             BNE.N    ??CAN_OperatingModeRequest_2
    879            {
    880              /* Request initialisation */
    881              CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000004E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000052   0x6020             STR      R0,[R4, #+0]
    882          
    883              /* Wait the acknowledge */
    884              while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
   \                     ??CAN_OperatingModeRequest_3: (+1)
   \   00000054   0x6860             LDR      R0,[R4, #+4]
   \   00000056   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   0000005A   0x2801             CMP      R0,#+1
   \   0000005C   0xD003             BEQ.N    ??CAN_OperatingModeRequest_4
   \   0000005E   0x2F00             CMP      R7,#+0
   \   00000060   0xD001             BEQ.N    ??CAN_OperatingModeRequest_4
    885              {
    886                timeout--;
   \   00000062   0x1E7F             SUBS     R7,R7,#+1
   \   00000064   0xE7F6             B.N      ??CAN_OperatingModeRequest_3
    887              }
    888              if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
   \                     ??CAN_OperatingModeRequest_4: (+1)
   \   00000066   0x6860             LDR      R0,[R4, #+4]
   \   00000068   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   0000006C   0x2801             CMP      R0,#+1
   \   0000006E   0xD002             BEQ.N    ??CAN_OperatingModeRequest_5
    889              {
    890                status = CAN_ModeStatus_Failed;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x0006             MOVS     R6,R0
   \   00000074   0xE03A             B.N      ??CAN_OperatingModeRequest_6
    891              }
    892              else
    893              {
    894                status = CAN_ModeStatus_Success;
   \                     ??CAN_OperatingModeRequest_5: (+1)
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0x0006             MOVS     R6,R0
   \   0000007A   0xE037             B.N      ??CAN_OperatingModeRequest_6
    895              }
    896            }
    897            else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
   \                     ??CAN_OperatingModeRequest_2: (+1)
   \   0000007C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007E   0x2D01             CMP      R5,#+1
   \   00000080   0xD115             BNE.N    ??CAN_OperatingModeRequest_7
    898            {
    899              /* Request leave initialisation and sleep mode  and enter Normal mode */
    900              CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x0880             LSRS     R0,R0,#+2
   \   00000086   0x0080             LSLS     R0,R0,#+2
   \   00000088   0x6020             STR      R0,[R4, #+0]
    901          
    902              /* Wait the acknowledge */
    903              while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
   \                     ??CAN_OperatingModeRequest_8: (+1)
   \   0000008A   0x6860             LDR      R0,[R4, #+4]
   \   0000008C   0xF010 0x0F03      TST      R0,#0x3
   \   00000090   0xD003             BEQ.N    ??CAN_OperatingModeRequest_9
   \   00000092   0x2F00             CMP      R7,#+0
   \   00000094   0xD001             BEQ.N    ??CAN_OperatingModeRequest_9
    904              {
    905                timeout--;
   \   00000096   0x1E7F             SUBS     R7,R7,#+1
   \   00000098   0xE7F7             B.N      ??CAN_OperatingModeRequest_8
    906              }
    907              if ((CANx->MSR & CAN_MODE_MASK) != 0)
   \                     ??CAN_OperatingModeRequest_9: (+1)
   \   0000009A   0x6860             LDR      R0,[R4, #+4]
   \   0000009C   0xF010 0x0F03      TST      R0,#0x3
   \   000000A0   0xD002             BEQ.N    ??CAN_OperatingModeRequest_10
    908              {
    909                status = CAN_ModeStatus_Failed;
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x0006             MOVS     R6,R0
   \   000000A6   0xE021             B.N      ??CAN_OperatingModeRequest_6
    910              }
    911              else
    912              {
    913                status = CAN_ModeStatus_Success;
   \                     ??CAN_OperatingModeRequest_10: (+1)
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0x0006             MOVS     R6,R0
   \   000000AC   0xE01E             B.N      ??CAN_OperatingModeRequest_6
    914              }
    915            }
    916            else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
   \                     ??CAN_OperatingModeRequest_7: (+1)
   \   000000AE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B0   0x2D02             CMP      R5,#+2
   \   000000B2   0xD119             BNE.N    ??CAN_OperatingModeRequest_11
    917            {
    918              /* Request Sleep mode */
    919              CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
   \   000000B4   0x6820             LDR      R0,[R4, #+0]
   \   000000B6   0x0840             LSRS     R0,R0,#+1
   \   000000B8   0x0040             LSLS     R0,R0,#+1
   \   000000BA   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000000BE   0x6020             STR      R0,[R4, #+0]
    920          
    921              /* Wait the acknowledge */
    922              while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
   \                     ??CAN_OperatingModeRequest_12: (+1)
   \   000000C0   0x6860             LDR      R0,[R4, #+4]
   \   000000C2   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   000000C6   0x2802             CMP      R0,#+2
   \   000000C8   0xD003             BEQ.N    ??CAN_OperatingModeRequest_13
   \   000000CA   0x2F00             CMP      R7,#+0
   \   000000CC   0xD001             BEQ.N    ??CAN_OperatingModeRequest_13
    923              {
    924                timeout--;
   \   000000CE   0x1E7F             SUBS     R7,R7,#+1
   \   000000D0   0xE7F6             B.N      ??CAN_OperatingModeRequest_12
    925              }
    926              if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
   \                     ??CAN_OperatingModeRequest_13: (+1)
   \   000000D2   0x6860             LDR      R0,[R4, #+4]
   \   000000D4   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   000000D8   0x2802             CMP      R0,#+2
   \   000000DA   0xD002             BEQ.N    ??CAN_OperatingModeRequest_14
    927              {
    928                status = CAN_ModeStatus_Failed;
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x0006             MOVS     R6,R0
   \   000000E0   0xE004             B.N      ??CAN_OperatingModeRequest_6
    929              }
    930              else
    931              {
    932                status = CAN_ModeStatus_Success;
   \                     ??CAN_OperatingModeRequest_14: (+1)
   \   000000E2   0x2001             MOVS     R0,#+1
   \   000000E4   0x0006             MOVS     R6,R0
   \   000000E6   0xE001             B.N      ??CAN_OperatingModeRequest_6
    933              }
    934            }
    935            else
    936            {
    937              status = CAN_ModeStatus_Failed;
   \                     ??CAN_OperatingModeRequest_11: (+1)
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0x0006             MOVS     R6,R0
    938            }
    939          
    940            return  (uint8_t) status;
   \                     ??CAN_OperatingModeRequest_6: (+1)
   \   000000EC   0x0030             MOVS     R0,R6
   \   000000EE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F0   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    941          }
    942          
    943          /**
    944            * @brief  Enters the Sleep (low power) mode.
    945            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    946            * @retval CAN_Sleep_Ok if sleep entered, CAN_Sleep_Failed otherwise.
    947            */

   \                                 In section .text, align 2, keep-with-next
    948          uint8_t CAN_Sleep(CAN_TypeDef* CANx)
    949          {
   \                     CAN_Sleep: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    950            uint8_t sleepstatus = CAN_Sleep_Failed;
   \   00000004   0x2500             MOVS     R5,#+0
    951            
    952            /* Check the parameters */
    953            assert_param(IS_CAN_ALL_PERIPH(CANx));
   \   00000006   0x....             LDR.N    R0,??DataTable16  ;; 0x40006400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD008             BEQ.N    ??CAN_Sleep_0
   \   0000000C   0x....             LDR.N    R0,??DataTable15  ;; 0x40006800
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD005             BEQ.N    ??CAN_Sleep_0
   \   00000012   0xF240 0x31B9      MOVW     R1,#+953
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable22
   \   0000001A   0x.... 0x....      BL       assert_failed
    954              
    955            /* Request Sleep mode */
    956             CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
   \                     ??CAN_Sleep_0: (+1)
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x0840             LSRS     R0,R0,#+1
   \   00000022   0x0040             LSLS     R0,R0,#+1
   \   00000024   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000028   0x6020             STR      R0,[R4, #+0]
    957             
    958            /* Sleep mode status */
    959            if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
   \   0000002A   0x6860             LDR      R0,[R4, #+4]
   \   0000002C   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   00000030   0x2802             CMP      R0,#+2
   \   00000032   0xD101             BNE.N    ??CAN_Sleep_1
    960            {
    961              /* Sleep mode not entered */
    962              sleepstatus =  CAN_Sleep_Ok;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x0005             MOVS     R5,R0
    963            }
    964            /* return sleep mode status */
    965             return (uint8_t)sleepstatus;
   \                     ??CAN_Sleep_1: (+1)
   \   00000038   0x0028             MOVS     R0,R5
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    966          }
    967          
    968          /**
    969            * @brief  Wakes up the CAN peripheral from sleep mode .
    970            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    971            * @retval CAN_WakeUp_Ok if sleep mode left, CAN_WakeUp_Failed otherwise.
    972            */

   \                                 In section .text, align 2, keep-with-next
    973          uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
    974          {
   \                     CAN_WakeUp: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    975            uint32_t wait_slak = SLAK_TIMEOUT;
   \   00000004   0xF64F 0x75FF      MOVW     R5,#+65535
    976            uint8_t wakeupstatus = CAN_WakeUp_Failed;
   \   00000008   0x2600             MOVS     R6,#+0
    977            
    978            /* Check the parameters */
    979            assert_param(IS_CAN_ALL_PERIPH(CANx));
   \   0000000A   0x....             LDR.N    R0,??DataTable16  ;; 0x40006400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD008             BEQ.N    ??CAN_WakeUp_0
   \   00000010   0x....             LDR.N    R0,??DataTable15  ;; 0x40006800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??CAN_WakeUp_0
   \   00000016   0xF240 0x31D3      MOVW     R1,#+979
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable22
   \   0000001E   0x.... 0x....      BL       assert_failed
    980              
    981            /* Wake up request */
    982            CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
   \                     ??CAN_WakeUp_0: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000028   0x6020             STR      R0,[R4, #+0]
    983              
    984            /* Sleep mode status */
    985            while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
   \                     ??CAN_WakeUp_1: (+1)
   \   0000002A   0x6860             LDR      R0,[R4, #+4]
   \   0000002C   0x0780             LSLS     R0,R0,#+30
   \   0000002E   0xD503             BPL.N    ??CAN_WakeUp_2
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD001             BEQ.N    ??CAN_WakeUp_2
    986            {
    987             wait_slak--;
   \   00000034   0x1E6D             SUBS     R5,R5,#+1
   \   00000036   0xE7F8             B.N      ??CAN_WakeUp_1
    988            }
    989            if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
   \                     ??CAN_WakeUp_2: (+1)
   \   00000038   0x6860             LDR      R0,[R4, #+4]
   \   0000003A   0x0780             LSLS     R0,R0,#+30
   \   0000003C   0xD401             BMI.N    ??CAN_WakeUp_3
    990            {
    991             /* wake up done : Sleep mode exited */
    992              wakeupstatus = CAN_WakeUp_Ok;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x0006             MOVS     R6,R0
    993            }
    994            /* return wakeup status */
    995            return (uint8_t)wakeupstatus;
   \                     ??CAN_WakeUp_3: (+1)
   \   00000042   0x0030             MOVS     R0,R6
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0xBD70             POP      {R4-R6,PC}       ;; return
    996          }
    997          /**
    998            * @}
    999            */
   1000          
   1001          
   1002          /** @defgroup CAN_Group5 CAN Bus Error management functions
   1003           *  @brief    CAN Bus Error management functions 
   1004           *
   1005          @verbatim    
   1006           ===============================================================================
   1007                                CAN Bus Error management functions
   1008           ===============================================================================  
   1009            This section provides functions allowing to 
   1010             -  Return the CANx's last error code (LEC)
   1011             -  Return the CANx Receive Error Counter (REC)
   1012             -  Return the LSB of the 9-bit CANx Transmit Error Counter(TEC).
   1013             
   1014             @note If TEC is greater than 255, The CAN is in bus-off state.
   1015             @note if REC or TEC are greater than 96, an Error warning flag occurs.
   1016             @note if REC or TEC are greater than 127, an Error Passive Flag occurs.
   1017                                  
   1018          @endverbatim
   1019            * @{
   1020            */
   1021            
   1022          /**
   1023            * @brief  Returns the CANx's last error code (LEC).
   1024            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
   1025            * @retval Error code: 
   1026            *          - CAN_ERRORCODE_NoErr: No Error  
   1027            *          - CAN_ERRORCODE_StuffErr: Stuff Error
   1028            *          - CAN_ERRORCODE_FormErr: Form Error
   1029            *          - CAN_ERRORCODE_ACKErr : Acknowledgment Error
   1030            *          - CAN_ERRORCODE_BitRecessiveErr: Bit Recessive Error
   1031            *          - CAN_ERRORCODE_BitDominantErr: Bit Dominant Error
   1032            *          - CAN_ERRORCODE_CRCErr: CRC Error
   1033            *          - CAN_ERRORCODE_SoftwareSetErr: Software Set Error  
   1034            */

   \                                 In section .text, align 2, keep-with-next
   1035          uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)
   1036          {
   \                     CAN_GetLastErrorCode: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1037            uint8_t errorcode=0;
   \   00000004   0x2500             MOVS     R5,#+0
   1038            
   1039            /* Check the parameters */
   1040            assert_param(IS_CAN_ALL_PERIPH(CANx));
   \   00000006   0x....             LDR.N    R0,??DataTable16  ;; 0x40006400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD008             BEQ.N    ??CAN_GetLastErrorCode_0
   \   0000000C   0x....             LDR.N    R0,??DataTable15  ;; 0x40006800
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD005             BEQ.N    ??CAN_GetLastErrorCode_0
   \   00000012   0xF44F 0x6182      MOV      R1,#+1040
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable22
   \   0000001A   0x.... 0x....      BL       assert_failed
   1041            
   1042            /* Get the error code*/
   1043            errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
   \                     ??CAN_GetLastErrorCode_0: (+1)
   \   0000001E   0x69A0             LDR      R0,[R4, #+24]
   \   00000020   0xF010 0x0070      ANDS     R0,R0,#0x70
   \   00000024   0x0005             MOVS     R5,R0
   1044            
   1045            /* Return the error code*/
   1046            return errorcode;
   \   00000026   0x0028             MOVS     R0,R5
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1047          }
   1048          
   1049          /**
   1050            * @brief  Returns the CANx Receive Error Counter (REC).
   1051            * @note   In case of an error during reception, this counter is incremented 
   1052            *         by 1 or by 8 depending on the error condition as defined by the CAN 
   1053            *         standard. After every successful reception, the counter is 
   1054            *         decremented by 1 or reset to 120 if its value was higher than 128. 
   1055            *         When the counter value exceeds 127, the CAN controller enters the 
   1056            *         error passive state.  
   1057            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.  
   1058            * @retval CAN Receive Error Counter. 
   1059            */

   \                                 In section .text, align 2, keep-with-next
   1060          uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)
   1061          {
   \                     CAN_GetReceiveErrorCounter: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1062            uint8_t counter=0;
   \   00000004   0x2500             MOVS     R5,#+0
   1063            
   1064            /* Check the parameters */
   1065            assert_param(IS_CAN_ALL_PERIPH(CANx));
   \   00000006   0x....             LDR.N    R0,??DataTable16  ;; 0x40006400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD009             BEQ.N    ??CAN_GetReceiveErrorCounter_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable22_7  ;; 0x40006800
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD005             BEQ.N    ??CAN_GetReceiveErrorCounter_0
   \   00000014   0xF240 0x4129      MOVW     R1,#+1065
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable22
   \   0000001C   0x.... 0x....      BL       assert_failed
   1066            
   1067            /* Get the Receive Error Counter*/
   1068            counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
   \                     ??CAN_GetReceiveErrorCounter_0: (+1)
   \   00000020   0x69A0             LDR      R0,[R4, #+24]
   \   00000022   0x0E00             LSRS     R0,R0,#+24
   \   00000024   0x0005             MOVS     R5,R0
   1069            
   1070            /* Return the Receive Error Counter*/
   1071            return counter;
   \   00000026   0x0028             MOVS     R0,R5
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1072          }
   1073          
   1074          
   1075          /**
   1076            * @brief  Returns the LSB of the 9-bit CANx Transmit Error Counter(TEC).
   1077            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1078            * @retval LSB of the 9-bit CAN Transmit Error Counter. 
   1079            */

   \                                 In section .text, align 2, keep-with-next
   1080          uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)
   1081          {
   \                     CAN_GetLSBTransmitErrorCounter: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1082            uint8_t counter=0;
   \   00000004   0x2500             MOVS     R5,#+0
   1083            
   1084            /* Check the parameters */
   1085            assert_param(IS_CAN_ALL_PERIPH(CANx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable22_8  ;; 0x40006400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??CAN_GetLSBTransmitErrorCounter_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable22_7  ;; 0x40006800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??CAN_GetLSBTransmitErrorCounter_0
   \   00000016   0xF240 0x413D      MOVW     R1,#+1085
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable22
   \   0000001E   0x.... 0x....      BL       assert_failed
   1086            
   1087            /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
   1088            counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
   \                     ??CAN_GetLSBTransmitErrorCounter_0: (+1)
   \   00000022   0x69A0             LDR      R0,[R4, #+24]
   \   00000024   0x0C00             LSRS     R0,R0,#+16
   \   00000026   0x0005             MOVS     R5,R0
   1089            
   1090            /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
   1091            return counter;
   \   00000028   0x0028             MOVS     R0,R5
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1092          }
   1093          /**
   1094            * @}
   1095            */
   1096          
   1097          /** @defgroup CAN_Group6 Interrupts and flags management functions
   1098           *  @brief   Interrupts and flags management functions
   1099           *
   1100          @verbatim   
   1101           ===============================================================================
   1102                             Interrupts and flags management functions
   1103           ===============================================================================  
   1104          
   1105            This section provides functions allowing to configure the CAN Interrupts and 
   1106            to get the status and clear flags and Interrupts pending bits.
   1107            
   1108            The CAN provides 14 Interrupts sources and 15 Flags:
   1109          
   1110            ===============  
   1111                Flags :
   1112            ===============
   1113            The 15 flags can be divided on 4 groups: 
   1114          
   1115             A. Transmit Flags
   1116            -----------------------
   1117                  CAN_FLAG_RQCP0, 
   1118                  CAN_FLAG_RQCP1, 
   1119                  CAN_FLAG_RQCP2  : Request completed MailBoxes 0, 1 and 2  Flags
   1120                                    Set when when the last request (transmit or abort) has 
   1121                                    been performed. 
   1122          
   1123            B. Receive Flags
   1124            -----------------------
   1125          
   1126                  CAN_FLAG_FMP0,
   1127                  CAN_FLAG_FMP1   : FIFO 0 and 1 Message Pending Flags 
   1128                                    set to signal that messages are pending in the receive 
   1129                                    FIFO.
   1130                                    These Flags are cleared only by hardware. 
   1131          
   1132                  CAN_FLAG_FF0,
   1133                  CAN_FLAG_FF1    : FIFO 0 and 1 Full Flags
   1134                                    set when three messages are stored in the selected 
   1135                                    FIFO.                        
   1136          
   1137                  CAN_FLAG_FOV0              
   1138                  CAN_FLAG_FOV1   : FIFO 0 and 1 Overrun Flags
   1139                                    set when a new message has been received and passed 
   1140                                    the filter while the FIFO was full.         
   1141          
   1142            C. Operating Mode Flags
   1143            ----------------------- 
   1144                  CAN_FLAG_WKU    : Wake up Flag
   1145                                    set to signal that a SOF bit has been detected while 
   1146                                    the CAN hardware was in Sleep mode. 
   1147                  
   1148                  CAN_FLAG_SLAK   : Sleep acknowledge Flag
   1149                                    Set to signal that the CAN has entered Sleep Mode. 
   1150              
   1151            D. Error Flags
   1152            ----------------------- 
   1153                  CAN_FLAG_EWG    : Error Warning Flag
   1154                                    Set when the warning limit has been reached (Receive 
   1155                                    Error Counter or Transmit Error Counter greater than 96). 
   1156                                    This Flag is cleared only by hardware.
   1157                                      
   1158                  CAN_FLAG_EPV    : Error Passive Flag
   1159                                    Set when the Error Passive limit has been reached 
   1160                                    (Receive Error Counter or Transmit Error Counter 
   1161                                    greater than 127).
   1162                                    This Flag is cleared only by hardware.
   1163                                       
   1164                  CAN_FLAG_BOF    : Bus-Off Flag
   1165                                    set when CAN enters the bus-off state. The bus-off 
   1166                                    state is entered on TEC overflow, greater than 255.
   1167                                    This Flag is cleared only by hardware.
   1168                                             
   1169                  CAN_FLAG_LEC    : Last error code Flag
   1170                                    set If a message has been transferred (reception or
   1171                                    transmission) with error, and the error code is hold.              
   1172                                    
   1173            ===============  
   1174             Interrupts :
   1175            ===============
   1176            The 14 interrupts can be divided on 4 groups: 
   1177            
   1178             A. Transmit interrupt
   1179            -----------------------   
   1180                    CAN_IT_TME   :  Transmit mailbox empty Interrupt
   1181                                    if enabled, this interrupt source is pending when 
   1182                                    no transmit request are pending for Tx mailboxes.      
   1183          
   1184             B. Receive Interrupts
   1185            -----------------------          
   1186                  CAN_IT_FMP0,
   1187                  CAN_IT_FMP1    :  FIFO 0 and FIFO1 message pending Interrupts
   1188                                    if enabled, these interrupt sources are pending when 
   1189                                    messages are pending in the receive FIFO.
   1190                                    The corresponding interrupt pending bits are cleared 
   1191                                    only by hardware.
   1192                          
   1193                  CAN_IT_FF0,              
   1194                  CAN_IT_FF1     :  FIFO 0 and FIFO1 full Interrupts
   1195                                    if enabled, these interrupt sources are pending when
   1196                                    three messages are stored in the selected FIFO.
   1197                  
   1198                  CAN_IT_FOV0,        
   1199                  CAN_IT_FOV1    :  FIFO 0 and FIFO1 overrun Interrupts        
   1200                                    if enabled, these interrupt sources are pending when
   1201                                    a new message has been received and passed the filter
   1202                                    while the FIFO was full.
   1203          
   1204             C. Operating Mode Interrupts
   1205            -------------------------------          
   1206                  CAN_IT_WKU     :  Wake-up Interrupt
   1207                                    if enabled, this interrupt source is pending when 
   1208                                    a SOF bit has been detected while the CAN hardware was 
   1209                                    in Sleep mode.
   1210                                            
   1211                  CAN_IT_SLK     :  Sleep acknowledge Interrupt
   1212                                    if enabled, this interrupt source is pending when 
   1213                                    the CAN has entered Sleep Mode.       
   1214          
   1215             D. Error Interrupts 
   1216            -----------------------         
   1217                  CAN_IT_EWG     :  Error warning Interrupt 
   1218                                    if enabled, this interrupt source is pending when
   1219                                    the warning limit has been reached (Receive Error 
   1220                                    Counter or Transmit Error Counter=96). 
   1221                                         
   1222                  CAN_IT_EPV     :  Error passive Interrupt        
   1223                                    if enabled, this interrupt source is pending when
   1224                                    the Error Passive limit has been reached (Receive 
   1225                                    Error Counter or Transmit Error Counter>127).
   1226                                    
   1227                  CAN_IT_BOF     :  Bus-off Interrupt
   1228                                    if enabled, this interrupt source is pending when
   1229                                    CAN enters the bus-off state. The bus-off state is 
   1230                                    entered on TEC overflow, greater than 255.
   1231                                    This Flag is cleared only by hardware.
   1232                                            
   1233                  CAN_IT_LEC     :  Last error code Interrupt        
   1234                                    if enabled, this interrupt source is pending  when
   1235                                    a message has been transferred (reception or
   1236                                    transmission) with error, and the error code is hold.
   1237                                    
   1238                  CAN_IT_ERR     :  Error Interrupt
   1239                                    if enabled, this interrupt source is pending when 
   1240                                    an error condition is pending.      
   1241                                
   1242          
   1243            Managing the CAN controller events :
   1244            ------------------------------------ 
   1245            The user should identify which mode will be used in his application to manage 
   1246            the CAN controller events: Polling mode or Interrupt mode.
   1247            
   1248            1.  In the Polling Mode it is advised to use the following functions:
   1249                - CAN_GetFlagStatus() : to check if flags events occur. 
   1250                - CAN_ClearFlag()     : to clear the flags events.
   1251            
   1252          
   1253            
   1254            2.  In the Interrupt Mode it is advised to use the following functions:
   1255                - CAN_ITConfig()       : to enable or disable the interrupt source.
   1256                - CAN_GetITStatus()    : to check if Interrupt occurs.
   1257                - CAN_ClearITPendingBit() : to clear the Interrupt pending Bit (corresponding Flag).
   1258                @note  This function has no impact on CAN_IT_FMP0 and CAN_IT_FMP1 Interrupts 
   1259                       pending bits since there are cleared only by hardware. 
   1260            
   1261          @endverbatim
   1262            * @{
   1263            */ 
   1264          /**
   1265            * @brief  Enables or disables the specified CANx interrupts.
   1266            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1267            * @param  CAN_IT: specifies the CAN interrupt sources to be enabled or disabled.
   1268            *          This parameter can be: 
   1269            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt 
   1270            *            @arg CAN_IT_FMP0: FIFO 0 message pending Interrupt 
   1271            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1272            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1273            *            @arg CAN_IT_FMP1: FIFO 1 message pending Interrupt 
   1274            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1275            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1276            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1277            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1278            *            @arg CAN_IT_EWG: Error warning Interrupt
   1279            *            @arg CAN_IT_EPV: Error passive Interrupt
   1280            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1281            *            @arg CAN_IT_LEC: Last error code Interrupt
   1282            *            @arg CAN_IT_ERR: Error Interrupt
   1283            * @param  NewState: new state of the CAN interrupts.
   1284            *          This parameter can be: ENABLE or DISABLE.
   1285            * @retval None
   1286            */

   \                                 In section .text, align 2, keep-with-next
   1287          void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
   1288          {
   \                     CAN_ITConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1289            /* Check the parameters */
   1290            assert_param(IS_CAN_ALL_PERIPH(CANx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable22_8  ;; 0x40006400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD009             BEQ.N    ??CAN_ITConfig_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable22_7  ;; 0x40006800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD005             BEQ.N    ??CAN_ITConfig_0
   \   00000018   0xF240 0x510A      MOVW     R1,#+1290
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000020   0x.... 0x....      BL       assert_failed
   1291            assert_param(IS_CAN_IT(CAN_IT));
   \                     ??CAN_ITConfig_0: (+1)
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD026             BEQ.N    ??CAN_ITConfig_1
   \   00000028   0x2D02             CMP      R5,#+2
   \   0000002A   0xD024             BEQ.N    ??CAN_ITConfig_1
   \   0000002C   0x2D04             CMP      R5,#+4
   \   0000002E   0xD022             BEQ.N    ??CAN_ITConfig_1
   \   00000030   0x2D08             CMP      R5,#+8
   \   00000032   0xD020             BEQ.N    ??CAN_ITConfig_1
   \   00000034   0x2D10             CMP      R5,#+16
   \   00000036   0xD01E             BEQ.N    ??CAN_ITConfig_1
   \   00000038   0x2D20             CMP      R5,#+32
   \   0000003A   0xD01C             BEQ.N    ??CAN_ITConfig_1
   \   0000003C   0x2D40             CMP      R5,#+64
   \   0000003E   0xD01A             BEQ.N    ??CAN_ITConfig_1
   \   00000040   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000044   0xD017             BEQ.N    ??CAN_ITConfig_1
   \   00000046   0xF5B5 0x7F00      CMP      R5,#+512
   \   0000004A   0xD014             BEQ.N    ??CAN_ITConfig_1
   \   0000004C   0xF5B5 0x6F80      CMP      R5,#+1024
   \   00000050   0xD011             BEQ.N    ??CAN_ITConfig_1
   \   00000052   0xF5B5 0x6F00      CMP      R5,#+2048
   \   00000056   0xD00E             BEQ.N    ??CAN_ITConfig_1
   \   00000058   0xF5B5 0x4F00      CMP      R5,#+32768
   \   0000005C   0xD00B             BEQ.N    ??CAN_ITConfig_1
   \   0000005E   0xF5B5 0x3F80      CMP      R5,#+65536
   \   00000062   0xD008             BEQ.N    ??CAN_ITConfig_1
   \   00000064   0xF5B5 0x3F00      CMP      R5,#+131072
   \   00000068   0xD005             BEQ.N    ??CAN_ITConfig_1
   \   0000006A   0xF240 0x510B      MOVW     R1,#+1291
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000072   0x.... 0x....      BL       assert_failed
   1292            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??CAN_ITConfig_1: (+1)
   \   00000076   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000078   0x2E00             CMP      R6,#+0
   \   0000007A   0xD008             BEQ.N    ??CAN_ITConfig_2
   \   0000007C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000007E   0x2E01             CMP      R6,#+1
   \   00000080   0xD005             BEQ.N    ??CAN_ITConfig_2
   \   00000082   0xF240 0x510C      MOVW     R1,#+1292
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable22
   \   0000008A   0x.... 0x....      BL       assert_failed
   1293          
   1294            if (NewState != DISABLE)
   \                     ??CAN_ITConfig_2: (+1)
   \   0000008E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000090   0x2E00             CMP      R6,#+0
   \   00000092   0xD003             BEQ.N    ??CAN_ITConfig_3
   1295            {
   1296              /* Enable the selected CANx interrupt */
   1297              CANx->IER |= CAN_IT;
   \   00000094   0x6960             LDR      R0,[R4, #+20]
   \   00000096   0x4328             ORRS     R0,R5,R0
   \   00000098   0x6160             STR      R0,[R4, #+20]
   \   0000009A   0xE002             B.N      ??CAN_ITConfig_4
   1298            }
   1299            else
   1300            {
   1301              /* Disable the selected CANx interrupt */
   1302              CANx->IER &= ~CAN_IT;
   \                     ??CAN_ITConfig_3: (+1)
   \   0000009C   0x6960             LDR      R0,[R4, #+20]
   \   0000009E   0x43A8             BICS     R0,R0,R5
   \   000000A0   0x6160             STR      R0,[R4, #+20]
   1303            }
   1304          }
   \                     ??CAN_ITConfig_4: (+1)
   \   000000A2   0xBD70             POP      {R4-R6,PC}       ;; return
   1305          /**
   1306            * @brief  Checks whether the specified CAN flag is set or not.
   1307            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1308            * @param  CAN_FLAG: specifies the flag to check.
   1309            *          This parameter can be one of the following values:
   1310            *            @arg CAN_FLAG_RQCP0: Request MailBox0 Flag
   1311            *            @arg CAN_FLAG_RQCP1: Request MailBox1 Flag
   1312            *            @arg CAN_FLAG_RQCP2: Request MailBox2 Flag
   1313            *            @arg CAN_FLAG_FMP0: FIFO 0 Message Pending Flag   
   1314            *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag       
   1315            *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag 
   1316            *            @arg CAN_FLAG_FMP1: FIFO 1 Message Pending Flag   
   1317            *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag        
   1318            *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag     
   1319            *            @arg CAN_FLAG_WKU: Wake up Flag
   1320            *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag 
   1321            *            @arg CAN_FLAG_EWG: Error Warning Flag
   1322            *            @arg CAN_FLAG_EPV: Error Passive Flag  
   1323            *            @arg CAN_FLAG_BOF: Bus-Off Flag    
   1324            *            @arg CAN_FLAG_LEC: Last error code Flag      
   1325            * @retval The new state of CAN_FLAG (SET or RESET).
   1326            */

   \                                 In section .text, align 2, keep-with-next
   1327          FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
   1328          {
   \                     CAN_GetFlagStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1329            FlagStatus bitstatus = RESET;
   \   00000006   0x2600             MOVS     R6,#+0
   1330            
   1331            /* Check the parameters */
   1332            assert_param(IS_CAN_ALL_PERIPH(CANx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable22_8  ;; 0x40006400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD009             BEQ.N    ??CAN_GetFlagStatus_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable22_7  ;; 0x40006800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD005             BEQ.N    ??CAN_GetFlagStatus_0
   \   00000018   0xF240 0x5134      MOVW     R1,#+1332
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000020   0x.... 0x....      BL       assert_failed
   1333            assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
   \                     ??CAN_GetFlagStatus_0: (+1)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable22_9  ;; 0x30f00070
   \   00000028   0x4285             CMP      R5,R0
   \   0000002A   0xD03D             BEQ.N    ??CAN_GetFlagStatus_1
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable22_10  ;; 0x10f00004
   \   00000030   0x4285             CMP      R5,R0
   \   00000032   0xD039             BEQ.N    ??CAN_GetFlagStatus_1
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable22_11  ;; 0x10f00002
   \   00000038   0x4285             CMP      R5,R0
   \   0000003A   0xD035             BEQ.N    ??CAN_GetFlagStatus_1
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable22_12  ;; 0x10f00001
   \   00000040   0x4285             CMP      R5,R0
   \   00000042   0xD031             BEQ.N    ??CAN_GetFlagStatus_1
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable22_13  ;; 0x31000008
   \   00000048   0x4285             CMP      R5,R0
   \   0000004A   0xD02D             BEQ.N    ??CAN_GetFlagStatus_1
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable22_14  ;; 0x32000010
   \   00000050   0x4285             CMP      R5,R0
   \   00000052   0xD029             BEQ.N    ??CAN_GetFlagStatus_1
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable22_15  ;; 0x32000008
   \   00000058   0x4285             CMP      R5,R0
   \   0000005A   0xD025             BEQ.N    ??CAN_GetFlagStatus_1
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable22_16  ;; 0x12000003
   \   00000060   0x4285             CMP      R5,R0
   \   00000062   0xD021             BEQ.N    ??CAN_GetFlagStatus_1
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable22_17  ;; 0x34000010
   \   00000068   0x4285             CMP      R5,R0
   \   0000006A   0xD01D             BEQ.N    ??CAN_GetFlagStatus_1
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable22_18  ;; 0x34000008
   \   00000070   0x4285             CMP      R5,R0
   \   00000072   0xD019             BEQ.N    ??CAN_GetFlagStatus_1
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable22_19  ;; 0x14000003
   \   00000078   0x4285             CMP      R5,R0
   \   0000007A   0xD015             BEQ.N    ??CAN_GetFlagStatus_1
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable22_20  ;; 0x38010000
   \   00000080   0x4285             CMP      R5,R0
   \   00000082   0xD011             BEQ.N    ??CAN_GetFlagStatus_1
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable22_21  ;; 0x38000100
   \   00000088   0x4285             CMP      R5,R0
   \   0000008A   0xD00D             BEQ.N    ??CAN_GetFlagStatus_1
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable22_22  ;; 0x38000001
   \   00000090   0x4285             CMP      R5,R0
   \   00000092   0xD009             BEQ.N    ??CAN_GetFlagStatus_1
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable22_23  ;; 0x31000012
   \   00000098   0x4285             CMP      R5,R0
   \   0000009A   0xD005             BEQ.N    ??CAN_GetFlagStatus_1
   \   0000009C   0xF240 0x5135      MOVW     R1,#+1333
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable22
   \   000000A4   0x.... 0x....      BL       assert_failed
   1334            
   1335          
   1336            if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_1: (+1)
   \   000000A8   0xF415 0x0F70      TST      R5,#0xF00000
   \   000000AC   0xD009             BEQ.N    ??CAN_GetFlagStatus_2
   1337            { 
   1338              /* Check the status of the specified CAN flag */
   1339              if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \   000000AE   0x69A0             LDR      R0,[R4, #+24]
   \   000000B0   0x4028             ANDS     R0,R5,R0
   \   000000B2   0x0300             LSLS     R0,R0,#+12
   \   000000B4   0xD002             BEQ.N    ??CAN_GetFlagStatus_3
   1340              { 
   1341                /* CAN_FLAG is set */
   1342                bitstatus = SET;
   \   000000B6   0x2001             MOVS     R0,#+1
   \   000000B8   0x0006             MOVS     R6,R0
   \   000000BA   0xE02F             B.N      ??CAN_GetFlagStatus_4
   1343              }
   1344              else
   1345              { 
   1346                /* CAN_FLAG is reset */
   1347                bitstatus = RESET;
   \                     ??CAN_GetFlagStatus_3: (+1)
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x0006             MOVS     R6,R0
   \   000000C0   0xE02C             B.N      ??CAN_GetFlagStatus_4
   1348              }
   1349            }
   1350            else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_2: (+1)
   \   000000C2   0x01E8             LSLS     R0,R5,#+7
   \   000000C4   0xD509             BPL.N    ??CAN_GetFlagStatus_5
   1351            { 
   1352              /* Check the status of the specified CAN flag */
   1353              if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \   000000C6   0x6860             LDR      R0,[R4, #+4]
   \   000000C8   0x4028             ANDS     R0,R5,R0
   \   000000CA   0x0300             LSLS     R0,R0,#+12
   \   000000CC   0xD002             BEQ.N    ??CAN_GetFlagStatus_6
   1354              { 
   1355                /* CAN_FLAG is set */
   1356                bitstatus = SET;
   \   000000CE   0x2001             MOVS     R0,#+1
   \   000000D0   0x0006             MOVS     R6,R0
   \   000000D2   0xE023             B.N      ??CAN_GetFlagStatus_4
   1357              }
   1358              else
   1359              { 
   1360                /* CAN_FLAG is reset */
   1361                bitstatus = RESET;
   \                     ??CAN_GetFlagStatus_6: (+1)
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0x0006             MOVS     R6,R0
   \   000000D8   0xE020             B.N      ??CAN_GetFlagStatus_4
   1362              }
   1363            }
   1364            else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_5: (+1)
   \   000000DA   0x0128             LSLS     R0,R5,#+4
   \   000000DC   0xD509             BPL.N    ??CAN_GetFlagStatus_7
   1365            { 
   1366              /* Check the status of the specified CAN flag */
   1367              if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \   000000DE   0x68A0             LDR      R0,[R4, #+8]
   \   000000E0   0x4028             ANDS     R0,R5,R0
   \   000000E2   0x0300             LSLS     R0,R0,#+12
   \   000000E4   0xD002             BEQ.N    ??CAN_GetFlagStatus_8
   1368              { 
   1369                /* CAN_FLAG is set */
   1370                bitstatus = SET;
   \   000000E6   0x2001             MOVS     R0,#+1
   \   000000E8   0x0006             MOVS     R6,R0
   \   000000EA   0xE017             B.N      ??CAN_GetFlagStatus_4
   1371              }
   1372              else
   1373              { 
   1374                /* CAN_FLAG is reset */
   1375                bitstatus = RESET;
   \                     ??CAN_GetFlagStatus_8: (+1)
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0x0006             MOVS     R6,R0
   \   000000F0   0xE014             B.N      ??CAN_GetFlagStatus_4
   1376              }
   1377            }
   1378            else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_7: (+1)
   \   000000F2   0x01A8             LSLS     R0,R5,#+6
   \   000000F4   0xD509             BPL.N    ??CAN_GetFlagStatus_9
   1379            { 
   1380              /* Check the status of the specified CAN flag */
   1381              if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \   000000F6   0x68E0             LDR      R0,[R4, #+12]
   \   000000F8   0x4028             ANDS     R0,R5,R0
   \   000000FA   0x0300             LSLS     R0,R0,#+12
   \   000000FC   0xD002             BEQ.N    ??CAN_GetFlagStatus_10
   1382              { 
   1383                /* CAN_FLAG is set */
   1384                bitstatus = SET;
   \   000000FE   0x2001             MOVS     R0,#+1
   \   00000100   0x0006             MOVS     R6,R0
   \   00000102   0xE00B             B.N      ??CAN_GetFlagStatus_4
   1385              }
   1386              else
   1387              { 
   1388                /* CAN_FLAG is reset */
   1389                bitstatus = RESET;
   \                     ??CAN_GetFlagStatus_10: (+1)
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0x0006             MOVS     R6,R0
   \   00000108   0xE008             B.N      ??CAN_GetFlagStatus_4
   1390              }
   1391            }
   1392            else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
   1393            { 
   1394              /* Check the status of the specified CAN flag */
   1395              if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_9: (+1)
   \   0000010A   0x6920             LDR      R0,[R4, #+16]
   \   0000010C   0x4028             ANDS     R0,R5,R0
   \   0000010E   0x0300             LSLS     R0,R0,#+12
   \   00000110   0xD002             BEQ.N    ??CAN_GetFlagStatus_11
   1396              { 
   1397                /* CAN_FLAG is set */
   1398                bitstatus = SET;
   \   00000112   0x2001             MOVS     R0,#+1
   \   00000114   0x0006             MOVS     R6,R0
   \   00000116   0xE001             B.N      ??CAN_GetFlagStatus_4
   1399              }
   1400              else
   1401              { 
   1402                /* CAN_FLAG is reset */
   1403                bitstatus = RESET;
   \                     ??CAN_GetFlagStatus_11: (+1)
   \   00000118   0x2000             MOVS     R0,#+0
   \   0000011A   0x0006             MOVS     R6,R0
   1404              }
   1405            }
   1406            /* Return the CAN_FLAG status */
   1407            return  bitstatus;
   \                     ??CAN_GetFlagStatus_4: (+1)
   \   0000011C   0x0030             MOVS     R0,R6
   \   0000011E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000120   0xBD70             POP      {R4-R6,PC}       ;; return
   1408          }
   1409          
   1410          /**
   1411            * @brief  Clears the CAN's pending flags.
   1412            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1413            * @param  CAN_FLAG: specifies the flag to clear.
   1414            *          This parameter can be one of the following values:
   1415            *            @arg CAN_FLAG_RQCP0: Request MailBox0 Flag
   1416            *            @arg CAN_FLAG_RQCP1: Request MailBox1 Flag
   1417            *            @arg CAN_FLAG_RQCP2: Request MailBox2 Flag 
   1418            *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag       
   1419            *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag  
   1420            *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag        
   1421            *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag     
   1422            *            @arg CAN_FLAG_WKU: Wake up Flag
   1423            *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag    
   1424            *            @arg CAN_FLAG_LEC: Last error code Flag        
   1425            * @retval None
   1426            */

   \                                 In section .text, align 2, keep-with-next
   1427          void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
   1428          {
   \                     CAN_ClearFlag: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1429            uint32_t flagtmp=0;
   \   00000006   0x2600             MOVS     R6,#+0
   1430            /* Check the parameters */
   1431            assert_param(IS_CAN_ALL_PERIPH(CANx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable22_8  ;; 0x40006400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD009             BEQ.N    ??CAN_ClearFlag_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable22_7  ;; 0x40006800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD005             BEQ.N    ??CAN_ClearFlag_0
   \   00000018   0xF240 0x5197      MOVW     R1,#+1431
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000020   0x.... 0x....      BL       assert_failed
   1432            assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
   \                     ??CAN_ClearFlag_0: (+1)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable22_9  ;; 0x30f00070
   \   00000028   0x4285             CMP      R5,R0
   \   0000002A   0xD025             BEQ.N    ??CAN_ClearFlag_1
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable22_20  ;; 0x38010000
   \   00000030   0x4285             CMP      R5,R0
   \   00000032   0xD021             BEQ.N    ??CAN_ClearFlag_1
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable22_21  ;; 0x38000100
   \   00000038   0x4285             CMP      R5,R0
   \   0000003A   0xD01D             BEQ.N    ??CAN_ClearFlag_1
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable22_22  ;; 0x38000001
   \   00000040   0x4285             CMP      R5,R0
   \   00000042   0xD019             BEQ.N    ??CAN_ClearFlag_1
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable22_15  ;; 0x32000008
   \   00000048   0x4285             CMP      R5,R0
   \   0000004A   0xD015             BEQ.N    ??CAN_ClearFlag_1
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable22_14  ;; 0x32000010
   \   00000050   0x4285             CMP      R5,R0
   \   00000052   0xD011             BEQ.N    ??CAN_ClearFlag_1
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable22_18  ;; 0x34000008
   \   00000058   0x4285             CMP      R5,R0
   \   0000005A   0xD00D             BEQ.N    ??CAN_ClearFlag_1
   \   0000005C   0x....             LDR.N    R0,??DataTable22_17  ;; 0x34000010
   \   0000005E   0x4285             CMP      R5,R0
   \   00000060   0xD00A             BEQ.N    ??CAN_ClearFlag_1
   \   00000062   0x....             LDR.N    R0,??DataTable22_13  ;; 0x31000008
   \   00000064   0x4285             CMP      R5,R0
   \   00000066   0xD007             BEQ.N    ??CAN_ClearFlag_1
   \   00000068   0x....             LDR.N    R0,??DataTable22_23  ;; 0x31000012
   \   0000006A   0x4285             CMP      R5,R0
   \   0000006C   0xD004             BEQ.N    ??CAN_ClearFlag_1
   \   0000006E   0xF44F 0x61B3      MOV      R1,#+1432
   \   00000072   0x....             LDR.N    R0,??DataTable22
   \   00000074   0x.... 0x....      BL       assert_failed
   1433            
   1434            if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
   \                     ??CAN_ClearFlag_1: (+1)
   \   00000078   0x....             LDR.N    R0,??DataTable22_9  ;; 0x30f00070
   \   0000007A   0x4285             CMP      R5,R0
   \   0000007C   0xD102             BNE.N    ??CAN_ClearFlag_2
   1435            {
   1436              /* Clear the selected CAN flags */
   1437              CANx->ESR = (uint32_t)RESET;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x61A0             STR      R0,[R4, #+24]
   \   00000082   0xE00F             B.N      ??CAN_ClearFlag_3
   1438            }
   1439            else /* MSR or TSR or RF0R or RF1R */
   1440            {
   1441              flagtmp = CAN_FLAG & 0x000FFFFF;
   \                     ??CAN_ClearFlag_2: (+1)
   \   00000084   0x0328             LSLS     R0,R5,#+12       ;; ZeroExtS R0,R5,#+12,#+12
   \   00000086   0x0B00             LSRS     R0,R0,#+12
   \   00000088   0x0006             MOVS     R6,R0
   1442          
   1443              if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
   \   0000008A   0x01A8             LSLS     R0,R5,#+6
   \   0000008C   0xD501             BPL.N    ??CAN_ClearFlag_4
   1444              {
   1445                /* Receive Flags */
   1446                CANx->RF0R = (uint32_t)(flagtmp);
   \   0000008E   0x60E6             STR      R6,[R4, #+12]
   \   00000090   0xE008             B.N      ??CAN_ClearFlag_3
   1447              }
   1448              else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
   \                     ??CAN_ClearFlag_4: (+1)
   \   00000092   0x0168             LSLS     R0,R5,#+5
   \   00000094   0xD501             BPL.N    ??CAN_ClearFlag_5
   1449              {
   1450                /* Receive Flags */
   1451                CANx->RF1R = (uint32_t)(flagtmp);
   \   00000096   0x6126             STR      R6,[R4, #+16]
   \   00000098   0xE004             B.N      ??CAN_ClearFlag_3
   1452              }
   1453              else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
   \                     ??CAN_ClearFlag_5: (+1)
   \   0000009A   0x0128             LSLS     R0,R5,#+4
   \   0000009C   0xD501             BPL.N    ??CAN_ClearFlag_6
   1454              {
   1455                /* Transmit Flags */
   1456                CANx->TSR = (uint32_t)(flagtmp);
   \   0000009E   0x60A6             STR      R6,[R4, #+8]
   \   000000A0   0xE000             B.N      ??CAN_ClearFlag_3
   1457              }
   1458              else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
   1459              {
   1460                /* Operating mode Flags */
   1461                CANx->MSR = (uint32_t)(flagtmp);
   \                     ??CAN_ClearFlag_6: (+1)
   \   000000A2   0x6066             STR      R6,[R4, #+4]
   1462              }
   1463            }
   1464          }
   \                     ??CAN_ClearFlag_3: (+1)
   \   000000A4   0xBD70             POP      {R4-R6,PC}       ;; return
   1465          
   1466          /**
   1467            * @brief  Checks whether the specified CANx interrupt has occurred or not.
   1468            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1469            * @param  CAN_IT: specifies the CAN interrupt source to check.
   1470            *          This parameter can be one of the following values:
   1471            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt 
   1472            *            @arg CAN_IT_FMP0: FIFO 0 message pending Interrupt 
   1473            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1474            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1475            *            @arg CAN_IT_FMP1: FIFO 1 message pending Interrupt 
   1476            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1477            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1478            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1479            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1480            *            @arg CAN_IT_EWG: Error warning Interrupt
   1481            *            @arg CAN_IT_EPV: Error passive Interrupt
   1482            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1483            *            @arg CAN_IT_LEC: Last error code Interrupt
   1484            *            @arg CAN_IT_ERR: Error Interrupt
   1485            * @retval The current state of CAN_IT (SET or RESET).
   1486            */

   \                                 In section .text, align 2, keep-with-next
   1487          ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
   1488          {
   \                     CAN_GetITStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1489            ITStatus itstatus = RESET;
   \   00000006   0x2600             MOVS     R6,#+0
   1490            /* Check the parameters */
   1491            assert_param(IS_CAN_ALL_PERIPH(CANx));
   \   00000008   0x....             LDR.N    R0,??DataTable22_8  ;; 0x40006400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD007             BEQ.N    ??CAN_GetITStatus_0
   \   0000000E   0x....             LDR.N    R0,??DataTable22_7  ;; 0x40006800
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD004             BEQ.N    ??CAN_GetITStatus_0
   \   00000014   0xF240 0x51D3      MOVW     R1,#+1491
   \   00000018   0x....             LDR.N    R0,??DataTable22
   \   0000001A   0x.... 0x....      BL       assert_failed
   1492            assert_param(IS_CAN_IT(CAN_IT));
   \                     ??CAN_GetITStatus_0: (+1)
   \   0000001E   0x2D01             CMP      R5,#+1
   \   00000020   0xD025             BEQ.N    ??CAN_GetITStatus_1
   \   00000022   0x2D02             CMP      R5,#+2
   \   00000024   0xD023             BEQ.N    ??CAN_GetITStatus_1
   \   00000026   0x2D04             CMP      R5,#+4
   \   00000028   0xD021             BEQ.N    ??CAN_GetITStatus_1
   \   0000002A   0x2D08             CMP      R5,#+8
   \   0000002C   0xD01F             BEQ.N    ??CAN_GetITStatus_1
   \   0000002E   0x2D10             CMP      R5,#+16
   \   00000030   0xD01D             BEQ.N    ??CAN_GetITStatus_1
   \   00000032   0x2D20             CMP      R5,#+32
   \   00000034   0xD01B             BEQ.N    ??CAN_GetITStatus_1
   \   00000036   0x2D40             CMP      R5,#+64
   \   00000038   0xD019             BEQ.N    ??CAN_GetITStatus_1
   \   0000003A   0xF5B5 0x7F80      CMP      R5,#+256
   \   0000003E   0xD016             BEQ.N    ??CAN_GetITStatus_1
   \   00000040   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000044   0xD013             BEQ.N    ??CAN_GetITStatus_1
   \   00000046   0xF5B5 0x6F80      CMP      R5,#+1024
   \   0000004A   0xD010             BEQ.N    ??CAN_GetITStatus_1
   \   0000004C   0xF5B5 0x6F00      CMP      R5,#+2048
   \   00000050   0xD00D             BEQ.N    ??CAN_GetITStatus_1
   \   00000052   0xF5B5 0x4F00      CMP      R5,#+32768
   \   00000056   0xD00A             BEQ.N    ??CAN_GetITStatus_1
   \   00000058   0xF5B5 0x3F80      CMP      R5,#+65536
   \   0000005C   0xD007             BEQ.N    ??CAN_GetITStatus_1
   \   0000005E   0xF5B5 0x3F00      CMP      R5,#+131072
   \   00000062   0xD004             BEQ.N    ??CAN_GetITStatus_1
   \   00000064   0xF240 0x51D4      MOVW     R1,#+1492
   \   00000068   0x....             LDR.N    R0,??DataTable22
   \   0000006A   0x.... 0x....      BL       assert_failed
   1493            
   1494            /* check the interrupt enable bit */
   1495           if((CANx->IER & CAN_IT) != RESET)
   \                     ??CAN_GetITStatus_1: (+1)
   \   0000006E   0x6960             LDR      R0,[R4, #+20]
   \   00000070   0x4228             TST      R0,R5
   \   00000072   0xD07B             BEQ.N    ??CAN_GetITStatus_2
   1496           {
   1497             /* in case the Interrupt is enabled, .... */
   1498              switch (CAN_IT)
   \   00000074   0x0028             MOVS     R0,R5
   \   00000076   0x2801             CMP      R0,#+1
   \   00000078   0xD021             BEQ.N    ??CAN_GetITStatus_3
   \   0000007A   0x2802             CMP      R0,#+2
   \   0000007C   0xD025             BEQ.N    ??CAN_GetITStatus_4
   \   0000007E   0x2804             CMP      R0,#+4
   \   00000080   0xD029             BEQ.N    ??CAN_GetITStatus_5
   \   00000082   0x2808             CMP      R0,#+8
   \   00000084   0xD02D             BEQ.N    ??CAN_GetITStatus_6
   \   00000086   0x2810             CMP      R0,#+16
   \   00000088   0xD031             BEQ.N    ??CAN_GetITStatus_7
   \   0000008A   0x2820             CMP      R0,#+32
   \   0000008C   0xD035             BEQ.N    ??CAN_GetITStatus_8
   \   0000008E   0x2840             CMP      R0,#+64
   \   00000090   0xD039             BEQ.N    ??CAN_GetITStatus_9
   \   00000092   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000096   0xD048             BEQ.N    ??CAN_GetITStatus_10
   \   00000098   0xF5B0 0x7F00      CMP      R0,#+512
   \   0000009C   0xD04B             BEQ.N    ??CAN_GetITStatus_11
   \   0000009E   0xF5B0 0x6F80      CMP      R0,#+1024
   \   000000A2   0xD04E             BEQ.N    ??CAN_GetITStatus_12
   \   000000A4   0xF5B0 0x6F00      CMP      R0,#+2048
   \   000000A8   0xD051             BEQ.N    ??CAN_GetITStatus_13
   \   000000AA   0xF5B0 0x4F00      CMP      R0,#+32768
   \   000000AE   0xD054             BEQ.N    ??CAN_GetITStatus_14
   \   000000B0   0xF5B0 0x3F80      CMP      R0,#+65536
   \   000000B4   0xD02D             BEQ.N    ??CAN_GetITStatus_15
   \   000000B6   0xF5B0 0x3F00      CMP      R0,#+131072
   \   000000BA   0xD030             BEQ.N    ??CAN_GetITStatus_16
   \   000000BC   0xE053             B.N      ??CAN_GetITStatus_17
   1499              {
   1500                case CAN_IT_TME:
   1501                  /* Check CAN_TSR_RQCPx bits */
   1502                  itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
   \                     ??CAN_GetITStatus_3: (+1)
   \   000000BE   0x....             LDR.N    R1,??DataTable22_24  ;; 0x10101
   \   000000C0   0x68A0             LDR      R0,[R4, #+8]
   \   000000C2   0x.... 0x....      BL       CheckITStatus
   \   000000C6   0x0006             MOVS     R6,R0
   1503                  break;
   \   000000C8   0xE052             B.N      ??CAN_GetITStatus_18
   1504                case CAN_IT_FMP0:
   1505                  /* Check CAN_RF0R_FMP0 bit */
   1506                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
   \                     ??CAN_GetITStatus_4: (+1)
   \   000000CA   0x2103             MOVS     R1,#+3
   \   000000CC   0x68E0             LDR      R0,[R4, #+12]
   \   000000CE   0x.... 0x....      BL       CheckITStatus
   \   000000D2   0x0006             MOVS     R6,R0
   1507                  break;
   \   000000D4   0xE04C             B.N      ??CAN_GetITStatus_18
   1508                case CAN_IT_FF0:
   1509                  /* Check CAN_RF0R_FULL0 bit */
   1510                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
   \                     ??CAN_GetITStatus_5: (+1)
   \   000000D6   0x2108             MOVS     R1,#+8
   \   000000D8   0x68E0             LDR      R0,[R4, #+12]
   \   000000DA   0x.... 0x....      BL       CheckITStatus
   \   000000DE   0x0006             MOVS     R6,R0
   1511                  break;
   \   000000E0   0xE046             B.N      ??CAN_GetITStatus_18
   1512                case CAN_IT_FOV0:
   1513                  /* Check CAN_RF0R_FOVR0 bit */
   1514                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
   \                     ??CAN_GetITStatus_6: (+1)
   \   000000E2   0x2110             MOVS     R1,#+16
   \   000000E4   0x68E0             LDR      R0,[R4, #+12]
   \   000000E6   0x.... 0x....      BL       CheckITStatus
   \   000000EA   0x0006             MOVS     R6,R0
   1515                  break;
   \   000000EC   0xE040             B.N      ??CAN_GetITStatus_18
   1516                case CAN_IT_FMP1:
   1517                  /* Check CAN_RF1R_FMP1 bit */
   1518                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
   \                     ??CAN_GetITStatus_7: (+1)
   \   000000EE   0x2103             MOVS     R1,#+3
   \   000000F0   0x6920             LDR      R0,[R4, #+16]
   \   000000F2   0x.... 0x....      BL       CheckITStatus
   \   000000F6   0x0006             MOVS     R6,R0
   1519                  break;
   \   000000F8   0xE03A             B.N      ??CAN_GetITStatus_18
   1520                case CAN_IT_FF1:
   1521                  /* Check CAN_RF1R_FULL1 bit */
   1522                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
   \                     ??CAN_GetITStatus_8: (+1)
   \   000000FA   0x2108             MOVS     R1,#+8
   \   000000FC   0x6920             LDR      R0,[R4, #+16]
   \   000000FE   0x.... 0x....      BL       CheckITStatus
   \   00000102   0x0006             MOVS     R6,R0
   1523                  break;
   \   00000104   0xE034             B.N      ??CAN_GetITStatus_18
   1524                case CAN_IT_FOV1:
   1525                  /* Check CAN_RF1R_FOVR1 bit */
   1526                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
   \                     ??CAN_GetITStatus_9: (+1)
   \   00000106   0x2110             MOVS     R1,#+16
   \   00000108   0x6920             LDR      R0,[R4, #+16]
   \   0000010A   0x.... 0x....      BL       CheckITStatus
   \   0000010E   0x0006             MOVS     R6,R0
   1527                  break;
   \   00000110   0xE02E             B.N      ??CAN_GetITStatus_18
   1528                case CAN_IT_WKU:
   1529                  /* Check CAN_MSR_WKUI bit */
   1530                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
   \                     ??CAN_GetITStatus_15: (+1)
   \   00000112   0x2108             MOVS     R1,#+8
   \   00000114   0x6860             LDR      R0,[R4, #+4]
   \   00000116   0x.... 0x....      BL       CheckITStatus
   \   0000011A   0x0006             MOVS     R6,R0
   1531                  break;
   \   0000011C   0xE028             B.N      ??CAN_GetITStatus_18
   1532                case CAN_IT_SLK:
   1533                  /* Check CAN_MSR_SLAKI bit */
   1534                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
   \                     ??CAN_GetITStatus_16: (+1)
   \   0000011E   0x2110             MOVS     R1,#+16
   \   00000120   0x6860             LDR      R0,[R4, #+4]
   \   00000122   0x.... 0x....      BL       CheckITStatus
   \   00000126   0x0006             MOVS     R6,R0
   1535                  break;
   \   00000128   0xE022             B.N      ??CAN_GetITStatus_18
   1536                case CAN_IT_EWG:
   1537                  /* Check CAN_ESR_EWGF bit */
   1538                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
   \                     ??CAN_GetITStatus_10: (+1)
   \   0000012A   0x2101             MOVS     R1,#+1
   \   0000012C   0x69A0             LDR      R0,[R4, #+24]
   \   0000012E   0x.... 0x....      BL       CheckITStatus
   \   00000132   0x0006             MOVS     R6,R0
   1539                  break;
   \   00000134   0xE01C             B.N      ??CAN_GetITStatus_18
   1540                case CAN_IT_EPV:
   1541                  /* Check CAN_ESR_EPVF bit */
   1542                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
   \                     ??CAN_GetITStatus_11: (+1)
   \   00000136   0x2102             MOVS     R1,#+2
   \   00000138   0x69A0             LDR      R0,[R4, #+24]
   \   0000013A   0x.... 0x....      BL       CheckITStatus
   \   0000013E   0x0006             MOVS     R6,R0
   1543                  break;
   \   00000140   0xE016             B.N      ??CAN_GetITStatus_18
   1544                case CAN_IT_BOF:
   1545                  /* Check CAN_ESR_BOFF bit */
   1546                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
   \                     ??CAN_GetITStatus_12: (+1)
   \   00000142   0x2104             MOVS     R1,#+4
   \   00000144   0x69A0             LDR      R0,[R4, #+24]
   \   00000146   0x.... 0x....      BL       CheckITStatus
   \   0000014A   0x0006             MOVS     R6,R0
   1547                  break;
   \   0000014C   0xE010             B.N      ??CAN_GetITStatus_18
   1548                case CAN_IT_LEC:
   1549                  /* Check CAN_ESR_LEC bit */
   1550                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
   \                     ??CAN_GetITStatus_13: (+1)
   \   0000014E   0x2170             MOVS     R1,#+112
   \   00000150   0x69A0             LDR      R0,[R4, #+24]
   \   00000152   0x.... 0x....      BL       CheckITStatus
   \   00000156   0x0006             MOVS     R6,R0
   1551                  break;
   \   00000158   0xE00A             B.N      ??CAN_GetITStatus_18
   1552                case CAN_IT_ERR:
   1553                  /* Check CAN_MSR_ERRI bit */ 
   1554                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
   \                     ??CAN_GetITStatus_14: (+1)
   \   0000015A   0x2104             MOVS     R1,#+4
   \   0000015C   0x6860             LDR      R0,[R4, #+4]
   \   0000015E   0x.... 0x....      BL       CheckITStatus
   \   00000162   0x0006             MOVS     R6,R0
   1555                  break;
   \   00000164   0xE004             B.N      ??CAN_GetITStatus_18
   1556                default:
   1557                  /* in case of error, return RESET */
   1558                  itstatus = RESET;
   \                     ??CAN_GetITStatus_17: (+1)
   \   00000166   0x2000             MOVS     R0,#+0
   \   00000168   0x0006             MOVS     R6,R0
   1559                  break;
   \   0000016A   0xE001             B.N      ??CAN_GetITStatus_18
   1560              }
   1561            }
   1562            else
   1563            {
   1564             /* in case the Interrupt is not enabled, return RESET */
   1565              itstatus  = RESET;
   \                     ??CAN_GetITStatus_2: (+1)
   \   0000016C   0x2000             MOVS     R0,#+0
   \   0000016E   0x0006             MOVS     R6,R0
   1566            }
   1567            
   1568            /* Return the CAN_IT status */
   1569            return  itstatus;
   \                     ??CAN_GetITStatus_18: (+1)
   \   00000170   0x0030             MOVS     R0,R6
   \   00000172   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000174   0xBD70             POP      {R4-R6,PC}       ;; return
   1570          }
   1571          
   1572          /**
   1573            * @brief  Clears the CANx's interrupt pending bits.
   1574            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1575            * @param  CAN_IT: specifies the interrupt pending bit to clear.
   1576            *          This parameter can be one of the following values:
   1577            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt
   1578            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1579            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1580            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1581            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1582            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1583            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1584            *            @arg CAN_IT_EWG: Error warning Interrupt
   1585            *            @arg CAN_IT_EPV: Error passive Interrupt
   1586            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1587            *            @arg CAN_IT_LEC: Last error code Interrupt
   1588            *            @arg CAN_IT_ERR: Error Interrupt 
   1589            * @retval None
   1590            */

   \                                 In section .text, align 2, keep-with-next
   1591          void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
   1592          {
   \                     CAN_ClearITPendingBit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1593            /* Check the parameters */
   1594            assert_param(IS_CAN_ALL_PERIPH(CANx));
   \   00000006   0x....             LDR.N    R0,??DataTable22_8  ;; 0x40006400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD007             BEQ.N    ??CAN_ClearITPendingBit_0
   \   0000000C   0x....             LDR.N    R0,??DataTable22_7  ;; 0x40006800
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD004             BEQ.N    ??CAN_ClearITPendingBit_0
   \   00000012   0xF240 0x613A      MOVW     R1,#+1594
   \   00000016   0x....             LDR.N    R0,??DataTable22
   \   00000018   0x.... 0x....      BL       assert_failed
   1595            assert_param(IS_CAN_CLEAR_IT(CAN_IT));
   \                     ??CAN_ClearITPendingBit_0: (+1)
   \   0000001C   0x2D01             CMP      R5,#+1
   \   0000001E   0xD021             BEQ.N    ??CAN_ClearITPendingBit_1
   \   00000020   0x2D04             CMP      R5,#+4
   \   00000022   0xD01F             BEQ.N    ??CAN_ClearITPendingBit_1
   \   00000024   0x2D08             CMP      R5,#+8
   \   00000026   0xD01D             BEQ.N    ??CAN_ClearITPendingBit_1
   \   00000028   0x2D20             CMP      R5,#+32
   \   0000002A   0xD01B             BEQ.N    ??CAN_ClearITPendingBit_1
   \   0000002C   0x2D40             CMP      R5,#+64
   \   0000002E   0xD019             BEQ.N    ??CAN_ClearITPendingBit_1
   \   00000030   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000034   0xD016             BEQ.N    ??CAN_ClearITPendingBit_1
   \   00000036   0xF5B5 0x7F00      CMP      R5,#+512
   \   0000003A   0xD013             BEQ.N    ??CAN_ClearITPendingBit_1
   \   0000003C   0xF5B5 0x6F80      CMP      R5,#+1024
   \   00000040   0xD010             BEQ.N    ??CAN_ClearITPendingBit_1
   \   00000042   0xF5B5 0x6F00      CMP      R5,#+2048
   \   00000046   0xD00D             BEQ.N    ??CAN_ClearITPendingBit_1
   \   00000048   0xF5B5 0x4F00      CMP      R5,#+32768
   \   0000004C   0xD00A             BEQ.N    ??CAN_ClearITPendingBit_1
   \   0000004E   0xF5B5 0x3F80      CMP      R5,#+65536
   \   00000052   0xD007             BEQ.N    ??CAN_ClearITPendingBit_1
   \   00000054   0xF5B5 0x3F00      CMP      R5,#+131072
   \   00000058   0xD004             BEQ.N    ??CAN_ClearITPendingBit_1
   \   0000005A   0xF240 0x613B      MOVW     R1,#+1595
   \   0000005E   0x....             LDR.N    R0,??DataTable22
   \   00000060   0x.... 0x....      BL       assert_failed
   1596          
   1597            switch (CAN_IT)
   \                     ??CAN_ClearITPendingBit_1: (+1)
   \   00000064   0x0028             MOVS     R0,R5
   \   00000066   0x2801             CMP      R0,#+1
   \   00000068   0xD01D             BEQ.N    ??CAN_ClearITPendingBit_2
   \   0000006A   0x2804             CMP      R0,#+4
   \   0000006C   0xD01E             BEQ.N    ??CAN_ClearITPendingBit_3
   \   0000006E   0x2808             CMP      R0,#+8
   \   00000070   0xD01F             BEQ.N    ??CAN_ClearITPendingBit_4
   \   00000072   0x2820             CMP      R0,#+32
   \   00000074   0xD020             BEQ.N    ??CAN_ClearITPendingBit_5
   \   00000076   0x2840             CMP      R0,#+64
   \   00000078   0xD021             BEQ.N    ??CAN_ClearITPendingBit_6
   \   0000007A   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000007E   0xD027             BEQ.N    ??CAN_ClearITPendingBit_7
   \   00000080   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000084   0xD027             BEQ.N    ??CAN_ClearITPendingBit_8
   \   00000086   0xF5B0 0x6F80      CMP      R0,#+1024
   \   0000008A   0xD027             BEQ.N    ??CAN_ClearITPendingBit_9
   \   0000008C   0xF5B0 0x6F00      CMP      R0,#+2048
   \   00000090   0xD027             BEQ.N    ??CAN_ClearITPendingBit_10
   \   00000092   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000096   0xD029             BEQ.N    ??CAN_ClearITPendingBit_11
   \   00000098   0xF5B0 0x3F80      CMP      R0,#+65536
   \   0000009C   0xD012             BEQ.N    ??CAN_ClearITPendingBit_12
   \   0000009E   0xF5B0 0x3F00      CMP      R0,#+131072
   \   000000A2   0xD012             BEQ.N    ??CAN_ClearITPendingBit_13
   \   000000A4   0xE027             B.N      ??CAN_ClearITPendingBit_14
   1598            {
   1599              case CAN_IT_TME:
   1600                /* Clear CAN_TSR_RQCPx (rc_w1)*/
   1601                CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
   \                     ??CAN_ClearITPendingBit_2: (+1)
   \   000000A6   0x....             LDR.N    R0,??DataTable22_24  ;; 0x10101
   \   000000A8   0x60A0             STR      R0,[R4, #+8]
   1602                break;
   \   000000AA   0xE024             B.N      ??CAN_ClearITPendingBit_15
   1603              case CAN_IT_FF0:
   1604                /* Clear CAN_RF0R_FULL0 (rc_w1)*/
   1605                CANx->RF0R = CAN_RF0R_FULL0; 
   \                     ??CAN_ClearITPendingBit_3: (+1)
   \   000000AC   0x2008             MOVS     R0,#+8
   \   000000AE   0x60E0             STR      R0,[R4, #+12]
   1606                break;
   \   000000B0   0xE021             B.N      ??CAN_ClearITPendingBit_15
   1607              case CAN_IT_FOV0:
   1608                /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
   1609                CANx->RF0R = CAN_RF0R_FOVR0; 
   \                     ??CAN_ClearITPendingBit_4: (+1)
   \   000000B2   0x2010             MOVS     R0,#+16
   \   000000B4   0x60E0             STR      R0,[R4, #+12]
   1610                break;
   \   000000B6   0xE01E             B.N      ??CAN_ClearITPendingBit_15
   1611              case CAN_IT_FF1:
   1612                /* Clear CAN_RF1R_FULL1 (rc_w1)*/
   1613                CANx->RF1R = CAN_RF1R_FULL1;  
   \                     ??CAN_ClearITPendingBit_5: (+1)
   \   000000B8   0x2008             MOVS     R0,#+8
   \   000000BA   0x6120             STR      R0,[R4, #+16]
   1614                break;
   \   000000BC   0xE01B             B.N      ??CAN_ClearITPendingBit_15
   1615              case CAN_IT_FOV1:
   1616                /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
   1617                CANx->RF1R = CAN_RF1R_FOVR1; 
   \                     ??CAN_ClearITPendingBit_6: (+1)
   \   000000BE   0x2010             MOVS     R0,#+16
   \   000000C0   0x6120             STR      R0,[R4, #+16]
   1618                break;
   \   000000C2   0xE018             B.N      ??CAN_ClearITPendingBit_15
   1619              case CAN_IT_WKU:
   1620                /* Clear CAN_MSR_WKUI (rc_w1)*/
   1621                CANx->MSR = CAN_MSR_WKUI;  
   \                     ??CAN_ClearITPendingBit_12: (+1)
   \   000000C4   0x2008             MOVS     R0,#+8
   \   000000C6   0x6060             STR      R0,[R4, #+4]
   1622                break;
   \   000000C8   0xE015             B.N      ??CAN_ClearITPendingBit_15
   1623              case CAN_IT_SLK:
   1624                /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
   1625                CANx->MSR = CAN_MSR_SLAKI;   
   \                     ??CAN_ClearITPendingBit_13: (+1)
   \   000000CA   0x2010             MOVS     R0,#+16
   \   000000CC   0x6060             STR      R0,[R4, #+4]
   1626                break;
   \   000000CE   0xE012             B.N      ??CAN_ClearITPendingBit_15
   1627              case CAN_IT_EWG:
   1628                /* Clear CAN_MSR_ERRI (rc_w1) */
   1629                CANx->MSR = CAN_MSR_ERRI;
   \                     ??CAN_ClearITPendingBit_7: (+1)
   \   000000D0   0x2004             MOVS     R0,#+4
   \   000000D2   0x6060             STR      R0,[R4, #+4]
   1630                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/ 
   1631                break;
   \   000000D4   0xE00F             B.N      ??CAN_ClearITPendingBit_15
   1632              case CAN_IT_EPV:
   1633                /* Clear CAN_MSR_ERRI (rc_w1) */
   1634                CANx->MSR = CAN_MSR_ERRI; 
   \                     ??CAN_ClearITPendingBit_8: (+1)
   \   000000D6   0x2004             MOVS     R0,#+4
   \   000000D8   0x6060             STR      R0,[R4, #+4]
   1635                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
   1636                break;
   \   000000DA   0xE00C             B.N      ??CAN_ClearITPendingBit_15
   1637              case CAN_IT_BOF:
   1638                /* Clear CAN_MSR_ERRI (rc_w1) */ 
   1639                CANx->MSR = CAN_MSR_ERRI; 
   \                     ??CAN_ClearITPendingBit_9: (+1)
   \   000000DC   0x2004             MOVS     R0,#+4
   \   000000DE   0x6060             STR      R0,[R4, #+4]
   1640                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
   1641                 break;
   \   000000E0   0xE009             B.N      ??CAN_ClearITPendingBit_15
   1642              case CAN_IT_LEC:
   1643                /*  Clear LEC bits */
   1644                CANx->ESR = RESET; 
   \                     ??CAN_ClearITPendingBit_10: (+1)
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0x61A0             STR      R0,[R4, #+24]
   1645                /* Clear CAN_MSR_ERRI (rc_w1) */
   1646                CANx->MSR = CAN_MSR_ERRI; 
   \   000000E6   0x2004             MOVS     R0,#+4
   \   000000E8   0x6060             STR      R0,[R4, #+4]
   1647                break;
   \   000000EA   0xE004             B.N      ??CAN_ClearITPendingBit_15
   1648              case CAN_IT_ERR:
   1649                /*Clear LEC bits */
   1650                CANx->ESR = RESET; 
   \                     ??CAN_ClearITPendingBit_11: (+1)
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0x61A0             STR      R0,[R4, #+24]
   1651                /* Clear CAN_MSR_ERRI (rc_w1) */
   1652                CANx->MSR = CAN_MSR_ERRI; 
   \   000000F0   0x2004             MOVS     R0,#+4
   \   000000F2   0x6060             STR      R0,[R4, #+4]
   1653                 /* @note BOFF, EPVF and EWGF Flags are cleared by hardware depending on the CAN Bus status*/
   1654                 break;
   \   000000F4   0xE7FF             B.N      ??CAN_ClearITPendingBit_15
   1655              default:
   1656                 break;
   1657             }
   1658          }
   \                     ??CAN_ClearITPendingBit_14: (+1)
   \                     ??CAN_ClearITPendingBit_15: (+1)
   \   000000F6   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1659           /**
   1660            * @}
   1661            */
   1662          
   1663          /**
   1664            * @brief  Checks whether the CAN interrupt has occurred or not.
   1665            * @param  CAN_Reg: specifies the CAN interrupt register to check.
   1666            * @param  It_Bit: specifies the interrupt source bit to check.
   1667            * @retval The new state of the CAN Interrupt (SET or RESET).
   1668            */

   \                                 In section .text, align 2, keep-with-next
   1669          static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
   1670          {
   \                     CheckITStatus: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   1671            ITStatus pendingbitstatus = RESET;
   \   00000002   0x2000             MOVS     R0,#+0
   1672            
   1673            if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
   \   00000004   0x420A             TST      R2,R1
   \   00000006   0xD002             BEQ.N    ??CheckITStatus_0
   1674            {
   1675              /* CAN_IT is set */
   1676              pendingbitstatus = SET;
   \   00000008   0x2301             MOVS     R3,#+1
   \   0000000A   0x0018             MOVS     R0,R3
   \   0000000C   0xE001             B.N      ??CheckITStatus_1
   1677            }
   1678            else
   1679            {
   1680              /* CAN_IT is reset */
   1681              pendingbitstatus = RESET;
   \                     ??CheckITStatus_0: (+1)
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x0018             MOVS     R0,R3
   1682            }
   1683            return pendingbitstatus;
   \                     ??CheckITStatus_1: (+1)
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x4770             BX       LR               ;; return
   1684          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x40006800         DC32     0x40006800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x40006400         DC32     0x40006400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x4000661C         DC32     0x4000661c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x4000660C         DC32     0x4000660c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0x40006640         DC32     0x40006640

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \   00000000   0x40006604         DC32     0x40006604

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \   00000000   0x40006614         DC32     0x40006614

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x40006600         DC32     0x40006600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0xFFFFC0F1         DC32     0xffffc0f1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \   00000000   0x04000003         DC32     0x4000003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \   00000000   0x08000300         DC32     0x8000300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_3:
   \   00000000   0x10030000         DC32     0x10030000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_4:
   \   00000000   0x04000001         DC32     0x4000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_5:
   \   00000000   0x040000FD         DC32     0x40000fd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_6:
   \   00000000   0x0800FD00         DC32     0x800fd00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_7:
   \   00000000   0x40006800         DC32     0x40006800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_8:
   \   00000000   0x40006400         DC32     0x40006400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_9:
   \   00000000   0x30F00070         DC32     0x30f00070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_10:
   \   00000000   0x10F00004         DC32     0x10f00004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_11:
   \   00000000   0x10F00002         DC32     0x10f00002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_12:
   \   00000000   0x10F00001         DC32     0x10f00001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_13:
   \   00000000   0x31000008         DC32     0x31000008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_14:
   \   00000000   0x32000010         DC32     0x32000010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_15:
   \   00000000   0x32000008         DC32     0x32000008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_16:
   \   00000000   0x12000003         DC32     0x12000003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_17:
   \   00000000   0x34000010         DC32     0x34000010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_18:
   \   00000000   0x34000008         DC32     0x34000008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_19:
   \   00000000   0x14000003         DC32     0x14000003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_20:
   \   00000000   0x38010000         DC32     0x38010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_21:
   \   00000000   0x38000100         DC32     0x38000100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_22:
   \   00000000   0x38000001         DC32     0x38000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_23:
   \   00000000   0x31000012         DC32     0x31000012

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_24:
   \   00000000   0x00010101         DC32     0x10101

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 49H, 41H, 52H, 20H, 57H
   \              0x5C 0x49    
   \              0x41 0x52    
   \              0x20 0x57    
   \   00000008   0x6F 0x72          DC8 6FH, 72H, 6BH, 73H, 70H, 61H, 63H, 65H
   \              0x6B 0x73    
   \              0x70 0x61    
   \              0x63 0x65    
   \   00000010   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 46H, 34H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x46 0x34    
   \   00000018   0x30 0x37          DC8 30H, 37H, 5CH, 53H, 54H, 4DH, 33H, 32H
   \              0x5C 0x53    
   \              0x54 0x4D    
   \              0x33 0x32    
   \   00000020   0x46 0x34          DC8 46H, 34H, 2DH, 44H, 69H, 73H, 63H, 6FH
   \              0x2D 0x44    
   \              0x69 0x73    
   \              0x63 0x6F    
   \   00000028   0x76 0x65          DC8 76H, 65H, 72H, 79H, 5FH, 46H, 57H, 5FH
   \              0x72 0x79    
   \              0x5F 0x46    
   \              0x57 0x5F    
   \   00000030   0x56 0x31          DC8 56H, 31H, 2EH, 31H, 2EH, 30H, 5CH, 4CH
   \              0x2E 0x31    
   \              0x2E 0x30    
   \              0x5C 0x4C    
   \   00000038   0x69 0x62          DC8 69H, 62H, 72H, 61H, 72H, 69H, 65H, 73H
   \              0x72 0x61    
   \              0x72 0x69    
   \              0x65 0x73    
   \   00000040   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 46H, 34H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x46 0x34    
   \   00000048   0x78 0x78          DC8 78H, 78H, 5FH, 53H, 74H, 64H, 50H, 65H
   \              0x5F 0x53    
   \              0x74 0x64    
   \              0x50 0x65    
   \   00000050   0x72 0x69          DC8 72H, 69H, 70H, 68H, 5FH, 44H, 72H, 69H
   \              0x70 0x68    
   \              0x5F 0x44    
   \              0x72 0x69    
   \   00000058   0x76 0x65          DC8 76H, 65H, 72H, 5CH, 73H, 72H, 63H, 5CH
   \              0x72 0x5C    
   \              0x73 0x72    
   \              0x63 0x5C    
   \   00000060   0x73 0x74          DC8 73H, 74H, 6DH, 33H, 32H, 66H, 34H, 78H
   \              0x6D 0x33    
   \              0x32 0x66    
   \              0x34 0x78    
   \   00000068   0x78 0x5F          DC8 78H, 5FH, 63H, 61H, 6EH, 2EH, 63H, 0
   \              0x63 0x61    
   \              0x6E 0x2E    
   \              0x63 0x00    
   1685          
   1686          /**
   1687            * @}
   1688            */
   1689          
   1690          /**
   1691            * @}
   1692            */
   1693          
   1694          /**
   1695            * @}
   1696            */
   1697          
   1698          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   CAN_CancelTransmit
        16   -> assert_failed
      16   CAN_ClearFlag
        16   -> assert_failed
      16   CAN_ClearITPendingBit
        16   -> assert_failed
      16   CAN_DBGFreeze
        16   -> assert_failed
       8   CAN_DeInit
         8   -> RCC_APB1PeriphResetCmd
         8   -> assert_failed
      16   CAN_FIFORelease
        16   -> assert_failed
      16   CAN_FilterInit
        16   -> assert_failed
      16   CAN_GetFlagStatus
        16   -> assert_failed
      16   CAN_GetITStatus
        16   -> CheckITStatus
        16   -> assert_failed
      16   CAN_GetLSBTransmitErrorCounter
        16   -> assert_failed
      16   CAN_GetLastErrorCode
        16   -> assert_failed
      16   CAN_GetReceiveErrorCounter
        16   -> assert_failed
      16   CAN_ITConfig
        16   -> assert_failed
      24   CAN_Init
        24   -> assert_failed
      16   CAN_MessagePending
        16   -> assert_failed
      24   CAN_OperatingModeRequest
        24   -> assert_failed
      16   CAN_Receive
        16   -> assert_failed
       8   CAN_SlaveStartBank
         8   -> assert_failed
      16   CAN_Sleep
        16   -> assert_failed
       0   CAN_StructInit
      16   CAN_TTComModeCmd
        16   -> assert_failed
      16   CAN_Transmit
        16   -> assert_failed
      16   CAN_TransmitStatus
        16   -> assert_failed
      16   CAN_WakeUp
        16   -> assert_failed
       0   CheckITStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable16
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_10
       4  ??DataTable22_11
       4  ??DataTable22_12
       4  ??DataTable22_13
       4  ??DataTable22_14
       4  ??DataTable22_15
       4  ??DataTable22_16
       4  ??DataTable22_17
       4  ??DataTable22_18
       4  ??DataTable22_19
       4  ??DataTable22_2
       4  ??DataTable22_20
       4  ??DataTable22_21
       4  ??DataTable22_22
       4  ??DataTable22_23
       4  ??DataTable22_24
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable22_5
       4  ??DataTable22_6
       4  ??DataTable22_7
       4  ??DataTable22_8
       4  ??DataTable22_9
     112  ?_0
      98  CAN_CancelTransmit
     166  CAN_ClearFlag
     248  CAN_ClearITPendingBit
      84  CAN_DBGFreeze
      82  CAN_DeInit
      80  CAN_FIFORelease
     388  CAN_FilterInit
     290  CAN_GetFlagStatus
     374  CAN_GetITStatus
      46  CAN_GetLSBTransmitErrorCounter
      44  CAN_GetLastErrorCode
      44  CAN_GetReceiveErrorCounter
     164  CAN_ITConfig
     564  CAN_Init
      98  CAN_MessagePending
     242  CAN_OperatingModeRequest
     292  CAN_Receive
      98  CAN_SlaveStartBank
      62  CAN_Sleep
      46  CAN_StructInit
     156  CAN_TTComModeCmd
     432  CAN_Transmit
     212  CAN_TransmitStatus
      72  CAN_WakeUp
      22  CheckITStatus

 
   112 bytes in section .rodata
 4 544 bytes in section .text
 
 4 544 bytes of CODE  memory
   112 bytes of CONST memory

Errors: none
Warnings: none
