###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       06/May/2016  23:31:37
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\usb_lib\otg\usb_dcd_int.c
#    Command line =  
#        "D:\IAR Workspace\STM32F407\VCP_ESP\usb_lib\otg\usb_dcd_int.c" -D
#        USE_STDPERIPH_DRIVER -D STM32F4XX -D USE_FULL_ASSERT -lCN "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\List" -o "D:\IAR
#        Workspace\STM32F407\VCP_ESP\Debug\Obj" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\Include\" -I
#        "D:\IAR Workspace\STM32F407\VCP_ESP\..\Utilities\STM32F4-Discovery\"
#        -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\..\Libraries\CMSIS\ST\STM32F4xx\Include\"
#        -I "D:\IAR Workspace\STM32F407\VCP_ESP\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_conf\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\cdc\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\otg\" -I "D:\IAR
#        Workspace\STM32F407\VCP_ESP\usb_lib\core\" -On --use_c++_inline -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    List file    =  
#        D:\IAR Workspace\STM32F407\VCP_ESP\Debug\List\usb_dcd_int.lst
#    Object file  =  D:\IAR Workspace\STM32F407\VCP_ESP\Debug\Obj\usb_dcd_int.o
#
###############################################################################

D:\IAR Workspace\STM32F407\VCP_ESP\usb_lib\otg\usb_dcd_int.c
      1          /**
      2            ******************************************************************************
      3            * @file    usb_dcd_int.c
      4            * @author  MCD Application Team
      5            * @version V2.0.0
      6            * @date    22-July-2011
      7            * @brief   Peripheral Device interrupt subroutines
      8            ******************************************************************************
      9            * @attention 
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          #include "usb_conf.h"
     23          #ifdef USE_DEVICE_MODE
     24          /* Includes ------------------------------------------------------------------*/
     25          #include "usb_dcd_int.h"
     26          /** @addtogroup USB_OTG_DRIVER
     27          * @{
     28          */
     29          
     30          /** @defgroup USB_DCD_INT 
     31          * @brief This file contains the interrupt subroutines for the Device mode.
     32          * @{
     33          */
     34          
     35          
     36          /** @defgroup USB_DCD_INT_Private_Defines
     37          * @{
     38          */ 
     39          /**
     40          * @}
     41          */ 
     42          
     43          
     44          /** @defgroup USB_DCD_INT_Private_TypesDefinitions
     45          * @{
     46          */ 
     47          /**
     48          * @}
     49          */ 
     50          
     51          
     52          
     53          /** @defgroup USB_DCD_INT_Private_Macros
     54          * @{
     55          */ 
     56          /**
     57          * @}
     58          */ 
     59          
     60          
     61          /** @defgroup USB_DCD_INT_Private_Variables
     62          * @{
     63          */ 
     64          /**
     65          * @}
     66          */ 
     67          
     68          
     69          /** @defgroup USB_DCD_INT_Private_FunctionPrototypes
     70          * @{
     71          */ 
     72          /* static functions */
     73          static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum);
     74          
     75          /* Interrupt Handlers */
     76          static uint32_t DCD_HandleInEP_ISR(USB_OTG_CORE_HANDLE *pdev);
     77          static uint32_t DCD_HandleOutEP_ISR(USB_OTG_CORE_HANDLE *pdev);
     78          static uint32_t DCD_HandleSof_ISR(USB_OTG_CORE_HANDLE *pdev);
     79          
     80          static uint32_t DCD_HandleRxStatusQueueLevel_ISR(USB_OTG_CORE_HANDLE *pdev);
     81          static uint32_t DCD_WriteEmptyTxFifo(USB_OTG_CORE_HANDLE *pdev , uint32_t epnum);
     82          
     83          static uint32_t DCD_HandleUsbReset_ISR(USB_OTG_CORE_HANDLE *pdev);
     84          static uint32_t DCD_HandleEnumDone_ISR(USB_OTG_CORE_HANDLE *pdev);
     85          static uint32_t DCD_HandleResume_ISR(USB_OTG_CORE_HANDLE *pdev);
     86          static uint32_t DCD_HandleUSBSuspend_ISR(USB_OTG_CORE_HANDLE *pdev);
     87          
     88          static uint32_t DCD_IsoINIncomplete_ISR(USB_OTG_CORE_HANDLE *pdev);
     89          static uint32_t DCD_IsoOUTIncomplete_ISR(USB_OTG_CORE_HANDLE *pdev);
     90          #ifdef VBUS_SENSING_ENABLED
     91          static uint32_t DCD_SessionRequest_ISR(USB_OTG_CORE_HANDLE *pdev);
     92          static uint32_t DCD_OTG_ISR(USB_OTG_CORE_HANDLE *pdev);
     93          #endif
     94          
     95          /**
     96          * @}
     97          */ 
     98          
     99          
    100          /** @defgroup USB_DCD_INT_Private_Functions
    101          * @{
    102          */ 
    103          
    104          
    105          #ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED  
    106          /**
    107          * @brief  USBD_OTG_EP1OUT_ISR_Handler
    108          *         handles all USB Interrupts
    109          * @param  pdev: device instance
    110          * @retval status
    111          */
    112          uint32_t USBD_OTG_EP1OUT_ISR_Handler (USB_OTG_CORE_HANDLE *pdev)
    113          {
    114            
    115            USB_OTG_DOEPINTn_TypeDef  doepint;
    116            USB_OTG_DEPXFRSIZ_TypeDef  deptsiz;  
    117            
    118            doepint.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[1]->DOEPINT);
    119            doepint.d32&= USB_OTG_READ_REG32(&pdev->regs.DREGS->DOUTEP1MSK);
    120            
    121            /* Transfer complete */
    122            if ( doepint.b.xfercompl )
    123            {
    124              /* Clear the bit in DOEPINTn for this interrupt */
    125              CLEAR_OUT_EP_INTR(1, xfercompl);
    126              if (pdev->cfg.dma_enable == 1)
    127              {
    128                deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[1]->DOEPTSIZ));
    129                /*ToDo : handle more than one single MPS size packet */
    130                pdev->dev.out_ep[1].xfer_count = pdev->dev.out_ep[1].maxpacket - \
    131                  deptsiz.b.xfersize;
    132              }    
    133              /* Inform upper layer: data ready */
    134              /* RX COMPLETE */
    135              USBD_DCD_INT_fops->DataOutStage(pdev , 1);
    136              
    137            }
    138            
    139            /* Endpoint disable  */
    140            if ( doepint.b.epdisabled )
    141            {
    142              /* Clear the bit in DOEPINTn for this interrupt */
    143              CLEAR_OUT_EP_INTR(1, epdisabled);
    144            }
    145            /* AHB Error */
    146            if ( doepint.b.ahberr )
    147            {
    148              CLEAR_OUT_EP_INTR(1, ahberr);
    149            } 
    150            return 1;
    151          }
    152          
    153          /**
    154          * @brief  USBD_OTG_EP1IN_ISR_Handler
    155          *         handles all USB Interrupts
    156          * @param  pdev: device instance
    157          * @retval status
    158          */
    159          uint32_t USBD_OTG_EP1IN_ISR_Handler (USB_OTG_CORE_HANDLE *pdev)
    160          {
    161            
    162            USB_OTG_DIEPINTn_TypeDef  diepint;
    163            uint32_t fifoemptymsk, msk, emp;
    164            
    165            msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DINEP1MSK);
    166            emp = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPEMPMSK);
    167            msk |= ((emp >> 1 ) & 0x1) << 7;
    168            diepint.d32  = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[1]->DIEPINT) & msk;  
    169            
    170            if ( diepint.b.xfercompl )
    171            {
    172              fifoemptymsk = 0x1 << 1;
    173              USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
    174              CLEAR_IN_EP_INTR(1, xfercompl);
    175              /* TX COMPLETE */
    176              USBD_DCD_INT_fops->DataInStage(pdev , 1);
    177            }
    178            if ( diepint.b.ahberr )
    179            {
    180              CLEAR_IN_EP_INTR(1, ahberr);
    181            }
    182            if ( diepint.b.epdisabled )
    183            {
    184              CLEAR_IN_EP_INTR(1, epdisabled);
    185            }  
    186            if ( diepint.b.timeout )
    187            {
    188              CLEAR_IN_EP_INTR(1, timeout);
    189            }
    190            if (diepint.b.intktxfemp)
    191            {
    192              CLEAR_IN_EP_INTR(1, intktxfemp);
    193            }
    194            if (diepint.b.intknepmis)
    195            {
    196              CLEAR_IN_EP_INTR(1, intknepmis);
    197            }
    198            if (diepint.b.inepnakeff)
    199            {
    200              CLEAR_IN_EP_INTR(1, inepnakeff);
    201            }
    202            if (diepint.b.emptyintr)
    203            {
    204              DCD_WriteEmptyTxFifo(pdev , 1);
    205              CLEAR_IN_EP_INTR(1, emptyintr);
    206            }
    207            return 1;
    208          }
    209          #endif
    210          
    211          /**
    212          * @brief  STM32_USBF_OTG_ISR_Handler
    213          *         handles all USB Interrupts
    214          * @param  pdev: device instance
    215          * @retval status
    216          */

   \                                 In section .text, align 2, keep-with-next
    217          uint32_t USBD_OTG_ISR_Handler (USB_OTG_CORE_HANDLE *pdev)
    218          {
   \                     USBD_OTG_ISR_Handler: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    219            USB_OTG_GINTSTS_TypeDef  gintr_status;
    220            uint32_t retval = 0;
   \   00000004   0x2600             MOVS     R6,#+0
    221            
    222            if (USB_OTG_IsDeviceMode(pdev)) /* ensure that we are in device mode */
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       USB_OTG_IsDeviceMode
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD06A             BEQ.N    ??USBD_OTG_ISR_Handler_0
    223            {
    224              gintr_status.d32 = USB_OTG_ReadCoreItr(pdev);
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       USB_OTG_ReadCoreItr
   \   00000016   0x0005             MOVS     R5,R0
    225              if (!gintr_status.d32) /* avoid spurious interrupt */
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD101             BNE.N    ??USBD_OTG_ISR_Handler_1
    226              {
    227                return 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE063             B.N      ??USBD_OTG_ISR_Handler_2
    228              }
    229              
    230              if (gintr_status.b.outepintr)
   \                     ??USBD_OTG_ISR_Handler_1: (+1)
   \   00000020   0xF3C5 0x40C0      UBFX     R0,R5,#+19,#+1
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD004             BEQ.N    ??USBD_OTG_ISR_Handler_3
    231              {
    232                retval |= DCD_HandleOutEP_ISR(pdev);
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       DCD_HandleOutEP_ISR
   \   0000002E   0x4330             ORRS     R0,R0,R6
   \   00000030   0x0006             MOVS     R6,R0
    233              }    
    234              
    235              if (gintr_status.b.inepint)
   \                     ??USBD_OTG_ISR_Handler_3: (+1)
   \   00000032   0xF3C5 0x4080      UBFX     R0,R5,#+18,#+1
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD004             BEQ.N    ??USBD_OTG_ISR_Handler_4
    236              {
    237                retval |= DCD_HandleInEP_ISR(pdev);
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       DCD_HandleInEP_ISR
   \   00000040   0x4330             ORRS     R0,R0,R6
   \   00000042   0x0006             MOVS     R6,R0
    238              }
    239              
    240              if (gintr_status.b.modemismatch)
   \                     ??USBD_OTG_ISR_Handler_4: (+1)
   \   00000044   0xF3C5 0x0040      UBFX     R0,R5,#+1,#+1
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD005             BEQ.N    ??USBD_OTG_ISR_Handler_5
    241              {
    242                USB_OTG_GINTSTS_TypeDef  gintsts;
    243                
    244                /* Clear interrupt */
    245                gintsts.d32 = 0;
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0x0008             MOVS     R0,R1
    246                gintsts.b.modemismatch = 1;
   \   00000050   0xF050 0x0002      ORRS     R0,R0,#0x2
    247                USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
   \   00000054   0x68E1             LDR      R1,[R4, #+12]
   \   00000056   0x6148             STR      R0,[R1, #+20]
    248              }
    249              
    250              if (gintr_status.b.wkupintr)
   \                     ??USBD_OTG_ISR_Handler_5: (+1)
   \   00000058   0x0FE8             LSRS     R0,R5,#+31
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD004             BEQ.N    ??USBD_OTG_ISR_Handler_6
    251              {
    252                retval |= DCD_HandleResume_ISR(pdev);
   \   0000005E   0x0020             MOVS     R0,R4
   \   00000060   0x.... 0x....      BL       DCD_HandleResume_ISR
   \   00000064   0x4330             ORRS     R0,R0,R6
   \   00000066   0x0006             MOVS     R6,R0
    253              }
    254              
    255              if (gintr_status.b.usbsuspend)
   \                     ??USBD_OTG_ISR_Handler_6: (+1)
   \   00000068   0xF3C5 0x20C0      UBFX     R0,R5,#+11,#+1
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD004             BEQ.N    ??USBD_OTG_ISR_Handler_7
    256              {
    257                retval |= DCD_HandleUSBSuspend_ISR(pdev);
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0x.... 0x....      BL       DCD_HandleUSBSuspend_ISR
   \   00000076   0x4330             ORRS     R0,R0,R6
   \   00000078   0x0006             MOVS     R6,R0
    258              }
    259              if (gintr_status.b.sofintr)
   \                     ??USBD_OTG_ISR_Handler_7: (+1)
   \   0000007A   0xF3C5 0x00C0      UBFX     R0,R5,#+3,#+1
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD004             BEQ.N    ??USBD_OTG_ISR_Handler_8
    260              {
    261                retval |= DCD_HandleSof_ISR(pdev);
   \   00000082   0x0020             MOVS     R0,R4
   \   00000084   0x.... 0x....      BL       DCD_HandleSof_ISR
   \   00000088   0x4330             ORRS     R0,R0,R6
   \   0000008A   0x0006             MOVS     R6,R0
    262                
    263              }
    264              
    265              if (gintr_status.b.rxstsqlvl)
   \                     ??USBD_OTG_ISR_Handler_8: (+1)
   \   0000008C   0xF3C5 0x1000      UBFX     R0,R5,#+4,#+1
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD004             BEQ.N    ??USBD_OTG_ISR_Handler_9
    266              {
    267                retval |= DCD_HandleRxStatusQueueLevel_ISR(pdev);
   \   00000094   0x0020             MOVS     R0,R4
   \   00000096   0x.... 0x....      BL       DCD_HandleRxStatusQueueLevel_ISR
   \   0000009A   0x4330             ORRS     R0,R0,R6
   \   0000009C   0x0006             MOVS     R6,R0
    268                
    269              }
    270              
    271              if (gintr_status.b.usbreset)
   \                     ??USBD_OTG_ISR_Handler_9: (+1)
   \   0000009E   0xF3C5 0x3000      UBFX     R0,R5,#+12,#+1
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD004             BEQ.N    ??USBD_OTG_ISR_Handler_10
    272              {
    273                retval |= DCD_HandleUsbReset_ISR(pdev);
   \   000000A6   0x0020             MOVS     R0,R4
   \   000000A8   0x.... 0x....      BL       DCD_HandleUsbReset_ISR
   \   000000AC   0x4330             ORRS     R0,R0,R6
   \   000000AE   0x0006             MOVS     R6,R0
    274                
    275              }
    276              if (gintr_status.b.enumdone)
   \                     ??USBD_OTG_ISR_Handler_10: (+1)
   \   000000B0   0xF3C5 0x3040      UBFX     R0,R5,#+13,#+1
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD004             BEQ.N    ??USBD_OTG_ISR_Handler_11
    277              {
    278                retval |= DCD_HandleEnumDone_ISR(pdev);
   \   000000B8   0x0020             MOVS     R0,R4
   \   000000BA   0x.... 0x....      BL       DCD_HandleEnumDone_ISR
   \   000000BE   0x4330             ORRS     R0,R0,R6
   \   000000C0   0x0006             MOVS     R6,R0
    279              }
    280              
    281              if (gintr_status.b.incomplisoin)
   \                     ??USBD_OTG_ISR_Handler_11: (+1)
   \   000000C2   0xF3C5 0x5000      UBFX     R0,R5,#+20,#+1
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD004             BEQ.N    ??USBD_OTG_ISR_Handler_12
    282              {
    283                retval |= DCD_IsoINIncomplete_ISR(pdev);
   \   000000CA   0x0020             MOVS     R0,R4
   \   000000CC   0x.... 0x....      BL       DCD_IsoINIncomplete_ISR
   \   000000D0   0x4330             ORRS     R0,R0,R6
   \   000000D2   0x0006             MOVS     R6,R0
    284              }
    285          
    286              if (gintr_status.b.incomplisoout)
   \                     ??USBD_OTG_ISR_Handler_12: (+1)
   \   000000D4   0xF3C5 0x5040      UBFX     R0,R5,#+21,#+1
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD004             BEQ.N    ??USBD_OTG_ISR_Handler_0
    287              {
    288                retval |= DCD_IsoOUTIncomplete_ISR(pdev);
   \   000000DC   0x0020             MOVS     R0,R4
   \   000000DE   0x.... 0x....      BL       DCD_IsoOUTIncomplete_ISR
   \   000000E2   0x4330             ORRS     R0,R0,R6
   \   000000E4   0x0006             MOVS     R6,R0
    289              }    
    290          #ifdef VBUS_SENSING_ENABLED
    291              if (gintr_status.b.sessreqintr)
    292              {
    293                retval |= DCD_SessionRequest_ISR(pdev);
    294              }
    295          
    296              if (gintr_status.b.otgintr)
    297              {
    298                retval |= DCD_OTG_ISR(pdev);
    299              }   
    300          #endif    
    301            }
    302            return retval;
   \                     ??USBD_OTG_ISR_Handler_0: (+1)
   \   000000E6   0x0030             MOVS     R0,R6
   \                     ??USBD_OTG_ISR_Handler_2: (+1)
   \   000000E8   0xBD70             POP      {R4-R6,PC}       ;; return
    303          }
    304          
    305          #ifdef VBUS_SENSING_ENABLED
    306          /**
    307          * @brief  DCD_SessionRequest_ISR
    308          *         Indicates that the USB_OTG controller has detected a connection
    309          * @param  pdev: device instance
    310          * @retval status
    311          */
    312          static uint32_t DCD_SessionRequest_ISR(USB_OTG_CORE_HANDLE *pdev)
    313          {
    314            USB_OTG_GINTSTS_TypeDef  gintsts;  
    315            USBD_DCD_INT_fops->DevConnected (pdev);
    316          
    317            /* Clear interrupt */
    318            gintsts.d32 = 0;
    319            gintsts.b.sessreqintr = 1;
    320            USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);   
    321            return 1;
    322          }
    323          
    324          /**
    325          * @brief  DCD_OTG_ISR
    326          *         Indicates that the USB_OTG controller has detected an OTG event:
    327          *                 used to detect the end of session i.e. disconnection
    328          * @param  pdev: device instance
    329          * @retval status
    330          */
    331          static uint32_t DCD_OTG_ISR(USB_OTG_CORE_HANDLE *pdev)
    332          {
    333          
    334            USB_OTG_GOTGINT_TypeDef  gotgint;
    335          
    336            gotgint.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GOTGINT);
    337            
    338            if (gotgint.b.sesenddet)
    339            {
    340              USBD_DCD_INT_fops->DevDisconnected (pdev);
    341            }
    342            /* Clear OTG interrupt */
    343            USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GOTGINT, gotgint.d32); 
    344            return 1;
    345          }
    346          #endif
    347          /**
    348          * @brief  DCD_HandleResume_ISR
    349          *         Indicates that the USB_OTG controller has detected a resume or
    350          *                 remote Wake-up sequence
    351          * @param  pdev: device instance
    352          * @retval status
    353          */

   \                                 In section .text, align 2, keep-with-next
    354          static uint32_t DCD_HandleResume_ISR(USB_OTG_CORE_HANDLE *pdev)
    355          {
   \                     DCD_HandleResume_ISR: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    356            USB_OTG_GINTSTS_TypeDef  gintsts;
    357            USB_OTG_DCTL_TypeDef     devctl;
    358            USB_OTG_PCGCCTL_TypeDef  power;
    359            
    360            if(pdev->cfg.low_power)
   \   00000004   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD009             BEQ.N    ??DCD_HandleResume_ISR_0
    361            {
    362              /* un-gate USB Core clock */
    363              power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
   \   0000000A   0xF8D4 0x010C      LDR      R0,[R4, #+268]
   \   0000000E   0x0006             MOVS     R6,R0
    364              power.b.gatehclk = 0;
   \   00000010   0xF036 0x0602      BICS     R6,R6,#0x2
    365              power.b.stoppclk = 0;
   \   00000014   0x0876             LSRS     R6,R6,#+1
   \   00000016   0x0076             LSLS     R6,R6,#+1
    366              USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
   \   00000018   0xF8D4 0x010C      LDR      R0,[R4, #+268]
   \   0000001C   0x6006             STR      R6,[R0, #+0]
    367            }
    368            
    369            /* Clear the Remote Wake-up Signaling */
    370            devctl.d32 = 0;
   \                     ??DCD_HandleResume_ISR_0: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x0007             MOVS     R7,R0
    371            devctl.b.rmtwkupsig = 1;
   \   00000022   0xF057 0x0701      ORRS     R7,R7,#0x1
    372            USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, devctl.d32, 0);
   \   00000026   0x6920             LDR      R0,[R4, #+16]
   \   00000028   0x6840             LDR      R0,[R0, #+4]
   \   0000002A   0x43B8             BICS     R0,R0,R7
   \   0000002C   0x6921             LDR      R1,[R4, #+16]
   \   0000002E   0x6048             STR      R0,[R1, #+4]
    373            
    374            /* Inform upper layer by the Resume Event */
    375            USBD_DCD_INT_fops->Resume (pdev);
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable7
   \   00000036   0x6809             LDR      R1,[R1, #+0]
   \   00000038   0x6989             LDR      R1,[R1, #+24]
   \   0000003A   0x4788             BLX      R1
    376            
    377            /* Clear interrupt */
    378            gintsts.d32 = 0;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x0005             MOVS     R5,R0
    379            gintsts.b.wkupintr = 1;
   \   00000040   0xF055 0x4500      ORRS     R5,R5,#0x80000000
    380            USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
   \   00000044   0x68E0             LDR      R0,[R4, #+12]
   \   00000046   0x6145             STR      R5,[R0, #+20]
    381            return 1;
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    382          }
    383          
    384          /**
    385          * @brief  USB_OTG_HandleUSBSuspend_ISR
    386          *         Indicates that SUSPEND state has been detected on the USB
    387          * @param  pdev: device instance
    388          * @retval status
    389          */

   \                                 In section .text, align 2, keep-with-next
    390          static uint32_t DCD_HandleUSBSuspend_ISR(USB_OTG_CORE_HANDLE *pdev)
    391          {
   \                     DCD_HandleUSBSuspend_ISR: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    392            USB_OTG_GINTSTS_TypeDef  gintsts;
    393            USB_OTG_PCGCCTL_TypeDef  power;
    394            USB_OTG_DSTS_TypeDef     dsts;
    395            
    396            USBD_DCD_INT_fops->Suspend (pdev);      
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable7
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x6949             LDR      R1,[R1, #+20]
   \   0000000E   0x4788             BLX      R1
    397            
    398            dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
   \   00000010   0x6920             LDR      R0,[R4, #+16]
   \   00000012   0x6880             LDR      R0,[R0, #+8]
   \   00000014   0x0007             MOVS     R7,R0
    399              
    400            /* Clear interrupt */
    401            gintsts.d32 = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x0005             MOVS     R5,R0
    402            gintsts.b.usbsuspend = 1;
   \   0000001A   0xF455 0x6500      ORRS     R5,R5,#0x800
    403            USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
   \   0000001E   0x68E0             LDR      R0,[R4, #+12]
   \   00000020   0x6145             STR      R5,[R0, #+20]
    404            
    405            if((pdev->cfg.low_power) && (dsts.b.suspsts == 1))
   \   00000022   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD01D             BEQ.N    ??DCD_HandleUSBSuspend_ISR_0
   \   00000028   0x07F8             LSLS     R0,R7,#+31
   \   0000002A   0xD51B             BPL.N    ??DCD_HandleUSBSuspend_ISR_0
    406            {
    407          	/*  switch-off the clocks */
    408              power.d32 = 0;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x0006             MOVS     R6,R0
    409              power.b.stoppclk = 1;
   \   00000030   0xF056 0x0601      ORRS     R6,R6,#0x1
    410              USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);  
   \   00000034   0xF8D4 0x010C      LDR      R0,[R4, #+268]
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x4330             ORRS     R0,R6,R0
   \   0000003C   0xF8D4 0x110C      LDR      R1,[R4, #+268]
   \   00000040   0x6008             STR      R0,[R1, #+0]
    411              
    412              power.b.gatehclk = 1;
   \   00000042   0xF056 0x0602      ORRS     R6,R6,#0x2
    413              USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);
   \   00000046   0xF8D4 0x010C      LDR      R0,[R4, #+268]
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x4330             ORRS     R0,R6,R0
   \   0000004E   0xF8D4 0x110C      LDR      R1,[R4, #+268]
   \   00000052   0x6008             STR      R0,[R1, #+0]
    414              
    415              /* Request to enter Sleep mode after exit from current ISR */
    416              SCB->SCR |= (SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk);
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable7_1  ;; 0xe000ed10
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xF050 0x0006      ORRS     R0,R0,#0x6
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable7_1  ;; 0xe000ed10
   \   00000062   0x6008             STR      R0,[R1, #+0]
    417            }
    418            return 1;
   \                     ??DCD_HandleUSBSuspend_ISR_0: (+1)
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    419          }
    420          
    421          /**
    422          * @brief  DCD_HandleInEP_ISR
    423          *         Indicates that an IN EP has a pending Interrupt
    424          * @param  pdev: device instance
    425          * @retval status
    426          */

   \                                 In section .text, align 2, keep-with-next
    427          static uint32_t DCD_HandleInEP_ISR(USB_OTG_CORE_HANDLE *pdev)
    428          {
   \                     DCD_HandleInEP_ISR: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
    429            USB_OTG_DIEPINTn_TypeDef  diepint;
    430            
    431            uint32_t ep_intr;
    432            uint32_t epnum = 0;
   \   00000006   0x2700             MOVS     R7,#+0
    433            uint32_t fifoemptymsk;
    434            diepint.d32 = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0005             MOVS     R5,R0
    435            ep_intr = USB_OTG_ReadDevAllInEPItr(pdev);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       USB_OTG_ReadDevAllInEPItr
   \   00000012   0x0006             MOVS     R6,R0
    436            
    437            while ( ep_intr )
   \                     ??DCD_HandleInEP_ISR_0: (+1)
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xF000 0x808B      BEQ.W    ??DCD_HandleInEP_ISR_1
    438            {
    439              if (ep_intr&0x1) /* In ITR */
   \   0000001A   0x07F0             LSLS     R0,R6,#+31
   \   0000001C   0xF140 0x8085      BPL.W    ??DCD_HandleInEP_ISR_2
    440              {
    441                diepint.d32 = DCD_ReadDevInEP(pdev , epnum); /* Get In ITR status */
   \   00000020   0x0039             MOVS     R1,R7
   \   00000022   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       DCD_ReadDevInEP
   \   0000002A   0x0005             MOVS     R5,R0
    442                if ( diepint.b.xfercompl )
   \   0000002C   0x07E8             LSLS     R0,R5,#+31
   \   0000002E   0xD524             BPL.N    ??DCD_HandleInEP_ISR_3
    443                {
    444                  fifoemptymsk = 0x1 << epnum;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x40B8             LSLS     R0,R0,R7
   \   00000034   0x4680             MOV      R8,R0
    445                  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
   \   00000036   0x6920             LDR      R0,[R4, #+16]
   \   00000038   0x6B40             LDR      R0,[R0, #+52]
   \   0000003A   0xEA30 0x0008      BICS     R0,R0,R8
   \   0000003E   0x6921             LDR      R1,[R4, #+16]
   \   00000040   0x6348             STR      R0,[R1, #+52]
    446                  CLEAR_IN_EP_INTR(epnum, xfercompl);
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x0005             MOVS     R5,R0
   \   00000046   0xF055 0x0501      ORRS     R5,R5,#0x1
   \   0000004A   0xEB14 0x0087      ADDS     R0,R4,R7, LSL #+2
   \   0000004E   0x6980             LDR      R0,[R0, #+24]
   \   00000050   0x6085             STR      R5,[R0, #+8]
    447                  /* TX COMPLETE */
    448                  USBD_DCD_INT_fops->DataInStage(pdev , epnum);
   \   00000052   0x0039             MOVS     R1,R7
   \   00000054   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0x.... 0x....      LDR.W    R2,??DataTable7
   \   0000005C   0x6812             LDR      R2,[R2, #+0]
   \   0000005E   0x6852             LDR      R2,[R2, #+4]
   \   00000060   0x4790             BLX      R2
    449                  
    450                  if (pdev->cfg.dma_enable == 1)
   \   00000062   0x78E0             LDRB     R0,[R4, #+3]
   \   00000064   0x2801             CMP      R0,#+1
   \   00000066   0xD108             BNE.N    ??DCD_HandleInEP_ISR_3
    451                  {
    452                    if((epnum == 0) && (pdev->dev.device_state == USB_OTG_EP0_STATUS_IN))
   \   00000068   0x2F00             CMP      R7,#+0
   \   0000006A   0xD106             BNE.N    ??DCD_HandleInEP_ISR_3
   \   0000006C   0xF894 0x0111      LDRB     R0,[R4, #+273]
   \   00000070   0x2804             CMP      R0,#+4
   \   00000072   0xD102             BNE.N    ??DCD_HandleInEP_ISR_3
    453                    {
    454                      /* prepare to rx more setup packets */
    455                      USB_OTG_EP0_OutStart(pdev);
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      BL       USB_OTG_EP0_OutStart
    456                    }
    457                  }           
    458                }
    459                if ( diepint.b.ahberr )
   \                     ??DCD_HandleInEP_ISR_3: (+1)
   \   0000007A   0xF3C5 0x0080      UBFX     R0,R5,#+2,#+1
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD007             BEQ.N    ??DCD_HandleInEP_ISR_4
    460                {
    461                  CLEAR_IN_EP_INTR(epnum, ahberr);
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x0005             MOVS     R5,R0
   \   00000086   0xF055 0x0504      ORRS     R5,R5,#0x4
   \   0000008A   0xEB14 0x0087      ADDS     R0,R4,R7, LSL #+2
   \   0000008E   0x6980             LDR      R0,[R0, #+24]
   \   00000090   0x6085             STR      R5,[R0, #+8]
    462                }
    463                if ( diepint.b.timeout )
   \                     ??DCD_HandleInEP_ISR_4: (+1)
   \   00000092   0xF3C5 0x00C0      UBFX     R0,R5,#+3,#+1
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD007             BEQ.N    ??DCD_HandleInEP_ISR_5
    464                {
    465                  CLEAR_IN_EP_INTR(epnum, timeout);
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x0005             MOVS     R5,R0
   \   0000009E   0xF055 0x0508      ORRS     R5,R5,#0x8
   \   000000A2   0xEB14 0x0087      ADDS     R0,R4,R7, LSL #+2
   \   000000A6   0x6980             LDR      R0,[R0, #+24]
   \   000000A8   0x6085             STR      R5,[R0, #+8]
    466                }
    467                if (diepint.b.intktxfemp)
   \                     ??DCD_HandleInEP_ISR_5: (+1)
   \   000000AA   0xF3C5 0x1000      UBFX     R0,R5,#+4,#+1
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD007             BEQ.N    ??DCD_HandleInEP_ISR_6
    468                {
    469                  CLEAR_IN_EP_INTR(epnum, intktxfemp);
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x0005             MOVS     R5,R0
   \   000000B6   0xF055 0x0510      ORRS     R5,R5,#0x10
   \   000000BA   0xEB14 0x0087      ADDS     R0,R4,R7, LSL #+2
   \   000000BE   0x6980             LDR      R0,[R0, #+24]
   \   000000C0   0x6085             STR      R5,[R0, #+8]
    470                }
    471                if (diepint.b.intknepmis)
   \                     ??DCD_HandleInEP_ISR_6: (+1)
   \   000000C2   0xF3C5 0x1040      UBFX     R0,R5,#+5,#+1
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD007             BEQ.N    ??DCD_HandleInEP_ISR_7
    472                {
    473                  CLEAR_IN_EP_INTR(epnum, intknepmis);
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x0005             MOVS     R5,R0
   \   000000CE   0xF055 0x0520      ORRS     R5,R5,#0x20
   \   000000D2   0xEB14 0x0087      ADDS     R0,R4,R7, LSL #+2
   \   000000D6   0x6980             LDR      R0,[R0, #+24]
   \   000000D8   0x6085             STR      R5,[R0, #+8]
    474                }
    475                if (diepint.b.inepnakeff)
   \                     ??DCD_HandleInEP_ISR_7: (+1)
   \   000000DA   0xF3C5 0x1080      UBFX     R0,R5,#+6,#+1
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD007             BEQ.N    ??DCD_HandleInEP_ISR_8
    476                {
    477                  CLEAR_IN_EP_INTR(epnum, inepnakeff);
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0x0005             MOVS     R5,R0
   \   000000E6   0xF055 0x0540      ORRS     R5,R5,#0x40
   \   000000EA   0xEB14 0x0087      ADDS     R0,R4,R7, LSL #+2
   \   000000EE   0x6980             LDR      R0,[R0, #+24]
   \   000000F0   0x6085             STR      R5,[R0, #+8]
    478                }
    479                if ( diepint.b.epdisabled )
   \                     ??DCD_HandleInEP_ISR_8: (+1)
   \   000000F2   0xF3C5 0x0040      UBFX     R0,R5,#+1,#+1
   \   000000F6   0x2800             CMP      R0,#+0
   \   000000F8   0xD007             BEQ.N    ??DCD_HandleInEP_ISR_9
    480                {
    481                  CLEAR_IN_EP_INTR(epnum, epdisabled);
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0x0005             MOVS     R5,R0
   \   000000FE   0xF055 0x0502      ORRS     R5,R5,#0x2
   \   00000102   0xEB14 0x0087      ADDS     R0,R4,R7, LSL #+2
   \   00000106   0x6980             LDR      R0,[R0, #+24]
   \   00000108   0x6085             STR      R5,[R0, #+8]
    482                }       
    483                if (diepint.b.emptyintr)
   \                     ??DCD_HandleInEP_ISR_9: (+1)
   \   0000010A   0xF3C5 0x10C0      UBFX     R0,R5,#+7,#+1
   \   0000010E   0x2800             CMP      R0,#+0
   \   00000110   0xD00B             BEQ.N    ??DCD_HandleInEP_ISR_2
    484                {
    485                  
    486                  DCD_WriteEmptyTxFifo(pdev , epnum);
   \   00000112   0x0039             MOVS     R1,R7
   \   00000114   0x0020             MOVS     R0,R4
   \   00000116   0x.... 0x....      BL       DCD_WriteEmptyTxFifo
    487                  
    488                  CLEAR_IN_EP_INTR(epnum, emptyintr);
   \   0000011A   0x2000             MOVS     R0,#+0
   \   0000011C   0x0005             MOVS     R5,R0
   \   0000011E   0xF055 0x0580      ORRS     R5,R5,#0x80
   \   00000122   0xEB14 0x0087      ADDS     R0,R4,R7, LSL #+2
   \   00000126   0x6980             LDR      R0,[R0, #+24]
   \   00000128   0x6085             STR      R5,[R0, #+8]
    489                }
    490              }
    491              epnum++;
   \                     ??DCD_HandleInEP_ISR_2: (+1)
   \   0000012A   0x1C7F             ADDS     R7,R7,#+1
    492              ep_intr >>= 1;
   \   0000012C   0x0876             LSRS     R6,R6,#+1
   \   0000012E   0xE771             B.N      ??DCD_HandleInEP_ISR_0
    493            }
    494            
    495            return 1;
   \                     ??DCD_HandleInEP_ISR_1: (+1)
   \   00000130   0x2001             MOVS     R0,#+1
   \   00000132   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    496          }
    497          
    498          /**
    499          * @brief  DCD_HandleOutEP_ISR
    500          *         Indicates that an OUT EP has a pending Interrupt
    501          * @param  pdev: device instance
    502          * @retval status
    503          */

   \                                 In section .text, align 2, keep-with-next
    504          static uint32_t DCD_HandleOutEP_ISR(USB_OTG_CORE_HANDLE *pdev)
    505          {
   \                     DCD_HandleOutEP_ISR: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
    506            uint32_t ep_intr;
    507            USB_OTG_DOEPINTn_TypeDef  doepint;
    508            USB_OTG_DEPXFRSIZ_TypeDef  deptsiz;
    509            uint32_t epnum = 0;
   \   00000006   0xF05F 0x0800      MOVS     R8,#+0
    510            
    511            doepint.d32 = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x0006             MOVS     R6,R0
    512            
    513            /* Read in the device interrupt bits */
    514            ep_intr = USB_OTG_ReadDevAllOutEp_itr(pdev);
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       USB_OTG_ReadDevAllOutEp_itr
   \   00000014   0x0005             MOVS     R5,R0
    515            
    516            while ( ep_intr )
   \                     ??DCD_HandleOutEP_ISR_0: (+1)
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD067             BEQ.N    ??DCD_HandleOutEP_ISR_1
    517            {
    518              if (ep_intr&0x1)
   \   0000001A   0x07E8             LSLS     R0,R5,#+31
   \   0000001C   0xD561             BPL.N    ??DCD_HandleOutEP_ISR_2
    519              {
    520                
    521                doepint.d32 = USB_OTG_ReadDevOutEP_itr(pdev, epnum);
   \   0000001E   0x4641             MOV      R1,R8
   \   00000020   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       USB_OTG_ReadDevOutEP_itr
   \   00000028   0x0006             MOVS     R6,R0
    522                
    523                /* Transfer complete */
    524                if ( doepint.b.xfercompl )
   \   0000002A   0x07F0             LSLS     R0,R6,#+31
   \   0000002C   0xD530             BPL.N    ??DCD_HandleOutEP_ISR_3
    525                {
    526                  /* Clear the bit in DOEPINTn for this interrupt */
    527                  CLEAR_OUT_EP_INTR(epnum, xfercompl);
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x0006             MOVS     R6,R0
   \   00000032   0xF056 0x0601      ORRS     R6,R6,#0x1
   \   00000036   0xEB14 0x0088      ADDS     R0,R4,R8, LSL #+2
   \   0000003A   0x6D40             LDR      R0,[R0, #+84]
   \   0000003C   0x6086             STR      R6,[R0, #+8]
    528                  if (pdev->cfg.dma_enable == 1)
   \   0000003E   0x78E0             LDRB     R0,[R4, #+3]
   \   00000040   0x2801             CMP      R0,#+1
   \   00000042   0xD111             BNE.N    ??DCD_HandleOutEP_ISR_4
    529                  {
    530                    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[epnum]->DOEPTSIZ));
   \   00000044   0xEB14 0x0088      ADDS     R0,R4,R8, LSL #+2
   \   00000048   0x6D40             LDR      R0,[R0, #+84]
   \   0000004A   0x6900             LDR      R0,[R0, #+16]
   \   0000004C   0x0007             MOVS     R7,R0
    531                    /*ToDo : handle more than one single MPS size packet */
    532                    pdev->dev.out_ep[epnum].xfer_count = pdev->dev.out_ep[epnum].maxpacket - \
    533                      deptsiz.b.xfersize;
   \   0000004E   0x2028             MOVS     R0,#+40
   \   00000050   0xFB00 0x4008      MLA      R0,R0,R8,R4
   \   00000054   0xF8D0 0x0378      LDR      R0,[R0, #+888]
   \   00000058   0x0379             LSLS     R1,R7,#+13       ;; ZeroExtS R1,R7,#+13,#+13
   \   0000005A   0x0B49             LSRS     R1,R1,#+13
   \   0000005C   0x1A40             SUBS     R0,R0,R1
   \   0000005E   0x2128             MOVS     R1,#+40
   \   00000060   0xFB01 0x4108      MLA      R1,R1,R8,R4
   \   00000064   0xF8C1 0x0388      STR      R0,[R1, #+904]
    534                  }
    535                  /* Inform upper layer: data ready */
    536                  /* RX COMPLETE */
    537                  USBD_DCD_INT_fops->DataOutStage(pdev , epnum);
   \                     ??DCD_HandleOutEP_ISR_4: (+1)
   \   00000068   0x4641             MOV      R1,R8
   \   0000006A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0x....             LDR.N    R2,??DataTable7
   \   00000070   0x6812             LDR      R2,[R2, #+0]
   \   00000072   0x6812             LDR      R2,[R2, #+0]
   \   00000074   0x4790             BLX      R2
    538                  
    539                  if (pdev->cfg.dma_enable == 1)
   \   00000076   0x78E0             LDRB     R0,[R4, #+3]
   \   00000078   0x2801             CMP      R0,#+1
   \   0000007A   0xD109             BNE.N    ??DCD_HandleOutEP_ISR_3
    540                  {
    541                    if((epnum == 0) && (pdev->dev.device_state == USB_OTG_EP0_STATUS_OUT))
   \   0000007C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000080   0xD106             BNE.N    ??DCD_HandleOutEP_ISR_3
   \   00000082   0xF894 0x0111      LDRB     R0,[R4, #+273]
   \   00000086   0x2805             CMP      R0,#+5
   \   00000088   0xD102             BNE.N    ??DCD_HandleOutEP_ISR_3
    542                    {
    543                      /* prepare to rx more setup packets */
    544                      USB_OTG_EP0_OutStart(pdev);
   \   0000008A   0x0020             MOVS     R0,R4
   \   0000008C   0x.... 0x....      BL       USB_OTG_EP0_OutStart
    545                    }
    546                  }        
    547                }
    548                /* Endpoint disable  */
    549                if ( doepint.b.epdisabled )
   \                     ??DCD_HandleOutEP_ISR_3: (+1)
   \   00000090   0xF3C6 0x0040      UBFX     R0,R6,#+1,#+1
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD007             BEQ.N    ??DCD_HandleOutEP_ISR_5
    550                {
    551                  /* Clear the bit in DOEPINTn for this interrupt */
    552                  CLEAR_OUT_EP_INTR(epnum, epdisabled);
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x0006             MOVS     R6,R0
   \   0000009C   0xF056 0x0602      ORRS     R6,R6,#0x2
   \   000000A0   0xEB14 0x0088      ADDS     R0,R4,R8, LSL #+2
   \   000000A4   0x6D40             LDR      R0,[R0, #+84]
   \   000000A6   0x6086             STR      R6,[R0, #+8]
    553                }
    554                /* AHB Error */
    555                if ( doepint.b.ahberr )
   \                     ??DCD_HandleOutEP_ISR_5: (+1)
   \   000000A8   0xF3C6 0x0080      UBFX     R0,R6,#+2,#+1
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD007             BEQ.N    ??DCD_HandleOutEP_ISR_6
    556                {
    557                  CLEAR_OUT_EP_INTR(epnum, ahberr);
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x0006             MOVS     R6,R0
   \   000000B4   0xF056 0x0604      ORRS     R6,R6,#0x4
   \   000000B8   0xEB14 0x0088      ADDS     R0,R4,R8, LSL #+2
   \   000000BC   0x6D40             LDR      R0,[R0, #+84]
   \   000000BE   0x6086             STR      R6,[R0, #+8]
    558                }
    559                /* Setup Phase Done (control EPs) */
    560                if ( doepint.b.setup )
   \                     ??DCD_HandleOutEP_ISR_6: (+1)
   \   000000C0   0xF3C6 0x00C0      UBFX     R0,R6,#+3,#+1
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD00C             BEQ.N    ??DCD_HandleOutEP_ISR_2
    561                {
    562                  
    563                  /* inform the upper layer that a setup packet is available */
    564                  /* SETUP COMPLETE */
    565                  USBD_DCD_INT_fops->SetupStage(pdev);
   \   000000C8   0x0020             MOVS     R0,R4
   \   000000CA   0x....             LDR.N    R1,??DataTable7
   \   000000CC   0x6809             LDR      R1,[R1, #+0]
   \   000000CE   0x6889             LDR      R1,[R1, #+8]
   \   000000D0   0x4788             BLX      R1
    566                  CLEAR_OUT_EP_INTR(epnum, setup);
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0x0006             MOVS     R6,R0
   \   000000D6   0xF056 0x0608      ORRS     R6,R6,#0x8
   \   000000DA   0xEB14 0x0088      ADDS     R0,R4,R8, LSL #+2
   \   000000DE   0x6D40             LDR      R0,[R0, #+84]
   \   000000E0   0x6086             STR      R6,[R0, #+8]
    567                }
    568              }
    569              epnum++;
   \                     ??DCD_HandleOutEP_ISR_2: (+1)
   \   000000E2   0xF118 0x0801      ADDS     R8,R8,#+1
    570              ep_intr >>= 1;
   \   000000E6   0x086D             LSRS     R5,R5,#+1
   \   000000E8   0xE795             B.N      ??DCD_HandleOutEP_ISR_0
    571            }
    572            return 1;
   \                     ??DCD_HandleOutEP_ISR_1: (+1)
   \   000000EA   0x2001             MOVS     R0,#+1
   \   000000EC   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    573          }
    574          
    575          /**
    576          * @brief  DCD_HandleSof_ISR
    577          *         Handles the SOF Interrupts
    578          * @param  pdev: device instance
    579          * @retval status
    580          */

   \                                 In section .text, align 2, keep-with-next
    581          static uint32_t DCD_HandleSof_ISR(USB_OTG_CORE_HANDLE *pdev)
    582          {
   \                     DCD_HandleSof_ISR: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    583            USB_OTG_GINTSTS_TypeDef  GINTSTS;
    584            
    585            
    586            USBD_DCD_INT_fops->SOF(pdev);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x....             LDR.N    R1,??DataTable7
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x68C9             LDR      R1,[R1, #+12]
   \   0000000C   0x4788             BLX      R1
    587            
    588            /* Clear interrupt */
    589            GINTSTS.d32 = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x0005             MOVS     R5,R0
    590            GINTSTS.b.sofintr = 1;
   \   00000012   0xF055 0x0508      ORRS     R5,R5,#0x8
    591            USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, GINTSTS.d32);
   \   00000016   0x68E0             LDR      R0,[R4, #+12]
   \   00000018   0x6145             STR      R5,[R0, #+20]
    592            
    593            return 1;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    594          }
    595          
    596          /**
    597          * @brief  DCD_HandleRxStatusQueueLevel_ISR
    598          *         Handles the Rx Status Queue Level Interrupt
    599          * @param  pdev: device instance
    600          * @retval status
    601          */

   \                                 In section .text, align 2, keep-with-next
    602          static uint32_t DCD_HandleRxStatusQueueLevel_ISR(USB_OTG_CORE_HANDLE *pdev)
    603          {
   \                     DCD_HandleRxStatusQueueLevel_ISR: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    604            USB_OTG_GINTMSK_TypeDef  int_mask;
    605            USB_OTG_DRXSTS_TypeDef   status;
    606            USB_OTG_EP *ep;
    607            
    608            /* Disable the Rx Status Queue Level interrupt */
    609            int_mask.d32 = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x0007             MOVS     R7,R0
    610            int_mask.b.rxstsqlvl = 1;
   \   00000008   0xF057 0x0710      ORRS     R7,R7,#0x10
    611            USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32, 0);
   \   0000000C   0x68E0             LDR      R0,[R4, #+12]
   \   0000000E   0x6980             LDR      R0,[R0, #+24]
   \   00000010   0x43B8             BICS     R0,R0,R7
   \   00000012   0x68E1             LDR      R1,[R4, #+12]
   \   00000014   0x6188             STR      R0,[R1, #+24]
    612            
    613            /* Get the Status from the top of the FIFO */
    614            status.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRXSTSP );
   \   00000016   0x68E0             LDR      R0,[R4, #+12]
   \   00000018   0x6A00             LDR      R0,[R0, #+32]
   \   0000001A   0x0005             MOVS     R5,R0
    615            
    616            ep = &pdev->dev.out_ep[status.b.epnum];
   \   0000001C   0xF015 0x000F      ANDS     R0,R5,#0xF
   \   00000020   0x2128             MOVS     R1,#+40
   \   00000022   0xFB01 0x4000      MLA      R0,R1,R0,R4
   \   00000026   0xF510 0x705C      ADDS     R0,R0,#+880
   \   0000002A   0x0006             MOVS     R6,R0
    617            
    618            switch (status.b.pktsts)
   \   0000002C   0x0C68             LSRS     R0,R5,#+17
   \   0000002E   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000032   0x2801             CMP      R0,#+1
   \   00000034   0xD008             BEQ.N    ??DCD_HandleRxStatusQueueLevel_ISR_0
   \   00000036   0x2802             CMP      R0,#+2
   \   00000038   0xD007             BEQ.N    ??DCD_HandleRxStatusQueueLevel_ISR_1
   \   0000003A   0x2803             CMP      R0,#+3
   \   0000003C   0xD01A             BEQ.N    ??DCD_HandleRxStatusQueueLevel_ISR_2
   \   0000003E   0x2804             CMP      R0,#+4
   \   00000040   0xD019             BEQ.N    ??DCD_HandleRxStatusQueueLevel_ISR_3
   \   00000042   0x2806             CMP      R0,#+6
   \   00000044   0xD018             BEQ.N    ??DCD_HandleRxStatusQueueLevel_ISR_4
   \   00000046   0xE023             B.N      ??DCD_HandleRxStatusQueueLevel_ISR_5
    619            {
    620            case STS_GOUT_NAK:
    621              break;
   \                     ??DCD_HandleRxStatusQueueLevel_ISR_0: (+1)
   \   00000048   0xE022             B.N      ??DCD_HandleRxStatusQueueLevel_ISR_6
    622            case STS_DATA_UPDT:
    623              if (status.b.bcnt)
   \                     ??DCD_HandleRxStatusQueueLevel_ISR_1: (+1)
   \   0000004A   0x0928             LSRS     R0,R5,#+4
   \   0000004C   0x0540             LSLS     R0,R0,#+21
   \   0000004E   0xD010             BEQ.N    ??DCD_HandleRxStatusQueueLevel_ISR_7
    624              {
    625                USB_OTG_ReadPacket(pdev,ep->xfer_buff, status.b.bcnt);
   \   00000050   0xF3C5 0x120A      UBFX     R2,R5,#+4,#+11
   \   00000054   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000056   0x68F1             LDR      R1,[R6, #+12]
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0x.... 0x....      BL       USB_OTG_ReadPacket
    626                ep->xfer_buff += status.b.bcnt;
   \   0000005E   0x68F0             LDR      R0,[R6, #+12]
   \   00000060   0xF3C5 0x110A      UBFX     R1,R5,#+4,#+11
   \   00000064   0x1808             ADDS     R0,R1,R0
   \   00000066   0x60F0             STR      R0,[R6, #+12]
    627                ep->xfer_count += status.b.bcnt;
   \   00000068   0x69B0             LDR      R0,[R6, #+24]
   \   0000006A   0xF3C5 0x110A      UBFX     R1,R5,#+4,#+11
   \   0000006E   0x1808             ADDS     R0,R1,R0
   \   00000070   0x61B0             STR      R0,[R6, #+24]
    628              }
    629              break;
   \                     ??DCD_HandleRxStatusQueueLevel_ISR_7: (+1)
   \   00000072   0xE00D             B.N      ??DCD_HandleRxStatusQueueLevel_ISR_6
    630            case STS_XFER_COMP:
    631              break;
   \                     ??DCD_HandleRxStatusQueueLevel_ISR_2: (+1)
   \   00000074   0xE00C             B.N      ??DCD_HandleRxStatusQueueLevel_ISR_6
    632            case STS_SETUP_COMP:
    633              break;
   \                     ??DCD_HandleRxStatusQueueLevel_ISR_3: (+1)
   \   00000076   0xE00B             B.N      ??DCD_HandleRxStatusQueueLevel_ISR_6
    634            case STS_SETUP_UPDT:
    635              /* Copy the setup packet received in FIFO into the setup buffer in RAM */
    636              USB_OTG_ReadPacket(pdev , pdev->dev.setup_packet, 8);
   \                     ??DCD_HandleRxStatusQueueLevel_ISR_4: (+1)
   \   00000078   0x2208             MOVS     R2,#+8
   \   0000007A   0xF514 0x61B9      ADDS     R1,R4,#+1480
   \   0000007E   0x0020             MOVS     R0,R4
   \   00000080   0x.... 0x....      BL       USB_OTG_ReadPacket
    637              ep->xfer_count += status.b.bcnt;
   \   00000084   0x69B0             LDR      R0,[R6, #+24]
   \   00000086   0xF3C5 0x110A      UBFX     R1,R5,#+4,#+11
   \   0000008A   0x1808             ADDS     R0,R1,R0
   \   0000008C   0x61B0             STR      R0,[R6, #+24]
    638              break;
   \   0000008E   0xE7FF             B.N      ??DCD_HandleRxStatusQueueLevel_ISR_6
    639            default:
    640              break;
    641            }
    642            
    643            /* Enable the Rx Status Queue Level interrupt */
    644            USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, int_mask.d32);
   \                     ??DCD_HandleRxStatusQueueLevel_ISR_5: (+1)
   \                     ??DCD_HandleRxStatusQueueLevel_ISR_6: (+1)
   \   00000090   0x68E0             LDR      R0,[R4, #+12]
   \   00000092   0x6980             LDR      R0,[R0, #+24]
   \   00000094   0x4338             ORRS     R0,R7,R0
   \   00000096   0x68E1             LDR      R1,[R4, #+12]
   \   00000098   0x6188             STR      R0,[R1, #+24]
    645            
    646            return 1;
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    647          }
    648          
    649          /**
    650          * @brief  DCD_WriteEmptyTxFifo
    651          *         check FIFO for the next packet to be loaded
    652          * @param  pdev: device instance
    653          * @retval status
    654          */

   \                                 In section .text, align 2, keep-with-next
    655          static uint32_t DCD_WriteEmptyTxFifo(USB_OTG_CORE_HANDLE *pdev, uint32_t epnum)
    656          {
   \                     DCD_WriteEmptyTxFifo: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    657            USB_OTG_DTXFSTSn_TypeDef  txstatus;
    658            USB_OTG_EP *ep;
    659            uint32_t len = 0;
   \   00000008   0xF05F 0x0800      MOVS     R8,#+0
    660            uint32_t len32b;
    661            txstatus.d32 = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x0006             MOVS     R6,R0
    662            
    663            ep = &pdev->dev.in_ep[epnum];    
   \   00000010   0x2028             MOVS     R0,#+40
   \   00000012   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   00000016   0xF510 0x708C      ADDS     R0,R0,#+280
   \   0000001A   0x0007             MOVS     R7,R0
    664            
    665            len = ep->xfer_len - ep->xfer_count;
   \   0000001C   0x6978             LDR      R0,[R7, #+20]
   \   0000001E   0x69B9             LDR      R1,[R7, #+24]
   \   00000020   0x1A40             SUBS     R0,R0,R1
   \   00000022   0x4680             MOV      R8,R0
    666            
    667            if (len > ep->maxpacket)
   \   00000024   0x68B8             LDR      R0,[R7, #+8]
   \   00000026   0x4540             CMP      R0,R8
   \   00000028   0xD201             BCS.N    ??DCD_WriteEmptyTxFifo_0
    668            {
    669              len = ep->maxpacket;
   \   0000002A   0x68B8             LDR      R0,[R7, #+8]
   \   0000002C   0x4680             MOV      R8,R0
    670            }
    671            
    672            len32b = (len + 3) / 4;
   \                     ??DCD_WriteEmptyTxFifo_0: (+1)
   \   0000002E   0xF118 0x0003      ADDS     R0,R8,#+3
   \   00000032   0x0880             LSRS     R0,R0,#+2
   \   00000034   0x4681             MOV      R9,R0
    673            txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
   \   00000036   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   0000003A   0x6980             LDR      R0,[R0, #+24]
   \   0000003C   0x6980             LDR      R0,[R0, #+24]
   \   0000003E   0x0006             MOVS     R6,R0
    674            
    675            
    676            
    677            while  (txstatus.b.txfspcavail > len32b &&
    678                    ep->xfer_count < ep->xfer_len &&
    679                      ep->xfer_len != 0)
   \                     ??DCD_WriteEmptyTxFifo_1: (+1)
   \   00000040   0xB2B0             UXTH     R0,R6            ;; ZeroExt  R0,R6,#+16,#+16
   \   00000042   0x4581             CMP      R9,R0
   \   00000044   0xD229             BCS.N    ??DCD_WriteEmptyTxFifo_2
   \   00000046   0x69B8             LDR      R0,[R7, #+24]
   \   00000048   0x6979             LDR      R1,[R7, #+20]
   \   0000004A   0x4288             CMP      R0,R1
   \   0000004C   0xD225             BCS.N    ??DCD_WriteEmptyTxFifo_2
   \   0000004E   0x6978             LDR      R0,[R7, #+20]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD022             BEQ.N    ??DCD_WriteEmptyTxFifo_2
    680            {
    681              /* Write the FIFO */
    682              len = ep->xfer_len - ep->xfer_count;
   \   00000054   0x6978             LDR      R0,[R7, #+20]
   \   00000056   0x69B9             LDR      R1,[R7, #+24]
   \   00000058   0x1A40             SUBS     R0,R0,R1
   \   0000005A   0x4680             MOV      R8,R0
    683              
    684              if (len > ep->maxpacket)
   \   0000005C   0x68B8             LDR      R0,[R7, #+8]
   \   0000005E   0x4540             CMP      R0,R8
   \   00000060   0xD201             BCS.N    ??DCD_WriteEmptyTxFifo_3
    685              {
    686                len = ep->maxpacket;
   \   00000062   0x68B8             LDR      R0,[R7, #+8]
   \   00000064   0x4680             MOV      R8,R0
    687              }
    688              len32b = (len + 3) / 4;
   \                     ??DCD_WriteEmptyTxFifo_3: (+1)
   \   00000066   0xF118 0x0003      ADDS     R0,R8,#+3
   \   0000006A   0x0880             LSRS     R0,R0,#+2
   \   0000006C   0x4681             MOV      R9,R0
    689              
    690              USB_OTG_WritePacket (pdev , ep->xfer_buff, epnum, len);
   \   0000006E   0x4643             MOV      R3,R8
   \   00000070   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000072   0x002A             MOVS     R2,R5
   \   00000074   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000076   0x68F9             LDR      R1,[R7, #+12]
   \   00000078   0x0020             MOVS     R0,R4
   \   0000007A   0x.... 0x....      BL       USB_OTG_WritePacket
    691              
    692              ep->xfer_buff  += len;
   \   0000007E   0x68F8             LDR      R0,[R7, #+12]
   \   00000080   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000084   0x60F8             STR      R0,[R7, #+12]
    693              ep->xfer_count += len;
   \   00000086   0x69B8             LDR      R0,[R7, #+24]
   \   00000088   0xEB18 0x0000      ADDS     R0,R8,R0
   \   0000008C   0x61B8             STR      R0,[R7, #+24]
    694              
    695              txstatus.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DTXFSTS);
   \   0000008E   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000092   0x6980             LDR      R0,[R0, #+24]
   \   00000094   0x6980             LDR      R0,[R0, #+24]
   \   00000096   0x0006             MOVS     R6,R0
   \   00000098   0xE7D2             B.N      ??DCD_WriteEmptyTxFifo_1
    696            }
    697            
    698            return 1;
   \                     ??DCD_WriteEmptyTxFifo_2: (+1)
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    699          }
    700          
    701          /**
    702          * @brief  DCD_HandleUsbReset_ISR
    703          *         This interrupt occurs when a USB Reset is detected
    704          * @param  pdev: device instance
    705          * @retval status
    706          */

   \                                 In section .text, align 2, keep-with-next
    707          static uint32_t DCD_HandleUsbReset_ISR(USB_OTG_CORE_HANDLE *pdev)
    708          {
   \                     DCD_HandleUsbReset_ISR: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
    709            USB_OTG_DAINT_TypeDef    daintmsk;
    710            USB_OTG_DOEPMSK_TypeDef  doepmsk;
    711            USB_OTG_DIEPMSK_TypeDef  diepmsk;
    712            USB_OTG_DCFG_TypeDef     dcfg;
    713            USB_OTG_DCTL_TypeDef     dctl;
    714            USB_OTG_GINTSTS_TypeDef  gintsts;
    715            uint32_t i;
    716            
    717            dctl.d32 = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x4681             MOV      R9,R0
    718            daintmsk.d32 = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x0005             MOVS     R5,R0
    719            doepmsk.d32 = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x0006             MOVS     R6,R0
    720            diepmsk.d32 = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x0007             MOVS     R7,R0
    721            dcfg.d32 = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4680             MOV      R8,R0
    722            gintsts.d32 = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4682             MOV      R10,R0
    723            
    724            /* Clear the Remote Wake-up Signaling */
    725            dctl.b.rmtwkupsig = 1;
   \   0000001E   0xF059 0x0901      ORRS     R9,R9,#0x1
    726            USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
   \   00000022   0x6920             LDR      R0,[R4, #+16]
   \   00000024   0x6840             LDR      R0,[R0, #+4]
   \   00000026   0xEA30 0x0009      BICS     R0,R0,R9
   \   0000002A   0x6921             LDR      R1,[R4, #+16]
   \   0000002C   0x6048             STR      R0,[R1, #+4]
    727            
    728            /* Flush the Tx FIFO */
    729            USB_OTG_FlushTxFifo(pdev ,  0 );
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       USB_OTG_FlushTxFifo
    730            
    731            for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x4683             MOV      R11,R0
   \                     ??DCD_HandleUsbReset_ISR_0: (+1)
   \   0000003A   0x7860             LDRB     R0,[R4, #+1]
   \   0000003C   0x4583             CMP      R11,R0
   \   0000003E   0xD20C             BCS.N    ??DCD_HandleUsbReset_ISR_1
    732            {
    733              USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
   \   00000040   0xEB14 0x008B      ADDS     R0,R4,R11, LSL #+2
   \   00000044   0x6980             LDR      R0,[R0, #+24]
   \   00000046   0x21FF             MOVS     R1,#+255
   \   00000048   0x6081             STR      R1,[R0, #+8]
    734              USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
   \   0000004A   0xEB14 0x008B      ADDS     R0,R4,R11, LSL #+2
   \   0000004E   0x6D40             LDR      R0,[R0, #+84]
   \   00000050   0x21FF             MOVS     R1,#+255
   \   00000052   0x6081             STR      R1,[R0, #+8]
    735            }
   \   00000054   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   00000058   0xE7EF             B.N      ??DCD_HandleUsbReset_ISR_0
    736            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
   \                     ??DCD_HandleUsbReset_ISR_1: (+1)
   \   0000005A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000005E   0x6921             LDR      R1,[R4, #+16]
   \   00000060   0x6188             STR      R0,[R1, #+24]
    737            
    738            daintmsk.ep.in = 1;
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0xF360 0x050F      BFI      R5,R0,#+0,#+16
    739            daintmsk.ep.out = 1;
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0xF360 0x451F      BFI      R5,R0,#+16,#+16
    740            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, daintmsk.d32 );
   \   0000006E   0x6920             LDR      R0,[R4, #+16]
   \   00000070   0x61C5             STR      R5,[R0, #+28]
    741            
    742            doepmsk.b.setup = 1;
   \   00000072   0xF056 0x0608      ORRS     R6,R6,#0x8
    743            doepmsk.b.xfercompl = 1;
   \   00000076   0xF056 0x0601      ORRS     R6,R6,#0x1
    744            doepmsk.b.ahberr = 1;
   \   0000007A   0xF056 0x0604      ORRS     R6,R6,#0x4
    745            doepmsk.b.epdisabled = 1;
   \   0000007E   0xF056 0x0602      ORRS     R6,R6,#0x2
    746            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, doepmsk.d32 );
   \   00000082   0x6920             LDR      R0,[R4, #+16]
   \   00000084   0x6146             STR      R6,[R0, #+20]
    747          #ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED   
    748            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOUTEP1MSK, doepmsk.d32 );
    749          #endif
    750            diepmsk.b.xfercompl = 1;
   \   00000086   0xF057 0x0701      ORRS     R7,R7,#0x1
    751            diepmsk.b.timeout = 1;
   \   0000008A   0xF057 0x0708      ORRS     R7,R7,#0x8
    752            diepmsk.b.epdisabled = 1;
   \   0000008E   0xF057 0x0702      ORRS     R7,R7,#0x2
    753            diepmsk.b.ahberr = 1;
   \   00000092   0xF057 0x0704      ORRS     R7,R7,#0x4
    754            diepmsk.b.intknepmis = 1;
   \   00000096   0xF057 0x0720      ORRS     R7,R7,#0x20
    755            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, diepmsk.d32 );
   \   0000009A   0x6920             LDR      R0,[R4, #+16]
   \   0000009C   0x6107             STR      R7,[R0, #+16]
    756          #ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED  
    757            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DINEP1MSK, diepmsk.d32 );
    758          #endif
    759            /* Reset Device Address */
    760            dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
   \   0000009E   0x6920             LDR      R0,[R4, #+16]
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x4680             MOV      R8,R0
    761            dcfg.b.devaddr = 0;
   \   000000A4   0xF438 0x68FE      BICS     R8,R8,#0x7F0
    762            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DCFG, dcfg.d32);
   \   000000A8   0x6920             LDR      R0,[R4, #+16]
   \   000000AA   0xF8C0 0x8000      STR      R8,[R0, #+0]
    763            
    764            
    765            /* setup EP0 to receive SETUP packets */
    766            USB_OTG_EP0_OutStart(pdev);
   \   000000AE   0x0020             MOVS     R0,R4
   \   000000B0   0x.... 0x....      BL       USB_OTG_EP0_OutStart
    767            
    768            /* Clear interrupt */
    769            gintsts.d32 = 0;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x4682             MOV      R10,R0
    770            gintsts.b.usbreset = 1;
   \   000000B8   0xF45A 0x5A80      ORRS     R10,R10,#0x1000
    771            USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
   \   000000BC   0x68E0             LDR      R0,[R4, #+12]
   \   000000BE   0xF8C0 0xA014      STR      R10,[R0, #+20]
    772            
    773            /*Reset internal state machine */
    774            USBD_DCD_INT_fops->Reset(pdev);
   \   000000C2   0x0020             MOVS     R0,R4
   \   000000C4   0x....             LDR.N    R1,??DataTable7
   \   000000C6   0x6809             LDR      R1,[R1, #+0]
   \   000000C8   0x6909             LDR      R1,[R1, #+16]
   \   000000CA   0x4788             BLX      R1
    775            return 1;
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    776          }
    777          
    778          /**
    779          * @brief  DCD_HandleEnumDone_ISR
    780          *         Read the device status register and set the device speed
    781          * @param  pdev: device instance
    782          * @retval status
    783          */

   \                                 In section .text, align 2, keep-with-next
    784          static uint32_t DCD_HandleEnumDone_ISR(USB_OTG_CORE_HANDLE *pdev)
    785          {
   \                     DCD_HandleEnumDone_ISR: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    786            USB_OTG_GINTSTS_TypeDef  gintsts;
    787            USB_OTG_GUSBCFG_TypeDef  gusbcfg;
    788            
    789            USB_OTG_EP0Activate(pdev);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       USB_OTG_EP0Activate
    790            
    791            /* Set USB turn-around time based on device speed and PHY interface. */
    792            gusbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
   \   0000000A   0x68E0             LDR      R0,[R4, #+12]
   \   0000000C   0x68C0             LDR      R0,[R0, #+12]
   \   0000000E   0x0006             MOVS     R6,R0
    793            
    794            /* Full or High speed */
    795            if ( USB_OTG_GetDeviceSpeed(pdev) == USB_SPEED_HIGH)
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       USB_OTG_GetDeviceSpeed
   \   00000016   0x2803             CMP      R0,#+3
   \   00000018   0xD108             BNE.N    ??DCD_HandleEnumDone_ISR_0
    796            {
    797              pdev->cfg.speed            = USB_OTG_SPEED_HIGH;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x70A0             STRB     R0,[R4, #+2]
    798              pdev->cfg.mps              = USB_OTG_HS_MAX_PACKET_SIZE ;    
   \   0000001E   0xF44F 0x7000      MOV      R0,#+512
   \   00000022   0x80A0             STRH     R0,[R4, #+4]
    799              gusbcfg.b.usbtrdtim = 9;
   \   00000024   0x2009             MOVS     R0,#+9
   \   00000026   0xF360 0x268D      BFI      R6,R0,#+10,#+4
   \   0000002A   0xE006             B.N      ??DCD_HandleEnumDone_ISR_1
    800            }
    801            else
    802            {
    803              pdev->cfg.speed            = USB_OTG_SPEED_FULL;
   \                     ??DCD_HandleEnumDone_ISR_0: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x70A0             STRB     R0,[R4, #+2]
    804              pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;  
   \   00000030   0x2040             MOVS     R0,#+64
   \   00000032   0x80A0             STRH     R0,[R4, #+4]
    805              gusbcfg.b.usbtrdtim = 5;
   \   00000034   0x2005             MOVS     R0,#+5
   \   00000036   0xF360 0x268D      BFI      R6,R0,#+10,#+4
    806            }
    807            
    808            USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, gusbcfg.d32);
   \                     ??DCD_HandleEnumDone_ISR_1: (+1)
   \   0000003A   0x68E0             LDR      R0,[R4, #+12]
   \   0000003C   0x60C6             STR      R6,[R0, #+12]
    809            
    810            /* Clear interrupt */
    811            gintsts.d32 = 0;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x0005             MOVS     R5,R0
    812            gintsts.b.enumdone = 1;
   \   00000042   0xF455 0x5500      ORRS     R5,R5,#0x2000
    813            USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, gintsts.d32 );
   \   00000046   0x68E0             LDR      R0,[R4, #+12]
   \   00000048   0x6145             STR      R5,[R0, #+20]
    814            return 1;
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xBD70             POP      {R4-R6,PC}       ;; return
    815          }
    816          
    817          
    818          /**
    819          * @brief  DCD_IsoINIncomplete_ISR
    820          *         handle the ISO IN incomplete interrupt
    821          * @param  pdev: device instance
    822          * @retval status
    823          */

   \                                 In section .text, align 2, keep-with-next
    824          static uint32_t DCD_IsoINIncomplete_ISR(USB_OTG_CORE_HANDLE *pdev)
    825          {
   \                     DCD_IsoINIncomplete_ISR: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    826            USB_OTG_GINTSTS_TypeDef gintsts;  
    827            
    828            gintsts.d32 = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x0005             MOVS     R5,R0
    829          
    830            USBD_DCD_INT_fops->IsoINIncomplete (pdev); 
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x....             LDR.N    R1,??DataTable7
   \   0000000C   0x6809             LDR      R1,[R1, #+0]
   \   0000000E   0x69C9             LDR      R1,[R1, #+28]
   \   00000010   0x4788             BLX      R1
    831            
    832            /* Clear interrupt */
    833            gintsts.b.incomplisoin = 1;
   \   00000012   0xF455 0x1580      ORRS     R5,R5,#0x100000
    834            USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
   \   00000016   0x68E0             LDR      R0,[R4, #+12]
   \   00000018   0x6145             STR      R5,[R0, #+20]
    835            
    836            return 1;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    837          }
    838          
    839          /**
    840          * @brief  DCD_IsoOUTIncomplete_ISR
    841          *         handle the ISO OUT incomplete interrupt
    842          * @param  pdev: device instance
    843          * @retval status
    844          */

   \                                 In section .text, align 2, keep-with-next
    845          static uint32_t DCD_IsoOUTIncomplete_ISR(USB_OTG_CORE_HANDLE *pdev)
    846          {
   \                     DCD_IsoOUTIncomplete_ISR: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    847            USB_OTG_GINTSTS_TypeDef gintsts;  
    848            
    849            gintsts.d32 = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x0005             MOVS     R5,R0
    850          
    851            USBD_DCD_INT_fops->IsoOUTIncomplete (pdev); 
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x....             LDR.N    R1,??DataTable7
   \   0000000C   0x6809             LDR      R1,[R1, #+0]
   \   0000000E   0x6A09             LDR      R1,[R1, #+32]
   \   00000010   0x4788             BLX      R1
    852            
    853            /* Clear interrupt */
    854            gintsts.b.incomplisoout = 1;
   \   00000012   0xF455 0x1500      ORRS     R5,R5,#0x200000
    855            USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
   \   00000016   0x68E0             LDR      R0,[R4, #+12]
   \   00000018   0x6145             STR      R5,[R0, #+20]
    856            return 1;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    857          }
    858          /**
    859          * @brief  DCD_ReadDevInEP
    860          *         Reads ep flags
    861          * @param  pdev: device instance
    862          * @retval status
    863          */

   \                                 In section .text, align 2, keep-with-next
    864          static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
    865          {
   \                     DCD_ReadDevInEP: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
    866            uint32_t v, msk, emp;
    867            msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
   \   00000004   0x6915             LDR      R5,[R2, #+16]
   \   00000006   0x692D             LDR      R5,[R5, #+16]
   \   00000008   0x002C             MOVS     R4,R5
    868            emp = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPEMPMSK);
   \   0000000A   0x6915             LDR      R5,[R2, #+16]
   \   0000000C   0x6B6D             LDR      R5,[R5, #+52]
   \   0000000E   0x002B             MOVS     R3,R5
    869            msk |= ((emp >> epnum) & 0x1) << 7;
   \   00000010   0x001D             MOVS     R5,R3
   \   00000012   0x40CD             LSRS     R5,R5,R1
   \   00000014   0xF015 0x0501      ANDS     R5,R5,#0x1
   \   00000018   0xEA54 0x14C5      ORRS     R4,R4,R5, LSL #+7
    870            v = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPINT) & msk;
   \   0000001C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001E   0xEB12 0x0581      ADDS     R5,R2,R1, LSL #+2
   \   00000022   0x69AD             LDR      R5,[R5, #+24]
   \   00000024   0x68AD             LDR      R5,[R5, #+8]
   \   00000026   0x4025             ANDS     R5,R4,R5
   \   00000028   0x0028             MOVS     R0,R5
    871            return v;
   \   0000002A   0xBC30             POP      {R4,R5}
   \   0000002C   0x4770             BX       LR               ;; return
    872          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     USBD_DCD_INT_fops

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0xE000ED10         DC32     0xe000ed10
    873          
    874          
    875          
    876          /**
    877          * @}
    878          */ 
    879          
    880          /**
    881          * @}
    882          */ 
    883          
    884          /**
    885          * @}
    886          */
    887          #endif
    888          
    889          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   DCD_HandleEnumDone_ISR
        16   -> USB_OTG_EP0Activate
        16   -> USB_OTG_GetDeviceSpeed
      24   DCD_HandleInEP_ISR
        24   -- Indirect call
        24   -> DCD_ReadDevInEP
        24   -> DCD_WriteEmptyTxFifo
        24   -> USB_OTG_EP0_OutStart
        24   -> USB_OTG_ReadDevAllInEPItr
      24   DCD_HandleOutEP_ISR
        24   -- Indirect call
        24   -> USB_OTG_EP0_OutStart
        24   -> USB_OTG_ReadDevAllOutEp_itr
        24   -> USB_OTG_ReadDevOutEP_itr
      24   DCD_HandleResume_ISR
        24   -- Indirect call
      24   DCD_HandleRxStatusQueueLevel_ISR
        24   -> USB_OTG_ReadPacket
      16   DCD_HandleSof_ISR
        16   -- Indirect call
      24   DCD_HandleUSBSuspend_ISR
        24   -- Indirect call
      40   DCD_HandleUsbReset_ISR
        40   -- Indirect call
        40   -> USB_OTG_EP0_OutStart
        40   -> USB_OTG_FlushTxFifo
      16   DCD_IsoINIncomplete_ISR
        16   -- Indirect call
      16   DCD_IsoOUTIncomplete_ISR
        16   -- Indirect call
       8   DCD_ReadDevInEP
      32   DCD_WriteEmptyTxFifo
        32   -> USB_OTG_WritePacket
      16   USBD_OTG_ISR_Handler
        16   -> DCD_HandleEnumDone_ISR
        16   -> DCD_HandleInEP_ISR
        16   -> DCD_HandleOutEP_ISR
        16   -> DCD_HandleResume_ISR
        16   -> DCD_HandleRxStatusQueueLevel_ISR
        16   -> DCD_HandleSof_ISR
        16   -> DCD_HandleUSBSuspend_ISR
        16   -> DCD_HandleUsbReset_ISR
        16   -> DCD_IsoINIncomplete_ISR
        16   -> DCD_IsoOUTIncomplete_ISR
        16   -> USB_OTG_IsDeviceMode
        16   -> USB_OTG_ReadCoreItr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
      78  DCD_HandleEnumDone_ISR
     310  DCD_HandleInEP_ISR
     240  DCD_HandleOutEP_ISR
      76  DCD_HandleResume_ISR
     158  DCD_HandleRxStatusQueueLevel_ISR
      30  DCD_HandleSof_ISR
     104  DCD_HandleUSBSuspend_ISR
     210  DCD_HandleUsbReset_ISR
      30  DCD_IsoINIncomplete_ISR
      30  DCD_IsoOUTIncomplete_ISR
      46  DCD_ReadDevInEP
     160  DCD_WriteEmptyTxFifo
     234  USBD_OTG_ISR_Handler

 
 1 714 bytes in section .text
 
 1 714 bytes of CODE memory

Errors: none
Warnings: 1
